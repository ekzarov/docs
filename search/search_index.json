{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Fetch.ai developer resources. Let's get started. Developing agents Speed up the development of Autonomous Economic Agents using our framework Joining our networks Learn how to use our ledger technologies to join our mainnet v2 Here to build agents? Learn about the concepts . Build your first agent. Once you\u2019ve built your agent, you\u2019ll want to use the SOEF to perform search and discovery to find other agents to trade with. Learn about the SOEF and how to use it in your agents . Learn about how to trade with other agents . Proceed to the beginner or advanced guides to learn more. Learn about the agent framework's architecture . What is Fetch.ai There are billions of devices, processes and pipelines around the world that are desperate for automation and communication. Most blockchains aren't built to handle such a large number of transactions, and none enable their clients to learn from the data generated and exchanged. Fetch.ai is a platform built to bring value to data, by connecting devices and facilitating the creation of new markets based on what they learn from each other. It is the platform where truly autonomous decisions can be made. Some of the technical features that will enable this autonomous world are: Blockchain sharding to increase concurrency and scalability Smart contract language with ML and AI capabilities Framework for rapid development of Autonomous Economic Agents (AEAs) that can be deployed in any device Support for fixed-point arithmetics to guarantee precision and determinism across all operations and transactions Versions and release notes As with any software and its documentation, things do change and evolve. We at Fetch.ai try to support backwards compatibility as much as possible, but deprecations will occur. Keep an eye our release notes, as these list all major changes. Upgrading from a previous version of the agent framework? Here\u2019s our helpful guide .","title":"Home"},{"location":"aea/","text":"The AEA framework provides the tools for creating Autonomous Economic Agents (AEA). What are AEAs? We define an autonomous economic agent or AEA as: An intelligent agent acting on an owner's behalf, with limited or no interference, and whose goal is to generate economic value for its owner. An AEA represents an individual, organisation or object and looks after its interests. AEAs act independently of constant input from their owner and autonomously execute actions to achieve their prescribed goals. Their purpose is to create economic value for you, their owner, in clearly defined domains. AEAs have a wide range of application areas and we provide demo guides to highlight examples of their use cases. What is not an AEA Any agent : AEAs' purpose is to generate economic value in a multi-stakeholder environment with competing incentives between agents. They represent humans, organisations or objects. APIs or sensors which do not have agency. Smart contracts which do not display any proactiveness and are purely reactive to external requests (=contract calls and transactions). Artificial General Intelligence (AGI) . AEAs can have a very narrow, goal directed focus involving some economic gain and can have a very simple logic. Note In the rest of the documentation, unless specified otherwise, we use the terms AEA and agent interchangeably to refer to AEA as defined above. What is the AEA Framework? The AEA framework is a development suite, currently implemented in Python, which equips you with an efficient and accessible set of tools for building and running AEAs. The framework is modular, extensible, and composable. It attempts to make agent development as straightforward an experience as possible, similar to web development using popular web frameworks. AEAs achieve their goals with the help of a search & discovery service for AEAs -- the simple Open Economic Framework (sOEF) -- a decentralized agent communication system -- the Agent Communication Network (ACN) -- and using Fetch.ai's blockchain as a financial settlement and commitment layer. AEAs can also be integrated with third-party blockchains, such as Ethereum . Why build with the AEA Framework? The AEA framework provides the developer with a number of features, which combined cannot be found anywhere else: The peer-to-peer agent communication network (ACN) allows your AEAs to interact with all other AEAs over the public internet. The search and discovery system sOEF allows your AEAs to find other AEAs. The AEA registry enables code sharing and re-use by providing a space in which AEAs or their individual components may be shared. The framework's crypto and ledger APIs make it possible for AEAs to interact with blockchains. The contract packages enable AEAs to interact with smart contracts in Fetch.ai and other third-party decentralised ledgers. Next steps To get started developing your own AEA, check out the getting started section. To learn more about some of the distinctive characteristics of agent-oriented development, check out the guide on agent-oriented development . If you would like to develop an AEA in a language different to Python then check out our language agnostic AEA definition . If you want to run a demo, check out the demo guides . Help us improve Note This developer documentation is a work in progress. If you spot any errors please open an issue on Github or contact us in the developer Discord channel .","title":"Introduction"},{"location":"aea/#what-are-aeas","text":"We define an autonomous economic agent or AEA as: An intelligent agent acting on an owner's behalf, with limited or no interference, and whose goal is to generate economic value for its owner. An AEA represents an individual, organisation or object and looks after its interests. AEAs act independently of constant input from their owner and autonomously execute actions to achieve their prescribed goals. Their purpose is to create economic value for you, their owner, in clearly defined domains. AEAs have a wide range of application areas and we provide demo guides to highlight examples of their use cases.","title":"What are AEAs?"},{"location":"aea/#what-is-not-an-aea","text":"Any agent : AEAs' purpose is to generate economic value in a multi-stakeholder environment with competing incentives between agents. They represent humans, organisations or objects. APIs or sensors which do not have agency. Smart contracts which do not display any proactiveness and are purely reactive to external requests (=contract calls and transactions). Artificial General Intelligence (AGI) . AEAs can have a very narrow, goal directed focus involving some economic gain and can have a very simple logic. Note In the rest of the documentation, unless specified otherwise, we use the terms AEA and agent interchangeably to refer to AEA as defined above.","title":"What is not an AEA"},{"location":"aea/#what-is-the-aea-framework","text":"The AEA framework is a development suite, currently implemented in Python, which equips you with an efficient and accessible set of tools for building and running AEAs. The framework is modular, extensible, and composable. It attempts to make agent development as straightforward an experience as possible, similar to web development using popular web frameworks. AEAs achieve their goals with the help of a search & discovery service for AEAs -- the simple Open Economic Framework (sOEF) -- a decentralized agent communication system -- the Agent Communication Network (ACN) -- and using Fetch.ai's blockchain as a financial settlement and commitment layer. AEAs can also be integrated with third-party blockchains, such as Ethereum .","title":"What is the AEA Framework?"},{"location":"aea/#why-build-with-the-aea-framework","text":"The AEA framework provides the developer with a number of features, which combined cannot be found anywhere else: The peer-to-peer agent communication network (ACN) allows your AEAs to interact with all other AEAs over the public internet. The search and discovery system sOEF allows your AEAs to find other AEAs. The AEA registry enables code sharing and re-use by providing a space in which AEAs or their individual components may be shared. The framework's crypto and ledger APIs make it possible for AEAs to interact with blockchains. The contract packages enable AEAs to interact with smart contracts in Fetch.ai and other third-party decentralised ledgers.","title":"Why build with the AEA Framework?"},{"location":"aea/#next-steps","text":"To get started developing your own AEA, check out the getting started section. To learn more about some of the distinctive characteristics of agent-oriented development, check out the guide on agent-oriented development . If you would like to develop an AEA in a language different to Python then check out our language agnostic AEA definition . If you want to run a demo, check out the demo guides .","title":"Next steps"},{"location":"aea/#help-us-improve","text":"Note This developer documentation is a work in progress. If you spot any errors please open an issue on Github or contact us in the developer Discord channel .","title":"Help us improve"},{"location":"aea/12-factor/","text":"Relationship with the Twelve-Factor App methodology. The Twelve-Factor App is a set of best practices to build modern web applications, or software-as-a-service . In this section, we will see how the AEA framework facilitates the achievement of those in the development, release and deployment phases of an AEA project. Note that an AEA instance, as a software agent, can be seen as a more general case of a web app, as it not only shows reactive behaviour, but it is also proactive , depending on the goals assigned to it. Codebase One codebase tracked in revision control, many deploys Support: Excellent The framework does not impose any particular requirement or convention on the type of version control software to be used to store an AEA project. Dependencies Explicitly declare and isolate dependencies Support: Good The framework allows an AEA project to explicitly declare the AEA package dependencies, and the PyPI dependencies needed to proper working. However, it does not provide built-in support for checking platform-specific dependencies, e.g. specific Python version, or needed system-wide available libraries. Nevertheless, this can be indirectly achieved by means of build scripts called on aea build , which can do the checks manually according to the specific requirements of the project. Configuration Store configuration in the environment Support: Good An AEA project can specify an environment configuration file .env , stored in the project root, that the framework will use to update environment variables before the execution of the AEA instance. The CLI tool command aea run accepts the option --env PATH to change the default configuration file. However, the framework does not automatically switch between, nor allows to add, different types of configuration files, one for each deployment step (e.g. development, staging, production), without using the --env option. Backing services Treat backing services as attached resources Support: Good A persistent storage of an AEA can be seen as an attached resource in the 12-factor terminology. The default storage is SQLite, but the interface AbstractStorageBacked allows to implement specific wrappers to other backing services, without changing the AEA project code. The support for integrating different storage back-end implementations in an AEA project by using a plug-in mechanism is currently missing. Moreover, new adapters to backing services can be implemented as custom connections, which can connect to attached resources. This does not usually requires a change in the skill code, especially in the case when a custom protocol can abstract the details of the interaction with the specific resource. Build, release, run Strictly separate build and run stages Support: Excellent The phases of build, release and run of an AEA project are neatly separated, both for programmatic usage and through the usage of the CLI tool, as each of them corresponds to different subcommands. Processes Execute the app as one or more stateless processes Support: Excellent Whether the process is stateless depends on the specific AEA. No strict enforcement is applied by the framework. Moreover, dialogue histories can be stored with persistent storage, if enabled by the developer. Port binding Export services via port binding Support: Excellent An AEA project may not need to expose services via HTTP. This property depends on the specific choices of the project developer, and the framework does not impose any restriction. One of the provided package, the \"HTTP server\" connection, relies on aiohttp , which makes the connection completely self-contained\u2014therefore, it satisfies the requirement. Another relevant example is the ACN node, which exposes its service to the Libp2p AEA connection Concurrency Scale out via the process model Support: Not Supported The framework does not easily allow to scale up an AEA instance with multiple processes, as it is bound to a process. However, note that its attached services can live in a different process, which could give better scalability. Disposability Maximize robustness with fast startup and graceful shutdown Support: Good Disposability of an AEA instance depends, in general, on the AEA itself; whether the connections can be quickly connected and disconnected, whether skills can be easily torn down or not, whether other resources can be detached successfully like the persistent storage, just to name a few examples. There has been put some effort into reducing startup time, and to ensure that a graceful shut down can happen when the process receives a SIGTERM under normal circumstances, but robustness cannot be ensured for individual components, as it depends on their implementation. Additionally, the framework does provide some features to control some aspects of AEA disposability, e.g. the possibility to change execution timeout for behaviours or handlers, implementation of an effective exception propagation from a component code to the main agent loop. Dev/prod parity Keep development, staging, and production as similar as possible Support: Good This aspect mostly depends on the specific AEA project, and the framework does not impose particular restrictions on best deployment practices (e.g. continuous integration, same backing services between development and production stages). Logs Treat logs as event streams Support: Excellent Thanks to the seamless integration with the Python standard library logging , the developer or the deployer has great control on the routing and filtering of log records. The behaviour can be changed by providing a proper configuration in the AEA project configuration file, according to the standard library specification. The framework facilitates this by creating ad-hoc logger names that can be used for finer-grained routing or filtering; for example, each AEA instance uses its own logging namespace to send logging events. Integration with other log handlers is delegated to extensions of the standard library, hence not necessarily coupled with the AEA framework. Admin processes Run admin/management tasks as one-off processes Support: Good The CLI tool provides commands to manage private keys and ledger related operations, and it is possible to extend it with a plugin to manage databases of AEA's persistent storage for maintenance operations. Moreover, the Python programming language makes it easy to run one-off scripts or running a console (also known as REPL) to do management tasks. It follows that it is also easy to ensure dependency isolation and same configurations of the running AEA instance.","title":"12-Factor app and AEAs"},{"location":"aea/12-factor/#relationship-with-the-twelve-factor-app-methodology","text":"The Twelve-Factor App is a set of best practices to build modern web applications, or software-as-a-service . In this section, we will see how the AEA framework facilitates the achievement of those in the development, release and deployment phases of an AEA project. Note that an AEA instance, as a software agent, can be seen as a more general case of a web app, as it not only shows reactive behaviour, but it is also proactive , depending on the goals assigned to it.","title":"Relationship with the Twelve-Factor App methodology."},{"location":"aea/12-factor/#codebase","text":"One codebase tracked in revision control, many deploys Support: Excellent The framework does not impose any particular requirement or convention on the type of version control software to be used to store an AEA project.","title":"Codebase"},{"location":"aea/12-factor/#dependencies","text":"Explicitly declare and isolate dependencies Support: Good The framework allows an AEA project to explicitly declare the AEA package dependencies, and the PyPI dependencies needed to proper working. However, it does not provide built-in support for checking platform-specific dependencies, e.g. specific Python version, or needed system-wide available libraries. Nevertheless, this can be indirectly achieved by means of build scripts called on aea build , which can do the checks manually according to the specific requirements of the project.","title":"Dependencies"},{"location":"aea/12-factor/#configuration","text":"Store configuration in the environment Support: Good An AEA project can specify an environment configuration file .env , stored in the project root, that the framework will use to update environment variables before the execution of the AEA instance. The CLI tool command aea run accepts the option --env PATH to change the default configuration file. However, the framework does not automatically switch between, nor allows to add, different types of configuration files, one for each deployment step (e.g. development, staging, production), without using the --env option.","title":"Configuration"},{"location":"aea/12-factor/#backing-services","text":"Treat backing services as attached resources Support: Good A persistent storage of an AEA can be seen as an attached resource in the 12-factor terminology. The default storage is SQLite, but the interface AbstractStorageBacked allows to implement specific wrappers to other backing services, without changing the AEA project code. The support for integrating different storage back-end implementations in an AEA project by using a plug-in mechanism is currently missing. Moreover, new adapters to backing services can be implemented as custom connections, which can connect to attached resources. This does not usually requires a change in the skill code, especially in the case when a custom protocol can abstract the details of the interaction with the specific resource.","title":"Backing services"},{"location":"aea/12-factor/#build-release-run","text":"Strictly separate build and run stages Support: Excellent The phases of build, release and run of an AEA project are neatly separated, both for programmatic usage and through the usage of the CLI tool, as each of them corresponds to different subcommands.","title":"Build, release, run"},{"location":"aea/12-factor/#processes","text":"Execute the app as one or more stateless processes Support: Excellent Whether the process is stateless depends on the specific AEA. No strict enforcement is applied by the framework. Moreover, dialogue histories can be stored with persistent storage, if enabled by the developer.","title":"Processes"},{"location":"aea/12-factor/#port-binding","text":"Export services via port binding Support: Excellent An AEA project may not need to expose services via HTTP. This property depends on the specific choices of the project developer, and the framework does not impose any restriction. One of the provided package, the \"HTTP server\" connection, relies on aiohttp , which makes the connection completely self-contained\u2014therefore, it satisfies the requirement. Another relevant example is the ACN node, which exposes its service to the Libp2p AEA connection","title":"Port binding"},{"location":"aea/12-factor/#concurrency","text":"Scale out via the process model Support: Not Supported The framework does not easily allow to scale up an AEA instance with multiple processes, as it is bound to a process. However, note that its attached services can live in a different process, which could give better scalability.","title":"Concurrency"},{"location":"aea/12-factor/#disposability","text":"Maximize robustness with fast startup and graceful shutdown Support: Good Disposability of an AEA instance depends, in general, on the AEA itself; whether the connections can be quickly connected and disconnected, whether skills can be easily torn down or not, whether other resources can be detached successfully like the persistent storage, just to name a few examples. There has been put some effort into reducing startup time, and to ensure that a graceful shut down can happen when the process receives a SIGTERM under normal circumstances, but robustness cannot be ensured for individual components, as it depends on their implementation. Additionally, the framework does provide some features to control some aspects of AEA disposability, e.g. the possibility to change execution timeout for behaviours or handlers, implementation of an effective exception propagation from a component code to the main agent loop.","title":"Disposability"},{"location":"aea/12-factor/#devprod-parity","text":"Keep development, staging, and production as similar as possible Support: Good This aspect mostly depends on the specific AEA project, and the framework does not impose particular restrictions on best deployment practices (e.g. continuous integration, same backing services between development and production stages).","title":"Dev/prod parity"},{"location":"aea/12-factor/#logs","text":"Treat logs as event streams Support: Excellent Thanks to the seamless integration with the Python standard library logging , the developer or the deployer has great control on the routing and filtering of log records. The behaviour can be changed by providing a proper configuration in the AEA project configuration file, according to the standard library specification. The framework facilitates this by creating ad-hoc logger names that can be used for finer-grained routing or filtering; for example, each AEA instance uses its own logging namespace to send logging events. Integration with other log handlers is delegated to extensions of the standard library, hence not necessarily coupled with the AEA framework.","title":"Logs"},{"location":"aea/12-factor/#admin-processes","text":"Run admin/management tasks as one-off processes Support: Good The CLI tool provides commands to manage private keys and ledger related operations, and it is possible to extend it with a plugin to manage databases of AEA's persistent storage for maintenance operations. Moreover, the Python programming language makes it easy to run one-off scripts or running a console (also known as REPL) to do management tasks. It follows that it is also easy to ensure dependency isolation and same configurations of the running AEA instance.","title":"Admin processes"},{"location":"aea/acn-internals/","text":"The aim of this document is to describe at a high-level the main implementation of the Agent Communication Network (ACN). In particular: the libp2p_node Golang library ; the p2p_libp2p AEA connection, written in Python, that implements the direct connection with an ACN peer ; the p2p_libp2p_client AEA connection, written in Python, which implements the delegate connection with an ACN peer . It is assumed the reader already knows what is the ACN and its purposes; if not, we suggest reading this page . This documentation page is structured as follows: Firstly, the ACN protocol is described: all the messages and data structures involved, as well as some example of interaction protocol with these messages; Then, it is explained how a peer can join an existing ACN network, and the message exchange involved; It follows the description of the journey of an envelope in the ACN network: from the agent connection to its contact peer, between ACN peers, and then from the contact peer of the destination agent to the target agent; The following section describes the functionalities of the AEA connections that allow to communicate through the ACN: fetchai/p2p_libp2p and fetchia/p2p_libp2p_delegate ; The documentation ends with a section of known issues and limitations of the current implementation. Messages and Data Structures At the foundation of the ACN there is the ACN protocol . The protocol messages and the reply structure are generated from this protocol specification , using the protocol generator . Therefore, it uses Protocol Buffers as a serialization format, and the definition of the data structures involved is defined in this .proto file . To know more about the protocol generator, refer to the relevant section of the documentation: Protocol Generator . Agent Record An agent record is a data structure containing information about an agent and its Proof-of-Representation (PoR) to be used by a peer for other peers. This data structure is used as a payload in other ACN messages (see below). The AgentRecord data structure contains the following fields: service_id : a string describing the service identifier. ledger_id : a string. It is the identifier of the ledger this agent record is associated to. Currently, the allowed values are: fetchai , the identifier for the Fetch.AI ledger; ethereum , the identifier for the Ethereum ledger; cosmos , the identifier for the Cosmos ledger; address : a string. It is the public key of a public-private key pair. It is used as an identifier for routing purposes. public_key : a string. The representative's public key. Used in case of (PoR). peer_public_key : a string. The public key of the peer. signature : a string. The signature for PoR. not_before : a string. Specify the lower bound for certificate validity. If it is a string, it must follow the format: YYYY-MM-DD . It will be interpreted as time zone UTC-0 not_after : a string. Specify the upper bound for certificate validity. If it is a string, it must follow the format: YYYY-MM-DD . It will be interpreted as time zone UTC-0. ACN Message Entities in the ACN (i.e. either agents or peers) exchange ACN messages . An ACN message contains a payload field, which is the actual content of the message. There are different types of payloads: Status Register LookupRequest LookupResponse AeaEnvelope Status The Status payload is used as a response message to inform the sender about the handling of certain requests. The payload contains: the status_code , a positive integer among the ones in the Protobuf file . a list of error messages (string). A status code 0 , identified as SUCCESS , means that the request has been processed successfully. Status codes greater than 0 can be: Generic errors: errors that occur under generic circumstances. ERROR_UNSUPPORTED_VERSION , with integer value 1 : the receiver of the message does not support the protocol version of the sender; ERROR_UNEXPECTED_PAYLOAD , with integer value 2 : the payload could not be deserialised on the receiver side; ERROR_GENERIC , with integer value 3 : an internal error; ERROR_SERIALIZATION , with integer value 4 : a serialization error occurred on the receiving end; Register errors: errors that occur during agent registration operations in the ACN. ERROR_WRONG_AGENT_ADDRESS , with integer value 10 : the PoR by a peer from another peer does not match the destination address of the envelope to be routed by the receiving peer. ERROR_WRONG_PUBLIC_KEY , with integer value 11 : the representative peer public key does not match the one in the agent record; ERROR_INVALID_PROOF , with integer value 12 : the signature is invalid; ERROR_UNSUPPORTED_LEDGER , with integer value 13 : the ledger of the PoR is not supported by the peer; Lookup and delivery errors: errors that occur during lookup to the DHT and envelope delivery operations in the ACN. ERROR_UNKNOWN_AGENT_ADDRESS , with integer value 20 : the requested agent address has not been found in the local DHT of the peer; ERROR_AGENT_NOT_READY , with integer value 21 : the agent is not ready for envelope delivery. Register The Register payload is used to request a peer to register an agent among his known ones. The payload contains the field record , which is an instance of AgentRecord . LookupRequest The LookupRequest payload is sent between peer to look-up addresses in the Distributed Hash Table (DHT). It contains the agent address (a string) that the sender needs to correctly route an envelope. LookupResponse The LookupResponse payload is the response sent by a peer that received a LookupRequest . It contains the AgentRecord associated to the requested address. AeaEnvelope The AeaEnvelope payload contains the envelope sent by an agent and to be delivered to another agent. It contains: envelope : the envelope to be forwarded, in byte representation; an AgentRecord (see above). ACN Protocol Interactions The ACN protocol specifies three different possible interactions: the registration interaction the look-up interaction the routing interaction \"Registration\" Interaction The registration interaction is used by delegate agents or relayed peers to register themselves to another peer. sequenceDiagram participant Agent/RelayedPeer participant Peer Agent/RelayedPeer->>Peer: Register(AgentRecord) alt success note over Peer: check PoR Peer->>Agent/RelayedPeer: Status(SUCCESS) else wrong agent address Peer->>Agent/RelayedPeer: Status(ERROR_WRONG_AGENT_ADDRESS) else wrong public key Peer->>Agent/RelayedPeer: Status(ERROR_WRONG_PUBLIC_KEY) else invalid proof of representation Peer->>Agent/RelayedPeer: Status(ERROR_INVALID_PROOF) else unsupported ledger Peer->>Agent/RelayedPeer: Status(ERROR_UNSUPPORTED_LEDGER) end \"Look-up\" Interaction The look-up interaction is used by a peer to request information to another peer about an agent address. sequenceDiagram participant Peer1 participant Peer2 Peer1->>Peer2: LookupRequest(address) alt success Peer2->>Peer1: LookupResponse(AgentRecord) else unknown agent address Peer2->>Peer1: Status(ERROR_UNKNOWN_AGENT_ADDRESS) end \"Routing\" Interaction The routing interaction is used by agents and peers to route the envelope through the ACN. sequenceDiagram participant Peer1 participant Peer2 Peer1->>Peer2: AeaEnvelope(envelope, AgentRecord) alt success note over Peer2: check PoR Peer2->>Peer1: Status(SUCCESS) else error on decoding of Envelope payload Peer2->>Peer1: Status(ERROR_SERIALIZATION) else PoR errors note over Peer1,Peer2: see above end Joining the ACN network When an ACN peer wants to join the network, it has to start from a list of bootstrap peers , i.e. a list of ACN peers to connect with (at least one). Each node handles four different types of libp2p streams : the notification stream , identified by the URI /aea-notif/ : this stream is used by new peers to notify their existence to the address stream , identified by the URI /aea-address/ : used to send look-up requests and look-up responses; the envelope stream , identified by the URI /aea/ : used to forward and to receive ACN envelopes; the register relay stream , identified by the URI /aea-register/ : this is to receive messages from clients that want to register their agents addresses; this peer, and then it can register their addresses. To begin with, the node process initializes the transport connections with the bootstrap peers, the local copy of the Kademlia Distributed Hash Table (DHT), the persistent storage for agent records, and performs other non-functional operations like setting up the Prometheus monitoring system . Optionally, can also start listening for relay connections and delegate connections. Then, it sets up the notification stream and notifies the bootstrap peers (if any). sequenceDiagram participant Peer1 participant Peer2 participant Peer3 note over Peer1: notify bootstrap peers Peer1->>Peer2: notify Peer2->>Peer2: wait until notifying peer added to DHT activate Peer2 Peer1->>Peer3: notify Peer3->>Peer3: wait until notifying peer added to DHT activate Peer3 note over Peer2,Peer3: Peer1 registered to DHT deactivate Peer2 deactivate Peer3 loop for each local/relay/delegate address Peer1->>Peer1: compute CID from address Peer1->>Peer2: register address Peer1->>Peer3: register address end note over Peer1: set up: - address stream - envelope stream - register relay stream Relay connections If the ACN node is configured to run the relay service, it sets up the register relay stream, waiting for registration requests. The following diagram shows an example of the message exchanged during a registration request: sequenceDiagram participant Agent participant Peer Agent->>Peer: Register alt decoding error of ACN message Peer->>Agent: Status(ERROR_SERIALIZATION) else wrong payload Peer->>Agent: Status(ERROR_UNEXPECTED_PAYLOAD) else PoR check fails alt wrong agent address Peer->>Agent: Status(ERROR_WRONG_AGENT_ADDRESS) else unsupported ledger Peer->>Agent: Status(ERROR_UNSUPPORTED_LEDGER) else agent address and public key don't match Peer->>Agent: Status(ERROR_WRONG_AGENT_ADDRESS) else invalid proof Peer->>Agent: Status(ERROR_INVALID_PROOF) end else PoR check succeeds Peer->>Agent: Status(SUCCESS) note over Peer: announce agent address to other peers end Delegate connections If the ACN node is configured to run the delegate service, it start listening from a TCP socket at a configurable URI. To see a diagram of the message exchanged during a registration request read this section . ACN transport In the following sections, we describe the main three steps of the routing of an envelope through the ACN: ACN entrance : when an envelope sent by an agent enters the peer-to-peer network via the peer the agent is connected to i.e. agent-to-peer communication; ACN routing : when an envelope gets routed through the peer-to-peer network, i.e. peer-to-peer communication; ACN exit : when an envelope gets delivered to the receiving agent through its representative peer, i.e. peer-to-agent communication. ACN Envelope Entrance: Agent -> Peer In this section, we will describe the interaction protocols between agents and peers for the messages sent by the agent to the ACN network; in particular, the communication from the contact peer of an agent to the agent. The following diagram explains the exchange of messages on entering an envelope in the ACN. In the case of direct connection , Agent is a Python process, whereas Peer is in a separate (Golang) process. The logic of the Python Agent client is implemented in the AEA connection fetchai/p2p_libp2p The communication between Agent and Peer is done through an OS pipe for Inter-Process Communication (IPC) between the AEA's process and the libp2p node process; then, the message gets enqueued to an output queue by an input coroutine. Finally, the envelope ends up in an output queue, which is processed by an output coroutine and routed to the next peer. In the case of delegate connection , the message exchange is very similar; however, instead of using pipes, the communication is done through the network, i.e. TCP, with a peer which has the delegate service enabled. The logic of the Agent client connected with a delegate connection is implemented in the AEA connection fetchai/p2p_libp2p_client sequenceDiagram participant Agent participant Peer loop until Status(success) received Agent->>Peer: AeaEnvelope Agent->>Agent: wait note left of Agent: Wait until Status(success) alt successful case Peer->>Agent: Status(success) note over Agent: break loop else ack-timeout OR conn-error note left of Agent: continue: Try to resend/reconnect else version not supported Peer->>Agent: Status(ERROR_UNSUPPORTED_VERSION) else error on decoding of ACN message Peer->>Agent: Status(ERROR_SERIALIZATION) else error on decoding of Envelope payload Peer->>Agent: Status(ERROR_SERIALIZATION) else the payload cannot be handled Peer->>Agent: Status(ERROR_UNEXPECTED_PAYLOAD) end end note over Peer: route envelope to next peer ACN Envelope Routing In this section, we describe the interaction between peers when it comes to envelope routing. Assume an envelope arrives from an agent to peer Peer1 , i.e. Peer1 is the first hop of the routing. Let Agent be the local agent directly connected to Peer1 , Peer2 a direct peer of peer Peer1 . When the envelope is leaving Peer1 , we may have different scenario: 1) In case of direct connection, and the field sender of the envelope is not the local agent address: the message is considered invalid, and it is dropped. sequenceDiagram participant Agent participant Peer1 participant Peer2 Agent->>Peer1: AeaEnvelope alt envelope sender not registered locally note over Peer1: stop, log error end 2) the target of the envelope is the local agent connected to the peer: the envelope is routed to the local agent. sequenceDiagram participant Agent participant Peer1 participant Peer2 Agent->>Peer1: AeaEnvelope alt target == peer1.my_agent note over Peer1: envelope destinated to local agent, not routing loop agent not ready note over Peer1: sleep for 100ms end Peer1->>Agent: AeaEnvelope Agent->>Peer1: Status(Success) end 3) the target is a delegate client. Send the envelope via TCP. sequenceDiagram participant Delegate participant Peer1 participant Peer2 Delegate->>Peer1: AeaEnvelope alt destination is a delegate note over Peer1: send envelope to delegate via TCP Peer1->>Delegate: AeaEnvelope Delegate->>Peer1: Status(Success) end 4) Otherwise, look up the local DHT. If an entry is found, use it; otherwise, send a look-up request to connected peers. sequenceDiagram participant Agent participant Peer1 participant Peer2 Agent->>Peer1: AeaEnvelope alt address found in DHT note over Peer1: destination is a relay client else lookup address in DHT note over Peer1: send lookup request to all peers Peer1->>Peer2: LookupRequest alt generic error Peer2->>Peer1: Status(GENERIC_ERROR) else look-up response Peer2->>Peer1: LookupResponse note over Peer1: Check PoR else not found Peer2->>Peer1:Status(UNKNOWN_AGENT_ADDRESS) end end note over Peer1,Peer2: Now Peer1 knows the contact peer is PeerX In particular, when a peer receives a LookupRequest message, it does the following: sequenceDiagram participant Peer1 participant Peer2 Peer1->>Peer2: LookupRequest alt error Peer2->>Peer1: Status(Error) else local agent/relay/delegate note over Peer2: requested address is a local agent OR requested address is in my relay clients OR requested address is in my delegate clients Peer2->>Peer1: LookupResponse note over Peer1: Check PoR else not found locally note over Peer2: send lookup request to other peers... alt found Peer2->>Peer1: LookupResponse note over Peer1: Check PoR else not found Peer2->>Peer1:Status(UNKNOWN_AGENT_ADDRESS) end end Let Peer3 the contact peer of the recipient of the envelope. The following diagram shows how the contact peer of the envelope recipient handles the incoming envelope: sequenceDiagram participant Peer1 participant Peer3 Peer1->>Peer3: AeaEnvelope alt decoding error of ACN message Peer3->>Peer1: Status(ERROR_SERIALIZATION) else unexpected payload Peer3->>Peer1: Status(ERROR_UNEXPECTED_PAYLOAD) else decoding error of envelope payload Peer3->>Peer1: Status(ERROR_SERIALIZATION) else PoR check fails alt wrong agent address Peer3->>Peer1: Status(ERROR_WRONG_AGENT_ADDRESS) else unsupported ledger Peer3->>Peer1: Status(ERROR_UNSUPPORTED_LEDGER) else agent address and public key don't match Peer3->>Peer1: Status(ERROR_WRONG_AGENT_ADDRESS) else invalid proof Peer3->>Peer1: Status(ERROR_INVALID_PROOF) end else PoR check succeeds alt target is delegate, not ready Peer3->>Peer1: Status(ERROR_AGENT_NOT_READY) else exists delegate, ready note over Peer3: forward envelope via delegate connection Peer3->>Peer1: Status(SUCCESS) else target is local agent, not ready Peer3->>Peer1: Status(ERROR_AGENT_NOT_READY) else target is local agent, ready note over Peer3: forward envelope via direct connection Peer3->>Peer1: Status(SUCCESS) else agent does not exist Peer3->>Peer1: Status(ERROR_UNKNOWN_AGENT_ADDRESS) end end ACN Envelope Exit: Peer -> Agent The following diagram explains the exchange of messages on exiting an envelope in the ACN. That is, the communication from the contact peer of an agent to the agent. The same message exchange is done both in the case of direct connection and delegate connection, similarly for what has been described for the envelope entrance (see above) . sequenceDiagram participant Agent participant Peer Peer->>Agent: AeaEnvelope alt successful case Agent->>Peer: Status(success) else ack-timeout OR conn-error note left of Peer: do nothing else error on decoding of ACN message Agent->>Peer: Status(GENERIC_ERROR) else error on decoding of Envelope payload Agent->>Peer: Status(GENERIC_ERROR) else wrong payload Agent->>Peer: Status(GENERIC_ERROR) end Connect your AEA to the ACN To connect the AEA to the ACN network, there are two AEA connections available: the fetchai/p2p_libp2p , that implements a direct connection, and the fetchai/p2p_libp2p_delegate connection, that implements the delegate connection. For more information on the AEA connection package type, refer to this guide . The fetchai/p2p_libp2p connection The source code of the fetchai/p2p_libp2p connection can be downloaded from the AEA Registry , or from the main AEA framework repository. The package provides the connection class P2PLibp2pConnection , which implements the Connection interface and therefore can be used by the Multiplexer as any other connection. The connect method of this connection spawns a new instance of the libp2p_node program (i.e. an ACN peer node) and connects to it through OS pipes. Then, it sets up the message receiving loop , which enqueues messages in the input queue to be read by read method calls, and the message sending loop , which dequeues messages from the output queue and forwards them to the Libp2p node. The loops are run concurrently in the Multiplexer thread, using the Python asynchronous programming library asyncio . sequenceDiagram participant Libp2p Connection participant sending loop participant receiving loop participant Libp2p Node Libp2p Connection->>Libp2p Node: spawn process activate Libp2p Node Libp2p Connection->>sending loop: start recv loop sending loop->>sending loop: wait messages from output queue activate sending loop Libp2p Connection->>receiving loop: start send loop receiving loop->>receiving loop: wait messages from input queue activate receiving loop deactivate Libp2p Node deactivate sending loop deactivate receiving loop The send method enqueues a message in the output queue. The message is then dequeued by the sending loop, and then sent to the Libp2p node. sequenceDiagram participant Libp2p Connection participant sending loop participant Libp2p Node activate sending loop Libp2p Connection->>Libp2p Connection: enqueue message to output queue sending loop->>sending loop: dequeue message from output queue deactivate sending loop sending loop->>Libp2p Node: AeaEnvelope sending loop->>sending loop: wait for status activate sending loop alt success note over Libp2p Node: route envelope Libp2p Node->>sending loop: Status(SUCCESS) deactivate sending loop note over sending loop: OK else timed out note over sending loop: raise with error else acn message decoding error Libp2p Node->>sending loop: Status(ERROR_SERIALIZATION) else unexpected payload Libp2p Node->>sending loop: Status(ERROR_UNEXPECTED_PAYLOAD) else envelope decoding error Libp2p Node->>sending loop: Status(ERROR_SERIALIZATION) end The receive method dequeues a message from the input queue. The queue is populated by the receiving loop, which receives messages from the Libp2p node. sequenceDiagram participant Libp2p Connection participant receiving loop participant Libp2p Node activate receiving loop Libp2p Node->>receiving loop: AeaEnvelope deactivate receiving loop Libp2p Node->>Libp2p Node: wait for status activate Libp2p Node alt success note over receiving loop: enqueue envelope to input queue receiving loop->>Libp2p Node: Status(SUCCESS) deactivate Libp2p Node note over receiving loop: OK else timed out note over Libp2p Node: ignore else acn message decoding error receiving loop->>Libp2p Node: Status(ERROR_SERIALIZATION) else unexpected payload receiving loop->>Libp2p Node: Status(ERROR_UNEXPECTED_PAYLOAD) else envelope decoding error receiving loop->>Libp2p Node: Status(ERROR_SERIALIZATION) end Libp2p Connection->>receiving loop: read message from output queue note over Libp2p Connection: return message to Multiplexer the disconnect method stops both the receiving loop and the sending loop, and stops the Libp2p node. The fetchai/p2p_libp2p_delegate connection The source code of the fetchai/p2p_libp2p_delegate connection can be downloaded from the main AEA framework repository. or from the main AEA framework repository. The package provides the connection class P2PLibp2pClientConnection , which implements the Connection interface and therefore can be used by the Multiplexer as any other connection. The connect method of this connection will set up a TCP connection to the URI of the delegate peer. Then, it will send a Register request to register the agent among the peer's client connections. On registration success, it sets up the message receiving loop , which enqueues messages in the input queue to be read by read method calls, and the message sending loop , which dequeues messages from the output queue and forwards them to the Libp2p node. The loops are run concurrently in the Multiplexer thread, using the Python asynchronous programming library asyncio . sequenceDiagram participant Libp2p Client Connection participant Libp2p Node activate Libp2p Node Libp2p Node->>Libp2p Node: listening for TCP connections Libp2p Client Connection->>Libp2p Node: Register (via TCP) deactivate Libp2p Node alt decoding error of ACN message Libp2p Node->>Libp2p Client Connection: Status(ERROR_SERIALIZATION) else wrong payload Libp2p Node->>Libp2p Client Connection: Status(ERROR_UNEXPECTED_PAYLOAD) else PoR check fails alt wrong agent address Libp2p Node->>Libp2p Client Connection: Status(ERROR_WRONG_AGENT_ADDRESS) else unsupported ledger Libp2p Node->>Libp2p Client Connection: Status(ERROR_UNSUPPORTED_LEDGER) else agent address and public key don't match Libp2p Node->>Libp2p Client Connection: Status(ERROR_WRONG_AGENT_ADDRESS) else invalid proof Libp2p Node->>Libp2p Client Connection: Status(ERROR_INVALID_PROOF) end else PoR check succeeds Libp2p Node->>Libp2p Client Connection: Status(SUCCESS) note over Libp2p Node: announce agent address to other peers Libp2p Node->>Libp2p Node: wait data from socket activate Libp2p Node deactivate Libp2p Node end The send method and the receive methods behave similarly to the send and receive methods of the p2p_libp2p connection , in terms of message exchange; however, the communication is done via TCP rather than pipes. The disconnect method interrupts the connection with the delegate peer, without explicitly unregistering. Known issues and limitations In this section, we provide a list of known issues and limitations of the current implementation of the ACN, considering both the ACN nodes (written in Golang) and the AEA connections, for the Python AEA framework, to interact with them. Delegate client on client disconnection/reconnection In case of disconnection/reconnection, delegate client record will be removed. This can cause two problems: either the delegate client is not found, or connection is closed during the send operation. Possible solutions: Create more complicated structure for clients storage; Keep the delegate client record for longer; Clean up the record by timeout, per client queues. Code references: record removed: https://github.com/fetchai/agents-aea/blob/1db1720081969bcec1be5a2000ca176475d2b487/libs/go/libp2p_node/dht/dhtpeer/dhtpeer.go#L864 send code: https://github.com/fetchai/agents-aea/blob/1db1720081969bcec1be5a2000ca176475d2b487/libs/go/libp2p_node/dht/dhtpeer/dhtpeer.go#L955 Golang Node <> Python Client libp2p connection In case of connection between the Golang side (i.e. ACN node) and the Python side (i.e. the libp2p AEA connection) is broken, there is no reconnection attempt. The Golang side connect to the Python server opened, but if the connection is broken Golang can try to reconnect; however, the Python side does not know about this and will restart the node completely. Possible solutions: the problem requires updates on both sides and assume possible timeouts on broken connection. If connection is broken, the Python side awaits for reconnection from Golang side, and restart node completely after timeout. What a peer should do if it receives an acknowledgement with an error? If an ACN response is the Status with error code different from SUCCESS , the forwarding to other peers is not repeated. A possible solution is to resend the message; however, not clear why it should help in case of healthy connection, how many times the sender should retry, and how it would help. Discussion on GitHub: https://github.com/fetchai/agents-aea/pull/2509#discussion_r642628983 No possibility of switching peers In case of a peer becoming unavailable, a delegate client or relay client currently has no means to automatically switch the peer. In particular, the DHT should be updated when a client switches peers.","title":"ACN Internals"},{"location":"aea/acn-internals/#messages-and-data-structures","text":"At the foundation of the ACN there is the ACN protocol . The protocol messages and the reply structure are generated from this protocol specification , using the protocol generator . Therefore, it uses Protocol Buffers as a serialization format, and the definition of the data structures involved is defined in this .proto file . To know more about the protocol generator, refer to the relevant section of the documentation: Protocol Generator .","title":"Messages and Data Structures"},{"location":"aea/acn-internals/#agent-record","text":"An agent record is a data structure containing information about an agent and its Proof-of-Representation (PoR) to be used by a peer for other peers. This data structure is used as a payload in other ACN messages (see below). The AgentRecord data structure contains the following fields: service_id : a string describing the service identifier. ledger_id : a string. It is the identifier of the ledger this agent record is associated to. Currently, the allowed values are: fetchai , the identifier for the Fetch.AI ledger; ethereum , the identifier for the Ethereum ledger; cosmos , the identifier for the Cosmos ledger; address : a string. It is the public key of a public-private key pair. It is used as an identifier for routing purposes. public_key : a string. The representative's public key. Used in case of (PoR). peer_public_key : a string. The public key of the peer. signature : a string. The signature for PoR. not_before : a string. Specify the lower bound for certificate validity. If it is a string, it must follow the format: YYYY-MM-DD . It will be interpreted as time zone UTC-0 not_after : a string. Specify the upper bound for certificate validity. If it is a string, it must follow the format: YYYY-MM-DD . It will be interpreted as time zone UTC-0.","title":"Agent Record"},{"location":"aea/acn-internals/#acn-message","text":"Entities in the ACN (i.e. either agents or peers) exchange ACN messages . An ACN message contains a payload field, which is the actual content of the message. There are different types of payloads: Status Register LookupRequest LookupResponse AeaEnvelope","title":"ACN Message"},{"location":"aea/acn-internals/#status","text":"The Status payload is used as a response message to inform the sender about the handling of certain requests. The payload contains: the status_code , a positive integer among the ones in the Protobuf file . a list of error messages (string). A status code 0 , identified as SUCCESS , means that the request has been processed successfully. Status codes greater than 0 can be: Generic errors: errors that occur under generic circumstances. ERROR_UNSUPPORTED_VERSION , with integer value 1 : the receiver of the message does not support the protocol version of the sender; ERROR_UNEXPECTED_PAYLOAD , with integer value 2 : the payload could not be deserialised on the receiver side; ERROR_GENERIC , with integer value 3 : an internal error; ERROR_SERIALIZATION , with integer value 4 : a serialization error occurred on the receiving end; Register errors: errors that occur during agent registration operations in the ACN. ERROR_WRONG_AGENT_ADDRESS , with integer value 10 : the PoR by a peer from another peer does not match the destination address of the envelope to be routed by the receiving peer. ERROR_WRONG_PUBLIC_KEY , with integer value 11 : the representative peer public key does not match the one in the agent record; ERROR_INVALID_PROOF , with integer value 12 : the signature is invalid; ERROR_UNSUPPORTED_LEDGER , with integer value 13 : the ledger of the PoR is not supported by the peer; Lookup and delivery errors: errors that occur during lookup to the DHT and envelope delivery operations in the ACN. ERROR_UNKNOWN_AGENT_ADDRESS , with integer value 20 : the requested agent address has not been found in the local DHT of the peer; ERROR_AGENT_NOT_READY , with integer value 21 : the agent is not ready for envelope delivery.","title":"Status"},{"location":"aea/acn-internals/#register","text":"The Register payload is used to request a peer to register an agent among his known ones. The payload contains the field record , which is an instance of AgentRecord .","title":"Register"},{"location":"aea/acn-internals/#lookuprequest","text":"The LookupRequest payload is sent between peer to look-up addresses in the Distributed Hash Table (DHT). It contains the agent address (a string) that the sender needs to correctly route an envelope.","title":"LookupRequest"},{"location":"aea/acn-internals/#lookupresponse","text":"The LookupResponse payload is the response sent by a peer that received a LookupRequest . It contains the AgentRecord associated to the requested address.","title":"LookupResponse"},{"location":"aea/acn-internals/#aeaenvelope","text":"The AeaEnvelope payload contains the envelope sent by an agent and to be delivered to another agent. It contains: envelope : the envelope to be forwarded, in byte representation; an AgentRecord (see above).","title":"AeaEnvelope"},{"location":"aea/acn-internals/#acn-protocol-interactions","text":"The ACN protocol specifies three different possible interactions: the registration interaction the look-up interaction the routing interaction","title":"ACN Protocol Interactions"},{"location":"aea/acn-internals/#registration-interaction","text":"The registration interaction is used by delegate agents or relayed peers to register themselves to another peer. sequenceDiagram participant Agent/RelayedPeer participant Peer Agent/RelayedPeer->>Peer: Register(AgentRecord) alt success note over Peer: check PoR Peer->>Agent/RelayedPeer: Status(SUCCESS) else wrong agent address Peer->>Agent/RelayedPeer: Status(ERROR_WRONG_AGENT_ADDRESS) else wrong public key Peer->>Agent/RelayedPeer: Status(ERROR_WRONG_PUBLIC_KEY) else invalid proof of representation Peer->>Agent/RelayedPeer: Status(ERROR_INVALID_PROOF) else unsupported ledger Peer->>Agent/RelayedPeer: Status(ERROR_UNSUPPORTED_LEDGER) end","title":"\"Registration\" Interaction"},{"location":"aea/acn-internals/#look-up-interaction","text":"The look-up interaction is used by a peer to request information to another peer about an agent address. sequenceDiagram participant Peer1 participant Peer2 Peer1->>Peer2: LookupRequest(address) alt success Peer2->>Peer1: LookupResponse(AgentRecord) else unknown agent address Peer2->>Peer1: Status(ERROR_UNKNOWN_AGENT_ADDRESS) end","title":"\"Look-up\" Interaction"},{"location":"aea/acn-internals/#routing-interaction","text":"The routing interaction is used by agents and peers to route the envelope through the ACN. sequenceDiagram participant Peer1 participant Peer2 Peer1->>Peer2: AeaEnvelope(envelope, AgentRecord) alt success note over Peer2: check PoR Peer2->>Peer1: Status(SUCCESS) else error on decoding of Envelope payload Peer2->>Peer1: Status(ERROR_SERIALIZATION) else PoR errors note over Peer1,Peer2: see above end","title":"\"Routing\" Interaction"},{"location":"aea/acn-internals/#joining-the-acn-network","text":"When an ACN peer wants to join the network, it has to start from a list of bootstrap peers , i.e. a list of ACN peers to connect with (at least one). Each node handles four different types of libp2p streams : the notification stream , identified by the URI /aea-notif/ : this stream is used by new peers to notify their existence to the address stream , identified by the URI /aea-address/ : used to send look-up requests and look-up responses; the envelope stream , identified by the URI /aea/ : used to forward and to receive ACN envelopes; the register relay stream , identified by the URI /aea-register/ : this is to receive messages from clients that want to register their agents addresses; this peer, and then it can register their addresses. To begin with, the node process initializes the transport connections with the bootstrap peers, the local copy of the Kademlia Distributed Hash Table (DHT), the persistent storage for agent records, and performs other non-functional operations like setting up the Prometheus monitoring system . Optionally, can also start listening for relay connections and delegate connections. Then, it sets up the notification stream and notifies the bootstrap peers (if any). sequenceDiagram participant Peer1 participant Peer2 participant Peer3 note over Peer1: notify bootstrap peers Peer1->>Peer2: notify Peer2->>Peer2: wait until notifying peer added to DHT activate Peer2 Peer1->>Peer3: notify Peer3->>Peer3: wait until notifying peer added to DHT activate Peer3 note over Peer2,Peer3: Peer1 registered to DHT deactivate Peer2 deactivate Peer3 loop for each local/relay/delegate address Peer1->>Peer1: compute CID from address Peer1->>Peer2: register address Peer1->>Peer3: register address end note over Peer1: set up: - address stream - envelope stream - register relay stream","title":"Joining the ACN network"},{"location":"aea/acn-internals/#relay-connections","text":"If the ACN node is configured to run the relay service, it sets up the register relay stream, waiting for registration requests. The following diagram shows an example of the message exchanged during a registration request: sequenceDiagram participant Agent participant Peer Agent->>Peer: Register alt decoding error of ACN message Peer->>Agent: Status(ERROR_SERIALIZATION) else wrong payload Peer->>Agent: Status(ERROR_UNEXPECTED_PAYLOAD) else PoR check fails alt wrong agent address Peer->>Agent: Status(ERROR_WRONG_AGENT_ADDRESS) else unsupported ledger Peer->>Agent: Status(ERROR_UNSUPPORTED_LEDGER) else agent address and public key don't match Peer->>Agent: Status(ERROR_WRONG_AGENT_ADDRESS) else invalid proof Peer->>Agent: Status(ERROR_INVALID_PROOF) end else PoR check succeeds Peer->>Agent: Status(SUCCESS) note over Peer: announce agent address to other peers end","title":"Relay connections"},{"location":"aea/acn-internals/#delegate-connections","text":"If the ACN node is configured to run the delegate service, it start listening from a TCP socket at a configurable URI. To see a diagram of the message exchanged during a registration request read this section .","title":"Delegate connections"},{"location":"aea/acn-internals/#acn-transport","text":"In the following sections, we describe the main three steps of the routing of an envelope through the ACN: ACN entrance : when an envelope sent by an agent enters the peer-to-peer network via the peer the agent is connected to i.e. agent-to-peer communication; ACN routing : when an envelope gets routed through the peer-to-peer network, i.e. peer-to-peer communication; ACN exit : when an envelope gets delivered to the receiving agent through its representative peer, i.e. peer-to-agent communication.","title":"ACN transport"},{"location":"aea/acn-internals/#acn-envelope-entrance-agent-peer","text":"In this section, we will describe the interaction protocols between agents and peers for the messages sent by the agent to the ACN network; in particular, the communication from the contact peer of an agent to the agent. The following diagram explains the exchange of messages on entering an envelope in the ACN. In the case of direct connection , Agent is a Python process, whereas Peer is in a separate (Golang) process. The logic of the Python Agent client is implemented in the AEA connection fetchai/p2p_libp2p The communication between Agent and Peer is done through an OS pipe for Inter-Process Communication (IPC) between the AEA's process and the libp2p node process; then, the message gets enqueued to an output queue by an input coroutine. Finally, the envelope ends up in an output queue, which is processed by an output coroutine and routed to the next peer. In the case of delegate connection , the message exchange is very similar; however, instead of using pipes, the communication is done through the network, i.e. TCP, with a peer which has the delegate service enabled. The logic of the Agent client connected with a delegate connection is implemented in the AEA connection fetchai/p2p_libp2p_client sequenceDiagram participant Agent participant Peer loop until Status(success) received Agent->>Peer: AeaEnvelope Agent->>Agent: wait note left of Agent: Wait until Status(success) alt successful case Peer->>Agent: Status(success) note over Agent: break loop else ack-timeout OR conn-error note left of Agent: continue: Try to resend/reconnect else version not supported Peer->>Agent: Status(ERROR_UNSUPPORTED_VERSION) else error on decoding of ACN message Peer->>Agent: Status(ERROR_SERIALIZATION) else error on decoding of Envelope payload Peer->>Agent: Status(ERROR_SERIALIZATION) else the payload cannot be handled Peer->>Agent: Status(ERROR_UNEXPECTED_PAYLOAD) end end note over Peer: route envelope to next peer","title":"ACN Envelope Entrance: Agent -&gt; Peer"},{"location":"aea/acn-internals/#acn-envelope-routing","text":"In this section, we describe the interaction between peers when it comes to envelope routing. Assume an envelope arrives from an agent to peer Peer1 , i.e. Peer1 is the first hop of the routing. Let Agent be the local agent directly connected to Peer1 , Peer2 a direct peer of peer Peer1 . When the envelope is leaving Peer1 , we may have different scenario: 1) In case of direct connection, and the field sender of the envelope is not the local agent address: the message is considered invalid, and it is dropped. sequenceDiagram participant Agent participant Peer1 participant Peer2 Agent->>Peer1: AeaEnvelope alt envelope sender not registered locally note over Peer1: stop, log error end 2) the target of the envelope is the local agent connected to the peer: the envelope is routed to the local agent. sequenceDiagram participant Agent participant Peer1 participant Peer2 Agent->>Peer1: AeaEnvelope alt target == peer1.my_agent note over Peer1: envelope destinated to local agent, not routing loop agent not ready note over Peer1: sleep for 100ms end Peer1->>Agent: AeaEnvelope Agent->>Peer1: Status(Success) end 3) the target is a delegate client. Send the envelope via TCP. sequenceDiagram participant Delegate participant Peer1 participant Peer2 Delegate->>Peer1: AeaEnvelope alt destination is a delegate note over Peer1: send envelope to delegate via TCP Peer1->>Delegate: AeaEnvelope Delegate->>Peer1: Status(Success) end 4) Otherwise, look up the local DHT. If an entry is found, use it; otherwise, send a look-up request to connected peers. sequenceDiagram participant Agent participant Peer1 participant Peer2 Agent->>Peer1: AeaEnvelope alt address found in DHT note over Peer1: destination is a relay client else lookup address in DHT note over Peer1: send lookup request to all peers Peer1->>Peer2: LookupRequest alt generic error Peer2->>Peer1: Status(GENERIC_ERROR) else look-up response Peer2->>Peer1: LookupResponse note over Peer1: Check PoR else not found Peer2->>Peer1:Status(UNKNOWN_AGENT_ADDRESS) end end note over Peer1,Peer2: Now Peer1 knows the contact peer is PeerX In particular, when a peer receives a LookupRequest message, it does the following: sequenceDiagram participant Peer1 participant Peer2 Peer1->>Peer2: LookupRequest alt error Peer2->>Peer1: Status(Error) else local agent/relay/delegate note over Peer2: requested address is a local agent OR requested address is in my relay clients OR requested address is in my delegate clients Peer2->>Peer1: LookupResponse note over Peer1: Check PoR else not found locally note over Peer2: send lookup request to other peers... alt found Peer2->>Peer1: LookupResponse note over Peer1: Check PoR else not found Peer2->>Peer1:Status(UNKNOWN_AGENT_ADDRESS) end end Let Peer3 the contact peer of the recipient of the envelope. The following diagram shows how the contact peer of the envelope recipient handles the incoming envelope: sequenceDiagram participant Peer1 participant Peer3 Peer1->>Peer3: AeaEnvelope alt decoding error of ACN message Peer3->>Peer1: Status(ERROR_SERIALIZATION) else unexpected payload Peer3->>Peer1: Status(ERROR_UNEXPECTED_PAYLOAD) else decoding error of envelope payload Peer3->>Peer1: Status(ERROR_SERIALIZATION) else PoR check fails alt wrong agent address Peer3->>Peer1: Status(ERROR_WRONG_AGENT_ADDRESS) else unsupported ledger Peer3->>Peer1: Status(ERROR_UNSUPPORTED_LEDGER) else agent address and public key don't match Peer3->>Peer1: Status(ERROR_WRONG_AGENT_ADDRESS) else invalid proof Peer3->>Peer1: Status(ERROR_INVALID_PROOF) end else PoR check succeeds alt target is delegate, not ready Peer3->>Peer1: Status(ERROR_AGENT_NOT_READY) else exists delegate, ready note over Peer3: forward envelope via delegate connection Peer3->>Peer1: Status(SUCCESS) else target is local agent, not ready Peer3->>Peer1: Status(ERROR_AGENT_NOT_READY) else target is local agent, ready note over Peer3: forward envelope via direct connection Peer3->>Peer1: Status(SUCCESS) else agent does not exist Peer3->>Peer1: Status(ERROR_UNKNOWN_AGENT_ADDRESS) end end","title":"ACN Envelope Routing"},{"location":"aea/acn-internals/#acn-envelope-exit-peer-agent","text":"The following diagram explains the exchange of messages on exiting an envelope in the ACN. That is, the communication from the contact peer of an agent to the agent. The same message exchange is done both in the case of direct connection and delegate connection, similarly for what has been described for the envelope entrance (see above) . sequenceDiagram participant Agent participant Peer Peer->>Agent: AeaEnvelope alt successful case Agent->>Peer: Status(success) else ack-timeout OR conn-error note left of Peer: do nothing else error on decoding of ACN message Agent->>Peer: Status(GENERIC_ERROR) else error on decoding of Envelope payload Agent->>Peer: Status(GENERIC_ERROR) else wrong payload Agent->>Peer: Status(GENERIC_ERROR) end","title":"ACN Envelope Exit: Peer -&gt; Agent"},{"location":"aea/acn-internals/#connect-your-aea-to-the-acn","text":"To connect the AEA to the ACN network, there are two AEA connections available: the fetchai/p2p_libp2p , that implements a direct connection, and the fetchai/p2p_libp2p_delegate connection, that implements the delegate connection. For more information on the AEA connection package type, refer to this guide .","title":"Connect your AEA to the ACN"},{"location":"aea/acn-internals/#the-fetchaip2p_libp2p-connection","text":"The source code of the fetchai/p2p_libp2p connection can be downloaded from the AEA Registry , or from the main AEA framework repository. The package provides the connection class P2PLibp2pConnection , which implements the Connection interface and therefore can be used by the Multiplexer as any other connection. The connect method of this connection spawns a new instance of the libp2p_node program (i.e. an ACN peer node) and connects to it through OS pipes. Then, it sets up the message receiving loop , which enqueues messages in the input queue to be read by read method calls, and the message sending loop , which dequeues messages from the output queue and forwards them to the Libp2p node. The loops are run concurrently in the Multiplexer thread, using the Python asynchronous programming library asyncio . sequenceDiagram participant Libp2p Connection participant sending loop participant receiving loop participant Libp2p Node Libp2p Connection->>Libp2p Node: spawn process activate Libp2p Node Libp2p Connection->>sending loop: start recv loop sending loop->>sending loop: wait messages from output queue activate sending loop Libp2p Connection->>receiving loop: start send loop receiving loop->>receiving loop: wait messages from input queue activate receiving loop deactivate Libp2p Node deactivate sending loop deactivate receiving loop The send method enqueues a message in the output queue. The message is then dequeued by the sending loop, and then sent to the Libp2p node. sequenceDiagram participant Libp2p Connection participant sending loop participant Libp2p Node activate sending loop Libp2p Connection->>Libp2p Connection: enqueue message to output queue sending loop->>sending loop: dequeue message from output queue deactivate sending loop sending loop->>Libp2p Node: AeaEnvelope sending loop->>sending loop: wait for status activate sending loop alt success note over Libp2p Node: route envelope Libp2p Node->>sending loop: Status(SUCCESS) deactivate sending loop note over sending loop: OK else timed out note over sending loop: raise with error else acn message decoding error Libp2p Node->>sending loop: Status(ERROR_SERIALIZATION) else unexpected payload Libp2p Node->>sending loop: Status(ERROR_UNEXPECTED_PAYLOAD) else envelope decoding error Libp2p Node->>sending loop: Status(ERROR_SERIALIZATION) end The receive method dequeues a message from the input queue. The queue is populated by the receiving loop, which receives messages from the Libp2p node. sequenceDiagram participant Libp2p Connection participant receiving loop participant Libp2p Node activate receiving loop Libp2p Node->>receiving loop: AeaEnvelope deactivate receiving loop Libp2p Node->>Libp2p Node: wait for status activate Libp2p Node alt success note over receiving loop: enqueue envelope to input queue receiving loop->>Libp2p Node: Status(SUCCESS) deactivate Libp2p Node note over receiving loop: OK else timed out note over Libp2p Node: ignore else acn message decoding error receiving loop->>Libp2p Node: Status(ERROR_SERIALIZATION) else unexpected payload receiving loop->>Libp2p Node: Status(ERROR_UNEXPECTED_PAYLOAD) else envelope decoding error receiving loop->>Libp2p Node: Status(ERROR_SERIALIZATION) end Libp2p Connection->>receiving loop: read message from output queue note over Libp2p Connection: return message to Multiplexer the disconnect method stops both the receiving loop and the sending loop, and stops the Libp2p node.","title":"The fetchai/p2p_libp2p connection"},{"location":"aea/acn-internals/#the-fetchaip2p_libp2p_delegate-connection","text":"The source code of the fetchai/p2p_libp2p_delegate connection can be downloaded from the main AEA framework repository. or from the main AEA framework repository. The package provides the connection class P2PLibp2pClientConnection , which implements the Connection interface and therefore can be used by the Multiplexer as any other connection. The connect method of this connection will set up a TCP connection to the URI of the delegate peer. Then, it will send a Register request to register the agent among the peer's client connections. On registration success, it sets up the message receiving loop , which enqueues messages in the input queue to be read by read method calls, and the message sending loop , which dequeues messages from the output queue and forwards them to the Libp2p node. The loops are run concurrently in the Multiplexer thread, using the Python asynchronous programming library asyncio . sequenceDiagram participant Libp2p Client Connection participant Libp2p Node activate Libp2p Node Libp2p Node->>Libp2p Node: listening for TCP connections Libp2p Client Connection->>Libp2p Node: Register (via TCP) deactivate Libp2p Node alt decoding error of ACN message Libp2p Node->>Libp2p Client Connection: Status(ERROR_SERIALIZATION) else wrong payload Libp2p Node->>Libp2p Client Connection: Status(ERROR_UNEXPECTED_PAYLOAD) else PoR check fails alt wrong agent address Libp2p Node->>Libp2p Client Connection: Status(ERROR_WRONG_AGENT_ADDRESS) else unsupported ledger Libp2p Node->>Libp2p Client Connection: Status(ERROR_UNSUPPORTED_LEDGER) else agent address and public key don't match Libp2p Node->>Libp2p Client Connection: Status(ERROR_WRONG_AGENT_ADDRESS) else invalid proof Libp2p Node->>Libp2p Client Connection: Status(ERROR_INVALID_PROOF) end else PoR check succeeds Libp2p Node->>Libp2p Client Connection: Status(SUCCESS) note over Libp2p Node: announce agent address to other peers Libp2p Node->>Libp2p Node: wait data from socket activate Libp2p Node deactivate Libp2p Node end The send method and the receive methods behave similarly to the send and receive methods of the p2p_libp2p connection , in terms of message exchange; however, the communication is done via TCP rather than pipes. The disconnect method interrupts the connection with the delegate peer, without explicitly unregistering.","title":"The fetchai/p2p_libp2p_delegate connection"},{"location":"aea/acn-internals/#known-issues-and-limitations","text":"In this section, we provide a list of known issues and limitations of the current implementation of the ACN, considering both the ACN nodes (written in Golang) and the AEA connections, for the Python AEA framework, to interact with them.","title":"Known issues and limitations"},{"location":"aea/acn-internals/#delegate-client-on-client-disconnectionreconnection","text":"In case of disconnection/reconnection, delegate client record will be removed. This can cause two problems: either the delegate client is not found, or connection is closed during the send operation. Possible solutions: Create more complicated structure for clients storage; Keep the delegate client record for longer; Clean up the record by timeout, per client queues. Code references: record removed: https://github.com/fetchai/agents-aea/blob/1db1720081969bcec1be5a2000ca176475d2b487/libs/go/libp2p_node/dht/dhtpeer/dhtpeer.go#L864 send code: https://github.com/fetchai/agents-aea/blob/1db1720081969bcec1be5a2000ca176475d2b487/libs/go/libp2p_node/dht/dhtpeer/dhtpeer.go#L955","title":"Delegate client on client disconnection/reconnection"},{"location":"aea/acn-internals/#golang-node-python-client-libp2p-connection","text":"In case of connection between the Golang side (i.e. ACN node) and the Python side (i.e. the libp2p AEA connection) is broken, there is no reconnection attempt. The Golang side connect to the Python server opened, but if the connection is broken Golang can try to reconnect; however, the Python side does not know about this and will restart the node completely. Possible solutions: the problem requires updates on both sides and assume possible timeouts on broken connection. If connection is broken, the Python side awaits for reconnection from Golang side, and restart node completely after timeout.","title":"Golang Node &lt;&gt; Python Client libp2p connection"},{"location":"aea/acn-internals/#what-a-peer-should-do-if-it-receives-an-acknowledgement-with-an-error","text":"If an ACN response is the Status with error code different from SUCCESS , the forwarding to other peers is not repeated. A possible solution is to resend the message; however, not clear why it should help in case of healthy connection, how many times the sender should retry, and how it would help. Discussion on GitHub: https://github.com/fetchai/agents-aea/pull/2509#discussion_r642628983","title":"What a peer should do if it receives an acknowledgement with an error?"},{"location":"aea/acn-internals/#no-possibility-of-switching-peers","text":"In case of a peer becoming unavailable, a delegate client or relay client currently has no means to automatically switch the peer. In particular, the DHT should be updated when a client switches peers.","title":"No possibility of switching peers"},{"location":"aea/acn/","text":"The agent communication network (ACN) provides a system for agents to find each other and communicate, solely based on their wallet addresses. It addresses the message delivery problem. Message delivery problem Agents need to contact each others. Given the wallet address of a target agent, how can the originator agent deliver a message to it whilst guaranteeing certain properties? The properties we would like to have are: Reliability: with guarantees on message reception Authentication: to prevent impersonation Confidentiality: to prevent exposing sensitive information within the message Availability: some guarantees about the liveness of the service (tampering detection) The problem statement and the agents framework context impose a number of design constraints: Distributed environment: no assumption are placed about the location of the agent, they can be anywhere in the publicly reachable internet Decentralized environment: no trusted central authority Support for resource-constrained devices The ACN solves the above problem whilst providing the above guarantees and satisfying the constraints. Peers The ACN is maintained by peers. Peers are not to be equated with agents. They are processes (usually distributed and decentralized) that together maintain the service. To use the service, agents need to associate themselves with peers. Thanks to digital signatures, the association between a given peer and agent can be verified by any participant in the system. Distributed hash table At its core, the ACN implements a distributed hash table (DHT). A DHT is similar to a regular hash table in that it stores key-value pairs. However, storage is distributed across the participating machines (peers) with an efficient lookup operation. This is enabled by: Consistent hashing: decide responsibility for assignment of the DHT key-value storage Structured overlays: organize the participating peers in a well defined topology for efficient routing For the ACN, we use the DHT to store and maintain association between an agent address and the (network) location of its peer. N-tier architecture To satisfy different resource constraints and flexible deployment the ACN is implemented as a multi-tier architecture. As such, it provides an extension of the client-server model. The agent framework exploits this by implementing different tiers as different Connections : Note The p2p_libp2p_mailbox connection is not available yet. Trust and security An agent can choose which connection to use depending on the resource and trust requirements: p2p_libp2p connection: the agent maintains a peer of the ACN. The agent has full control over the peer and does not need to trust any other entity. p2p_libp2p_client connection: the agent maintains a client connection to a server which is operated by a peer of the ACN. The agent does need to trust the entity operating the peer. All communication protocols use public cryptography to ensure security (authentication, confidentiality, and availability) using TLS handshakes with pre-shared public keys.","title":"Agent Communication Network"},{"location":"aea/acn/#message-delivery-problem","text":"Agents need to contact each others. Given the wallet address of a target agent, how can the originator agent deliver a message to it whilst guaranteeing certain properties? The properties we would like to have are: Reliability: with guarantees on message reception Authentication: to prevent impersonation Confidentiality: to prevent exposing sensitive information within the message Availability: some guarantees about the liveness of the service (tampering detection) The problem statement and the agents framework context impose a number of design constraints: Distributed environment: no assumption are placed about the location of the agent, they can be anywhere in the publicly reachable internet Decentralized environment: no trusted central authority Support for resource-constrained devices The ACN solves the above problem whilst providing the above guarantees and satisfying the constraints.","title":"Message delivery problem"},{"location":"aea/acn/#peers","text":"The ACN is maintained by peers. Peers are not to be equated with agents. They are processes (usually distributed and decentralized) that together maintain the service. To use the service, agents need to associate themselves with peers. Thanks to digital signatures, the association between a given peer and agent can be verified by any participant in the system.","title":"Peers"},{"location":"aea/acn/#distributed-hash-table","text":"At its core, the ACN implements a distributed hash table (DHT). A DHT is similar to a regular hash table in that it stores key-value pairs. However, storage is distributed across the participating machines (peers) with an efficient lookup operation. This is enabled by: Consistent hashing: decide responsibility for assignment of the DHT key-value storage Structured overlays: organize the participating peers in a well defined topology for efficient routing For the ACN, we use the DHT to store and maintain association between an agent address and the (network) location of its peer.","title":"Distributed hash table"},{"location":"aea/acn/#n-tier-architecture","text":"To satisfy different resource constraints and flexible deployment the ACN is implemented as a multi-tier architecture. As such, it provides an extension of the client-server model. The agent framework exploits this by implementing different tiers as different Connections : Note The p2p_libp2p_mailbox connection is not available yet.","title":"N-tier architecture"},{"location":"aea/acn/#trust-and-security","text":"An agent can choose which connection to use depending on the resource and trust requirements: p2p_libp2p connection: the agent maintains a peer of the ACN. The agent has full control over the peer and does not need to trust any other entity. p2p_libp2p_client connection: the agent maintains a client connection to a server which is operated by a peer of the ACN. The agent does need to trust the entity operating the peer. All communication protocols use public cryptography to ensure security (authentication, confidentiality, and availability) using TLS handshakes with pre-shared public keys.","title":"Trust and security"},{"location":"aea/aea-vs-mvc/","text":"The AEA framework borrows several concepts from popular web frameworks like Django and Ruby on Rails . MVC Both aforementioned web frameworks use the MVC (model-view-controller) architecture. Models: contain business logic and data representations View: contain the HTML templates Controller: deals with the request-response handling Comparison to AEA framework The AEA framework is based on asynchronous messaging and other agent-oriented development assumptions . Hence, there is not a direct one-to-one relationship between MVC based architectures and the AEA framework. Nevertheless, there are some parallels which can help a developer familiar with MVC make quick progress in the AEA framework, in particular the development of Skills : Handler : receives messages for the protocol it is registered against and is supposed to handle these messages. Handlers are the reactive parts of a skill and can be thought of as similar to the Controller in MVC. They can also send new messages. Behaviour : a behaviour encapsulates proactive components of the agent. Since web apps do not have any goals or intentions, they do not proactively pursue an objective. Therefore, there is no equivalent concept in MVC. Behaviours also can, but do not have to, send messages. Task : they are meant to deal with long-running executions and can be thought of as the equivalent of background tasks in traditional web apps. Model : they implement business logic and data representation, and as such, they are similar to the Model in MVC. The View concept is probably best compared to the Message of a given Protocol in the AEA framework. Whilst views represent information to the client, messages represent information sent to other agents, other agent components and services. Next steps We recommend you continue with the next step in the 'Getting Started' series: Build a skill for an AEA","title":"AEA and web frameworks"},{"location":"aea/aea-vs-mvc/#mvc","text":"Both aforementioned web frameworks use the MVC (model-view-controller) architecture. Models: contain business logic and data representations View: contain the HTML templates Controller: deals with the request-response handling","title":"MVC"},{"location":"aea/aea-vs-mvc/#comparison-to-aea-framework","text":"The AEA framework is based on asynchronous messaging and other agent-oriented development assumptions . Hence, there is not a direct one-to-one relationship between MVC based architectures and the AEA framework. Nevertheless, there are some parallels which can help a developer familiar with MVC make quick progress in the AEA framework, in particular the development of Skills : Handler : receives messages for the protocol it is registered against and is supposed to handle these messages. Handlers are the reactive parts of a skill and can be thought of as similar to the Controller in MVC. They can also send new messages. Behaviour : a behaviour encapsulates proactive components of the agent. Since web apps do not have any goals or intentions, they do not proactively pursue an objective. Therefore, there is no equivalent concept in MVC. Behaviours also can, but do not have to, send messages. Task : they are meant to deal with long-running executions and can be thought of as the equivalent of background tasks in traditional web apps. Model : they implement business logic and data representation, and as such, they are similar to the Model in MVC. The View concept is probably best compared to the Message of a given Protocol in the AEA framework. Whilst views represent information to the client, messages represent information sent to other agents, other agent components and services.","title":"Comparison to AEA framework"},{"location":"aea/aea-vs-mvc/#next-steps","text":"We recommend you continue with the next step in the 'Getting Started' series: Build a skill for an AEA","title":"Next steps"},{"location":"aea/agent-oriented-development/","text":"Agent-oriented development In this section, we discuss some of the most fundamental characteristics of an agent-oriented approach to solution development, which might be different from existing paradigms and methodologies that you may be used to. We hope that with this, we can guide you towards the right mindset when designing your own agent-based solutions to real world problems. Decentralisation Multi-Agent Systems ( MAS ) are inherently decentralised. The vision is of an environment in which every agent is able to directly connect with everyone else and interact with them without having to rely on a third party acting as an intermediary or match-maker. This is in direct contrast to centralised systems in which a single entity is the central point of authority, through which all interactions happen. The conventional client-server model is an example of a centralized architecture where clients interact with one another regarding specific services (e.g. communication, commerce) only through a server. This is not to say that facilitators and middlemen have no place in a multi-agent system; rather it is the ' commanding reliance on middlemen ' that MAS rejects. Division of responsibilities: In a decentralised system, every agent is equally privileged, and (in principle) should be able to interact with any other agent. The idea is very much aligned with the peer-to-peer paradigm, in which it is the voluntary participation and contribution of the peers that create the infrastructure. Therefore, in a decentralised system, there is no central 'enforcer'. This means all the work that would typically fall under the responsibilities of a central entity must be performed by individual parties in a decentralised system. Blockchain-based cryptocurrencies are a good example of this. A notable characteristic of cryptocurrencies is the absence of central trusted entities (e.g. banks). But this in turn means that most security precautions related to the handling of digital assets and the execution of transactions are the responsibility of individuals. Decentralisation vs distribution: It is important to emphasise that by decentralisation we do not mean distribution; although multi-agent systems typically do also tend to be distributed. A distributed system is one whose components are physically located in different places and connected over a network. A fully centralised system, owned and operated by a single entity, may in fact be highly distributed. Google or Microsoft's cloud infrastructure are examples of this, where their components are distributed across the globe yet designed to work together harmoniously and function in unison. Decentralisation on the other hand refers to a system whose components may be owned, operated, and managed by different stakeholders, each with their own personal objectives, interests, and preferences which may not necessarily be aligned with one another or the system itself. Therefore, distribution refers to the physical placement of a system's components, whereas decentralisation refers to a) the diversity of ownership and control over a system's constituents, and b) the absence of central authorities between them. Example: To better illustrate the distinction between centralised and decentralised systems, consider another example: search and discoverability in a commerce environment. In a centralised system (say Amazon), there is a single search service -- provided, owned and run by the commerce company itself -- which takes care of all search-related functionality for every product within their domain. So to be discoverable in this system, all sellers must register their products with this particular service. However in a decentralised system, there may not necessarily be a single search service provider. There may be multiple such services, run by different, perhaps competing entities. Each seller has the freedom to register with (i.e. make themselves known to) one or a handful of services. On the buyers side, the more services they contact and query, the higher their chances of finding the product they are looking for. Conflicting Environment As discussed above, the notion of decentralisation extends as far as ownership and control. Therefore, the different components that make up a decentralised system may each be owned by a different entity, designed according to very different principles and standards, with heterogeneous software and hardware, and each with internal objectives that may be fundamentally inconsistent, worse yet contradictory, with those of others. As such, a distinctive characteristic of a multi-agent environment, is that it is inhabited by more than one agent (as the name suggests), where each agent may be owned potentially by a different stakeholder (individual, company, government). Since by design, each agent represents and looks after the interests of its owner(s), and because different stakeholders may have unaligned, conflicting, or contradictory interests, it is very common to have multi-agent systems in which the agents' objectives, values and preferences are unaligned, conflicting, or contradictory. In practice: There are practical implications that follow from the above when it comes to designing an agent. For example, it is not rational for an agent to automatically rely on the information it receives from other agents. The information could be: Incomplete: what is unrevealed may have been deemed private for strategic reasons. Uncertain: it may be the result of an inaccurate prediction. Incorrect: it could be an outright lie, due to the adversarial nature of the environment. Therefore one can argue, that there is a degree of uncertainty attached to almost all information an agent receives or infers in a multi-agent system. It wouldn't then be illogical for an agent to take a sceptical approach: treating everything as uncertain, unless proved otherwise. Asynchronisation The conflicting nature of multi-agent systems, consisting of self-interested autonomous agents, points to asynchronisation as the preferred method of designing and managing processes and interactions. Synchronisation vs asynchronisation: In general, asynchronisation refers to the decoupling of events that do interact with one another but do not occur at predetermined intervals, not necessarily relying on each other's existence to function. This is in contrast with synchronous systems in which processes are aware of one another, where one's execution depends in some way on the other. Asynchronisation in MAS: In the context of multi-agent systems, the decentralised and potentially conflicting nature of the environment creates uncertainty over the behaviour of the whole system, in particular of other agents. For example, suppose an agent i sends a message requesting some resources from an agent j . Since MAS often tends to be distributed, there is the usual uncertainties with communication over a network: j may never receive i 's request, or may receive it after a long delay. Furthermore, j could receive the request in time and respond immediately, but as mentioned in the last section, its answer might be incomplete (gives only some of the requested resources), uncertain (promises to give the resources, but cannot be fully trusted), or incorrect (sends a wrong resource). In addition, since agents are self-interested, j may decide to reply much later, to the point that the resource is no longer useful to agent i , or j may simply decide not to respond at all. There might be a myriad of reasons why it may choose to do that; it could be because j assigns a low priority to answering i over its other tasks. But that's beside the point. The take away is that agents' autonomy strongly influences what can be expected of them, and of an environment inhabited by them. As such, developing for a system whose constituents are autonomous, e.g. agents in a multi-agent system, is fundamentally different from one whose constituents aren't, e.g. objects in an object-oriented system. Objects vs agents: In object-oriented systems, objects are entities that encapsulate state and perform actions, i.e. call methods, on this state. In object-oriented languages, like C++ and Java, it is common practice to declare methods as public, so they can be invoked by other objects in the system whenever they wish. This implies that an object does not control its own behaviour. If an object\u2019s method is public, the object has no control over whether or not that method is executed. We cannot take for granted that an agent j will execute an action (the equivalent of a method in object-oriented systems) just because another agent i wants it to; this action may not be in the best interests of agent j . So we do not think of agents as invoking methods on one another, rather as requesting actions. If i requests j to perform an action, then j may or may not perform the action. It may choose to do it later or do it in exchange for something. The locus of control is therefore different in object-oriented and agent-oriented systems. In the former, the decision lies with the object invoking the method, whereas in the latter, the decision lies with the agent receiving the request. This distinction could be summarised by the following slogan (from An Introduction to MultiAgent Systems by Michael Wooldridge ): objects do it for free; agents do it because they want to. All of this makes asynchronisation the preferred method for designing agent processes and interactions. An agent's interactions should be independent of each other, as much as possible, and of the agent's decision making processes and actions. This means the success or failure of, or delay in any single interaction does not block the agent's other tasks. Time Closely related with the discussion of asynchronicity, is the idea that in multi-agent systems, time is not a universally agreed notion. Agents may not necessarily share the same clock and this fact must be taken into account when designing agent-based systems. For example, you cannot necessarily expect agents to synchronise their behaviour according to time (e.g. perform a certain task at a time X ). Another related issue, is that unlike some agent-based simulation (ABS) systems where there is a global tick rate for all agents, in AEA-based systems tick rates may be different for different agents. This is due to the fundamental difference that ABS systems control some aspects of all of their agents' executions while in AEA-based systems, agents are truly decoupled from one another - most likely distributed and running on different machines and networks - and there is absolutely no central unit that moderates any aspect of their behaviour. Complex, Incomplete, Inconsistent and Uncertain The fourth characteristic(s) relate to the environment in which agents are expected to operate in, and these have been mentioned a number of times in the previous sections. The environment agents are suited for typically tend to be complex, to the point that it is usually impossible for any single agent to perceive the whole of the environment on its own. This means that at any point in time, any agent has a limited knowledge about the state of the environment. In other words, the agents;' information tend to be incomplete due to the complexity and sophistication of the world in which they reside. Consider an agent which represents a driverless vehicle. The complexity of the problem of driving on the road makes it impossible for a single vehicle to have an accurate and up-to-date knowledge of the overall state of the world . This means that an agent's model of the world is at best uncertain. For instance, the vehicle, through its sensor may detect green light at a junction, and by being aware of what it means, it may infer that it is safe to cross a junction. However, that simply may not be true as another car in the opposite direction may still cross the junction violating their red light. Therefore, there is uncertainty associated with the knowledge \"it is safe to cross the road because the light is green\", and the agent must recognise that. Furthermore, the often conflicting nature of the environment means information obtained from multiple sources (agents) may be inconsistent. Again, this must be taken into consideration when designing an agent which is expected to operate successfully in a potentially conflicting environment. Further Reading Wooldridge, M. (2009). An Introduction to MultiAgent Systems . Wiley, Second edition. Shoham, Y. and Leyton-Brown, K. (2008). Multiagent Systems: Algorithmic, Game-Theoretic, and Logical Foundations . Cambridge University Press","title":"Agent-oriented development"},{"location":"aea/agent-oriented-development/#agent-oriented-development","text":"In this section, we discuss some of the most fundamental characteristics of an agent-oriented approach to solution development, which might be different from existing paradigms and methodologies that you may be used to. We hope that with this, we can guide you towards the right mindset when designing your own agent-based solutions to real world problems.","title":"Agent-oriented development"},{"location":"aea/agent-oriented-development/#decentralisation","text":"Multi-Agent Systems ( MAS ) are inherently decentralised. The vision is of an environment in which every agent is able to directly connect with everyone else and interact with them without having to rely on a third party acting as an intermediary or match-maker. This is in direct contrast to centralised systems in which a single entity is the central point of authority, through which all interactions happen. The conventional client-server model is an example of a centralized architecture where clients interact with one another regarding specific services (e.g. communication, commerce) only through a server. This is not to say that facilitators and middlemen have no place in a multi-agent system; rather it is the ' commanding reliance on middlemen ' that MAS rejects. Division of responsibilities: In a decentralised system, every agent is equally privileged, and (in principle) should be able to interact with any other agent. The idea is very much aligned with the peer-to-peer paradigm, in which it is the voluntary participation and contribution of the peers that create the infrastructure. Therefore, in a decentralised system, there is no central 'enforcer'. This means all the work that would typically fall under the responsibilities of a central entity must be performed by individual parties in a decentralised system. Blockchain-based cryptocurrencies are a good example of this. A notable characteristic of cryptocurrencies is the absence of central trusted entities (e.g. banks). But this in turn means that most security precautions related to the handling of digital assets and the execution of transactions are the responsibility of individuals. Decentralisation vs distribution: It is important to emphasise that by decentralisation we do not mean distribution; although multi-agent systems typically do also tend to be distributed. A distributed system is one whose components are physically located in different places and connected over a network. A fully centralised system, owned and operated by a single entity, may in fact be highly distributed. Google or Microsoft's cloud infrastructure are examples of this, where their components are distributed across the globe yet designed to work together harmoniously and function in unison. Decentralisation on the other hand refers to a system whose components may be owned, operated, and managed by different stakeholders, each with their own personal objectives, interests, and preferences which may not necessarily be aligned with one another or the system itself. Therefore, distribution refers to the physical placement of a system's components, whereas decentralisation refers to a) the diversity of ownership and control over a system's constituents, and b) the absence of central authorities between them. Example: To better illustrate the distinction between centralised and decentralised systems, consider another example: search and discoverability in a commerce environment. In a centralised system (say Amazon), there is a single search service -- provided, owned and run by the commerce company itself -- which takes care of all search-related functionality for every product within their domain. So to be discoverable in this system, all sellers must register their products with this particular service. However in a decentralised system, there may not necessarily be a single search service provider. There may be multiple such services, run by different, perhaps competing entities. Each seller has the freedom to register with (i.e. make themselves known to) one or a handful of services. On the buyers side, the more services they contact and query, the higher their chances of finding the product they are looking for.","title":"Decentralisation"},{"location":"aea/agent-oriented-development/#conflicting-environment","text":"As discussed above, the notion of decentralisation extends as far as ownership and control. Therefore, the different components that make up a decentralised system may each be owned by a different entity, designed according to very different principles and standards, with heterogeneous software and hardware, and each with internal objectives that may be fundamentally inconsistent, worse yet contradictory, with those of others. As such, a distinctive characteristic of a multi-agent environment, is that it is inhabited by more than one agent (as the name suggests), where each agent may be owned potentially by a different stakeholder (individual, company, government). Since by design, each agent represents and looks after the interests of its owner(s), and because different stakeholders may have unaligned, conflicting, or contradictory interests, it is very common to have multi-agent systems in which the agents' objectives, values and preferences are unaligned, conflicting, or contradictory. In practice: There are practical implications that follow from the above when it comes to designing an agent. For example, it is not rational for an agent to automatically rely on the information it receives from other agents. The information could be: Incomplete: what is unrevealed may have been deemed private for strategic reasons. Uncertain: it may be the result of an inaccurate prediction. Incorrect: it could be an outright lie, due to the adversarial nature of the environment. Therefore one can argue, that there is a degree of uncertainty attached to almost all information an agent receives or infers in a multi-agent system. It wouldn't then be illogical for an agent to take a sceptical approach: treating everything as uncertain, unless proved otherwise.","title":"Conflicting Environment"},{"location":"aea/agent-oriented-development/#asynchronisation","text":"The conflicting nature of multi-agent systems, consisting of self-interested autonomous agents, points to asynchronisation as the preferred method of designing and managing processes and interactions. Synchronisation vs asynchronisation: In general, asynchronisation refers to the decoupling of events that do interact with one another but do not occur at predetermined intervals, not necessarily relying on each other's existence to function. This is in contrast with synchronous systems in which processes are aware of one another, where one's execution depends in some way on the other. Asynchronisation in MAS: In the context of multi-agent systems, the decentralised and potentially conflicting nature of the environment creates uncertainty over the behaviour of the whole system, in particular of other agents. For example, suppose an agent i sends a message requesting some resources from an agent j . Since MAS often tends to be distributed, there is the usual uncertainties with communication over a network: j may never receive i 's request, or may receive it after a long delay. Furthermore, j could receive the request in time and respond immediately, but as mentioned in the last section, its answer might be incomplete (gives only some of the requested resources), uncertain (promises to give the resources, but cannot be fully trusted), or incorrect (sends a wrong resource). In addition, since agents are self-interested, j may decide to reply much later, to the point that the resource is no longer useful to agent i , or j may simply decide not to respond at all. There might be a myriad of reasons why it may choose to do that; it could be because j assigns a low priority to answering i over its other tasks. But that's beside the point. The take away is that agents' autonomy strongly influences what can be expected of them, and of an environment inhabited by them. As such, developing for a system whose constituents are autonomous, e.g. agents in a multi-agent system, is fundamentally different from one whose constituents aren't, e.g. objects in an object-oriented system. Objects vs agents: In object-oriented systems, objects are entities that encapsulate state and perform actions, i.e. call methods, on this state. In object-oriented languages, like C++ and Java, it is common practice to declare methods as public, so they can be invoked by other objects in the system whenever they wish. This implies that an object does not control its own behaviour. If an object\u2019s method is public, the object has no control over whether or not that method is executed. We cannot take for granted that an agent j will execute an action (the equivalent of a method in object-oriented systems) just because another agent i wants it to; this action may not be in the best interests of agent j . So we do not think of agents as invoking methods on one another, rather as requesting actions. If i requests j to perform an action, then j may or may not perform the action. It may choose to do it later or do it in exchange for something. The locus of control is therefore different in object-oriented and agent-oriented systems. In the former, the decision lies with the object invoking the method, whereas in the latter, the decision lies with the agent receiving the request. This distinction could be summarised by the following slogan (from An Introduction to MultiAgent Systems by Michael Wooldridge ): objects do it for free; agents do it because they want to. All of this makes asynchronisation the preferred method for designing agent processes and interactions. An agent's interactions should be independent of each other, as much as possible, and of the agent's decision making processes and actions. This means the success or failure of, or delay in any single interaction does not block the agent's other tasks.","title":"Asynchronisation"},{"location":"aea/agent-oriented-development/#time","text":"Closely related with the discussion of asynchronicity, is the idea that in multi-agent systems, time is not a universally agreed notion. Agents may not necessarily share the same clock and this fact must be taken into account when designing agent-based systems. For example, you cannot necessarily expect agents to synchronise their behaviour according to time (e.g. perform a certain task at a time X ). Another related issue, is that unlike some agent-based simulation (ABS) systems where there is a global tick rate for all agents, in AEA-based systems tick rates may be different for different agents. This is due to the fundamental difference that ABS systems control some aspects of all of their agents' executions while in AEA-based systems, agents are truly decoupled from one another - most likely distributed and running on different machines and networks - and there is absolutely no central unit that moderates any aspect of their behaviour.","title":"Time"},{"location":"aea/agent-oriented-development/#complex-incomplete-inconsistent-and-uncertain","text":"The fourth characteristic(s) relate to the environment in which agents are expected to operate in, and these have been mentioned a number of times in the previous sections. The environment agents are suited for typically tend to be complex, to the point that it is usually impossible for any single agent to perceive the whole of the environment on its own. This means that at any point in time, any agent has a limited knowledge about the state of the environment. In other words, the agents;' information tend to be incomplete due to the complexity and sophistication of the world in which they reside. Consider an agent which represents a driverless vehicle. The complexity of the problem of driving on the road makes it impossible for a single vehicle to have an accurate and up-to-date knowledge of the overall state of the world . This means that an agent's model of the world is at best uncertain. For instance, the vehicle, through its sensor may detect green light at a junction, and by being aware of what it means, it may infer that it is safe to cross a junction. However, that simply may not be true as another car in the opposite direction may still cross the junction violating their red light. Therefore, there is uncertainty associated with the knowledge \"it is safe to cross the road because the light is green\", and the agent must recognise that. Furthermore, the often conflicting nature of the environment means information obtained from multiple sources (agents) may be inconsistent. Again, this must be taken into consideration when designing an agent which is expected to operate successfully in a potentially conflicting environment.","title":"Complex, Incomplete, Inconsistent and Uncertain"},{"location":"aea/agent-oriented-development/#further-reading","text":"Wooldridge, M. (2009). An Introduction to MultiAgent Systems . Wiley, Second edition. Shoham, Y. and Leyton-Brown, K. (2008). Multiagent Systems: Algorithmic, Game-Theoretic, and Logical Foundations . Cambridge University Press","title":"Further Reading"},{"location":"aea/agent-vs-aea/","text":"AEAs are more than just agents. In this guide we show some of the differences in terms of code. The Build an AEA programmatically guide shows how to programmatically build an AEA. We can build an agent of the Agent class programmatically as well. First, import the python and application specific libraries. (Get the packages directory from the AEA repository svn export https://github.com/fetchai/agents-aea.git/trunk/packages .) import os import time from threading import Thread from typing import List from aea.agent import Agent from aea.configurations.base import ConnectionConfig from aea.connections.base import Connection from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from packages.fetchai.connections.stub.connection import StubConnection from packages.fetchai.protocols.default.message import DefaultMessage Unlike an AEA , an Agent does not require a Wallet , LedgerApis or Resources module. However, we need to implement 4 abstract methods: - setup() - act() - handle_envelope() - teardown() When we run an agent, start() calls setup() and then the main agent loop. The main agent loop calls act() , react() and update() on each tick. When the agent is stopped via stop() then teardown() is called. Such a lightweight agent can be used to implement simple logic. Code an Agent We define our Agent which simply receives envelopes, prints the sender address and protocol_id and returns it unopened. INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" class MyAgent ( Agent ): \"\"\"A simple agent.\"\"\" def __init__ ( self , identity : Identity , connections : List [ Connection ]): \"\"\"Initialise the agent.\"\"\" super () . __init__ ( identity , connections ) def setup ( self ): \"\"\"Setup the agent.\"\"\" def act ( self ): \"\"\"Act implementation.\"\"\" print ( \"Act called for tick {} \" . format ( self . tick )) def handle_envelope ( self , envelope : Envelope ) -> None : \"\"\" Handle envelope. :param envelope: the envelope received :return: None \"\"\" print ( \"React called for tick {} \" . format ( self . tick )) if ( envelope is not None and envelope . protocol_specification_id == DefaultMessage . protocol_specification_id ): sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver envelope . message = DefaultMessage . serializer . decode ( envelope . message_bytes ) envelope . message . sender = receiver envelope . message . to = sender print ( \"Received envelope from {} with protocol_specification_id= {} \" . format ( sender , envelope . protocol_specification_id ) ) self . outbox . put ( envelope ) def teardown ( self ): \"\"\"Teardown the agent.\"\"\" Instantiate an Agent # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" , public_key = \"public_key\" ) # Set up the stub connection configuration = ConnectionConfig ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , data_dir = \".\" , identity = identity ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ]) Start the agent We run the agent from a different thread so that we can still use the main thread to pass it messages. # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 ) Send and receive an envelope We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = b \"my_agent,other_agent,fetchai/default:1.0.0, \\x12\\r\\x08\\x01 * \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"rb\" ) as f : print ( \"output message: \" + f . readline () . decode ( \"utf-8\" )) Shutdown Finally stop our agent and wait for it to finish finally : # Shut down the agent my_agent . stop () t . join () Your turn Now it is your turn to develop a simple agent with the Agent class. Entire code listing If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from typing import List from aea.agent import Agent from aea.configurations.base import ConnectionConfig from aea.connections.base import Connection from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from packages.fetchai.connections.stub.connection import StubConnection from packages.fetchai.protocols.default.message import DefaultMessage INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" class MyAgent ( Agent ): \"\"\"A simple agent.\"\"\" def __init__ ( self , identity : Identity , connections : List [ Connection ]): \"\"\"Initialise the agent.\"\"\" super () . __init__ ( identity , connections ) def setup ( self ): \"\"\"Setup the agent.\"\"\" def act ( self ): \"\"\"Act implementation.\"\"\" print ( \"Act called for tick {} \" . format ( self . tick )) def handle_envelope ( self , envelope : Envelope ) -> None : \"\"\" Handle envelope. :param envelope: the envelope received :return: None \"\"\" print ( \"React called for tick {} \" . format ( self . tick )) if ( envelope is not None and envelope . protocol_specification_id == DefaultMessage . protocol_specification_id ): sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver envelope . message = DefaultMessage . serializer . decode ( envelope . message_bytes ) envelope . message . sender = receiver envelope . message . to = sender print ( \"Received envelope from {} with protocol_specification_id= {} \" . format ( sender , envelope . protocol_specification_id ) ) self . outbox . put ( envelope ) def teardown ( self ): \"\"\"Teardown the agent.\"\"\" def run (): \"\"\"Run demo.\"\"\" # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" , public_key = \"public_key\" ) # Set up the stub connection configuration = ConnectionConfig ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , data_dir = \".\" , identity = identity ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ]) # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 ) # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = b \"my_agent,other_agent,fetchai/default:1.0.0, \\x12\\r\\x08\\x01 * \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"rb\" ) as f : print ( \"output message: \" + f . readline () . decode ( \"utf-8\" )) finally : # Shut down the agent my_agent . stop () t . join () if __name__ == \"__main__\" : run ()","title":"AEAs vs agents"},{"location":"aea/agent-vs-aea/#code-an-agent","text":"We define our Agent which simply receives envelopes, prints the sender address and protocol_id and returns it unopened. INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" class MyAgent ( Agent ): \"\"\"A simple agent.\"\"\" def __init__ ( self , identity : Identity , connections : List [ Connection ]): \"\"\"Initialise the agent.\"\"\" super () . __init__ ( identity , connections ) def setup ( self ): \"\"\"Setup the agent.\"\"\" def act ( self ): \"\"\"Act implementation.\"\"\" print ( \"Act called for tick {} \" . format ( self . tick )) def handle_envelope ( self , envelope : Envelope ) -> None : \"\"\" Handle envelope. :param envelope: the envelope received :return: None \"\"\" print ( \"React called for tick {} \" . format ( self . tick )) if ( envelope is not None and envelope . protocol_specification_id == DefaultMessage . protocol_specification_id ): sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver envelope . message = DefaultMessage . serializer . decode ( envelope . message_bytes ) envelope . message . sender = receiver envelope . message . to = sender print ( \"Received envelope from {} with protocol_specification_id= {} \" . format ( sender , envelope . protocol_specification_id ) ) self . outbox . put ( envelope ) def teardown ( self ): \"\"\"Teardown the agent.\"\"\"","title":"Code an Agent"},{"location":"aea/agent-vs-aea/#instantiate-an-agent","text":"# Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" , public_key = \"public_key\" ) # Set up the stub connection configuration = ConnectionConfig ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , data_dir = \".\" , identity = identity ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ])","title":"Instantiate an Agent"},{"location":"aea/agent-vs-aea/#start-the-agent","text":"We run the agent from a different thread so that we can still use the main thread to pass it messages. # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 )","title":"Start the agent"},{"location":"aea/agent-vs-aea/#send-and-receive-an-envelope","text":"We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = b \"my_agent,other_agent,fetchai/default:1.0.0, \\x12\\r\\x08\\x01 * \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"rb\" ) as f : print ( \"output message: \" + f . readline () . decode ( \"utf-8\" ))","title":"Send and receive an envelope"},{"location":"aea/agent-vs-aea/#shutdown","text":"Finally stop our agent and wait for it to finish finally : # Shut down the agent my_agent . stop () t . join ()","title":"Shutdown"},{"location":"aea/agent-vs-aea/#your-turn","text":"Now it is your turn to develop a simple agent with the Agent class.","title":"Your turn"},{"location":"aea/agent-vs-aea/#entire-code-listing","text":"If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from typing import List from aea.agent import Agent from aea.configurations.base import ConnectionConfig from aea.connections.base import Connection from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from packages.fetchai.connections.stub.connection import StubConnection from packages.fetchai.protocols.default.message import DefaultMessage INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" class MyAgent ( Agent ): \"\"\"A simple agent.\"\"\" def __init__ ( self , identity : Identity , connections : List [ Connection ]): \"\"\"Initialise the agent.\"\"\" super () . __init__ ( identity , connections ) def setup ( self ): \"\"\"Setup the agent.\"\"\" def act ( self ): \"\"\"Act implementation.\"\"\" print ( \"Act called for tick {} \" . format ( self . tick )) def handle_envelope ( self , envelope : Envelope ) -> None : \"\"\" Handle envelope. :param envelope: the envelope received :return: None \"\"\" print ( \"React called for tick {} \" . format ( self . tick )) if ( envelope is not None and envelope . protocol_specification_id == DefaultMessage . protocol_specification_id ): sender = envelope . sender receiver = envelope . to envelope . to = sender envelope . sender = receiver envelope . message = DefaultMessage . serializer . decode ( envelope . message_bytes ) envelope . message . sender = receiver envelope . message . to = sender print ( \"Received envelope from {} with protocol_specification_id= {} \" . format ( sender , envelope . protocol_specification_id ) ) self . outbox . put ( envelope ) def teardown ( self ): \"\"\"Teardown the agent.\"\"\" def run (): \"\"\"Run demo.\"\"\" # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Create an addresses identity: identity = Identity ( name = \"my_agent\" , address = \"some_address\" , public_key = \"public_key\" ) # Set up the stub connection configuration = ConnectionConfig ( input_file_path = INPUT_FILE , output_file_path = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , data_dir = \".\" , identity = identity ) # Create our Agent my_agent = MyAgent ( identity , [ stub_connection ]) # Set the agent running in a different thread try : t = Thread ( target = my_agent . start ) t . start () # Wait for everything to start up time . sleep ( 3 ) # Create a message inside an envelope and get the stub connection to pass it into the agent message_text = b \"my_agent,other_agent,fetchai/default:1.0.0, \\x12\\r\\x08\\x01 * \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed time . sleep ( 2 ) # Read the output envelope generated by the agent with open ( OUTPUT_FILE , \"rb\" ) as f : print ( \"output message: \" + f . readline () . decode ( \"utf-8\" )) finally : # Shut down the agent my_agent . stop () t . join () if __name__ == \"__main__\" : run ()","title":"Entire code listing"},{"location":"aea/aggregation-demo/","text":"This demo shows how AEAs can aggregate values over the peer-to-peer network. Discussion This demonstration shows how to set up a simple aggregation network in which several AEAs take an average of values fetched from different sources for the same real-world quantity. For this particular example, we take an average of Bitcoin prices from four public APIs. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo Create the AEAs Repeat the following process four times in four different terminals (for each { i=0 , i=1 , i=2 , i=3 }): Fetch the aggregator AEA: agent_name = \"agg $i \" aea fetch fetchai/simple_aggregator:0.4.0 --alias $agent_name cd $agent_name aea install aea build Alternatively, create from scratch. Create the AEA. agent_name = \"agg $i \" aea create agent_name cd agent_name aea add connection fetchai/http_client:0.23.0 aea add connection fetchai/http_server:0.22.0 aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/prometheus:0.8.0 aea add skill fetchai/advanced_data_request:0.6.0 aea add skill fetchai/simple_aggregation:0.2.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea install aea build Set the desired decimal precision for the quantity: aea config set --type int vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.decimals 0 Disable the http server since it is not used in this demo: aea config set --type bool vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.use_http_server false Set the cert requests for the peer-to-peer connection: aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"fetchai\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"message_format\": \"{public_key}\", \"save_path\": \".certs/conn_cert.txt\"}]' Match the agent index i to the COIN_URL and JSON_PATH below: - agg0 : COIN_URL=\"https://api.coinbase.com/v2/prices/BTC-USD/buy\" && JSON_PATH=\"data.amount\" - agg1 : COIN_URL=\"https://api.coinpaprika.com/v1/tickers/btc-bitcoin\" && JSON_PATH=\"quotes.USD.price\" - agg2 : COIN_URL=\"https://api.cryptowat.ch/markets/kraken/btcusd/price\" && JSON_PATH=\"result.price\" - agg3 : COIN_URL=\"https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd\" && JSON_PATH=\"bitcoin.usd\" Set the following configuration for the advanced_data_request skill: aea config set vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.url $COIN_URL aea config set vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.outputs '[{\"name\": \"price\", \"json_path\": ' \"\\\" $JSON_PATH \\\"\" '}]' Set the name of the quantity to aggregate and choose an aggregation function for the AEAs (the currently implemented options are mean , median , and mode ): aea config set vendor.fetchai.skills.simple_aggregation.models.strategy.args.quantity_name price aea config set vendor.fetchai.skills.simple_aggregation.models.strategy.args.aggregation_function mean Specify a name for your aggregation service: SERVICE_ID = my_btc_aggregation_service aea config set vendor.fetchai.skills.simple_aggregation.models.strategy.args.service_id $SERVICE_ID aea config set vendor.fetchai.skills.simple_aggregation.models.strategy.args.search_query.search_value $SERVICE_ID Additionally, create private keys for use with the ledger and the peer-to-peer connection: aea generate-key fetchai aea add-key fetchai aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the keys for use by the connections that request them: aea issue-certificates Configure the peer-to-peer network Set the multi-address of the first AEA as an initial peer to help the remaining AEAs find each other on the network. Also, if these AEAs are all running on the same machine, set different ports for their connections to ensure there are no conflicts (from the agg1 , agg2 , and agg3 directories): MULTIADDR = $( cd ../agg0 && aea get-multiaddress fetchai --connection ) aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:' $(( 11000 + i )) '\", \"entry_peers\": [\"/dns4/127.0.0.1/tcp/9000/p2p/' \" $MULTIADDR \\\"\" '], \"local_uri\": \"127.0.0.1:' $(( 9000 + i )) '\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:' $(( 9000 + i )) '\" }' aea config set vendor.fetchai.connections.prometheus.config.port $(( 20000 + i )) aea config set vendor.fetchai.connections.http_server.config.port $(( 8000 + i )) Oracle integration (optional) To publish the aggregated value to an oracle smart contract, add the ledger connection and simple oracle skill to one of the aggregators: aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/simple_oracle:0.14.0 Configure the simple oracle skill for the fetchai ledger: aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.ledger_id fetchai aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.update_function update_oracle_value Generate some wealth to use for transactions on the testnet ledger: aea generate-wealth fetchai Set the name of the oracle value to match the value collected by the aggregators: aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.oracle_value_name price_mean Run the AEAs Run each of the aggregator AEAs in separate terminals: aea run After a few moments, you should see the AEAs finding peers, making observations, sending them to peers, and taking the average of their observations: info: [ agg_i ] found agents... ... info: [ agg_i ] Fetching data from... ... info: [ agg_i ] Observation: { 'price' : { 'value' :... ... info: [ agg_i ] sending observation to peer... ... info: [ agg_i ] received observation from sender... ... info: [ agg_i ] Observations:... ... info: [ agg_i ] Aggregation ( mean ) :...","title":"Aggegation skill"},{"location":"aea/aggregation-demo/#discussion","text":"This demonstration shows how to set up a simple aggregation network in which several AEAs take an average of values fetched from different sources for the same real-world quantity. For this particular example, we take an average of Bitcoin prices from four public APIs.","title":"Discussion"},{"location":"aea/aggregation-demo/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/aggregation-demo/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/aggregation-demo/#demo","text":"","title":"Demo"},{"location":"aea/aggregation-demo/#create-the-aeas","text":"Repeat the following process four times in four different terminals (for each { i=0 , i=1 , i=2 , i=3 }): Fetch the aggregator AEA: agent_name = \"agg $i \" aea fetch fetchai/simple_aggregator:0.4.0 --alias $agent_name cd $agent_name aea install aea build Alternatively, create from scratch. Create the AEA. agent_name = \"agg $i \" aea create agent_name cd agent_name aea add connection fetchai/http_client:0.23.0 aea add connection fetchai/http_server:0.22.0 aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/prometheus:0.8.0 aea add skill fetchai/advanced_data_request:0.6.0 aea add skill fetchai/simple_aggregation:0.2.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea install aea build Set the desired decimal precision for the quantity: aea config set --type int vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.decimals 0 Disable the http server since it is not used in this demo: aea config set --type bool vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.use_http_server false Set the cert requests for the peer-to-peer connection: aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"fetchai\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"message_format\": \"{public_key}\", \"save_path\": \".certs/conn_cert.txt\"}]' Match the agent index i to the COIN_URL and JSON_PATH below: - agg0 : COIN_URL=\"https://api.coinbase.com/v2/prices/BTC-USD/buy\" && JSON_PATH=\"data.amount\" - agg1 : COIN_URL=\"https://api.coinpaprika.com/v1/tickers/btc-bitcoin\" && JSON_PATH=\"quotes.USD.price\" - agg2 : COIN_URL=\"https://api.cryptowat.ch/markets/kraken/btcusd/price\" && JSON_PATH=\"result.price\" - agg3 : COIN_URL=\"https://api.coingecko.com/api/v3/simple/price?ids=bitcoin&vs_currencies=usd\" && JSON_PATH=\"bitcoin.usd\" Set the following configuration for the advanced_data_request skill: aea config set vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.url $COIN_URL aea config set vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.outputs '[{\"name\": \"price\", \"json_path\": ' \"\\\" $JSON_PATH \\\"\" '}]' Set the name of the quantity to aggregate and choose an aggregation function for the AEAs (the currently implemented options are mean , median , and mode ): aea config set vendor.fetchai.skills.simple_aggregation.models.strategy.args.quantity_name price aea config set vendor.fetchai.skills.simple_aggregation.models.strategy.args.aggregation_function mean Specify a name for your aggregation service: SERVICE_ID = my_btc_aggregation_service aea config set vendor.fetchai.skills.simple_aggregation.models.strategy.args.service_id $SERVICE_ID aea config set vendor.fetchai.skills.simple_aggregation.models.strategy.args.search_query.search_value $SERVICE_ID Additionally, create private keys for use with the ledger and the peer-to-peer connection: aea generate-key fetchai aea add-key fetchai aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the keys for use by the connections that request them: aea issue-certificates","title":"Create the AEAs"},{"location":"aea/aggregation-demo/#configure-the-peer-to-peer-network","text":"Set the multi-address of the first AEA as an initial peer to help the remaining AEAs find each other on the network. Also, if these AEAs are all running on the same machine, set different ports for their connections to ensure there are no conflicts (from the agg1 , agg2 , and agg3 directories): MULTIADDR = $( cd ../agg0 && aea get-multiaddress fetchai --connection ) aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:' $(( 11000 + i )) '\", \"entry_peers\": [\"/dns4/127.0.0.1/tcp/9000/p2p/' \" $MULTIADDR \\\"\" '], \"local_uri\": \"127.0.0.1:' $(( 9000 + i )) '\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:' $(( 9000 + i )) '\" }' aea config set vendor.fetchai.connections.prometheus.config.port $(( 20000 + i )) aea config set vendor.fetchai.connections.http_server.config.port $(( 8000 + i ))","title":"Configure the peer-to-peer network"},{"location":"aea/aggregation-demo/#oracle-integration-optional","text":"To publish the aggregated value to an oracle smart contract, add the ledger connection and simple oracle skill to one of the aggregators: aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/simple_oracle:0.14.0 Configure the simple oracle skill for the fetchai ledger: aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.ledger_id fetchai aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.update_function update_oracle_value Generate some wealth to use for transactions on the testnet ledger: aea generate-wealth fetchai Set the name of the oracle value to match the value collected by the aggregators: aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.oracle_value_name price_mean","title":"Oracle integration (optional)"},{"location":"aea/aggregation-demo/#run-the-aeas","text":"Run each of the aggregator AEAs in separate terminals: aea run After a few moments, you should see the AEAs finding peers, making observations, sending them to peers, and taking the average of their observations: info: [ agg_i ] found agents... ... info: [ agg_i ] Fetching data from... ... info: [ agg_i ] Observation: { 'price' : { 'value' :... ... info: [ agg_i ] sending observation to peer... ... info: [ agg_i ] received observation from sender... ... info: [ agg_i ] Observations:... ... info: [ agg_i ] Aggregation ( mean ) :...","title":"Run the AEAs"},{"location":"aea/app-areas/","text":"The introduction and the agent-oriented development guide together present a picture of the kinds of solution an agent-based approach makes possible, and the types of environment they are most suited for. In short, this is where: the environment is decentralised, involves multiple stakeholders, and is inhabited by AEAs representing the different stakeholders who: interact autonomously, and communicate with one another directly via a peer-to-peer network. In light of those discussions, on this page we identify a number of application areas for AEA-based solutions. This list is by no means comprehensive. In fact, we are most excited about applications which we have not thought of before. Inhabitants : agents representing objects in the IoT (Internet of Things) space. For examples, AEAs paired with real world hardware devices such as drones, laptops, heat sensors, etc. An example is a thermometer agent . Interfaces : facilitation agents which provide the necessary API interfaces for interaction between existing (Web 2.0) and new (Web 3.0) economic models. An example is an AEA with HTTP connection and skill who has the capability to communicate using HTTP. Pure software : software agents living in the digital space that interact with interface agents and others. Digital data sales agents : software agents that attach to data sources and sell it via the open economic framework. An example can be found here . Representative : an agent which represents an individual's activities on the Fetch.ai network. An example can be found here . Likely short-term applications In the short-term we see AEAs primarily deployed in three areas: Off-load repetitive tasks: AEAs can automate well-defined processes in different domains such as supply chain, mobility and finance, etc. Micro transactions: AEAs make it economically viable to execute trades which involve small value transfers. This is particularly relevant in areas where there is a (data) supply side constituted of many small actors and a single demand side. Wallet agents: AEAs can simplify interactions with blockchains for end users. For instance, they can act as \"smart wallets\" which optimize blockchain interactions on behalf of the user. Multi-agent system versus agent-based modelling The multi-agent systems enabled by the AEA framework are technological agent-based solutions to real problems and, although there are some overlap, the framework is not designed from the outset to be used as an agent-based modelling software where the goal is scientific behavioural observation rather than practical economic gain. Moreover, there is no restriction to multi ; single-agent applications are also supported.","title":"Application areas"},{"location":"aea/app-areas/#likely-short-term-applications","text":"In the short-term we see AEAs primarily deployed in three areas: Off-load repetitive tasks: AEAs can automate well-defined processes in different domains such as supply chain, mobility and finance, etc. Micro transactions: AEAs make it economically viable to execute trades which involve small value transfers. This is particularly relevant in areas where there is a (data) supply side constituted of many small actors and a single demand side. Wallet agents: AEAs can simplify interactions with blockchains for end users. For instance, they can act as \"smart wallets\" which optimize blockchain interactions on behalf of the user.","title":"Likely short-term applications"},{"location":"aea/app-areas/#multi-agent-system-versus-agent-based-modelling","text":"The multi-agent systems enabled by the AEA framework are technological agent-based solutions to real problems and, although there are some overlap, the framework is not designed from the outset to be used as an agent-based modelling software where the goal is scientific behavioural observation rather than practical economic gain. Moreover, there is no restriction to multi ; single-agent applications are also supported.","title":"Multi-agent system versus agent-based modelling"},{"location":"aea/aries-cloud-agent-demo/","text":"Note This demo is incomplete and will soon be updated. Demonstrating an entire decentralised identity scenario involving AEAs and instances of Aries Cloud Agents (ACAs). Discussion This demo corresponds with the one here from Aries cloud agent repository . The aim of this demo is to illustrate how AEAs can connect to ACAs, thus gaining all of their capabilities, such as issuing and requesting verifiable credentials, selective disclosure and zero knowledge proofs. sequenceDiagram participant faea as Faber_AEA participant faca as Faber_ACA participant aaca as Alice_ACA participant aaea as Alice_AEA activate faea activate faca activate aaca activate aaea Note right of aaea: Shows P2P ID faea->>faca: Request status? faca->>faea: status faea->>faca: Register schema faca->>faea: schema_id faea->>faca: Register credential definition faca->>faea: credential_definition_id faea->>faca: create-invitation faca->>faea: connection inc. invitation faea->>aaea: invitation detail aaea->>aaca: receive-invitation deactivate faea deactivate faca deactivate aaca deactivate aaea There are two AEAs: Alice_AEA Faber_AEA and two ACAs: Alice_ACA Faber_ACA Each AEA is connected to its corresponding ACA: Alice_AEA to Alice_ACA and Faber_AEA to Faber_ACA . The following lists the sequence of interactions between the four agents: Alice_AEA : starts Alice_AEA : shows its P2P address in the terminal and waits for an invitation detail from Faber_AEA . Alice_AEA : registers itself on the SOEF. Faber_AEA : starts Faber_AEA : searches the SOEF and finds Alice_AEA . Faber_AEA : tests its connection to Faber_ACA . Faber_ACA : responds to Faber_AEA . Faber_AEA : registers a DID on the ledger. Faber_AEA : request Faber_ACA to register a schema on the ledger. Faber_ACA : responds by sending back the schema_id . Faber_AEA : request Faber_ACA to register a credential definition on the ledger. Faber_ACA : responds by sending back the credential_definition_id . Faber_AEA : requests Faber_ACA to create an invitation. Faber_ACA : responds by sending back the connection detail, which contains an invitation field. Faber_AEA : sends the invitation detail to Alice_AEA . Alice_AEA : receives invitation detail from Faber_AEA . Alice_AEA : requests Alice_ACA to accept the invitation, by passing it the invitation detail it received in the last step. All messages from an AEA to an ACA are http requests (using http_client connection). All messages from an AEA to another AEA utilise the P2P communication network accessed via the p2p_libp2p connection. All messages initiated from an ACA to an AEA are webhooks (using webhook connection). This is the extent of the demo at this point. The rest of the interactions require an instance of the Indy ledger to run. This is what will be implemented next. The rest of the interactions are broadly as follows: Alice_ACA : accepts the invitation. Alice_ACA : sends a matching invitation request to Faber_ACA . Faber_ACA : accepts At this point, the two ACAs are connected to each other. Faber_AEA : requests Faber_ACA to issue a credential (e.g. university degree) to Alice_AEA , which Faber_ACA does via Alice_ACA . Faber_AEA : requests proof that Alice_AEA 's age is above 18. Alice_AEA : presents proof that it's age is above 18, without presenting its credential. Preparation Instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Install Aries cloud-agents (for more info see here ) if you do not have it on your machine: pip install aries-cloudagent This demo has been successfully tested with aca-py version 0.4.5 . This demo requires an instance of von network running in docker locally (for more info see here ) This demo has been successfully tested with the von-network git repository pulled on 07 Aug 2020 (commit number ad1f84f64d4f4c106a81462f5fbff496c5fbf10e ). Terminals Open five terminals. The first terminal is used to run an instance of von-network locally in docker. The other four terminals will be used to run each of the four agents in this demo. VON Network In the first terminal move to the von-network directory and run an instance of von-network locally in docker. This tutorial has information on starting (and stopping) the network locally. ./manage build ./manage start --logs Once the ledger is running, you can see the ledger by going to the web server running on port 9000. On localhost, that means going to http://localhost:9000 . Alice and Faber ACAs To learn about the command for starting an ACA and its various options: aca-py start --help Faber_ACA In the first terminal: aca-py start --admin 127 .0.0.1 8021 --admin-insecure-mode --inbound-transport http 0 .0.0.0 8020 --outbound-transport http --webhook-url http://127.0.0.1:8022/webhooks Make sure the ports above are unused. Take note of the specific IP addresses and ports you used in the above command. We will refer to them by the following names: Faber admin IP : 127.0.0.1 Faber admin port : 8021 Faber webhook port : 8022 The admin IP and port will be used to send administrative commands to this ACA from an AEA. The webhook port is where the ACA will send notifications to. We will expose this from the AEA so it receives this ACA's notifications. Alice_ACA In the second terminal: aca-py start --admin 127 .0.0.1 8031 --admin-insecure-mode --inbound-transport http 0 .0.0.0 8030 --outbound-transp http --webhook-url http://127.0.0.1:8032/webhooks Again, make sure the above ports are unused and take note of the specific IP addresses and ports. In this case: Alice admin IP : 127.0.0.1 Alice admin port : 8031 Alice webhook port : 8032 Alice and Faber AEAs Now you can create Alice_AEA and Faber_AEA in terminals 3 and 4 respectively. Alice_AEA In the third terminal, fetch Alice_AEA and move into its project folder: aea fetch fetchai/aries_alice:0.31.0 cd aries_alice Alternatively, create from scratch. The following steps create Alice_AEA from scratch: aea create aries_alice cd aries_alice aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/http_client:0.23.0 aea add connection fetchai/webhook:0.19.0 aea add skill fetchai/aries_alice:0.24.0 Configure the aries_alice skill: (configuration file: alice/vendor/fetchai/skills/aries_alice/skill.yaml ) Ensure admin_host and admin_port values match with the values you noted above for Alice_ACA . You can use the framework's handy config CLI command to set these values: aea config set vendor.fetchai.skills.aries_alice.models.strategy.args.admin_host 127 .0.0.1 aea config set --type int vendor.fetchai.skills.aries_alice.models.strategy.args.admin_port 8031 Configure the webhook connection: (configuration file: alice/vendor/fetchai/connections/webhook/connection.yaml ). First ensure the value of webhook_port matches with what you used above for Alice_ACA . aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8032 Next, make sure the value of webhook_url_path is /webhooks/topic/{topic}/ . aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/ { topic } / Configure the p2p_libp2p connection: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11000\", \"entry_peers\": [], \"local_uri\": \"127.0.0.1:7000\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:7000\" }' Install the Dependencies and Run Alice_AEA: Now install all the dependencies: aea install aea build Finally run Alice_AEA : aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) We will refer to this as Alice_AEA's P2P address . Faber_AEA In the fourth terminal, fetch Faber_AEA and move into its project folder: aea fetch fetchai/aries_faber:0.31.0 cd aries_faber Alternatively, create from scratch. The following steps create Faber_AEA from scratch: aea create aries_faber cd aries_faber aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/http_client:0.23.0 aea add connection fetchai/webhook:0.19.0 aea add skill fetchai/aries_faber:0.22.0 Configure the aries_faber skill: (configuration file: faber/vendor/fetchai/skills/aries_alice/skill.yaml ) Ensure admin_host and admin_port values match with those you noted above for Faber_ACA . aea config set vendor.fetchai.skills.aries_faber.models.strategy.args.admin_host 127 .0.0.1 aea config set --type int vendor.fetchai.skills.aries_faber.models.strategy.args.admin_port 8021 Configure the webhook connection: (configuration file: faber/vendor/fetchai/connections/webhook/connection.yaml ). First, ensure the value of webhook_port matches with what you used above for Faber_ACA . aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8022 Next, make sure the value of webhook_url_path is /webhooks/topic/{topic}/ . aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/ { topic } / Configure the p2p_libp2p connection: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:7001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:7001\" }' where SOME_ADDRESS is Alice_AEA's P2P address as displayed in the third terminal. Install the Dependencies and Run Faber_AEA: Now install all the dependencies: aea install aea build Finally run Faber_AEA : aea run You should see Faber_AEA running and showing logs of its activities. For example: Looking now at Alice_AEA terminal, you should also see more activity by Alice_AEA after Faber_AEA was started. For example: The last error line in Alice_AEA 's terminal is caused due to the absence of an Indy ledger instance. In the next update to this demo, this will be resolved. Terminate and Delete the Agents You can terminate each agent by pressing Ctrl+C. To delete the AEAs, go to the projects' parent directory and delete the AEAs: aea delete aries_faber aea delete aries_alice Further developments In the next update to this demo, the remaining interactions between AEAs and ACAs must be implemented. This means: An instance of Indy ledger must be installed and running. See here for more detail. The commands for running the ACAs need to be adjusted. Additional options relating to a wallet (wallet-name, type, key, storage-type, configuration, credentials) need to be fed to the ACAs as well as the ledger's genesis file so the ACAs can connect to the ledger. The remaining interactions between the AEAs and ACAs as described here need to be implemented.","title":"Aries Cloud Agents Demo"},{"location":"aea/aries-cloud-agent-demo/#discussion","text":"This demo corresponds with the one here from Aries cloud agent repository . The aim of this demo is to illustrate how AEAs can connect to ACAs, thus gaining all of their capabilities, such as issuing and requesting verifiable credentials, selective disclosure and zero knowledge proofs. sequenceDiagram participant faea as Faber_AEA participant faca as Faber_ACA participant aaca as Alice_ACA participant aaea as Alice_AEA activate faea activate faca activate aaca activate aaea Note right of aaea: Shows P2P ID faea->>faca: Request status? faca->>faea: status faea->>faca: Register schema faca->>faea: schema_id faea->>faca: Register credential definition faca->>faea: credential_definition_id faea->>faca: create-invitation faca->>faea: connection inc. invitation faea->>aaea: invitation detail aaea->>aaca: receive-invitation deactivate faea deactivate faca deactivate aaca deactivate aaea There are two AEAs: Alice_AEA Faber_AEA and two ACAs: Alice_ACA Faber_ACA Each AEA is connected to its corresponding ACA: Alice_AEA to Alice_ACA and Faber_AEA to Faber_ACA . The following lists the sequence of interactions between the four agents: Alice_AEA : starts Alice_AEA : shows its P2P address in the terminal and waits for an invitation detail from Faber_AEA . Alice_AEA : registers itself on the SOEF. Faber_AEA : starts Faber_AEA : searches the SOEF and finds Alice_AEA . Faber_AEA : tests its connection to Faber_ACA . Faber_ACA : responds to Faber_AEA . Faber_AEA : registers a DID on the ledger. Faber_AEA : request Faber_ACA to register a schema on the ledger. Faber_ACA : responds by sending back the schema_id . Faber_AEA : request Faber_ACA to register a credential definition on the ledger. Faber_ACA : responds by sending back the credential_definition_id . Faber_AEA : requests Faber_ACA to create an invitation. Faber_ACA : responds by sending back the connection detail, which contains an invitation field. Faber_AEA : sends the invitation detail to Alice_AEA . Alice_AEA : receives invitation detail from Faber_AEA . Alice_AEA : requests Alice_ACA to accept the invitation, by passing it the invitation detail it received in the last step. All messages from an AEA to an ACA are http requests (using http_client connection). All messages from an AEA to another AEA utilise the P2P communication network accessed via the p2p_libp2p connection. All messages initiated from an ACA to an AEA are webhooks (using webhook connection). This is the extent of the demo at this point. The rest of the interactions require an instance of the Indy ledger to run. This is what will be implemented next. The rest of the interactions are broadly as follows: Alice_ACA : accepts the invitation. Alice_ACA : sends a matching invitation request to Faber_ACA . Faber_ACA : accepts At this point, the two ACAs are connected to each other. Faber_AEA : requests Faber_ACA to issue a credential (e.g. university degree) to Alice_AEA , which Faber_ACA does via Alice_ACA . Faber_AEA : requests proof that Alice_AEA 's age is above 18. Alice_AEA : presents proof that it's age is above 18, without presenting its credential.","title":"Discussion"},{"location":"aea/aries-cloud-agent-demo/#preparation-instructions","text":"","title":"Preparation Instructions"},{"location":"aea/aries-cloud-agent-demo/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start. Install Aries cloud-agents (for more info see here ) if you do not have it on your machine: pip install aries-cloudagent This demo has been successfully tested with aca-py version 0.4.5 . This demo requires an instance of von network running in docker locally (for more info see here ) This demo has been successfully tested with the von-network git repository pulled on 07 Aug 2020 (commit number ad1f84f64d4f4c106a81462f5fbff496c5fbf10e ).","title":"Dependencies"},{"location":"aea/aries-cloud-agent-demo/#terminals","text":"Open five terminals. The first terminal is used to run an instance of von-network locally in docker. The other four terminals will be used to run each of the four agents in this demo.","title":"Terminals"},{"location":"aea/aries-cloud-agent-demo/#von-network","text":"In the first terminal move to the von-network directory and run an instance of von-network locally in docker. This tutorial has information on starting (and stopping) the network locally. ./manage build ./manage start --logs Once the ledger is running, you can see the ledger by going to the web server running on port 9000. On localhost, that means going to http://localhost:9000 .","title":"VON Network"},{"location":"aea/aries-cloud-agent-demo/#alice-and-faber-acas","text":"To learn about the command for starting an ACA and its various options: aca-py start --help","title":"Alice and Faber ACAs"},{"location":"aea/aries-cloud-agent-demo/#faber_aca","text":"In the first terminal: aca-py start --admin 127 .0.0.1 8021 --admin-insecure-mode --inbound-transport http 0 .0.0.0 8020 --outbound-transport http --webhook-url http://127.0.0.1:8022/webhooks Make sure the ports above are unused. Take note of the specific IP addresses and ports you used in the above command. We will refer to them by the following names: Faber admin IP : 127.0.0.1 Faber admin port : 8021 Faber webhook port : 8022 The admin IP and port will be used to send administrative commands to this ACA from an AEA. The webhook port is where the ACA will send notifications to. We will expose this from the AEA so it receives this ACA's notifications.","title":"Faber_ACA"},{"location":"aea/aries-cloud-agent-demo/#alice_aca","text":"In the second terminal: aca-py start --admin 127 .0.0.1 8031 --admin-insecure-mode --inbound-transport http 0 .0.0.0 8030 --outbound-transp http --webhook-url http://127.0.0.1:8032/webhooks Again, make sure the above ports are unused and take note of the specific IP addresses and ports. In this case: Alice admin IP : 127.0.0.1 Alice admin port : 8031 Alice webhook port : 8032","title":"Alice_ACA"},{"location":"aea/aries-cloud-agent-demo/#alice-and-faber-aeas","text":"Now you can create Alice_AEA and Faber_AEA in terminals 3 and 4 respectively.","title":"Alice and Faber AEAs"},{"location":"aea/aries-cloud-agent-demo/#alice_aea","text":"In the third terminal, fetch Alice_AEA and move into its project folder: aea fetch fetchai/aries_alice:0.31.0 cd aries_alice Alternatively, create from scratch. The following steps create Alice_AEA from scratch: aea create aries_alice cd aries_alice aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/http_client:0.23.0 aea add connection fetchai/webhook:0.19.0 aea add skill fetchai/aries_alice:0.24.0","title":"Alice_AEA"},{"location":"aea/aries-cloud-agent-demo/#configure-the-aries_alice-skill","text":"(configuration file: alice/vendor/fetchai/skills/aries_alice/skill.yaml ) Ensure admin_host and admin_port values match with the values you noted above for Alice_ACA . You can use the framework's handy config CLI command to set these values: aea config set vendor.fetchai.skills.aries_alice.models.strategy.args.admin_host 127 .0.0.1 aea config set --type int vendor.fetchai.skills.aries_alice.models.strategy.args.admin_port 8031","title":"Configure the aries_alice skill:"},{"location":"aea/aries-cloud-agent-demo/#configure-the-webhook-connection","text":"(configuration file: alice/vendor/fetchai/connections/webhook/connection.yaml ). First ensure the value of webhook_port matches with what you used above for Alice_ACA . aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8032 Next, make sure the value of webhook_url_path is /webhooks/topic/{topic}/ . aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/ { topic } /","title":"Configure the webhook connection:"},{"location":"aea/aries-cloud-agent-demo/#configure-the-p2p_libp2p-connection","text":"aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11000\", \"entry_peers\": [], \"local_uri\": \"127.0.0.1:7000\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:7000\" }'","title":"Configure the p2p_libp2p connection:"},{"location":"aea/aries-cloud-agent-demo/#install-the-dependencies-and-run-alice_aea","text":"Now install all the dependencies: aea install aea build Finally run Alice_AEA : aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) We will refer to this as Alice_AEA's P2P address .","title":"Install the Dependencies and Run Alice_AEA:"},{"location":"aea/aries-cloud-agent-demo/#faber_aea","text":"In the fourth terminal, fetch Faber_AEA and move into its project folder: aea fetch fetchai/aries_faber:0.31.0 cd aries_faber Alternatively, create from scratch. The following steps create Faber_AEA from scratch: aea create aries_faber cd aries_faber aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/http_client:0.23.0 aea add connection fetchai/webhook:0.19.0 aea add skill fetchai/aries_faber:0.22.0","title":"Faber_AEA"},{"location":"aea/aries-cloud-agent-demo/#configure-the-aries_faber-skill","text":"(configuration file: faber/vendor/fetchai/skills/aries_alice/skill.yaml ) Ensure admin_host and admin_port values match with those you noted above for Faber_ACA . aea config set vendor.fetchai.skills.aries_faber.models.strategy.args.admin_host 127 .0.0.1 aea config set --type int vendor.fetchai.skills.aries_faber.models.strategy.args.admin_port 8021","title":"Configure the aries_faber skill:"},{"location":"aea/aries-cloud-agent-demo/#configure-the-webhook-connection_1","text":"(configuration file: faber/vendor/fetchai/connections/webhook/connection.yaml ). First, ensure the value of webhook_port matches with what you used above for Faber_ACA . aea config set --type int vendor.fetchai.connections.webhook.config.webhook_port 8022 Next, make sure the value of webhook_url_path is /webhooks/topic/{topic}/ . aea config set vendor.fetchai.connections.webhook.config.webhook_url_path /webhooks/topic/ { topic } /","title":"Configure the webhook connection:"},{"location":"aea/aries-cloud-agent-demo/#configure-the-p2p_libp2p-connection_1","text":"aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:7001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:7001\" }' where SOME_ADDRESS is Alice_AEA's P2P address as displayed in the third terminal.","title":"Configure the p2p_libp2p connection:"},{"location":"aea/aries-cloud-agent-demo/#install-the-dependencies-and-run-faber_aea","text":"Now install all the dependencies: aea install aea build Finally run Faber_AEA : aea run You should see Faber_AEA running and showing logs of its activities. For example: Looking now at Alice_AEA terminal, you should also see more activity by Alice_AEA after Faber_AEA was started. For example: The last error line in Alice_AEA 's terminal is caused due to the absence of an Indy ledger instance. In the next update to this demo, this will be resolved.","title":"Install the Dependencies and Run Faber_AEA:"},{"location":"aea/aries-cloud-agent-demo/#terminate-and-delete-the-agents","text":"You can terminate each agent by pressing Ctrl+C. To delete the AEAs, go to the projects' parent directory and delete the AEAs: aea delete aries_faber aea delete aries_alice","title":"Terminate and Delete the Agents"},{"location":"aea/aries-cloud-agent-demo/#further-developments","text":"In the next update to this demo, the remaining interactions between AEAs and ACAs must be implemented. This means: An instance of Indy ledger must be installed and running. See here for more detail. The commands for running the ACAs need to be adjusted. Additional options relating to a wallet (wallet-name, type, key, storage-type, configuration, credentials) need to be fed to the ACAs as well as the ledger's genesis file so the ACAs can connect to the ledger. The remaining interactions between the AEAs and ACAs as described here need to be implemented.","title":"Further developments"},{"location":"aea/build-aea-programmatically/","text":"These instructions detail the Python code you need for running an AEA outside the cli tool, using the code interface. Preparation Get the packages directory from the AEA repository: svn export https://github.com/fetchai/agents-aea.git/trunk/packages Also, install aea-ledger-fetchai plug-in: pip install aea-ledger-fetchai Imports First, import the necessary common Python libraries and classes. import os import time from threading import Thread Then, import the application specific libraries. from aea_ledger_fetchai import FetchAICrypto from aea.aea_builder import AEABuilder from aea.configurations.base import SkillConfig from aea.crypto.helpers import PRIVATE_KEY_PATH_SCHEMA , create_private_key from aea.helpers.file_io import write_with_lock from aea.skills.base import Skill Set up a variable pointing to where the packages directory is located - this should be our current directory - and where the input and output files are located. ROOT_DIR = \"./\" INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" FETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA . format ( FetchAICrypto . identifier ) Create a private key We need a private key to populate the AEA's wallet. # Create a private key create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) Clearing the input and output files We will use the stub connection to pass envelopes in and out of the AEA. Ensure that any input and output text files are removed before we start. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) Initialise the AEA We use the AEABuilder to readily build an AEA. By default, the AEABuilder adds the fetchai/default:1.0.0 , fetchai/state_update:1.0.0 and fetchai/signing:1.0.0 protocols. # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () We set the name, add the private key for the AEA to use and set the ledger configurations for the AEA to use. builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) Next, we add the fetchai/stub:0.15.0 connection which will read/write messages from file: # Add the stub connection (assuming it is present in the local directory 'packages') builder . add_connection ( \"./packages/fetchai/connections/stub\" ) Next, we add the echo skill which will bounce our messages back to us. We first need to place the echo skill into a relevant directory (see path), either by downloading the packages directory from the AEA repo or by getting the package from the registry. # Add the echo skill (assuming it is present in the local directory 'packages') builder . add_skill ( \"./packages/fetchai/skills/echo\" ) Also, we can add a component that was instantiated programmatically. : # create skill and handler manually from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.default.message import DefaultMessage class DummyHandler ( Handler ): \"\"\"Dummy handler to handle messages.\"\"\" SUPPORTED_PROTOCOL = DefaultMessage . protocol_id def setup ( self ) -> None : \"\"\"Noop setup.\"\"\" def teardown ( self ) -> None : \"\"\"Noop teardown.\"\"\" def handle ( self , message : Message ) -> None : \"\"\"Handle incoming message.\"\"\" self . context . logger . info ( \"You got a message: {} \" . format ( str ( message ))) config = SkillConfig ( name = \"test_skill\" , author = \"fetchai\" ) skill = Skill ( configuration = config ) dummy_handler = DummyHandler ( name = \"dummy_handler\" , skill_context = skill . skill_context ) skill . handlers . update ({ dummy_handler . name : dummy_handler }) builder . add_component_instance ( skill ) Finally, we can build our AEA: # Create our AEA my_aea = builder . build () Start the AEA We run the AEA from a different thread so that we can still use the main thread to pass it messages. # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 ) Send and receive an envelope We use the input and output text files to send an envelope to our AEA and receive a response (from the echo skill) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = b \"my_aea,other_agent,fetchai/default:1.0.0, \\x12\\x10\\x08\\x01\\x12\\x01 1* \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) print ( b \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"rb\" ) as f : print ( b \"output message: \" + f . readline ()) Shutdown Finally stop our AEA and wait for it to finish finally : # Shut down the AEA my_aea . stop () t . join () t = None Running the AEA If you now run this python script file, you should see this output: input message: my_aea,other_agent,fetchai/default:1.0.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello, output message: other_agent,my_aea,fetchai/default:1.0.0,...\\x05hello Entire code listing If you just want to copy and past the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from aea_ledger_fetchai import FetchAICrypto from aea.aea_builder import AEABuilder from aea.configurations.base import SkillConfig from aea.crypto.helpers import PRIVATE_KEY_PATH_SCHEMA , create_private_key from aea.helpers.file_io import write_with_lock from aea.skills.base import Skill ROOT_DIR = \"./\" INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" FETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA . format ( FetchAICrypto . identifier ) def run (): \"\"\"Run demo.\"\"\" # Create a private key create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) # Add the stub connection (assuming it is present in the local directory 'packages') builder . add_connection ( \"./packages/fetchai/connections/stub\" ) # Add the echo skill (assuming it is present in the local directory 'packages') builder . add_skill ( \"./packages/fetchai/skills/echo\" ) # create skill and handler manually from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.default.message import DefaultMessage class DummyHandler ( Handler ): \"\"\"Dummy handler to handle messages.\"\"\" SUPPORTED_PROTOCOL = DefaultMessage . protocol_id def setup ( self ) -> None : \"\"\"Noop setup.\"\"\" def teardown ( self ) -> None : \"\"\"Noop teardown.\"\"\" def handle ( self , message : Message ) -> None : \"\"\"Handle incoming message.\"\"\" self . context . logger . info ( \"You got a message: {} \" . format ( str ( message ))) config = SkillConfig ( name = \"test_skill\" , author = \"fetchai\" ) skill = Skill ( configuration = config ) dummy_handler = DummyHandler ( name = \"dummy_handler\" , skill_context = skill . skill_context ) skill . handlers . update ({ dummy_handler . name : dummy_handler }) builder . add_component_instance ( skill ) # Create our AEA my_aea = builder . build () # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 ) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = b \"my_aea,other_agent,fetchai/default:1.0.0, \\x12\\x10\\x08\\x01\\x12\\x01 1* \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) print ( b \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"rb\" ) as f : print ( b \"output message: \" + f . readline ()) finally : # Shut down the AEA my_aea . stop () t . join () t = None if __name__ == \"__main__\" : run ()","title":"Build an AEA programmatically"},{"location":"aea/build-aea-programmatically/#preparation","text":"Get the packages directory from the AEA repository: svn export https://github.com/fetchai/agents-aea.git/trunk/packages Also, install aea-ledger-fetchai plug-in: pip install aea-ledger-fetchai","title":"Preparation"},{"location":"aea/build-aea-programmatically/#imports","text":"First, import the necessary common Python libraries and classes. import os import time from threading import Thread Then, import the application specific libraries. from aea_ledger_fetchai import FetchAICrypto from aea.aea_builder import AEABuilder from aea.configurations.base import SkillConfig from aea.crypto.helpers import PRIVATE_KEY_PATH_SCHEMA , create_private_key from aea.helpers.file_io import write_with_lock from aea.skills.base import Skill Set up a variable pointing to where the packages directory is located - this should be our current directory - and where the input and output files are located. ROOT_DIR = \"./\" INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" FETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA . format ( FetchAICrypto . identifier )","title":"Imports"},{"location":"aea/build-aea-programmatically/#create-a-private-key","text":"We need a private key to populate the AEA's wallet. # Create a private key create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE )","title":"Create a private key"},{"location":"aea/build-aea-programmatically/#clearing-the-input-and-output-files","text":"We will use the stub connection to pass envelopes in and out of the AEA. Ensure that any input and output text files are removed before we start. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE )","title":"Clearing the input and output files"},{"location":"aea/build-aea-programmatically/#initialise-the-aea","text":"We use the AEABuilder to readily build an AEA. By default, the AEABuilder adds the fetchai/default:1.0.0 , fetchai/state_update:1.0.0 and fetchai/signing:1.0.0 protocols. # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () We set the name, add the private key for the AEA to use and set the ledger configurations for the AEA to use. builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) Next, we add the fetchai/stub:0.15.0 connection which will read/write messages from file: # Add the stub connection (assuming it is present in the local directory 'packages') builder . add_connection ( \"./packages/fetchai/connections/stub\" ) Next, we add the echo skill which will bounce our messages back to us. We first need to place the echo skill into a relevant directory (see path), either by downloading the packages directory from the AEA repo or by getting the package from the registry. # Add the echo skill (assuming it is present in the local directory 'packages') builder . add_skill ( \"./packages/fetchai/skills/echo\" ) Also, we can add a component that was instantiated programmatically. : # create skill and handler manually from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.default.message import DefaultMessage class DummyHandler ( Handler ): \"\"\"Dummy handler to handle messages.\"\"\" SUPPORTED_PROTOCOL = DefaultMessage . protocol_id def setup ( self ) -> None : \"\"\"Noop setup.\"\"\" def teardown ( self ) -> None : \"\"\"Noop teardown.\"\"\" def handle ( self , message : Message ) -> None : \"\"\"Handle incoming message.\"\"\" self . context . logger . info ( \"You got a message: {} \" . format ( str ( message ))) config = SkillConfig ( name = \"test_skill\" , author = \"fetchai\" ) skill = Skill ( configuration = config ) dummy_handler = DummyHandler ( name = \"dummy_handler\" , skill_context = skill . skill_context ) skill . handlers . update ({ dummy_handler . name : dummy_handler }) builder . add_component_instance ( skill ) Finally, we can build our AEA: # Create our AEA my_aea = builder . build ()","title":"Initialise the AEA"},{"location":"aea/build-aea-programmatically/#start-the-aea","text":"We run the AEA from a different thread so that we can still use the main thread to pass it messages. # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 )","title":"Start the AEA"},{"location":"aea/build-aea-programmatically/#send-and-receive-an-envelope","text":"We use the input and output text files to send an envelope to our AEA and receive a response (from the echo skill) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = b \"my_aea,other_agent,fetchai/default:1.0.0, \\x12\\x10\\x08\\x01\\x12\\x01 1* \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) print ( b \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"rb\" ) as f : print ( b \"output message: \" + f . readline ())","title":"Send and receive an envelope"},{"location":"aea/build-aea-programmatically/#shutdown","text":"Finally stop our AEA and wait for it to finish finally : # Shut down the AEA my_aea . stop () t . join () t = None","title":"Shutdown"},{"location":"aea/build-aea-programmatically/#running-the-aea","text":"If you now run this python script file, you should see this output: input message: my_aea,other_agent,fetchai/default:1.0.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello, output message: other_agent,my_aea,fetchai/default:1.0.0,...\\x05hello","title":"Running the AEA"},{"location":"aea/build-aea-programmatically/#entire-code-listing","text":"If you just want to copy and past the entire script in you can find it here: Click here to see full listing import os import time from threading import Thread from aea_ledger_fetchai import FetchAICrypto from aea.aea_builder import AEABuilder from aea.configurations.base import SkillConfig from aea.crypto.helpers import PRIVATE_KEY_PATH_SCHEMA , create_private_key from aea.helpers.file_io import write_with_lock from aea.skills.base import Skill ROOT_DIR = \"./\" INPUT_FILE = \"input_file\" OUTPUT_FILE = \"output_file\" FETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA . format ( FetchAICrypto . identifier ) def run (): \"\"\"Run demo.\"\"\" # Create a private key create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) # Add the stub connection (assuming it is present in the local directory 'packages') builder . add_connection ( \"./packages/fetchai/connections/stub\" ) # Add the echo skill (assuming it is present in the local directory 'packages') builder . add_skill ( \"./packages/fetchai/skills/echo\" ) # create skill and handler manually from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.default.message import DefaultMessage class DummyHandler ( Handler ): \"\"\"Dummy handler to handle messages.\"\"\" SUPPORTED_PROTOCOL = DefaultMessage . protocol_id def setup ( self ) -> None : \"\"\"Noop setup.\"\"\" def teardown ( self ) -> None : \"\"\"Noop teardown.\"\"\" def handle ( self , message : Message ) -> None : \"\"\"Handle incoming message.\"\"\" self . context . logger . info ( \"You got a message: {} \" . format ( str ( message ))) config = SkillConfig ( name = \"test_skill\" , author = \"fetchai\" ) skill = Skill ( configuration = config ) dummy_handler = DummyHandler ( name = \"dummy_handler\" , skill_context = skill . skill_context ) skill . handlers . update ({ dummy_handler . name : dummy_handler }) builder . add_component_instance ( skill ) # Create our AEA my_aea = builder . build () # Set the AEA running in a different thread try : t = Thread ( target = my_aea . start ) t . start () # Wait for everything to start up time . sleep ( 4 ) # Create a message inside an envelope and get the stub connection to pass it on to the echo skill message_text = b \"my_aea,other_agent,fetchai/default:1.0.0, \\x12\\x10\\x08\\x01\\x12\\x01 1* \\t * \\x07\\n\\x05 hello,\" with open ( INPUT_FILE , \"wb\" ) as f : write_with_lock ( f , message_text ) print ( b \"input message: \" + message_text ) # Wait for the envelope to get processed time . sleep ( 4 ) # Read the output envelope generated by the echo skill with open ( OUTPUT_FILE , \"rb\" ) as f : print ( b \"output message: \" + f . readline ()) finally : # Shut down the AEA my_aea . stop () t . join () t = None if __name__ == \"__main__\" : run ()","title":"Entire code listing"},{"location":"aea/build-aea-step-by-step/","text":"Building an AEA step by step (ensure you have followed the Preliminaries and Installation sections from the AEA quick start first): Set up your AEA project with the CLI: `aea create my_aea && cd my_aea` Look at, then add the right connections for your use case: `aea search connections`, then `aea add connection [public_id]` Look for, then add or generate the protocols you require: `aea search protocols`, then `aea add protocol [public_id]` or `aea generate protocol [path_to_specification]` Look for, then add or code the skills you need: `aea search skills`, then `aea add skill [public_id]`. This guide shows you step by step how to develop a skill. Where required, scaffold any of the above resources with the scaffolding tool or generate a protocol with the protocol generator . Now, run your AEA: `aea run --connections [public_id]` See information on the CLI tool here for all the available commands.","title":"Build an AEA with the CLI"},{"location":"aea/car-park-skills/","text":"The AEA car-park skills demonstrate an interaction between two AEAs. The carpark_detection AEA provides information on the number of car parking spaces available in a given vicinity. The carpark_client AEA is interested in purchasing information on available car parking spaces in the same vicinity. Discussion The full Fetch.ai car park AEA demo is documented in its own repo here . This demo allows you to test the AEA functionality of the car park AEA demo without the detection logic. It demonstrates how the AEAs trade car park information. Communication This diagram shows the communication between the various entities as data is successfully sold by the car park AEA to the client. sequenceDiagram participant Search participant Car_Data_Buyer_AEA participant Car_Park_AEA participant Blockchain activate Search activate Car_Data_Buyer_AEA activate Car_Park_AEA activate Blockchain Car_Park_AEA->>Search: register_service Car_Data_Buyer_AEA->>Search: search Search-->>Car_Data_Buyer_AEA: list_of_agents Car_Data_Buyer_AEA->>Car_Park_AEA: call_for_proposal Car_Park_AEA->>Car_Data_Buyer_AEA: propose Car_Data_Buyer_AEA->>Car_Park_AEA: accept Car_Park_AEA->>Car_Data_Buyer_AEA: match_accept Car_Data_Buyer_AEA->>Blockchain: transfer_funds Car_Data_Buyer_AEA->>Car_Park_AEA: send_transaction_hash Car_Park_AEA->>Blockchain: check_transaction_status Car_Park_AEA->>Car_Data_Buyer_AEA: send_data deactivate Search deactivate Car_Data_Buyer_AEA deactivate Car_Park_AEA deactivate Blockchain Option 1: AEA Manager approach Follow this approach when using the AEA Manager Desktop app. Otherwise, skip and follow the CLI approach below. Preparation instructions Install the AEA Manager . Demo instructions The following steps assume you have launched the AEA Manager Desktop app. Add a new AEA called car_detector with public id fetchai/car_detector:0.31.0 . Add another new AEA called car_data_buyer with public id fetchai/car_data_buyer:0.32.0 . Copy the address from the car_data_buyer into your clip board. Then go to the StargateWorld block explorer and request some test tokens via Get Funds . Run the car_detector AEA. Navigate to its logs and copy the multiaddress displayed. Navigate to the settings of the car_data_buyer and under components > connection > fetchai/p2p_libp2p:0.22.0 update as follows (make sure to replace the placeholder with the multiaddress): { \"delegate_uri\" : \"127.0.0.1:11001\" , \"entry_peers\" : [ \"REPLACE_WITH_MULTI_ADDRESS_HERE\" ] , \"local_uri\" : \"127.0.0.1:9001\" , \"log_file\" : \"libp2p_node.log\" , \"public_uri\" : \"127.0.0.1:9001\" } Run the car_data_buyer . In the AEA's logs, you should see the agent trading successfully. Option 2: CLI approach Follow this approach when using the aea CLI. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions Create car detector AEA First, fetch the car detector AEA: aea fetch fetchai/car_detector:0.31.0 cd car_detector aea install aea build Alternatively, create from scratch. The following steps create the car detector from scratch: aea create car_detector cd car_detector aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/carpark_detection:0.26.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build Create car data buyer AEA Then, fetch the car data client AEA: aea fetch fetchai/car_data_buyer:0.32.0 cd car_data_buyer aea install aea build Alternatively, create from scratch. The following steps create the car data client from scratch: aea create car_data_buyer cd car_data_buyer aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/carpark_client:0.26.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build Add keys for the car data seller AEA First, create the private key for the car data seller AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Add keys and generate wealth for the car data buyer AEA The buyer needs to have some wealth to purchase the service from the seller. First, create the private key for the car data buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your car data buyer based on the network you want to transact with. On the Fetch.ai StargateWorld network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Run the AEAs Run both AEAs from their respective terminals. First, run the car data seller AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the car data seller. Then, in the car data buyer, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the car data buyer to connect to the same local agent communication network as the car data seller. Then run the buyer AEA: aea run You will see that the AEAs negotiate and then transact using the Fetch.ai testnet. Cleaning up When you're finished, delete your AEAs: cd .. aea delete car_detector aea delete car_data_buyer","title":"Car park skills"},{"location":"aea/car-park-skills/#discussion","text":"The full Fetch.ai car park AEA demo is documented in its own repo here . This demo allows you to test the AEA functionality of the car park AEA demo without the detection logic. It demonstrates how the AEAs trade car park information.","title":"Discussion"},{"location":"aea/car-park-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the car park AEA to the client. sequenceDiagram participant Search participant Car_Data_Buyer_AEA participant Car_Park_AEA participant Blockchain activate Search activate Car_Data_Buyer_AEA activate Car_Park_AEA activate Blockchain Car_Park_AEA->>Search: register_service Car_Data_Buyer_AEA->>Search: search Search-->>Car_Data_Buyer_AEA: list_of_agents Car_Data_Buyer_AEA->>Car_Park_AEA: call_for_proposal Car_Park_AEA->>Car_Data_Buyer_AEA: propose Car_Data_Buyer_AEA->>Car_Park_AEA: accept Car_Park_AEA->>Car_Data_Buyer_AEA: match_accept Car_Data_Buyer_AEA->>Blockchain: transfer_funds Car_Data_Buyer_AEA->>Car_Park_AEA: send_transaction_hash Car_Park_AEA->>Blockchain: check_transaction_status Car_Park_AEA->>Car_Data_Buyer_AEA: send_data deactivate Search deactivate Car_Data_Buyer_AEA deactivate Car_Park_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/car-park-skills/#option-1-aea-manager-approach","text":"Follow this approach when using the AEA Manager Desktop app. Otherwise, skip and follow the CLI approach below.","title":"Option 1: AEA Manager approach"},{"location":"aea/car-park-skills/#preparation-instructions","text":"Install the AEA Manager .","title":"Preparation instructions"},{"location":"aea/car-park-skills/#demo-instructions","text":"The following steps assume you have launched the AEA Manager Desktop app. Add a new AEA called car_detector with public id fetchai/car_detector:0.31.0 . Add another new AEA called car_data_buyer with public id fetchai/car_data_buyer:0.32.0 . Copy the address from the car_data_buyer into your clip board. Then go to the StargateWorld block explorer and request some test tokens via Get Funds . Run the car_detector AEA. Navigate to its logs and copy the multiaddress displayed. Navigate to the settings of the car_data_buyer and under components > connection > fetchai/p2p_libp2p:0.22.0 update as follows (make sure to replace the placeholder with the multiaddress): { \"delegate_uri\" : \"127.0.0.1:11001\" , \"entry_peers\" : [ \"REPLACE_WITH_MULTI_ADDRESS_HERE\" ] , \"local_uri\" : \"127.0.0.1:9001\" , \"log_file\" : \"libp2p_node.log\" , \"public_uri\" : \"127.0.0.1:9001\" } Run the car_data_buyer . In the AEA's logs, you should see the agent trading successfully.","title":"Demo instructions"},{"location":"aea/car-park-skills/#option-2-cli-approach","text":"Follow this approach when using the aea CLI.","title":"Option 2: CLI approach"},{"location":"aea/car-park-skills/#preparation-instructions_1","text":"","title":"Preparation instructions"},{"location":"aea/car-park-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/car-park-skills/#demo-instructions_1","text":"","title":"Demo instructions"},{"location":"aea/car-park-skills/#create-car-detector-aea","text":"First, fetch the car detector AEA: aea fetch fetchai/car_detector:0.31.0 cd car_detector aea install aea build Alternatively, create from scratch. The following steps create the car detector from scratch: aea create car_detector cd car_detector aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/carpark_detection:0.26.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build","title":"Create car detector AEA"},{"location":"aea/car-park-skills/#create-car-data-buyer-aea","text":"Then, fetch the car data client AEA: aea fetch fetchai/car_data_buyer:0.32.0 cd car_data_buyer aea install aea build Alternatively, create from scratch. The following steps create the car data client from scratch: aea create car_data_buyer cd car_data_buyer aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/carpark_client:0.26.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build","title":"Create car data buyer AEA"},{"location":"aea/car-park-skills/#add-keys-for-the-car-data-seller-aea","text":"First, create the private key for the car data seller AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for the car data seller AEA"},{"location":"aea/car-park-skills/#add-keys-and-generate-wealth-for-the-car-data-buyer-aea","text":"The buyer needs to have some wealth to purchase the service from the seller. First, create the private key for the car data buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your car data buyer based on the network you want to transact with. On the Fetch.ai StargateWorld network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys and generate wealth for the car data buyer AEA"},{"location":"aea/car-park-skills/#run-the-aeas","text":"Run both AEAs from their respective terminals. First, run the car data seller AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the car data seller. Then, in the car data buyer, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the car data buyer to connect to the same local agent communication network as the car data seller. Then run the buyer AEA: aea run You will see that the AEAs negotiate and then transact using the Fetch.ai testnet.","title":"Run the AEAs"},{"location":"aea/car-park-skills/#cleaning-up","text":"When you're finished, delete your AEAs: cd .. aea delete car_detector aea delete car_data_buyer","title":"Cleaning up"},{"location":"aea/cli-commands/","text":"CLI commands Command Description add [package_type] [public_id] Add a package_type connection, contract, protocol, or skill, with [public_id] , to the AEA. add --local to add from local packages directory. add-key [ledger_id] file [--connection] Add a private key from a file for ledger_id . build Build the agent and its components. config get [path] Reads the configuration specified in path and prints its target. config set [path] [--type TYPE] Sets a new value for the target of the path . Optionally cast to type. create [name] Create a new AEA project called name . delete [name] Delete an AEA project. See below for disabling a resource. eject [package_type] [public_id] Move a package of package_type and package_id from vendor to project working directory. fetch [public_id] Fetch an AEA project with public_id . fetch --local to fetch from local packages directory. fingerprint [package_type] [public_id] Fingerprint connection, contract, protocol, or skill, with public_id . freeze Get all the dependencies needed for the AEA project and its components. generate protocol [protocol_spec_path] Generate a protocol from the specification. generate-key [ledger_id] Generate private keys. The AEA uses a private key to derive the associated public key and address. generate-wealth [ledger_id] Generate wealth for address on test network. get-address [ledger_id] Get the address associated with the private key. get-multiaddress [ledger_id]... Get the multiaddress associated with a private key or connection. get-public-key [ledger_id]... Get the public key associated with a private key of the agent. get-wealth [ledger_id] Get the wealth associated with the private key. init Initialize your AEA configurations. (With --author to define author.) install [-r <requirements_file>] Install the dependencies. (With --install-deps to install dependencies.) interact Interact with a running AEA via the stub connection. ipfs IPFS Commands issue-certificates Issue the connection certificates. launch [path_to_agent_project]... Launch many agents at the same time. list [package_type] List the installed resources. local-registry-sync Upgrade the local package registry. login USERNAME [--password password] Login to a registry account with credentials. logout Logout from registry account. publish Publish the AEA to registry. Needs to be executed from an AEA project. publish --local to publish to local packages directory. push [package_type] [public_id] Push connection, protocol, or skill with public_id to registry. push --local to push to local packages directory. register Create a new registry account. remove [package_type] [name] Remove connection, protocol, or skill, called name , from AEA. remove-key [ledger_id] [name] Remove a private key registered with id ledger_id . reset_password EMAIL Reset the password of the registry account. run {using [connections, ...]} Run the AEA on the Fetch.ai network with default or specified connections. scaffold [package_type] [name] Scaffold a new connection, protocol, or skill called name . search [package_type] Search for components in the registry. search --local [package_type] [--query searching_query] to search in local packages directory. transfer [type] [address] [amount] Transfer wealth associated with a private key of the agent to another account. upgrade [package_type] [public_id] Upgrade the packages of the agent. -v DEBUG run Run with debugging. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace. Tip You can skip the consistency checks on the AEA project by using the flag --skip-consistency-check . E.g. aea --skip-consistency-check run will bypass the fingerprint checks.","title":"Commands"},{"location":"aea/cli-commands/#cli-commands","text":"Command Description add [package_type] [public_id] Add a package_type connection, contract, protocol, or skill, with [public_id] , to the AEA. add --local to add from local packages directory. add-key [ledger_id] file [--connection] Add a private key from a file for ledger_id . build Build the agent and its components. config get [path] Reads the configuration specified in path and prints its target. config set [path] [--type TYPE] Sets a new value for the target of the path . Optionally cast to type. create [name] Create a new AEA project called name . delete [name] Delete an AEA project. See below for disabling a resource. eject [package_type] [public_id] Move a package of package_type and package_id from vendor to project working directory. fetch [public_id] Fetch an AEA project with public_id . fetch --local to fetch from local packages directory. fingerprint [package_type] [public_id] Fingerprint connection, contract, protocol, or skill, with public_id . freeze Get all the dependencies needed for the AEA project and its components. generate protocol [protocol_spec_path] Generate a protocol from the specification. generate-key [ledger_id] Generate private keys. The AEA uses a private key to derive the associated public key and address. generate-wealth [ledger_id] Generate wealth for address on test network. get-address [ledger_id] Get the address associated with the private key. get-multiaddress [ledger_id]... Get the multiaddress associated with a private key or connection. get-public-key [ledger_id]... Get the public key associated with a private key of the agent. get-wealth [ledger_id] Get the wealth associated with the private key. init Initialize your AEA configurations. (With --author to define author.) install [-r <requirements_file>] Install the dependencies. (With --install-deps to install dependencies.) interact Interact with a running AEA via the stub connection. ipfs IPFS Commands issue-certificates Issue the connection certificates. launch [path_to_agent_project]... Launch many agents at the same time. list [package_type] List the installed resources. local-registry-sync Upgrade the local package registry. login USERNAME [--password password] Login to a registry account with credentials. logout Logout from registry account. publish Publish the AEA to registry. Needs to be executed from an AEA project. publish --local to publish to local packages directory. push [package_type] [public_id] Push connection, protocol, or skill with public_id to registry. push --local to push to local packages directory. register Create a new registry account. remove [package_type] [name] Remove connection, protocol, or skill, called name , from AEA. remove-key [ledger_id] [name] Remove a private key registered with id ledger_id . reset_password EMAIL Reset the password of the registry account. run {using [connections, ...]} Run the AEA on the Fetch.ai network with default or specified connections. scaffold [package_type] [name] Scaffold a new connection, protocol, or skill called name . search [package_type] Search for components in the registry. search --local [package_type] [--query searching_query] to search in local packages directory. transfer [type] [address] [amount] Transfer wealth associated with a private key of the agent to another account. upgrade [package_type] [public_id] Upgrade the packages of the agent. -v DEBUG run Run with debugging. Tip You can also disable a resource without deleting it by removing the entry from the configuration but leaving the package in the skills namespace. Tip You can skip the consistency checks on the AEA project by using the flag --skip-consistency-check . E.g. aea --skip-consistency-check run will bypass the fingerprint checks.","title":"CLI commands"},{"location":"aea/cli-how-to/","text":"The command line interface is the easiest way to build an AEA. Installation The following installs the AEA CLI package. pip install aea [ cli ] The following installs the entire AEA package including the CLI. pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[cli]' and pip install 'aea[all]' respectively. Be sure that the bin folder of your Python environment is in the PATH variable. If so, you can execute the CLI tool as: aea You might find useful the execution of the aea.cli package as a script: python -m aea.cli which is just an alternative entry-point to the CLI tool. Troubleshooting To ensure no cache is used run. pip install aea [ all ] --force --no-cache-dir And for zsh run: pip install 'aea[all]' --force --no-cache-dir","title":"Installation"},{"location":"aea/cli-how-to/#installation","text":"The following installs the AEA CLI package. pip install aea [ cli ] The following installs the entire AEA package including the CLI. pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[cli]' and pip install 'aea[all]' respectively. Be sure that the bin folder of your Python environment is in the PATH variable. If so, you can execute the CLI tool as: aea You might find useful the execution of the aea.cli package as a script: python -m aea.cli which is just an alternative entry-point to the CLI tool.","title":"Installation"},{"location":"aea/cli-how-to/#troubleshooting","text":"To ensure no cache is used run. pip install aea [ all ] --force --no-cache-dir And for zsh run: pip install 'aea[all]' --force --no-cache-dir","title":"Troubleshooting"},{"location":"aea/cli-vs-programmatic-aeas/","text":"The AEA framework enables us to create agents either from the CLI tool or programmatically. The following demo demonstrates an interaction between two AEAs. The provider of weather data (managed with the CLI). The buyer of weather data (managed programmatically). Discussion The scope of the specific demo is to demonstrate how a CLI based AEA can interact with a programmatically managed AEA. In order to achieve this we are going to use the weather station skills. This demo does not utilize a smart contract or a ledger interaction. Get required packages Copy the packages directory into your local working directory: svn export https://github.com/fetchai/agents-aea.git/trunk/packages Also, install aea-ledger-fetchai plug-in: pip install aea-ledger-fetchai Demo instructions If you want to create the weather station AEA step by step you can follow this guide here Create the weather station AEA Fetch the weather station AEA with the following command : aea fetch fetchai/weather_station:0.31.0 cd weather_station aea install aea build Update the AEA configurations In the terminal change the configuration: aea config set vendor.fetchai.skills.weather_station.models.strategy.args.is_ledger_tx False --type bool The is_ledger_tx will prevent the AEA to communicate with a ledger. Add keys Add a private key for the weather station. aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Run the weather station AEA aea run Once you see a message of the form To join its network use multiaddr: ['SOME_ADDRESS'] take note of the address. Create the weather client AEA Since we want to show the interaction between a programmatically created AEA with a CLI based AEA we are going to write some code for the client. Create a new python file and name it weather_client.py and add the following code Weather client full code. import logging import os import sys from typing import cast from aea_ledger_fetchai import FetchAICrypto from aea.aea import AEA from aea.aea_builder import AEABuilder from aea.configurations.base import ConnectionConfig from aea.crypto.helpers import ( PRIVATE_KEY_PATH_SCHEMA , create_private_key , make_certificate , ) from aea.crypto.wallet import Wallet from aea.helpers.base import CertRequest from aea.identity.base import Identity from aea.protocols.base import Protocol from aea.registries.resources import Resources from aea.skills.base import Skill import packages.fetchai.connections.p2p_libp2p.connection from packages.fetchai.connections.ledger.connection import LedgerConnection from packages.fetchai.connections.p2p_libp2p.connection import P2PLibp2pConnection from packages.fetchai.connections.soef.connection import SOEFConnection from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.weather_client.strategy import Strategy API_KEY = \"TwiCIriSl0mLahw17pyqoA\" SOEF_ADDR = \"s-oef.fetch.ai\" SOEF_PORT = 443 ENTRY_PEER_ADDRESS = ( \"/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAmLBCAqHL8SuFosyDhAKYsLKXBZBWXBsB9oFw2qU4Kckun\" ) FETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA . format ( FetchAICrypto . identifier ) FETCHAI_PRIVATE_KEY_FILE_CONNECTION = PRIVATE_KEY_PATH_SCHEMA . format ( \"fetchai_connection\" ) ROOT_DIR = os . getcwd () logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( stream = sys . stdout , level = logging . INFO ) def run (): \"\"\"Run demo.\"\"\" # Create a private key create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_CONNECTION ) # Set up the wallet, identity and (empty) resources wallet = Wallet ( private_key_paths = { FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE }, connection_private_key_paths = { FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_CONNECTION }, ) identity = Identity ( \"my_aea\" , address = wallet . addresses . get ( FetchAICrypto . identifier ), public_key = wallet . public_keys . get ( FetchAICrypto . identifier ), ) resources = Resources () data_dir = os . getcwd () # specify the default routing for some protocols default_routing = { LedgerApiMessage . protocol_id : LedgerConnection . connection_id , OefSearchMessage . protocol_id : SOEFConnection . connection_id , } default_connection = P2PLibp2pConnection . connection_id state_update_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"state_update\" ) ) resources . add_protocol ( state_update_protocol ) # Add the default protocol (which is part of the AEA distribution) default_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"default\" ) ) resources . add_protocol ( default_protocol ) # Add the signing protocol (which is part of the AEA distribution) signing_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"signing\" ) ) resources . add_protocol ( signing_protocol ) # Add the ledger_api protocol ledger_api_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"ledger_api\" ,) ) resources . add_protocol ( ledger_api_protocol ) # Add the oef_search protocol oef_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"oef_search\" ,) ) resources . add_protocol ( oef_protocol ) # Add the fipa protocol fipa_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"fipa\" ,) ) resources . add_protocol ( fipa_protocol ) # Add the LedgerAPI connection configuration = ConnectionConfig ( connection_id = LedgerConnection . connection_id ) ledger_api_connection = LedgerConnection ( configuration = configuration , data_dir = data_dir , identity = identity ) resources . add_connection ( ledger_api_connection ) # Add the P2P connection cert_path = \".certs/conn_cert.txt\" cert_request = CertRequest ( identifier = \"acn\" , ledger_id = FetchAICrypto . identifier , not_after = \"2022-01-01\" , not_before = \"2021-01-01\" , public_key = \"fetchai\" , message_format = \" {public_key} \" , save_path = cert_path , ) public_key = wallet . connection_cryptos . public_keys . get ( FetchAICrypto . identifier ) message = cert_request . get_message ( public_key ) make_certificate ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE , message , cert_path ) configuration = ConnectionConfig ( connection_id = P2PLibp2pConnection . connection_id , delegate_uri = \"127.0.0.1:11001\" , entry_peers = [ ENTRY_PEER_ADDRESS ], local_uri = \"127.0.0.1:9001\" , log_file = \"libp2p_node.log\" , public_uri = \"127.0.0.1:9001\" , build_directory = os . getcwd (), build_entrypoint = \"check_dependencies.py\" , cert_requests = [ cert_request ], ) configuration . directory = os . path . dirname ( packages . fetchai . connections . p2p_libp2p . connection . __file__ ) AEABuilder . run_build_for_component_configuration ( configuration ) p2p_connection = P2PLibp2pConnection ( configuration = configuration , data_dir = data_dir , identity = identity , crypto_store = wallet . connection_cryptos , ) resources . add_connection ( p2p_connection ) # Add the SOEF connection configuration = ConnectionConfig ( api_key = API_KEY , soef_addr = SOEF_ADDR , soef_port = SOEF_PORT , restricted_to_protocols = { OefSearchMessage . protocol_id }, connection_id = SOEFConnection . connection_id , ) soef_connection = SOEFConnection ( configuration = configuration , data_dir = data_dir , identity = identity ) resources . add_connection ( soef_connection ) # create the AEA my_aea = AEA ( identity , wallet , resources , data_dir , default_connection = default_connection , default_routing = default_routing , ) # Add the error and weather_client skills error_skill = Skill . from_dir ( os . path . join ( ROOT_DIR , \"packages\" , \"fetchai\" , \"skills\" , \"error\" ), agent_context = my_aea . context , ) weather_skill = Skill . from_dir ( os . path . join ( ROOT_DIR , \"packages\" , \"fetchai\" , \"skills\" , \"weather_client\" ), agent_context = my_aea . context , ) strategy = cast ( Strategy , weather_skill . models . get ( \"strategy\" )) strategy . _is_ledger_tx = False for skill in [ error_skill , weather_skill ]: resources . add_skill ( skill ) # Run the AEA try : logger . info ( \"STARTING AEA NOW!\" ) my_aea . start () except KeyboardInterrupt : logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () if __name__ == \"__main__\" : run () Now replace ENTRY_PEER_ADDRESS with the peer address ( SOME_ADDRESS ) noted above. For more details on how to create an agent programmatically follow this guide here . Run the weather station AEA In a new terminal window, navigate to the folder that you created the script and run: python weather_client.py You should see both AEAs interacting now.","title":"CLI vs programmatic AEAs"},{"location":"aea/cli-vs-programmatic-aeas/#discussion","text":"The scope of the specific demo is to demonstrate how a CLI based AEA can interact with a programmatically managed AEA. In order to achieve this we are going to use the weather station skills. This demo does not utilize a smart contract or a ledger interaction.","title":"Discussion"},{"location":"aea/cli-vs-programmatic-aeas/#get-required-packages","text":"Copy the packages directory into your local working directory: svn export https://github.com/fetchai/agents-aea.git/trunk/packages Also, install aea-ledger-fetchai plug-in: pip install aea-ledger-fetchai","title":"Get required packages"},{"location":"aea/cli-vs-programmatic-aeas/#demo-instructions","text":"If you want to create the weather station AEA step by step you can follow this guide here","title":"Demo instructions"},{"location":"aea/cli-vs-programmatic-aeas/#create-the-weather-station-aea","text":"Fetch the weather station AEA with the following command : aea fetch fetchai/weather_station:0.31.0 cd weather_station aea install aea build","title":"Create the weather station AEA"},{"location":"aea/cli-vs-programmatic-aeas/#update-the-aea-configurations","text":"In the terminal change the configuration: aea config set vendor.fetchai.skills.weather_station.models.strategy.args.is_ledger_tx False --type bool The is_ledger_tx will prevent the AEA to communicate with a ledger.","title":"Update the AEA configurations"},{"location":"aea/cli-vs-programmatic-aeas/#add-keys","text":"Add a private key for the weather station. aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys"},{"location":"aea/cli-vs-programmatic-aeas/#run-the-weather-station-aea","text":"aea run Once you see a message of the form To join its network use multiaddr: ['SOME_ADDRESS'] take note of the address.","title":"Run the weather station AEA"},{"location":"aea/cli-vs-programmatic-aeas/#create-the-weather-client-aea","text":"Since we want to show the interaction between a programmatically created AEA with a CLI based AEA we are going to write some code for the client. Create a new python file and name it weather_client.py and add the following code Weather client full code. import logging import os import sys from typing import cast from aea_ledger_fetchai import FetchAICrypto from aea.aea import AEA from aea.aea_builder import AEABuilder from aea.configurations.base import ConnectionConfig from aea.crypto.helpers import ( PRIVATE_KEY_PATH_SCHEMA , create_private_key , make_certificate , ) from aea.crypto.wallet import Wallet from aea.helpers.base import CertRequest from aea.identity.base import Identity from aea.protocols.base import Protocol from aea.registries.resources import Resources from aea.skills.base import Skill import packages.fetchai.connections.p2p_libp2p.connection from packages.fetchai.connections.ledger.connection import LedgerConnection from packages.fetchai.connections.p2p_libp2p.connection import P2PLibp2pConnection from packages.fetchai.connections.soef.connection import SOEFConnection from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.weather_client.strategy import Strategy API_KEY = \"TwiCIriSl0mLahw17pyqoA\" SOEF_ADDR = \"s-oef.fetch.ai\" SOEF_PORT = 443 ENTRY_PEER_ADDRESS = ( \"/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAmLBCAqHL8SuFosyDhAKYsLKXBZBWXBsB9oFw2qU4Kckun\" ) FETCHAI_PRIVATE_KEY_FILE = PRIVATE_KEY_PATH_SCHEMA . format ( FetchAICrypto . identifier ) FETCHAI_PRIVATE_KEY_FILE_CONNECTION = PRIVATE_KEY_PATH_SCHEMA . format ( \"fetchai_connection\" ) ROOT_DIR = os . getcwd () logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( stream = sys . stdout , level = logging . INFO ) def run (): \"\"\"Run demo.\"\"\" # Create a private key create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE ) create_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_CONNECTION ) # Set up the wallet, identity and (empty) resources wallet = Wallet ( private_key_paths = { FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE }, connection_private_key_paths = { FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_CONNECTION }, ) identity = Identity ( \"my_aea\" , address = wallet . addresses . get ( FetchAICrypto . identifier ), public_key = wallet . public_keys . get ( FetchAICrypto . identifier ), ) resources = Resources () data_dir = os . getcwd () # specify the default routing for some protocols default_routing = { LedgerApiMessage . protocol_id : LedgerConnection . connection_id , OefSearchMessage . protocol_id : SOEFConnection . connection_id , } default_connection = P2PLibp2pConnection . connection_id state_update_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"state_update\" ) ) resources . add_protocol ( state_update_protocol ) # Add the default protocol (which is part of the AEA distribution) default_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"default\" ) ) resources . add_protocol ( default_protocol ) # Add the signing protocol (which is part of the AEA distribution) signing_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"signing\" ) ) resources . add_protocol ( signing_protocol ) # Add the ledger_api protocol ledger_api_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"ledger_api\" ,) ) resources . add_protocol ( ledger_api_protocol ) # Add the oef_search protocol oef_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"oef_search\" ,) ) resources . add_protocol ( oef_protocol ) # Add the fipa protocol fipa_protocol = Protocol . from_dir ( os . path . join ( os . getcwd (), \"packages\" , \"fetchai\" , \"protocols\" , \"fipa\" ,) ) resources . add_protocol ( fipa_protocol ) # Add the LedgerAPI connection configuration = ConnectionConfig ( connection_id = LedgerConnection . connection_id ) ledger_api_connection = LedgerConnection ( configuration = configuration , data_dir = data_dir , identity = identity ) resources . add_connection ( ledger_api_connection ) # Add the P2P connection cert_path = \".certs/conn_cert.txt\" cert_request = CertRequest ( identifier = \"acn\" , ledger_id = FetchAICrypto . identifier , not_after = \"2022-01-01\" , not_before = \"2021-01-01\" , public_key = \"fetchai\" , message_format = \" {public_key} \" , save_path = cert_path , ) public_key = wallet . connection_cryptos . public_keys . get ( FetchAICrypto . identifier ) message = cert_request . get_message ( public_key ) make_certificate ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE , message , cert_path ) configuration = ConnectionConfig ( connection_id = P2PLibp2pConnection . connection_id , delegate_uri = \"127.0.0.1:11001\" , entry_peers = [ ENTRY_PEER_ADDRESS ], local_uri = \"127.0.0.1:9001\" , log_file = \"libp2p_node.log\" , public_uri = \"127.0.0.1:9001\" , build_directory = os . getcwd (), build_entrypoint = \"check_dependencies.py\" , cert_requests = [ cert_request ], ) configuration . directory = os . path . dirname ( packages . fetchai . connections . p2p_libp2p . connection . __file__ ) AEABuilder . run_build_for_component_configuration ( configuration ) p2p_connection = P2PLibp2pConnection ( configuration = configuration , data_dir = data_dir , identity = identity , crypto_store = wallet . connection_cryptos , ) resources . add_connection ( p2p_connection ) # Add the SOEF connection configuration = ConnectionConfig ( api_key = API_KEY , soef_addr = SOEF_ADDR , soef_port = SOEF_PORT , restricted_to_protocols = { OefSearchMessage . protocol_id }, connection_id = SOEFConnection . connection_id , ) soef_connection = SOEFConnection ( configuration = configuration , data_dir = data_dir , identity = identity ) resources . add_connection ( soef_connection ) # create the AEA my_aea = AEA ( identity , wallet , resources , data_dir , default_connection = default_connection , default_routing = default_routing , ) # Add the error and weather_client skills error_skill = Skill . from_dir ( os . path . join ( ROOT_DIR , \"packages\" , \"fetchai\" , \"skills\" , \"error\" ), agent_context = my_aea . context , ) weather_skill = Skill . from_dir ( os . path . join ( ROOT_DIR , \"packages\" , \"fetchai\" , \"skills\" , \"weather_client\" ), agent_context = my_aea . context , ) strategy = cast ( Strategy , weather_skill . models . get ( \"strategy\" )) strategy . _is_ledger_tx = False for skill in [ error_skill , weather_skill ]: resources . add_skill ( skill ) # Run the AEA try : logger . info ( \"STARTING AEA NOW!\" ) my_aea . start () except KeyboardInterrupt : logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () if __name__ == \"__main__\" : run () Now replace ENTRY_PEER_ADDRESS with the peer address ( SOME_ADDRESS ) noted above. For more details on how to create an agent programmatically follow this guide here .","title":"Create the weather client AEA"},{"location":"aea/cli-vs-programmatic-aeas/#run-the-weather-station-aea_1","text":"In a new terminal window, navigate to the folder that you created the script and run: python weather_client.py You should see both AEAs interacting now.","title":"Run the weather station AEA"},{"location":"aea/config/","text":"This document describes the configuration files of the different packages. AEA configuration YAML The following provides a list of the relevant regex used: PACKAGE_REGEX : \"[a-zA-Z_][a-zA-Z0-9_]*\" AUTHOR_REGEX : \"[a-zA-Z_][a-zA-Z0-9_]*\" PUBLIC_ID_REGEX : \"^[a-zA-Z0-9_]*/[a-zA-Z_][a-zA-Z0-9_]*:(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\" LEDGER_ID_REGEX : \"^[^\\\\d\\\\W]\\\\w*\\\\Z\" The aea-config.yaml defines the AEA project. The compulsory components are listed below: agent_name : my_agent # Name of the AEA project (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the project's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the AEA project (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") description : A demo project # Description of the AEA project license : Apache-2.0 # License of the AEA project aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : {} # Fingerprint of AEA project components. fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. connections : # The list of connection public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX) - fetchai/stub:0.21.0 contracts : [] # The list of contract public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : # The list of protocol public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). - fetchai/default:1.0.0 skills : # The list of skill public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). - fetchai/error:0.17.0 default_connection : fetchai/p2p_libp2p:0.25.0 # The default connection used for envelopes sent by the AEA (must satisfy PUBLIC_ID_REGEX). default_ledger : fetchai # The default ledger identifier the AEA project uses (must satisfy LEDGER_ID_REGEX) required_ledgers : [ fetchai ] # the list of identifiers of ledgers that the AEA project requires key pairs for (each item must satisfy LEDGER_ID_REGEX) default_routing : {} # The default routing scheme applied to envelopes sent by the AEA, it maps from protocol public ids to connection public ids (both keys and values must satisfy PUBLIC_ID_REGEX) connection_private_key_paths : # The private key paths the AEA project uses for its connections (keys must satisfy LEDGER_ID_REGEX, values must be file paths) fetchai : fetchai_private_key.txt private_key_paths : # The private key paths the AEA project uses (keys must satisfy LEDGER_ID_REGEX, values must be file paths) fetchai : fetchai_private_key.txt logging_config : # The logging configurations the AEA project uses disable_existing_loggers : false version : 1 dependencies : {} # The python dependencies the AEA relies on (e.g. plugins). They will be installed when `aea install` is run. The aea-config.yaml can be extended with a number of optional fields: period : 0.05 # The period to call agent's act execution_timeout : 0 # The execution time limit on each call to `react` and `act` (0 disables the feature) timeout : 0.05 # The sleep time on each AEA loop spin (only relevant for the `sync` mode) max_reactions : 20 # The maximum number of envelopes processed per call to `react` (only relevant for the `sync` mode) skill_exception_policy : propagate # The exception policy applied to skills (must be one of \"propagate\", \"just_log\", or \"stop_and_exit\") connection_exception_policy : propagate # The exception policy applied to connections (must be one of \"propagate\", \"just_log\", or \"stop_and_exit\") loop_mode : async # The agent loop mode (must be one of \"sync\" or \"async\") runtime_mode : threaded # The runtime mode (must be one of \"threaded\" or \"async\") and determines how agent loop and multiplexer are run error_handler : None # The error handler to be used. decision_maker_handler : None # The decision maker handler to be used. storage_uri : None # The URI to the storage. data_dir : None # The path to the directory for local files. Defaults to current working directory. The aea-config.yaml can further be extended with component configuration overrides. For custom connection configurations: public_id : some_author/some_package:0.1.0 # The public id of the connection (must satisfy PUBLIC_ID_REGEX). type : connection # for connections, this must be \"connection\". config : ... # a dictionary to overwrite the `config` field (see below) For custom skill configurations: public_id : some_author/some_package:0.1.0 # The public id of the connection (must satisfy PUBLIC_ID_REGEX). type : skill # for skills, this must be \"skill\". behaviours : # override configurations for behaviours behaviour_1 : # override configurations for \"behaviour_1\" args : # arguments for a specific behaviour (see below) foo : bar handlers : # override configurations for handlers handler_1 : # override configurations for \"handler_1\" args : # arguments for a specific handler (see below) foo : bar models : # override configurations for models model_1 : # override configurations for \"model_1\" args : # arguments for a specific model (see below) foo : bar Connection configuration YAML The connection.yaml , which is present in each connection package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : connection # The type of the package; for connections, it must be \"connection\" description : A scaffold connection # Description of the package license : Apache-2.0 # License of the package aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmZvYZ5ECcWwqiNGh8qNTg735wu51HqaLxTSifUxkQ4KGj connection.py : QmagwVgaPgfeXqVTgcpFESA4DYsteSbojz94SLtmnHNAze fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. connections : [] # The list of connection public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : [] # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). class_name : MyScaffoldConnection # The class name of the class implementing the connection interface. config : # A dictionary containing the kwargs for the connection instantiation. foo : bar excluded_protocols : [] # The list of protocol public ids the package does not permit (each public id must satisfy PUBLIC_ID_REGEX). restricted_to_protocols : [] # The list of protocol public ids the package is limited to (each public id must satisfy PUBLIC_ID_REGEX). dependencies : {} # The python dependencies the package relies on. They will be installed when `aea install` is run. is_abstract : false # An optional boolean that if `true` makes the connection Contract configuration YAML The contract.yaml , which is present in each contract package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : contract # The type of the package; for contracts, it must be \"contract\" description : A scaffold contract # Description of the package license : Apache-2.0 # License of the package aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmPBwWhEg3wcH1q9612srZYAYdANVdWLDFWKs7TviZmVj6 contract.py : QmXvjkD7ZVEJDJspEz5YApe5bRUxvZHNi8vfyeVHPyQD5G fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. class_name : MyScaffoldContract # The class name of the class implementing the contract interface. contract_interface_paths : {} # The paths to the contract interfaces (one for each ledger identifier). config : # A dictionary containing the kwargs for the contract instantiation. foo : bar dependencies : {} # The python dependencies the package relies on. They will be installed when `aea install` is run. Protocol configuration YAML The protocol.yaml , which is present in each protocol package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : protocol # The type of the package; for protocols, it must be \"protocol\" description : A scaffold protocol # Description of the package license : Apache-2.0 # License of the package aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : Qmay9PmfeHqqVa3rdgiJYJnzZzTStboQEfpwXDpcgJMHTJ message.py : QmdvAdYSHNdZyUMrK3ue7quHAuSNwgZZSHqxYXyvh8Nie4 serialization.py : QmVUzwaSMErJgNFYQZkzsDhuuT2Ht4EdbGJ443usHmPxVv fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. dependencies : {} # The python dependencies the package relies on. They will be installed when `aea install` is run. Skill configuration YAML The skill.yaml , which is present in each protocol package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : skill # The type of the package; for skills, it must be \"skill\" description : A scaffold skill # Description of the package license : Apache-2.0 # License of the package aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmNkZAetyctaZCUf6ACxP5onGWsSxu2hjSNoFmJ3ta6Lta behaviours.py : QmYa1rczhGTtMJBgCd1QR9uZhhkf45orm7TnGTE5Eizjpy handlers.py : QmZYyTENRr6ecnxx1FeBdgjLiBhFLVn9mqarzUtFQmNUFn my_model.py : QmPaZ6G37Juk63mJj88nParaEp71XyURts8AmmX1axs24V fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. contracts : [] # The list of contract public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : [] # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). skills : [] # The list of skill public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). is_abstract : false # An optional boolean that if `true` makes the skill abstract, i.e. not instantiated by the framework but importable from other skills. Defaults to `false`. behaviours : # The dictionary describing the behaviours immplemented in the package (including their configuration) scaffold : # Name of the behaviour under which it is made available on the skill context. args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyScaffoldBehaviour # The class name of the class implementing the behaviour interface. handlers : # The dictionary describing the handlers immplemented in the package (including their configuration) scaffold : # Name of the handler under which it is made available on the skill args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyScaffoldHandler # The class name of the class implementing the handler interface. models : # The dictionary describing the models immplemented in the package (including their configuration) scaffold : # Name of the model under which it is made available on the skill args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyModel # The class name of the class implementing the model interface. dependencies : {} # The python dependencies the package relies on. They will be installed when `aea install` is run.","title":"Configurations"},{"location":"aea/config/#aea-configuration-yaml","text":"The following provides a list of the relevant regex used: PACKAGE_REGEX : \"[a-zA-Z_][a-zA-Z0-9_]*\" AUTHOR_REGEX : \"[a-zA-Z_][a-zA-Z0-9_]*\" PUBLIC_ID_REGEX : \"^[a-zA-Z0-9_]*/[a-zA-Z_][a-zA-Z0-9_]*:(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)\\\\.(0|[1-9]\\\\d*)(?:-((?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9]\\\\d*|\\\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+([0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\" LEDGER_ID_REGEX : \"^[^\\\\d\\\\W]\\\\w*\\\\Z\" The aea-config.yaml defines the AEA project. The compulsory components are listed below: agent_name : my_agent # Name of the AEA project (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the project's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the AEA project (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") description : A demo project # Description of the AEA project license : Apache-2.0 # License of the AEA project aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : {} # Fingerprint of AEA project components. fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. connections : # The list of connection public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX) - fetchai/stub:0.21.0 contracts : [] # The list of contract public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : # The list of protocol public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). - fetchai/default:1.0.0 skills : # The list of skill public ids the AEA project depends on (each public id must satisfy PUBLIC_ID_REGEX). - fetchai/error:0.17.0 default_connection : fetchai/p2p_libp2p:0.25.0 # The default connection used for envelopes sent by the AEA (must satisfy PUBLIC_ID_REGEX). default_ledger : fetchai # The default ledger identifier the AEA project uses (must satisfy LEDGER_ID_REGEX) required_ledgers : [ fetchai ] # the list of identifiers of ledgers that the AEA project requires key pairs for (each item must satisfy LEDGER_ID_REGEX) default_routing : {} # The default routing scheme applied to envelopes sent by the AEA, it maps from protocol public ids to connection public ids (both keys and values must satisfy PUBLIC_ID_REGEX) connection_private_key_paths : # The private key paths the AEA project uses for its connections (keys must satisfy LEDGER_ID_REGEX, values must be file paths) fetchai : fetchai_private_key.txt private_key_paths : # The private key paths the AEA project uses (keys must satisfy LEDGER_ID_REGEX, values must be file paths) fetchai : fetchai_private_key.txt logging_config : # The logging configurations the AEA project uses disable_existing_loggers : false version : 1 dependencies : {} # The python dependencies the AEA relies on (e.g. plugins). They will be installed when `aea install` is run. The aea-config.yaml can be extended with a number of optional fields: period : 0.05 # The period to call agent's act execution_timeout : 0 # The execution time limit on each call to `react` and `act` (0 disables the feature) timeout : 0.05 # The sleep time on each AEA loop spin (only relevant for the `sync` mode) max_reactions : 20 # The maximum number of envelopes processed per call to `react` (only relevant for the `sync` mode) skill_exception_policy : propagate # The exception policy applied to skills (must be one of \"propagate\", \"just_log\", or \"stop_and_exit\") connection_exception_policy : propagate # The exception policy applied to connections (must be one of \"propagate\", \"just_log\", or \"stop_and_exit\") loop_mode : async # The agent loop mode (must be one of \"sync\" or \"async\") runtime_mode : threaded # The runtime mode (must be one of \"threaded\" or \"async\") and determines how agent loop and multiplexer are run error_handler : None # The error handler to be used. decision_maker_handler : None # The decision maker handler to be used. storage_uri : None # The URI to the storage. data_dir : None # The path to the directory for local files. Defaults to current working directory. The aea-config.yaml can further be extended with component configuration overrides. For custom connection configurations: public_id : some_author/some_package:0.1.0 # The public id of the connection (must satisfy PUBLIC_ID_REGEX). type : connection # for connections, this must be \"connection\". config : ... # a dictionary to overwrite the `config` field (see below) For custom skill configurations: public_id : some_author/some_package:0.1.0 # The public id of the connection (must satisfy PUBLIC_ID_REGEX). type : skill # for skills, this must be \"skill\". behaviours : # override configurations for behaviours behaviour_1 : # override configurations for \"behaviour_1\" args : # arguments for a specific behaviour (see below) foo : bar handlers : # override configurations for handlers handler_1 : # override configurations for \"handler_1\" args : # arguments for a specific handler (see below) foo : bar models : # override configurations for models model_1 : # override configurations for \"model_1\" args : # arguments for a specific model (see below) foo : bar","title":"AEA configuration YAML"},{"location":"aea/config/#connection-configuration-yaml","text":"The connection.yaml , which is present in each connection package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : connection # The type of the package; for connections, it must be \"connection\" description : A scaffold connection # Description of the package license : Apache-2.0 # License of the package aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmZvYZ5ECcWwqiNGh8qNTg735wu51HqaLxTSifUxkQ4KGj connection.py : QmagwVgaPgfeXqVTgcpFESA4DYsteSbojz94SLtmnHNAze fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. connections : [] # The list of connection public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : [] # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). class_name : MyScaffoldConnection # The class name of the class implementing the connection interface. config : # A dictionary containing the kwargs for the connection instantiation. foo : bar excluded_protocols : [] # The list of protocol public ids the package does not permit (each public id must satisfy PUBLIC_ID_REGEX). restricted_to_protocols : [] # The list of protocol public ids the package is limited to (each public id must satisfy PUBLIC_ID_REGEX). dependencies : {} # The python dependencies the package relies on. They will be installed when `aea install` is run. is_abstract : false # An optional boolean that if `true` makes the connection","title":"Connection configuration YAML"},{"location":"aea/config/#contract-configuration-yaml","text":"The contract.yaml , which is present in each contract package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : contract # The type of the package; for contracts, it must be \"contract\" description : A scaffold contract # Description of the package license : Apache-2.0 # License of the package aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmPBwWhEg3wcH1q9612srZYAYdANVdWLDFWKs7TviZmVj6 contract.py : QmXvjkD7ZVEJDJspEz5YApe5bRUxvZHNi8vfyeVHPyQD5G fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. class_name : MyScaffoldContract # The class name of the class implementing the contract interface. contract_interface_paths : {} # The paths to the contract interfaces (one for each ledger identifier). config : # A dictionary containing the kwargs for the contract instantiation. foo : bar dependencies : {} # The python dependencies the package relies on. They will be installed when `aea install` is run.","title":"Contract configuration YAML"},{"location":"aea/config/#protocol-configuration-yaml","text":"The protocol.yaml , which is present in each protocol package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : protocol # The type of the package; for protocols, it must be \"protocol\" description : A scaffold protocol # Description of the package license : Apache-2.0 # License of the package aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : Qmay9PmfeHqqVa3rdgiJYJnzZzTStboQEfpwXDpcgJMHTJ message.py : QmdvAdYSHNdZyUMrK3ue7quHAuSNwgZZSHqxYXyvh8Nie4 serialization.py : QmVUzwaSMErJgNFYQZkzsDhuuT2Ht4EdbGJ443usHmPxVv fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. dependencies : {} # The python dependencies the package relies on. They will be installed when `aea install` is run.","title":"Protocol configuration YAML"},{"location":"aea/config/#skill-configuration-yaml","text":"The skill.yaml , which is present in each protocol package, has the following required fields: name : scaffold # Name of the package (must satisfy PACKAGE_REGEX) author : fetchai # Author handle of the package's author (must satisfy AUTHOR_REGEX) version : 0.1.0 # Version of the package (a semantic version number, see https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string\") type : skill # The type of the package; for skills, it must be \"skill\" description : A scaffold skill # Description of the package license : Apache-2.0 # License of the package aea_version : '>=1.0.0, <2.0.0' # AEA framework version(s) compatible with the AEA project (a version number that matches PEP 440 version schemes, or a comma-separated list of PEP 440 version specifiers, see https://www.python.org/dev/peps/pep-0440/#version-specifiers) fingerprint : # Fingerprint of package components. __init__.py : QmNkZAetyctaZCUf6ACxP5onGWsSxu2hjSNoFmJ3ta6Lta behaviours.py : QmYa1rczhGTtMJBgCd1QR9uZhhkf45orm7TnGTE5Eizjpy handlers.py : QmZYyTENRr6ecnxx1FeBdgjLiBhFLVn9mqarzUtFQmNUFn my_model.py : QmPaZ6G37Juk63mJj88nParaEp71XyURts8AmmX1axs24V fingerprint_ignore_patterns : [] # Ignore pattern for the fingerprinting tool. contracts : [] # The list of contract public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). protocols : [] # The list of protocol public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). skills : [] # The list of skill public ids the package depends on (each public id must satisfy PUBLIC_ID_REGEX). is_abstract : false # An optional boolean that if `true` makes the skill abstract, i.e. not instantiated by the framework but importable from other skills. Defaults to `false`. behaviours : # The dictionary describing the behaviours immplemented in the package (including their configuration) scaffold : # Name of the behaviour under which it is made available on the skill context. args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyScaffoldBehaviour # The class name of the class implementing the behaviour interface. handlers : # The dictionary describing the handlers immplemented in the package (including their configuration) scaffold : # Name of the handler under which it is made available on the skill args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyScaffoldHandler # The class name of the class implementing the handler interface. models : # The dictionary describing the models immplemented in the package (including their configuration) scaffold : # Name of the model under which it is made available on the skill args : # Keyword arguments provided to the skill component on instantiation. foo : bar class_name : MyModel # The class name of the class implementing the model interface. dependencies : {} # The python dependencies the package relies on. They will be installed when `aea install` is run.","title":"Skill configuration YAML"},{"location":"aea/connect-a-frontend/","text":"This page lays out two options for connecting a front-end to an AEA. The following diagram illustrates these two options. Case 1 The first option is to create a HTTP Server connection that handles incoming requests from a REST API. In this scenario, the REST API communicates with the AEA and requests are handled by the HTTP Server connection package. The REST API should send CRUD requests to the HTTP Server connection ( fetchai/http_server:0.22.0 ) which translates these into Envelopes to be consumed by the correct skill. Case 2 The second option is to create a front-end comprising a stand-alone Multiplexer with a P2P connection ( fetchai/p2p_libp2p:0.25.0 ). In this scenario the Agent Communication Network can be used to send Envelopes from the AEA to the front-end.","title":"Front-end intergration"},{"location":"aea/connect-a-frontend/#case-1","text":"The first option is to create a HTTP Server connection that handles incoming requests from a REST API. In this scenario, the REST API communicates with the AEA and requests are handled by the HTTP Server connection package. The REST API should send CRUD requests to the HTTP Server connection ( fetchai/http_server:0.22.0 ) which translates these into Envelopes to be consumed by the correct skill.","title":"Case 1"},{"location":"aea/connect-a-frontend/#case-2","text":"The second option is to create a front-end comprising a stand-alone Multiplexer with a P2P connection ( fetchai/p2p_libp2p:0.25.0 ). In this scenario the Agent Communication Network can be used to send Envelopes from the AEA to the front-end.","title":"Case 2"},{"location":"aea/connection/","text":"A Connection provides an interface for the agent to connect with entities in the outside world. Connections wrap SDKs or APIs and provide interfaces to networks, ledgers and other services. As such, a connection is concerned with I/O bound and continuously connected operations. Where necessary, a connection is responsible for translating between the framework specific protocol (an Envelope with its contained Message ) and the external service or third-party protocol (e.g. HTTP ). Hence, there are two roles for connections: wrapper and transport connection. The transport connection is responsible to delivering AEA envelopes. The messages constructed or received by a connection are eventually processed by one or several skills which deal with handling and generating messages related to a specific business objective. An AEA can interact with multiple connections at the same time via the Multiplexer . Connections are passive in terms of multiplexer interactions (its methods are called by the Multiplexer), but they can run their own asynchronous or threaded tasks. The Multiplexer maintains an InBox and OutBox , which are, respectively, queues for incoming and outgoing envelopes and their contained messages. Developing your connection The easiest way to get started developing your own connection is by using the scaffold command: aea scaffold connection my_new_connection This will scaffold a connection package called my_new_connection with three files: __init__.py connection.py containing the scaffolded connection class connection.yaml containing the scaffolded configuration file As a developer you have the choice between implementing a sync or asynchronous interface. The scaffolded connection.py file contains two classes: the MyScaffoldAsyncConnection inherited from the Connection base class and the MyScaffoldSyncConnection inherited from the BaseSyncConnection . Remove the unused class. Primary methods to develop - asynchronous connection interface The developer needs to implement four public coroutines: The connect coroutine implements the setup logic required to be performed for the connection when it is initially launched. The connect coroutine is called by the AEA framework once when the agent is being started. The disconnect coroutine implements the teardown logic required to be performed for the connection when it is eventually stopped. The disconnect coroutine is called by the AEA framework once when the agent is being stopped. The send coroutine is called by the AEA framework each time the Multiplexer handles an outgoing envelope specified to be handled by this connection. The send coroutine must implement the processing of the envelope leaving the agent. The receive coroutine is continuously called by the AEA framework. It either returns None or an envelope. The receive coroutine must implement the logic of data being received by the agent, and if necessary, its translation into a relevant protocol. The framework provides a demo stub connection which implements an I/O reader and writer to send and receive messages between the agent and a local file. To gain inspiration and become familiar with the structure of connection packages, you may find it useful to check out fetchai/stub:0.21.0 , fetchai/http_server:0.22.0 or fetchai/http_client:0.23.0 connections. The latter two connections are for external clients to connect with an agent, and for the agent to connect with external servers, respectively. Primary methods to develop - sync connection interface The BaseSyncConnection uses executors to execute synchronous code from the asynchronous context of the Multiplexer in executors/threads, which are limited by the amount of configured workers. The asynchronous methods connect , disconnect and send are converted to callbacks which the developer implements: * on_connect * on_disconnect * on_send All of these methods will be executed in the executor pool. Every method can create a message by putting it into the thread/asynchronous friendly queue that is consumed by the Multiplexer . The receive coroutine has no direct equivalent. Instead, the developer implements a main method which runs synchronously in the background. Configuration Every connection must have a configuration file in connection.yaml , containing meta-information about the connection as well as all the required configuration details. For more details, have a look here . Configuration options The connection.yaml file contains a number of fields that must be edited by the developer of the connection: connections : [] protocols : [] class_name : MyScaffoldConnection config : foo : bar excluded_protocols : [] restricted_to_protocols : [] dependencies : {} is_abstract : false cert_requests : [] connections specifies the list of other connection this connection depends on protocols specifies the list of protocols this connection depends on class_name needs to match the name of the connection class in connection.py config can contain arbitrary configuration information which is made available in the constructor of the connection as keyword arguments ( **kwargs ) excluded_protocols lists the protocols which cannot be used in this connection restricted_to_protocols lists the protocols which this connection is restricted to be used by dependencies lists any Python dependencies of the connection package is_abstract specifies whether this connection is only used as an abstract base class cert_requests lists certification requests of the connection (see proof of representation for details)","title":"Connections"},{"location":"aea/connection/#developing-your-connection","text":"The easiest way to get started developing your own connection is by using the scaffold command: aea scaffold connection my_new_connection This will scaffold a connection package called my_new_connection with three files: __init__.py connection.py containing the scaffolded connection class connection.yaml containing the scaffolded configuration file As a developer you have the choice between implementing a sync or asynchronous interface. The scaffolded connection.py file contains two classes: the MyScaffoldAsyncConnection inherited from the Connection base class and the MyScaffoldSyncConnection inherited from the BaseSyncConnection . Remove the unused class.","title":"Developing your connection"},{"location":"aea/connection/#primary-methods-to-develop-asynchronous-connection-interface","text":"The developer needs to implement four public coroutines: The connect coroutine implements the setup logic required to be performed for the connection when it is initially launched. The connect coroutine is called by the AEA framework once when the agent is being started. The disconnect coroutine implements the teardown logic required to be performed for the connection when it is eventually stopped. The disconnect coroutine is called by the AEA framework once when the agent is being stopped. The send coroutine is called by the AEA framework each time the Multiplexer handles an outgoing envelope specified to be handled by this connection. The send coroutine must implement the processing of the envelope leaving the agent. The receive coroutine is continuously called by the AEA framework. It either returns None or an envelope. The receive coroutine must implement the logic of data being received by the agent, and if necessary, its translation into a relevant protocol. The framework provides a demo stub connection which implements an I/O reader and writer to send and receive messages between the agent and a local file. To gain inspiration and become familiar with the structure of connection packages, you may find it useful to check out fetchai/stub:0.21.0 , fetchai/http_server:0.22.0 or fetchai/http_client:0.23.0 connections. The latter two connections are for external clients to connect with an agent, and for the agent to connect with external servers, respectively.","title":"Primary methods to develop - asynchronous connection interface"},{"location":"aea/connection/#primary-methods-to-develop-sync-connection-interface","text":"The BaseSyncConnection uses executors to execute synchronous code from the asynchronous context of the Multiplexer in executors/threads, which are limited by the amount of configured workers. The asynchronous methods connect , disconnect and send are converted to callbacks which the developer implements: * on_connect * on_disconnect * on_send All of these methods will be executed in the executor pool. Every method can create a message by putting it into the thread/asynchronous friendly queue that is consumed by the Multiplexer . The receive coroutine has no direct equivalent. Instead, the developer implements a main method which runs synchronously in the background.","title":"Primary methods to develop - sync connection interface"},{"location":"aea/connection/#configuration","text":"Every connection must have a configuration file in connection.yaml , containing meta-information about the connection as well as all the required configuration details. For more details, have a look here .","title":"Configuration"},{"location":"aea/connection/#configuration-options","text":"The connection.yaml file contains a number of fields that must be edited by the developer of the connection: connections : [] protocols : [] class_name : MyScaffoldConnection config : foo : bar excluded_protocols : [] restricted_to_protocols : [] dependencies : {} is_abstract : false cert_requests : [] connections specifies the list of other connection this connection depends on protocols specifies the list of protocols this connection depends on class_name needs to match the name of the connection class in connection.py config can contain arbitrary configuration information which is made available in the constructor of the connection as keyword arguments ( **kwargs ) excluded_protocols lists the protocols which cannot be used in this connection restricted_to_protocols lists the protocols which this connection is restricted to be used by dependencies lists any Python dependencies of the connection package is_abstract specifies whether this connection is only used as an abstract base class cert_requests lists certification requests of the connection (see proof of representation for details)","title":"Configuration options"},{"location":"aea/contract/","text":"Contracts wrap smart contracts for Fetch.ai and third-party decentralized ledgers. In particular, they provide wrappers around the API or ABI of a smart contract and its byte code. They implement a translation between framework messages (in the fetchai/contract_api:1.0.0 protocol) and the implementation specifics of the ABI. Contracts usually implement four types of methods: a method to create a smart contract deployment transaction, methods to create transactions to modify state in the deployed smart contract, methods to create contract calls to execute static methods on the deployed smart contract, and methods to query the state of the deployed smart contract. Contracts can be added as packages which means they become reusable across AEA projects. The smart contract wrapped in a AEA contract package might be a third-party smart contract or your own smart contract potentially interacting with a third-party contract on-chain. Interacting with contracts from skills Interacting with contracts in almost all cases requires network access. Therefore, the framework executes contract related logic in a Connection . In particular, the fetchai/ledger:0.19.0 connection can be used to execute contract related logic. The skills communicate with the fetchai/ledger:0.19.0 connection via the fetchai/contract_api:1.0.0 protocol. This protocol implements a request-response pattern to serve the four types of methods listed above: the get_deploy_transaction message is used to request a deploy transaction for a specific contract. For instance, to request a deploy transaction for the deployment of the smart contract wrapped in the fetchai/erc1155:0.22.0 package, we send the following message to the fetchai/ledger:0.19.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_DEPLOY_TRANSACTION , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.22.0\" , callable = \"get_deploy_transaction\" , kwargs = ContractApiMessage . Kwargs ( { \"deployer_address\" : self . context . agent_address } ), ) Any additional arguments needed by the contract's constructor method should be added to kwargs . This message will be handled by the fetchai/ledger:0.19.0 connection and then a raw_transaction message will be returned with the matching raw transaction. To send this transaction to the ledger for processing, we first sign the message with the decision maker and then send the signed transaction to the fetchai/ledger:0.19.0 connection using the fetchai/ledger_api:1.0.0 protocol. For details on how to implement the message handling, see the handlers in the erc1155_deploy skill. CosmWasm based smart contract deployments When using CosmWasm based smart contracts two types of deployment transactions exist. The first transaction stores the code on the chain. The second transaction initialises the code. This way, the same contract code can be initialised many times. Both the store and init messages use the ContractApiMessage.Performative.GET_DEPLOY_TRANSACTION performative. The ledger API automatically detects the type of transactions based on the provided keyword arguments. In particular, an init transaction requires the keyword arguments code_id (integer), label (string), amount (integer) and init_msg (JSON). For an example look at the fetchai/erc1155:0.22.0 package. the get_raw_transaction message is used to request any transaction for a specific contract which changes state in the contract. For instance, to request a transaction for the creation of token in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.22.0 package, we send the following message to the fetchai/ledger:0.19.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_RAW_TRANSACTION , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.22.0\" , contract_address = strategy . contract_address , callable = \"get_create_batch_transaction\" , kwargs = ContractApiMessage . Kwargs ( { \"deployer_address\" : self . context . agent_address , \"token_ids\" : strategy . token_ids , } ), ) This message will be handled by the fetchai/ledger:0.19.0 connection and then a raw_transaction message will be returned with the matching raw transaction. For this to be executed correctly, the fetchai/erc1155:0.22.0 contract package needs to implement the get_create_batch_transaction method with the specified key word arguments (see example in Deploy your own , below). Similarly to above, to send this transaction to the ledger for processing, we first sign the message with the decision maker and then send the signed transaction to the fetchai/ledger:0.19.0 connection using the fetchai/ledger_api:1.0.0 protocol. the get_raw_message message is used to request any contract method call for a specific contract which does not change state in the contract. For instance, to request a call to get a hash from some input data in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.22.0 package, we send the following message to the fetchai/ledger:0.19.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_RAW_MESSAGE , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.22.0\" , contract_address = strategy . contract_address , callable = \"get_hash_single\" , kwargs = ContractApiMessage . Kwargs ( { \"from_address\" : from_address , \"to_address\" : to_address , \"token_id\" : token_id , \"from_supply\" : from_supply , \"to_supply\" : to_supply , \"value\" : value , \"trade_nonce\" : trade_nonce , } ), ) This message will be handled by the fetchai/ledger:0.19.0 connection and then a raw_message message will be returned with the matching raw message. For this to be executed correctly, the fetchai/erc1155:0.22.0 contract package needs to implement the get_hash_single method with the specified key word arguments. We can then send the raw message to the fetchai/ledger:0.19.0 connection using the fetchai/ledger_api:1.0.0 protocol. In this case, signing is not required. the get_state message is used to request any contract method call to query state in the deployed contract. For instance, to request a call to get the balances in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.22.0 package, we send the following message to the fetchai/ledger:0.19.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_STATE , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.22.0\" , contract_address = strategy . contract_address , callable = \"get_balance\" , kwargs = ContractApiMessage . Kwargs ( { \"agent_address\" : address , \"token_id\" : token_id } ), ) This message will be handled by the fetchai/ledger:0.19.0 connection and then a state message will be returned with the matching state. For this to be executed correctly, the fetchai/erc1155:0.22.0 contract package needs to implement the get_balance method with the specified key word arguments. We can then send the raw message to the fetchai/ledger:0.19.0 connection using the fetchai/ledger_api:1.0.0 protocol. In this case, signing is not required. Developing your own The easiest way to get started developing your own contract is by using the scaffold command: aea scaffold contract my_new_contract This will scaffold a contract package called my_new_contract with three files: __init__.py contract.py , containing the scaffolded contract class contract.yaml containing the scaffolded configuration file Once your scaffold is in place, you can create a build folder in the package and copy the smart contract interface (e.g. bytes code and ABI) to it. Then, specify the path to the interfaces in the contract.yaml . For instance, if you use Ethereum, then you might specify the following: contract_interface_paths : ethereum : build/my_contract.json where ethereum is the ledger id and my_contract.json is the file containing the byte code and ABI. Finally, you will want to implement the part of the contract interface you need in contract.py : from aea.contracts.base import Contract from aea.crypto.base import LedgerApi class MyContract ( Contract ): \"\"\"The MyContract contract class which acts as a bridge between AEA framework and ERC1155 ABI.\"\"\" @classmethod def get_create_batch_transaction ( cls , ledger_api : LedgerApi , contract_address : str , deployer_address : str , token_ids : List [ int ], data : Optional [ bytes ] = b \"\" , gas : int = 300000 , ) -> Dict [ str , Any ]: \"\"\" Get the transaction to create a batch of tokens. :param ledger_api: the ledger API :param contract_address: the address of the contract :param deployer_address: the address of the deployer :param token_ids: the list of token ids for creation :param data: the data to include in the transaction :param gas: the gas to be used :return: the transaction object \"\"\" # create the transaction dict nonce = ledger_api . api . eth . getTransactionCount ( deployer_address ) instance = cls . get_instance ( ledger_api , contract_address ) tx = instance . functions . createBatch ( deployer_address , token_ids ) . buildTransaction ( { \"gas\" : gas , \"gasPrice\" : ledger_api . api . toWei ( \"50\" , \"gwei\" ), \"nonce\" : nonce , } ) tx = cls . _try_estimate_gas ( ledger_api , tx ) return tx Above, we implement a method to create a transaction, in this case a transaction to create a batch of tokens. The method will be called by the framework, specifically the fetchai/ledger:0.19.0 connection once it receives a message (see bullet point 2 above). The method first gets the latest transaction nonce of the deployer_address , then constructs the contract instance, then uses the instance to build the transaction and finally updates the gas on the transaction. It helps to look at existing contract packages, like fetchai/erc1155:0.22.0 , and skills using them, like fetchai/erc1155_client:0.11.0 and fetchai/erc1155_deploy:0.30.0 , for inspiration and guidance.","title":"Contracts"},{"location":"aea/contract/#interacting-with-contracts-from-skills","text":"Interacting with contracts in almost all cases requires network access. Therefore, the framework executes contract related logic in a Connection . In particular, the fetchai/ledger:0.19.0 connection can be used to execute contract related logic. The skills communicate with the fetchai/ledger:0.19.0 connection via the fetchai/contract_api:1.0.0 protocol. This protocol implements a request-response pattern to serve the four types of methods listed above: the get_deploy_transaction message is used to request a deploy transaction for a specific contract. For instance, to request a deploy transaction for the deployment of the smart contract wrapped in the fetchai/erc1155:0.22.0 package, we send the following message to the fetchai/ledger:0.19.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_DEPLOY_TRANSACTION , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.22.0\" , callable = \"get_deploy_transaction\" , kwargs = ContractApiMessage . Kwargs ( { \"deployer_address\" : self . context . agent_address } ), ) Any additional arguments needed by the contract's constructor method should be added to kwargs . This message will be handled by the fetchai/ledger:0.19.0 connection and then a raw_transaction message will be returned with the matching raw transaction. To send this transaction to the ledger for processing, we first sign the message with the decision maker and then send the signed transaction to the fetchai/ledger:0.19.0 connection using the fetchai/ledger_api:1.0.0 protocol. For details on how to implement the message handling, see the handlers in the erc1155_deploy skill. CosmWasm based smart contract deployments When using CosmWasm based smart contracts two types of deployment transactions exist. The first transaction stores the code on the chain. The second transaction initialises the code. This way, the same contract code can be initialised many times. Both the store and init messages use the ContractApiMessage.Performative.GET_DEPLOY_TRANSACTION performative. The ledger API automatically detects the type of transactions based on the provided keyword arguments. In particular, an init transaction requires the keyword arguments code_id (integer), label (string), amount (integer) and init_msg (JSON). For an example look at the fetchai/erc1155:0.22.0 package. the get_raw_transaction message is used to request any transaction for a specific contract which changes state in the contract. For instance, to request a transaction for the creation of token in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.22.0 package, we send the following message to the fetchai/ledger:0.19.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_RAW_TRANSACTION , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.22.0\" , contract_address = strategy . contract_address , callable = \"get_create_batch_transaction\" , kwargs = ContractApiMessage . Kwargs ( { \"deployer_address\" : self . context . agent_address , \"token_ids\" : strategy . token_ids , } ), ) This message will be handled by the fetchai/ledger:0.19.0 connection and then a raw_transaction message will be returned with the matching raw transaction. For this to be executed correctly, the fetchai/erc1155:0.22.0 contract package needs to implement the get_create_batch_transaction method with the specified key word arguments (see example in Deploy your own , below). Similarly to above, to send this transaction to the ledger for processing, we first sign the message with the decision maker and then send the signed transaction to the fetchai/ledger:0.19.0 connection using the fetchai/ledger_api:1.0.0 protocol. the get_raw_message message is used to request any contract method call for a specific contract which does not change state in the contract. For instance, to request a call to get a hash from some input data in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.22.0 package, we send the following message to the fetchai/ledger:0.19.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_RAW_MESSAGE , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.22.0\" , contract_address = strategy . contract_address , callable = \"get_hash_single\" , kwargs = ContractApiMessage . Kwargs ( { \"from_address\" : from_address , \"to_address\" : to_address , \"token_id\" : token_id , \"from_supply\" : from_supply , \"to_supply\" : to_supply , \"value\" : value , \"trade_nonce\" : trade_nonce , } ), ) This message will be handled by the fetchai/ledger:0.19.0 connection and then a raw_message message will be returned with the matching raw message. For this to be executed correctly, the fetchai/erc1155:0.22.0 contract package needs to implement the get_hash_single method with the specified key word arguments. We can then send the raw message to the fetchai/ledger:0.19.0 connection using the fetchai/ledger_api:1.0.0 protocol. In this case, signing is not required. the get_state message is used to request any contract method call to query state in the deployed contract. For instance, to request a call to get the balances in the deployed erc1155 smart contract wrapped in the fetchai/erc1155:0.22.0 package, we send the following message to the fetchai/ledger:0.19.0 : contract_api_msg = ContractApiMessage ( performative = ContractApiMessage . Performative . GET_STATE , dialogue_reference = contract_api_dialogues . new_self_initiated_dialogue_reference (), ledger_id = strategy . ledger_id , contract_id = \"fetchai/erc1155:0.22.0\" , contract_address = strategy . contract_address , callable = \"get_balance\" , kwargs = ContractApiMessage . Kwargs ( { \"agent_address\" : address , \"token_id\" : token_id } ), ) This message will be handled by the fetchai/ledger:0.19.0 connection and then a state message will be returned with the matching state. For this to be executed correctly, the fetchai/erc1155:0.22.0 contract package needs to implement the get_balance method with the specified key word arguments. We can then send the raw message to the fetchai/ledger:0.19.0 connection using the fetchai/ledger_api:1.0.0 protocol. In this case, signing is not required.","title":"Interacting with contracts from skills"},{"location":"aea/contract/#developing-your-own","text":"The easiest way to get started developing your own contract is by using the scaffold command: aea scaffold contract my_new_contract This will scaffold a contract package called my_new_contract with three files: __init__.py contract.py , containing the scaffolded contract class contract.yaml containing the scaffolded configuration file Once your scaffold is in place, you can create a build folder in the package and copy the smart contract interface (e.g. bytes code and ABI) to it. Then, specify the path to the interfaces in the contract.yaml . For instance, if you use Ethereum, then you might specify the following: contract_interface_paths : ethereum : build/my_contract.json where ethereum is the ledger id and my_contract.json is the file containing the byte code and ABI. Finally, you will want to implement the part of the contract interface you need in contract.py : from aea.contracts.base import Contract from aea.crypto.base import LedgerApi class MyContract ( Contract ): \"\"\"The MyContract contract class which acts as a bridge between AEA framework and ERC1155 ABI.\"\"\" @classmethod def get_create_batch_transaction ( cls , ledger_api : LedgerApi , contract_address : str , deployer_address : str , token_ids : List [ int ], data : Optional [ bytes ] = b \"\" , gas : int = 300000 , ) -> Dict [ str , Any ]: \"\"\" Get the transaction to create a batch of tokens. :param ledger_api: the ledger API :param contract_address: the address of the contract :param deployer_address: the address of the deployer :param token_ids: the list of token ids for creation :param data: the data to include in the transaction :param gas: the gas to be used :return: the transaction object \"\"\" # create the transaction dict nonce = ledger_api . api . eth . getTransactionCount ( deployer_address ) instance = cls . get_instance ( ledger_api , contract_address ) tx = instance . functions . createBatch ( deployer_address , token_ids ) . buildTransaction ( { \"gas\" : gas , \"gasPrice\" : ledger_api . api . toWei ( \"50\" , \"gwei\" ), \"nonce\" : nonce , } ) tx = cls . _try_estimate_gas ( ledger_api , tx ) return tx Above, we implement a method to create a transaction, in this case a transaction to create a batch of tokens. The method will be called by the framework, specifically the fetchai/ledger:0.19.0 connection once it receives a message (see bullet point 2 above). The method first gets the latest transaction nonce of the deployer_address , then constructs the contract instance, then uses the instance to build the transaction and finally updates the gas on the transaction. It helps to look at existing contract packages, like fetchai/erc1155:0.22.0 , and skills using them, like fetchai/erc1155_client:0.11.0 and fetchai/erc1155_deploy:0.30.0 , for inspiration and guidance.","title":"Developing your own"},{"location":"aea/core-components-1/","text":"The AEA framework consists of several core components, some required to run an AEA and others optional. The following sections discuss the inner workings of the AEA framework and how it calls the code in custom packages (see inversion of control and a helpful comparison here ). Whilst it is in principle possible to use parts of the framework as a library, we do not recommend it. The elements each AEA uses Envelope AEA objects communicate asynchronously via Envelopes . An Envelope is the core object with which agents communicate. It is a vehicle for Messages with five attributes: to : defines the destination address. sender : defines the sender address. protocol_id : defines the id of the Protocol . message : is a bytes field which holds the Message in serialized form. Optional[context] : an optional field to specify routing information in a URI. Messages must adhere to a Protocol . Protocol Protocols define agent-to-agent as well as component-to-component interactions within AEAs. As such, they include: Messages defining the syntax of messages; Serialization defining how a Message is encoded for transport; and, optionally Dialogues , which define rules over Message sequences. The framework provides one default Protocol , called default (current version fetchai/default:1.0.0 ). This Protocol provides a bare-bones implementation for an AEA Protocol which includes a DefaultMessage class and associated DefaultSerializer and DefaultDialogue classes. Additional Protocols , for new types of interactions, can be added as packages. For more details on Protocols you can read the protocol guide . To learn how you can easily automate protocol definition, head to the guide for the protocol generator . Protocol specific Messages , wrapped in Envelopes , are sent and received to other agents, agent components and services via Connections . Connection A Connection wraps an SDK or API and provides an interface to networks, ledgers or other services. Where necessary, a Connection is responsible for translating between the framework specific Envelope with its contained Message and the external service or third-party protocol (e.g. HTTP ). The framework provides one default Connection , called stub (current version fetchai/stub:0.21.0 ). It implements an I/O reader and writer to send Messages to the agent from a local file. Additional Connections can be added as packages. For more details on Connections read the Connection guide . An AEA runs and manages Connections via a Multiplexer . Multiplexer The Multiplexer is responsible for maintaining (potentially multiple) Connections . It maintains an InBox and OutBox , which are, respectively, queues for incoming and outgoing Envelopes from the perspective of Skills . Skill Skills are the core focus of the framework's extensibility as they implement business logic to deliver economic value for the AEA. They are self-contained capabilities that AEAs can dynamically take on board, in order to expand their effectiveness in different situations. A Skill encapsulates implementations of the three abstract base classes Handler , Behaviour , Model , and is closely related with the abstract base class Task : Handler : each Skill has zero, one or more Handler objects. There is a one-to-one correspondence between Handlers and the protocols in an AEA (also known as the registered protocols ). Handlers implement AEAs' reactive behaviour. If an AEA understands a Protocol referenced in a received Envelope (i.e. the protocol is registered in this AEA), this envelope is sent to the corresponding Handler which executes the AEA's reaction to this Message . Behaviour : a skill can have zero, one or more Behaviours , each encapsulating actions which further the AEAs goal and are initiated by internals of the AEA rather than external events. Behaviours implement AEAs' pro-activeness . The framework provides a number of abstract base classes implementing different types of simple and composite behaviours (e.g. cyclic, one-shot, finite-state-machine, etc), and these define how often and in what order a behaviour and its sub-behaviours must be executed. Model : zero, one or more Models that inherit from the Model abstract base class and are accessible via the SkillContext . Task : zero, one or more Tasks encapsulate background work internal to the AEA. Task differs from the other three in that it is not a part of Skills , but Tasks are declared in or from Skills if a packaging approach for AEA creation is used. A Skill can read (parts of) an AEA's state (as summarised in the AgentContext ), and suggests actions to the AEA according to its specific logic. As such, more than one Skill could exist per Protocol , competing with each other in suggesting to the AEA the best course of actions to take. In technical terms, this means Skills are horizontally arranged. For instance, an AEA which is trading goods, could subscribe to more than one Skill , where each corresponds to a different trading strategy. The framework places no limits on the complexity of Skills . They can implement simple (e.g. if-this-then-that ) logic or be complex (e.g. a deep learning model or reinforcement learning agent). The framework provides one default Skill , called error . Additional Skills can be added as packages. For more details on Skills head over to the Skill guide . Agent loop The AgentLoop performs a series of activities while the AEA state is not stopped . it calls the act() function of all active registered Behaviours at their respective tick rate. it grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the Protocol of the Envelope . it dispatches the internal Messages from the decision maker (described below) to the handler in the relevant Skill . The AgentLoop and Multiplexer are decoupled via the InBox and OutBox , and both are maintained by the Runtime . Next steps Recommended We recommend you continue with the next step in the 'Getting Started' series: AEA and web frameworks Relevant deep-dives Most AEA development focuses on developing the Skills and Protocols necessary for an AEA to deliver against its economic objectives. Understanding Protocols is core to developing your own agent. You can learn more about the Protocols agents use to communicate with each other and how they are created in the following section: Protocols Most of an AEA developer's time is spent on Skill development. Skills are the core business logic components of an AEA. Check out the following guide to learn more: Skills In most cases, one of the available Connection packages can be used. Occasionally, you might develop your own Connection : Connections","title":"Core components - Part 1"},{"location":"aea/core-components-1/#the-elements-each-aea-uses","text":"","title":"The elements each AEA uses"},{"location":"aea/core-components-1/#envelope","text":"AEA objects communicate asynchronously via Envelopes . An Envelope is the core object with which agents communicate. It is a vehicle for Messages with five attributes: to : defines the destination address. sender : defines the sender address. protocol_id : defines the id of the Protocol . message : is a bytes field which holds the Message in serialized form. Optional[context] : an optional field to specify routing information in a URI. Messages must adhere to a Protocol .","title":"Envelope"},{"location":"aea/core-components-1/#protocol","text":"Protocols define agent-to-agent as well as component-to-component interactions within AEAs. As such, they include: Messages defining the syntax of messages; Serialization defining how a Message is encoded for transport; and, optionally Dialogues , which define rules over Message sequences. The framework provides one default Protocol , called default (current version fetchai/default:1.0.0 ). This Protocol provides a bare-bones implementation for an AEA Protocol which includes a DefaultMessage class and associated DefaultSerializer and DefaultDialogue classes. Additional Protocols , for new types of interactions, can be added as packages. For more details on Protocols you can read the protocol guide . To learn how you can easily automate protocol definition, head to the guide for the protocol generator . Protocol specific Messages , wrapped in Envelopes , are sent and received to other agents, agent components and services via Connections .","title":"Protocol"},{"location":"aea/core-components-1/#connection","text":"A Connection wraps an SDK or API and provides an interface to networks, ledgers or other services. Where necessary, a Connection is responsible for translating between the framework specific Envelope with its contained Message and the external service or third-party protocol (e.g. HTTP ). The framework provides one default Connection , called stub (current version fetchai/stub:0.21.0 ). It implements an I/O reader and writer to send Messages to the agent from a local file. Additional Connections can be added as packages. For more details on Connections read the Connection guide . An AEA runs and manages Connections via a Multiplexer .","title":"Connection"},{"location":"aea/core-components-1/#multiplexer","text":"The Multiplexer is responsible for maintaining (potentially multiple) Connections . It maintains an InBox and OutBox , which are, respectively, queues for incoming and outgoing Envelopes from the perspective of Skills .","title":"Multiplexer"},{"location":"aea/core-components-1/#skill","text":"Skills are the core focus of the framework's extensibility as they implement business logic to deliver economic value for the AEA. They are self-contained capabilities that AEAs can dynamically take on board, in order to expand their effectiveness in different situations. A Skill encapsulates implementations of the three abstract base classes Handler , Behaviour , Model , and is closely related with the abstract base class Task : Handler : each Skill has zero, one or more Handler objects. There is a one-to-one correspondence between Handlers and the protocols in an AEA (also known as the registered protocols ). Handlers implement AEAs' reactive behaviour. If an AEA understands a Protocol referenced in a received Envelope (i.e. the protocol is registered in this AEA), this envelope is sent to the corresponding Handler which executes the AEA's reaction to this Message . Behaviour : a skill can have zero, one or more Behaviours , each encapsulating actions which further the AEAs goal and are initiated by internals of the AEA rather than external events. Behaviours implement AEAs' pro-activeness . The framework provides a number of abstract base classes implementing different types of simple and composite behaviours (e.g. cyclic, one-shot, finite-state-machine, etc), and these define how often and in what order a behaviour and its sub-behaviours must be executed. Model : zero, one or more Models that inherit from the Model abstract base class and are accessible via the SkillContext . Task : zero, one or more Tasks encapsulate background work internal to the AEA. Task differs from the other three in that it is not a part of Skills , but Tasks are declared in or from Skills if a packaging approach for AEA creation is used. A Skill can read (parts of) an AEA's state (as summarised in the AgentContext ), and suggests actions to the AEA according to its specific logic. As such, more than one Skill could exist per Protocol , competing with each other in suggesting to the AEA the best course of actions to take. In technical terms, this means Skills are horizontally arranged. For instance, an AEA which is trading goods, could subscribe to more than one Skill , where each corresponds to a different trading strategy. The framework places no limits on the complexity of Skills . They can implement simple (e.g. if-this-then-that ) logic or be complex (e.g. a deep learning model or reinforcement learning agent). The framework provides one default Skill , called error . Additional Skills can be added as packages. For more details on Skills head over to the Skill guide .","title":"Skill"},{"location":"aea/core-components-1/#agent-loop","text":"The AgentLoop performs a series of activities while the AEA state is not stopped . it calls the act() function of all active registered Behaviours at their respective tick rate. it grabs all Envelopes waiting in the InBox queue and calls the handle() function for the Handlers currently registered against the Protocol of the Envelope . it dispatches the internal Messages from the decision maker (described below) to the handler in the relevant Skill . The AgentLoop and Multiplexer are decoupled via the InBox and OutBox , and both are maintained by the Runtime .","title":"Agent loop"},{"location":"aea/core-components-1/#next-steps","text":"","title":"Next steps"},{"location":"aea/core-components-1/#recommended","text":"We recommend you continue with the next step in the 'Getting Started' series: AEA and web frameworks","title":"Recommended"},{"location":"aea/core-components-1/#relevant-deep-dives","text":"Most AEA development focuses on developing the Skills and Protocols necessary for an AEA to deliver against its economic objectives. Understanding Protocols is core to developing your own agent. You can learn more about the Protocols agents use to communicate with each other and how they are created in the following section: Protocols Most of an AEA developer's time is spent on Skill development. Skills are the core business logic components of an AEA. Check out the following guide to learn more: Skills In most cases, one of the available Connection packages can be used. Occasionally, you might develop your own Connection : Connections","title":"Relevant deep-dives"},{"location":"aea/core-components-2/","text":"The AEA framework consists of several core components, some required to run an AEA and others optional. In Core Components - Part 1 we described the common components each AEA uses. In this page, we will look at more advanced components. Required components used by AEAs Decision Maker The DecisionMaker can be thought of as a Wallet manager plus \"economic brain\" of the AEA. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA. The decision maker is the only component with access to the Wallet 's private keys. You can learn more about the decision maker here . In its simplest form, the decision maker acts like a Wallet with Handler to react to messages it receives from the skills. Wallet The Wallet contains the private-public key pairs used by the AEA. Skills do not have access to the wallet, only the decision maker does. The agent has two sets of private keys, as configured in the aea-config.yaml : private_key_paths : This is a dictionary mapping identifiers to the file paths of private keys used in the AEA. For each identifier, e.g. fetchai , the AEA can have one private key. The private keys listed here are available in the Decision Maker and the associated public keys and addresses are available in all skills. The AEA uses these keys to sign transactions and messages. These keys usually hold the AEAs funds. connection_private_key_paths : This is a dictionary mapping identifiers to the file paths of private keys used in connections. For each identifier, e.g. fetchai , the Multiplexer can have one private key. The private keys listed here are available in the connections. The connections use these keys to secure message transport, for instance. It is the responsibility of the AEA's user to safe-guard the keys used and ensure that keys are only used in a single AEA. Using the same key across different AEAs will lead to various failure modes. Private keys can be encrypted at rest. The CLI commands used for interacting with the wallet allow specifying a password for encryption/decryption. Identity The Identity is an abstraction that represents the identity of an AEA in the Open Economic Framework, backed by public-key cryptography. It contains the AEA's addresses as well as its name. The identity can be accessed in a Skill via the AgentContext . Optional components used by AEAs Contracts Contracts wrap smart contracts for third-party decentralized ledgers. In particular, they provide wrappers around the API or ABI of a smart contract. They expose an API to abstract implementation specifics of the ABI from the Skills . Contracts usually contain the logic to create contract transactions and make contract calls. Contracts can be added as packages. For more details on Contracts also read the Contract guide here . Putting it together Taken together, the core components from this section and the first part provide the following simplified illustration of an AEA: Next steps Recommended We recommend you continue with the next step in the 'Getting Started' series: How AEAs talk to each other - Interaction protocols Relevant deep-dives Understanding the decision maker is vital to developing a goal oriented and crypto-economically safe AEA. You can learn more about the DecisionMaker in the following section: Decision Maker Understanding Contracts is important when developing AEAs that make commitments or use smart contracts for other purposes. You can learn more about the Contracts agents use in the following section: Contracts","title":"Core components - Part 2"},{"location":"aea/core-components-2/#required-components-used-by-aeas","text":"","title":"Required components used by AEAs"},{"location":"aea/core-components-2/#decision-maker","text":"The DecisionMaker can be thought of as a Wallet manager plus \"economic brain\" of the AEA. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA. The decision maker is the only component with access to the Wallet 's private keys. You can learn more about the decision maker here . In its simplest form, the decision maker acts like a Wallet with Handler to react to messages it receives from the skills.","title":"Decision Maker"},{"location":"aea/core-components-2/#wallet","text":"The Wallet contains the private-public key pairs used by the AEA. Skills do not have access to the wallet, only the decision maker does. The agent has two sets of private keys, as configured in the aea-config.yaml : private_key_paths : This is a dictionary mapping identifiers to the file paths of private keys used in the AEA. For each identifier, e.g. fetchai , the AEA can have one private key. The private keys listed here are available in the Decision Maker and the associated public keys and addresses are available in all skills. The AEA uses these keys to sign transactions and messages. These keys usually hold the AEAs funds. connection_private_key_paths : This is a dictionary mapping identifiers to the file paths of private keys used in connections. For each identifier, e.g. fetchai , the Multiplexer can have one private key. The private keys listed here are available in the connections. The connections use these keys to secure message transport, for instance. It is the responsibility of the AEA's user to safe-guard the keys used and ensure that keys are only used in a single AEA. Using the same key across different AEAs will lead to various failure modes. Private keys can be encrypted at rest. The CLI commands used for interacting with the wallet allow specifying a password for encryption/decryption.","title":"Wallet"},{"location":"aea/core-components-2/#identity","text":"The Identity is an abstraction that represents the identity of an AEA in the Open Economic Framework, backed by public-key cryptography. It contains the AEA's addresses as well as its name. The identity can be accessed in a Skill via the AgentContext .","title":"Identity"},{"location":"aea/core-components-2/#optional-components-used-by-aeas","text":"","title":"Optional components used by AEAs"},{"location":"aea/core-components-2/#contracts","text":"Contracts wrap smart contracts for third-party decentralized ledgers. In particular, they provide wrappers around the API or ABI of a smart contract. They expose an API to abstract implementation specifics of the ABI from the Skills . Contracts usually contain the logic to create contract transactions and make contract calls. Contracts can be added as packages. For more details on Contracts also read the Contract guide here .","title":"Contracts"},{"location":"aea/core-components-2/#putting-it-together","text":"Taken together, the core components from this section and the first part provide the following simplified illustration of an AEA:","title":"Putting it together"},{"location":"aea/core-components-2/#next-steps","text":"","title":"Next steps"},{"location":"aea/core-components-2/#recommended","text":"We recommend you continue with the next step in the 'Getting Started' series: How AEAs talk to each other - Interaction protocols","title":"Recommended"},{"location":"aea/core-components-2/#relevant-deep-dives","text":"Understanding the decision maker is vital to developing a goal oriented and crypto-economically safe AEA. You can learn more about the DecisionMaker in the following section: Decision Maker Understanding Contracts is important when developing AEAs that make commitments or use smart contracts for other purposes. You can learn more about the Contracts agents use in the following section: Contracts","title":"Relevant deep-dives"},{"location":"aea/debug/","text":"There are multiple ways in which to configure your AEA for debugging during development. We focus on the standard Python approach here. Using pdb stdlib You can add a debugger anywhere in your code: import pdb ; pdb . set_trace () Then simply run you AEA with the --skip-consistency-check mode: aea -s run For more guidance on how to use pdb check out the documentation . Using an IDE: For VSCode modify the launch.json to include the following information: { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"aea run\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"program\" : \"PATH_TO_VIRTUAL_ENV/bin/aea\" , \"args\" : [ \"-v\" , \"DEBUG\" , \"--skip-consistency-check\" , \"run\" ], \"cwd\" : \"CWD\" , \"console\" : \"integratedTerminal\" } ] } where PATH_TO_VIRTUAL_ENV should be replaced with the path to the virtual environment and CWD with the working directory for the agent to debug (where the aea-config.yaml file is).","title":"Debugging"},{"location":"aea/debug/#using-pdb-stdlib","text":"You can add a debugger anywhere in your code: import pdb ; pdb . set_trace () Then simply run you AEA with the --skip-consistency-check mode: aea -s run For more guidance on how to use pdb check out the documentation .","title":"Using pdb stdlib"},{"location":"aea/debug/#using-an-ide","text":"For VSCode modify the launch.json to include the following information: { \"version\" : \"0.2.0\" , \"configurations\" : [ { \"name\" : \"aea run\" , \"type\" : \"python\" , \"request\" : \"launch\" , \"program\" : \"PATH_TO_VIRTUAL_ENV/bin/aea\" , \"args\" : [ \"-v\" , \"DEBUG\" , \"--skip-consistency-check\" , \"run\" ], \"cwd\" : \"CWD\" , \"console\" : \"integratedTerminal\" } ] } where PATH_TO_VIRTUAL_ENV should be replaced with the path to the virtual environment and CWD with the working directory for the agent to debug (where the aea-config.yaml file is).","title":"Using an IDE:"},{"location":"aea/decision-maker-transaction/","text":"This guide can be considered as a part 2 of the the stand-alone transaction demo . The main difference is that now we are going to use the decision-maker to sign the transaction. First, import the libraries and the set the constant values. (Get the packages directory from the AEA repository svn export https://github.com/fetchai/agents-aea.git/trunk/packages .) import logging import time from threading import Thread from typing import Optional , cast from aea_ledger_fetchai import FetchAICrypto from aea.aea_builder import AEABuilder from aea.configurations.base import PublicId , SkillConfig from aea.crypto.helpers import create_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.helpers.transaction.base import RawTransaction , Terms from aea.identity.base import Identity from aea.protocols.base import Address , Message from aea.protocols.dialogue.base import Dialogue from aea.skills.base import Handler , Model , Skill , SkillContext from packages.fetchai.protocols.signing.dialogues import SigningDialogue from packages.fetchai.protocols.signing.dialogues import ( SigningDialogues as BaseSigningDialogues , ) from packages.fetchai.protocols.signing.message import SigningMessage from tests.conftest import get_wealth_if_needed logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" Create a private key and an AEA To have access to the decision-maker, which is responsible for signing transactions, we need to create an AEA. We can create a an AEA with the builder, providing it with a private key we generate first. # Create a private key create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_1 ) # Create our AEA my_aea = builder . build () Add a simple skill Add a simple skill with a signing handler and the signing dialogues. # add a simple skill with handler skill_context = SkillContext ( my_aea . context ) skill_config = SkillConfig ( name = \"simple_skill\" , author = \"fetchai\" , version = \"0.1.0\" ) signing_handler = SigningHandler ( skill_context = skill_context , name = \"signing_handler\" ) signing_dialogues_model = SigningDialogues ( skill_context = skill_context , name = \"signing_dialogues\" , self_address = str ( skill_config . public_id ), ) simple_skill = Skill ( skill_config , skill_context , handlers = { signing_handler . name : signing_handler }, models = { signing_dialogues_model . name : signing_dialogues_model }, ) my_aea . resources . add_skill ( simple_skill ) Create a second identity # create a second identity create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) counterparty_wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) get_wealth_if_needed ( counterparty_wallet . addresses [ \"fetchai\" ]) counterparty_identity = Identity ( name = \"counterparty_aea\" , addresses = counterparty_wallet . addresses , public_keys = counterparty_wallet . public_keys , default_address_key = FetchAICrypto . identifier , ) Create the signing message Next, we are creating the signing message and we send it to the decision-maker. # create signing message for decision maker to sign terms = Terms ( ledger_id = FetchAICrypto . identifier , sender_address = my_aea . identity . address , counterparty_address = counterparty_identity . address , amount_by_currency_id = { \"FET\" : - 1 }, quantities_by_good_id = { \"some_service\" : 1 }, nonce = \"some_nonce\" , fee_by_currency_id = { \"FET\" : 0 }, ) get_wealth_if_needed ( terms . sender_address ) signing_dialogues = cast ( SigningDialogues , skill_context . signing_dialogues ) stub_transaction = LedgerApis . get_transfer_transaction ( terms . ledger_id , terms . sender_address , terms . counterparty_address , terms . sender_payable_amount , terms . sender_fee , terms . nonce , ) signing_msg = SigningMessage ( performative = SigningMessage . Performative . SIGN_TRANSACTION , dialogue_reference = signing_dialogues . new_self_initiated_dialogue_reference (), raw_transaction = RawTransaction ( FetchAICrypto . identifier , stub_transaction ), terms = terms , ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . create_with_message ( \"decision_maker\" , signing_msg ), ) assert signing_dialogue is not None my_aea . context . decision_maker_message_queue . put_nowait ( signing_msg ) Run the agent Finally, we are running the agent and we expect the signed transaction to be printed in the terminal. # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the decision maker time . sleep ( 1 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () After the completion of the signing, we get the signed transaction. More details To be able to register a handler that reads the internal messages, we have to create a class at the end of the file which processes the signing messages. class SigningDialogues ( Model , BaseSigningDialogues ): \"\"\"Signing dialogues model.\"\"\" def __init__ ( self , self_address : Address , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> Dialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return SigningDialogue . Role . SKILL BaseSigningDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , ) class SigningHandler ( Handler ): \"\"\"Implement the signing handler.\"\"\" SUPPORTED_PROTOCOL = SigningMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" signing_msg = cast ( SigningMessage , message ) # recover dialogue signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . update ( signing_msg ) ) if signing_dialogue is None : self . _handle_unidentified_dialogue ( signing_msg ) return # handle message if signing_msg . performative is SigningMessage . Performative . SIGNED_TRANSACTION : self . _handle_signed_transaction ( signing_msg , signing_dialogue ) elif signing_msg . performative is SigningMessage . Performative . ERROR : self . _handle_error ( signing_msg , signing_dialogue ) else : self . _handle_invalid ( signing_msg , signing_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" def _handle_unidentified_dialogue ( self , signing_msg : SigningMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid signing message= {} , unidentified dialogue.\" . format ( signing_msg ) ) def _handle_signed_transaction ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle a signing message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was successful.\" ) logger . info ( signing_msg . signed_transaction ) def _handle_error ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was not successful. Error_code= {} in dialogue= {} \" . format ( signing_msg . error_code , signing_dialogue ) ) def _handle_invalid ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle signing message of performative= {} in dialogue= {} .\" . format ( signing_msg . performative , signing_dialogue ) ) You can find the full code for this example below: Transaction via decision-maker full code import logging import time from threading import Thread from typing import Optional , cast from aea_ledger_fetchai import FetchAICrypto from aea.aea_builder import AEABuilder from aea.configurations.base import PublicId , SkillConfig from aea.crypto.helpers import create_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.helpers.transaction.base import RawTransaction , Terms from aea.identity.base import Identity from aea.protocols.base import Address , Message from aea.protocols.dialogue.base import Dialogue from aea.skills.base import Handler , Model , Skill , SkillContext from packages.fetchai.protocols.signing.dialogues import SigningDialogue from packages.fetchai.protocols.signing.dialogues import ( SigningDialogues as BaseSigningDialogues , ) from packages.fetchai.protocols.signing.message import SigningMessage from tests.conftest import get_wealth_if_needed logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" def run (): \"\"\"Run demo.\"\"\" # Create a private key create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_1 ) # Create our AEA my_aea = builder . build () # add a simple skill with handler skill_context = SkillContext ( my_aea . context ) skill_config = SkillConfig ( name = \"simple_skill\" , author = \"fetchai\" , version = \"0.1.0\" ) signing_handler = SigningHandler ( skill_context = skill_context , name = \"signing_handler\" ) signing_dialogues_model = SigningDialogues ( skill_context = skill_context , name = \"signing_dialogues\" , self_address = str ( skill_config . public_id ), ) simple_skill = Skill ( skill_config , skill_context , handlers = { signing_handler . name : signing_handler }, models = { signing_dialogues_model . name : signing_dialogues_model }, ) my_aea . resources . add_skill ( simple_skill ) # create a second identity create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) counterparty_wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) get_wealth_if_needed ( counterparty_wallet . addresses [ \"fetchai\" ]) counterparty_identity = Identity ( name = \"counterparty_aea\" , addresses = counterparty_wallet . addresses , public_keys = counterparty_wallet . public_keys , default_address_key = FetchAICrypto . identifier , ) # create signing message for decision maker to sign terms = Terms ( ledger_id = FetchAICrypto . identifier , sender_address = my_aea . identity . address , counterparty_address = counterparty_identity . address , amount_by_currency_id = { \"FET\" : - 1 }, quantities_by_good_id = { \"some_service\" : 1 }, nonce = \"some_nonce\" , fee_by_currency_id = { \"FET\" : 0 }, ) get_wealth_if_needed ( terms . sender_address ) signing_dialogues = cast ( SigningDialogues , skill_context . signing_dialogues ) stub_transaction = LedgerApis . get_transfer_transaction ( terms . ledger_id , terms . sender_address , terms . counterparty_address , terms . sender_payable_amount , terms . sender_fee , terms . nonce , ) signing_msg = SigningMessage ( performative = SigningMessage . Performative . SIGN_TRANSACTION , dialogue_reference = signing_dialogues . new_self_initiated_dialogue_reference (), raw_transaction = RawTransaction ( FetchAICrypto . identifier , stub_transaction ), terms = terms , ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . create_with_message ( \"decision_maker\" , signing_msg ), ) assert signing_dialogue is not None my_aea . context . decision_maker_message_queue . put_nowait ( signing_msg ) # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the decision maker time . sleep ( 1 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () class SigningDialogues ( Model , BaseSigningDialogues ): \"\"\"Signing dialogues model.\"\"\" def __init__ ( self , self_address : Address , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> Dialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return SigningDialogue . Role . SKILL BaseSigningDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , ) class SigningHandler ( Handler ): \"\"\"Implement the signing handler.\"\"\" SUPPORTED_PROTOCOL = SigningMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" signing_msg = cast ( SigningMessage , message ) # recover dialogue signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . update ( signing_msg ) ) if signing_dialogue is None : self . _handle_unidentified_dialogue ( signing_msg ) return # handle message if signing_msg . performative is SigningMessage . Performative . SIGNED_TRANSACTION : self . _handle_signed_transaction ( signing_msg , signing_dialogue ) elif signing_msg . performative is SigningMessage . Performative . ERROR : self . _handle_error ( signing_msg , signing_dialogue ) else : self . _handle_invalid ( signing_msg , signing_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" def _handle_unidentified_dialogue ( self , signing_msg : SigningMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid signing message= {} , unidentified dialogue.\" . format ( signing_msg ) ) def _handle_signed_transaction ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle a signing message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was successful.\" ) logger . info ( signing_msg . signed_transaction ) def _handle_error ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was not successful. Error_code= {} in dialogue= {} \" . format ( signing_msg . error_code , signing_dialogue ) ) def _handle_invalid ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle signing message of performative= {} in dialogue= {} .\" . format ( signing_msg . performative , signing_dialogue ) ) if __name__ == \"__main__\" : run ()","title":"Create decision-maker transaction"},{"location":"aea/decision-maker-transaction/#create-a-private-key-and-an-aea","text":"To have access to the decision-maker, which is responsible for signing transactions, we need to create an AEA. We can create a an AEA with the builder, providing it with a private key we generate first. # Create a private key create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_1 ) # Create our AEA my_aea = builder . build ()","title":"Create a private key and an AEA"},{"location":"aea/decision-maker-transaction/#add-a-simple-skill","text":"Add a simple skill with a signing handler and the signing dialogues. # add a simple skill with handler skill_context = SkillContext ( my_aea . context ) skill_config = SkillConfig ( name = \"simple_skill\" , author = \"fetchai\" , version = \"0.1.0\" ) signing_handler = SigningHandler ( skill_context = skill_context , name = \"signing_handler\" ) signing_dialogues_model = SigningDialogues ( skill_context = skill_context , name = \"signing_dialogues\" , self_address = str ( skill_config . public_id ), ) simple_skill = Skill ( skill_config , skill_context , handlers = { signing_handler . name : signing_handler }, models = { signing_dialogues_model . name : signing_dialogues_model }, ) my_aea . resources . add_skill ( simple_skill )","title":"Add a simple skill"},{"location":"aea/decision-maker-transaction/#create-a-second-identity","text":"# create a second identity create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) counterparty_wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) get_wealth_if_needed ( counterparty_wallet . addresses [ \"fetchai\" ]) counterparty_identity = Identity ( name = \"counterparty_aea\" , addresses = counterparty_wallet . addresses , public_keys = counterparty_wallet . public_keys , default_address_key = FetchAICrypto . identifier , )","title":"Create a second identity"},{"location":"aea/decision-maker-transaction/#create-the-signing-message","text":"Next, we are creating the signing message and we send it to the decision-maker. # create signing message for decision maker to sign terms = Terms ( ledger_id = FetchAICrypto . identifier , sender_address = my_aea . identity . address , counterparty_address = counterparty_identity . address , amount_by_currency_id = { \"FET\" : - 1 }, quantities_by_good_id = { \"some_service\" : 1 }, nonce = \"some_nonce\" , fee_by_currency_id = { \"FET\" : 0 }, ) get_wealth_if_needed ( terms . sender_address ) signing_dialogues = cast ( SigningDialogues , skill_context . signing_dialogues ) stub_transaction = LedgerApis . get_transfer_transaction ( terms . ledger_id , terms . sender_address , terms . counterparty_address , terms . sender_payable_amount , terms . sender_fee , terms . nonce , ) signing_msg = SigningMessage ( performative = SigningMessage . Performative . SIGN_TRANSACTION , dialogue_reference = signing_dialogues . new_self_initiated_dialogue_reference (), raw_transaction = RawTransaction ( FetchAICrypto . identifier , stub_transaction ), terms = terms , ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . create_with_message ( \"decision_maker\" , signing_msg ), ) assert signing_dialogue is not None my_aea . context . decision_maker_message_queue . put_nowait ( signing_msg )","title":"Create the signing message"},{"location":"aea/decision-maker-transaction/#run-the-agent","text":"Finally, we are running the agent and we expect the signed transaction to be printed in the terminal. # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the decision maker time . sleep ( 1 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () After the completion of the signing, we get the signed transaction.","title":"Run the agent"},{"location":"aea/decision-maker-transaction/#more-details","text":"To be able to register a handler that reads the internal messages, we have to create a class at the end of the file which processes the signing messages. class SigningDialogues ( Model , BaseSigningDialogues ): \"\"\"Signing dialogues model.\"\"\" def __init__ ( self , self_address : Address , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> Dialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return SigningDialogue . Role . SKILL BaseSigningDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , ) class SigningHandler ( Handler ): \"\"\"Implement the signing handler.\"\"\" SUPPORTED_PROTOCOL = SigningMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" signing_msg = cast ( SigningMessage , message ) # recover dialogue signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . update ( signing_msg ) ) if signing_dialogue is None : self . _handle_unidentified_dialogue ( signing_msg ) return # handle message if signing_msg . performative is SigningMessage . Performative . SIGNED_TRANSACTION : self . _handle_signed_transaction ( signing_msg , signing_dialogue ) elif signing_msg . performative is SigningMessage . Performative . ERROR : self . _handle_error ( signing_msg , signing_dialogue ) else : self . _handle_invalid ( signing_msg , signing_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" def _handle_unidentified_dialogue ( self , signing_msg : SigningMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid signing message= {} , unidentified dialogue.\" . format ( signing_msg ) ) def _handle_signed_transaction ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle a signing message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was successful.\" ) logger . info ( signing_msg . signed_transaction ) def _handle_error ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was not successful. Error_code= {} in dialogue= {} \" . format ( signing_msg . error_code , signing_dialogue ) ) def _handle_invalid ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle signing message of performative= {} in dialogue= {} .\" . format ( signing_msg . performative , signing_dialogue ) ) You can find the full code for this example below: Transaction via decision-maker full code import logging import time from threading import Thread from typing import Optional , cast from aea_ledger_fetchai import FetchAICrypto from aea.aea_builder import AEABuilder from aea.configurations.base import PublicId , SkillConfig from aea.crypto.helpers import create_private_key from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet from aea.helpers.transaction.base import RawTransaction , Terms from aea.identity.base import Identity from aea.protocols.base import Address , Message from aea.protocols.dialogue.base import Dialogue from aea.skills.base import Handler , Model , Skill , SkillContext from packages.fetchai.protocols.signing.dialogues import SigningDialogue from packages.fetchai.protocols.signing.dialogues import ( SigningDialogues as BaseSigningDialogues , ) from packages.fetchai.protocols.signing.message import SigningMessage from tests.conftest import get_wealth_if_needed logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" def run (): \"\"\"Run demo.\"\"\" # Create a private key create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) # Instantiate the builder and build the AEA # By default, the default protocol, error skill and stub connection are added builder = AEABuilder () builder . set_name ( \"my_aea\" ) builder . add_private_key ( FetchAICrypto . identifier , FETCHAI_PRIVATE_KEY_FILE_1 ) # Create our AEA my_aea = builder . build () # add a simple skill with handler skill_context = SkillContext ( my_aea . context ) skill_config = SkillConfig ( name = \"simple_skill\" , author = \"fetchai\" , version = \"0.1.0\" ) signing_handler = SigningHandler ( skill_context = skill_context , name = \"signing_handler\" ) signing_dialogues_model = SigningDialogues ( skill_context = skill_context , name = \"signing_dialogues\" , self_address = str ( skill_config . public_id ), ) simple_skill = Skill ( skill_config , skill_context , handlers = { signing_handler . name : signing_handler }, models = { signing_dialogues_model . name : signing_dialogues_model }, ) my_aea . resources . add_skill ( simple_skill ) # create a second identity create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) counterparty_wallet = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) get_wealth_if_needed ( counterparty_wallet . addresses [ \"fetchai\" ]) counterparty_identity = Identity ( name = \"counterparty_aea\" , addresses = counterparty_wallet . addresses , public_keys = counterparty_wallet . public_keys , default_address_key = FetchAICrypto . identifier , ) # create signing message for decision maker to sign terms = Terms ( ledger_id = FetchAICrypto . identifier , sender_address = my_aea . identity . address , counterparty_address = counterparty_identity . address , amount_by_currency_id = { \"FET\" : - 1 }, quantities_by_good_id = { \"some_service\" : 1 }, nonce = \"some_nonce\" , fee_by_currency_id = { \"FET\" : 0 }, ) get_wealth_if_needed ( terms . sender_address ) signing_dialogues = cast ( SigningDialogues , skill_context . signing_dialogues ) stub_transaction = LedgerApis . get_transfer_transaction ( terms . ledger_id , terms . sender_address , terms . counterparty_address , terms . sender_payable_amount , terms . sender_fee , terms . nonce , ) signing_msg = SigningMessage ( performative = SigningMessage . Performative . SIGN_TRANSACTION , dialogue_reference = signing_dialogues . new_self_initiated_dialogue_reference (), raw_transaction = RawTransaction ( FetchAICrypto . identifier , stub_transaction ), terms = terms , ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . create_with_message ( \"decision_maker\" , signing_msg ), ) assert signing_dialogue is not None my_aea . context . decision_maker_message_queue . put_nowait ( signing_msg ) # Set the AEA running in a different thread try : logger . info ( \"STARTING AEA NOW!\" ) t = Thread ( target = my_aea . start ) t . start () # Let it run long enough to interact with the decision maker time . sleep ( 1 ) finally : # Shut down the AEA logger . info ( \"STOPPING AEA NOW!\" ) my_aea . stop () t . join () class SigningDialogues ( Model , BaseSigningDialogues ): \"\"\"Signing dialogues model.\"\"\" def __init__ ( self , self_address : Address , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> Dialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return SigningDialogue . Role . SKILL BaseSigningDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , ) class SigningHandler ( Handler ): \"\"\"Implement the signing handler.\"\"\" SUPPORTED_PROTOCOL = SigningMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" signing_msg = cast ( SigningMessage , message ) # recover dialogue signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . update ( signing_msg ) ) if signing_dialogue is None : self . _handle_unidentified_dialogue ( signing_msg ) return # handle message if signing_msg . performative is SigningMessage . Performative . SIGNED_TRANSACTION : self . _handle_signed_transaction ( signing_msg , signing_dialogue ) elif signing_msg . performative is SigningMessage . Performative . ERROR : self . _handle_error ( signing_msg , signing_dialogue ) else : self . _handle_invalid ( signing_msg , signing_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" def _handle_unidentified_dialogue ( self , signing_msg : SigningMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid signing message= {} , unidentified dialogue.\" . format ( signing_msg ) ) def _handle_signed_transaction ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle a signing message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was successful.\" ) logger . info ( signing_msg . signed_transaction ) def _handle_error ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"transaction signing was not successful. Error_code= {} in dialogue= {} \" . format ( signing_msg . error_code , signing_dialogue ) ) def _handle_invalid ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle signing message of performative= {} in dialogue= {} .\" . format ( signing_msg . performative , signing_dialogue ) ) if __name__ == \"__main__\" : run ()","title":"More details"},{"location":"aea/decision-maker/","text":"The DecisionMaker can be thought of like a wallet manager plus \"economic brain\" of the AEA. It is responsible for the AEA's crypto-economic security and goal management, and it contains the preference and ownership representation of the AEA. The decision maker is the only component which has access to the wallet's private keys. Interaction with skills Skills communicate with the decision maker via Messages . At present, the decision maker processes messages of two protocols: SigningMessage : it is used by skills to propose a transaction to the decision-maker for signing. StateUpdateMessage : it is used to initialize the decision maker with preferences and ownership states. It can also be used to update the ownership states in the decision maker if the settlement of transaction takes place. A message, say msg , is sent to the decision maker like so from any skill: self.context.decision_maker_message_queue.put_nowait(msg) The decision maker processes messages and can accept or reject them. To process Messages from the decision maker in a given skill you need to create a Handler , in particular a SigningHandler like so: class SigningHandler ( Handler ): protocol_id = SigningMessage . protocol_id def handle ( self , message : Message ): \"\"\" Handle a signing message. :param message: the signing message from the decision maker. \"\"\" # code to handle the message Custom DecisionMaker The framework implements a default DecisionMakerHandler and an advanced DecisionMakerHandler . You can also implement your own and mount it. No further configuration is needed to use the default. To use the advanced decision maker handler, add the following configuration to the aea-config.yaml of your AEA (on page 1): decision_maker_handler : config : {} dotted_path : \"aea.decision_maker.gop:DecisionMakerHandler\" file_path : null The easiest way to add a custom decision maker handler is to run the following command to scaffold a custom DecisionMakerHandler : aea scaffold decision-maker-handler You can then implement your own custom logic to process messages and interact with the Wallet . Note For examples how to use these concepts have a look at the tac_ skills. These functionalities are experimental and subject to change.","title":"Decision Maker"},{"location":"aea/decision-maker/#interaction-with-skills","text":"Skills communicate with the decision maker via Messages . At present, the decision maker processes messages of two protocols: SigningMessage : it is used by skills to propose a transaction to the decision-maker for signing. StateUpdateMessage : it is used to initialize the decision maker with preferences and ownership states. It can also be used to update the ownership states in the decision maker if the settlement of transaction takes place. A message, say msg , is sent to the decision maker like so from any skill: self.context.decision_maker_message_queue.put_nowait(msg) The decision maker processes messages and can accept or reject them. To process Messages from the decision maker in a given skill you need to create a Handler , in particular a SigningHandler like so: class SigningHandler ( Handler ): protocol_id = SigningMessage . protocol_id def handle ( self , message : Message ): \"\"\" Handle a signing message. :param message: the signing message from the decision maker. \"\"\" # code to handle the message","title":"Interaction with skills"},{"location":"aea/decision-maker/#custom-decisionmaker","text":"The framework implements a default DecisionMakerHandler and an advanced DecisionMakerHandler . You can also implement your own and mount it. No further configuration is needed to use the default. To use the advanced decision maker handler, add the following configuration to the aea-config.yaml of your AEA (on page 1): decision_maker_handler : config : {} dotted_path : \"aea.decision_maker.gop:DecisionMakerHandler\" file_path : null The easiest way to add a custom decision maker handler is to run the following command to scaffold a custom DecisionMakerHandler : aea scaffold decision-maker-handler You can then implement your own custom logic to process messages and interact with the Wallet . Note For examples how to use these concepts have a look at the tac_ skills. These functionalities are experimental and subject to change.","title":"Custom DecisionMaker"},{"location":"aea/defining-data-models/","text":"In this section, we explain how to define data models , an important component of the OEF Search & Discovery. It allows agents to describe themselves and to discover the services/resources they are interested in. In a sentence, a DataModel is a set of attributes , and a Description of a service/resource is an assignment of those attributes. All you need to specify data models and descriptions (that is, instances of the data model) can be found in the aea.helpers.search module. Attributes At the lowest level of our data model language, we have the Attribute . An attribute is an abstract definition of a property. It is identified by a name , that must be unique in a given data model (that is, we can't have two attributes that share the same name). Every attribute has a type , that specifies the domain of the property, that is, the possible values that the attribute can assume. At the moment, we support five types of attributes: strings integers booleans floats locations, i.e. instances of Location (pairs of (latitude, longitude)) An attribute can be optional , in the sense that instantiation of the attribute is not mandatory by the instances of the data model. Finally, every attribute might have a description that explains the purpose of the attribute. Example : suppose we have a bookshop, and we want to describe the books we sell. Presumably, we would like to include: the following properties of our books: The title The author The genre (e.g. science fiction, horror) The year of publication The average rating (average of the ratings between 0 and 5) The ISBN code If it can be sold as an e-book. For each of this fields, we can define an attribute by using Attribute : from aea.helpers.search.models import Attribute , Location attr_title = Attribute ( \"title\" , str , True , \"The title of the book.\" ) attr_author = Attribute ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = Attribute ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = Attribute ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = Attribute ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = Attribute ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = Attribute ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = Attribute ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" ) Let's focus on the parameters of the Attribute constructor: the first one is the name of the attribute. It is needed to instantiate a data model and to define queries over it. the second one is the type of the attribute. It specifies the domain of the possible values the attribute can assume. E.g. the attribute year can only be an integer, whereas the average_rating can only be a floating-point number. The supported types are: str , int , bool , float and Location . the third one is a boolean that specifies whether the attribute is always required or it can be omitted . For example, we might not be able to specify the ebook_available attribute, maybe because it's not applicable to some kind of books. the fourth parameter is the description, that is a short description of the purpose of the attribute. Data models A data model is just a set of attributes . The class that implements the data model is DataModel . Example : let's continue with the example of the bookshop. Once we've defined the attributes, we'd like to group them in the same structure. We can do it in the following way: from aea.helpers.search.models import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel requires: a name (in the example the name is \"book\" ) used to refer to the data model. a list of attributes , that constitutes the abstract data model. an (optional) description about the purpose of the data model. Description A Description is just an instantiation of a data model . That is, we specify a value to every attribute belonging to the data model we are interested in. The class that implements the description is Description . Example : now we have all we need to create a little catalogue about our books: from aea.helpers.search.models import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) We defined the descriptions for two books, namely It and _1984 , that refers to a data model. The attributes are instantiated with a dictionary that has: as keys, the name of the attributes. as values, the values associated with the attributes. Notice that in the latter book we omitted the average_rating field. We are allowed to do that because of the average_rating attribute is not mandatory.","title":"Defining Data Models"},{"location":"aea/defining-data-models/#attributes","text":"At the lowest level of our data model language, we have the Attribute . An attribute is an abstract definition of a property. It is identified by a name , that must be unique in a given data model (that is, we can't have two attributes that share the same name). Every attribute has a type , that specifies the domain of the property, that is, the possible values that the attribute can assume. At the moment, we support five types of attributes: strings integers booleans floats locations, i.e. instances of Location (pairs of (latitude, longitude)) An attribute can be optional , in the sense that instantiation of the attribute is not mandatory by the instances of the data model. Finally, every attribute might have a description that explains the purpose of the attribute. Example : suppose we have a bookshop, and we want to describe the books we sell. Presumably, we would like to include: the following properties of our books: The title The author The genre (e.g. science fiction, horror) The year of publication The average rating (average of the ratings between 0 and 5) The ISBN code If it can be sold as an e-book. For each of this fields, we can define an attribute by using Attribute : from aea.helpers.search.models import Attribute , Location attr_title = Attribute ( \"title\" , str , True , \"The title of the book.\" ) attr_author = Attribute ( \"author\" , str , True , \"The author of the book.\" ) attr_genre = Attribute ( \"genre\" , str , True , \"The genre of the book.\" ) attr_year = Attribute ( \"year\" , int , True , \"The year of publication of the book.\" ) attr_avg_rat = Attribute ( \"average_rating\" , float , False , \"The average rating of the book.\" ) attr_isbn = Attribute ( \"ISBN\" , str , True , \"The ISBN.\" ) attr_ebook = Attribute ( \"ebook_available\" , bool , False , \"If the book can be sold as an e-book.\" ) attr_bookshop = Attribute ( \"bookshop_pos\" , Location , False , \"The location of the bookshop where you can find the book\" ) Let's focus on the parameters of the Attribute constructor: the first one is the name of the attribute. It is needed to instantiate a data model and to define queries over it. the second one is the type of the attribute. It specifies the domain of the possible values the attribute can assume. E.g. the attribute year can only be an integer, whereas the average_rating can only be a floating-point number. The supported types are: str , int , bool , float and Location . the third one is a boolean that specifies whether the attribute is always required or it can be omitted . For example, we might not be able to specify the ebook_available attribute, maybe because it's not applicable to some kind of books. the fourth parameter is the description, that is a short description of the purpose of the attribute.","title":"Attributes"},{"location":"aea/defining-data-models/#data-models","text":"A data model is just a set of attributes . The class that implements the data model is DataModel . Example : let's continue with the example of the bookshop. Once we've defined the attributes, we'd like to group them in the same structure. We can do it in the following way: from aea.helpers.search.models import DataModel book_model = DataModel ( \"book\" , [ attr_title , attr_author , attr_genre , attr_year , attr_avg_rat , attr_isbn , attr_ebook , attr_bookshop ], \"A data model to describe books.\" ) A DataModel requires: a name (in the example the name is \"book\" ) used to refer to the data model. a list of attributes , that constitutes the abstract data model. an (optional) description about the purpose of the data model.","title":"Data models"},{"location":"aea/defining-data-models/#description","text":"A Description is just an instantiation of a data model . That is, we specify a value to every attribute belonging to the data model we are interested in. The class that implements the description is Description . Example : now we have all we need to create a little catalogue about our books: from aea.helpers.search.models import Description It = Description ({ \"title\" : \"It\" , \"author\" : \"Stephen King\" , \"genre\" : \"horror\" , \"year\" : 1986 , \"average_rating\" : 4.5 , \"ISBN\" : \"0-670-81302-8\" , \"ebook_available\" : True , \"bookshop_pos\" : Location ( 52.2057092 , 0.1183431 ) }, book_model ) _1984 = Description ({ \"title\" : \"1984\" , \"author\" : \"George Orwell\" , \"genre\" : \"novel\" , \"year\" : 1949 , \"ISBN\" : \"978-0451524935\" , \"ebook_available\" : False }, book_model ) We defined the descriptions for two books, namely It and _1984 , that refers to a data model. The attributes are instantiated with a dictionary that has: as keys, the name of the attributes. as values, the values associated with the attributes. Notice that in the latter book we omitted the average_rating field. We are allowed to do that because of the average_rating attribute is not mandatory.","title":"Description"},{"location":"aea/demos/","text":"We provide demo guides for multiple use-cases, each one involving several AEAs interacting in a different scenario. These demos serve to highlight the concept of AEAs as well as provide inspiration for developers. Demos should not be taken as production ready software, although every care is taken to fix bugs when reported. Demos are alphabetically sorted, we recommend you start with the weather skills demo .","title":"Demos"},{"location":"aea/deployment/","text":"The easiest way to run an AEA is using your development environment. If you would like to run an AEA from a browser you can use Google Colab . This gist can be opened in Colab and implements the quick start . For deployment, we recommend you use Docker . Deployment using a Docker Image First, we fetch a directory containing a Dockerfile and some dependencies: svn export https://github.com/fetchai/agents-aea/branches/main/deploy-image cd deploy-image Then follow the README.md contained in the folder. Deployment using Kubernetes For an example of how to use Kubernetes navigate to our TAC deployment example .","title":"Deployment"},{"location":"aea/deployment/#deployment-using-a-docker-image","text":"First, we fetch a directory containing a Dockerfile and some dependencies: svn export https://github.com/fetchai/agents-aea/branches/main/deploy-image cd deploy-image Then follow the README.md contained in the folder.","title":"Deployment using a Docker Image"},{"location":"aea/deployment/#deployment-using-kubernetes","text":"For an example of how to use Kubernetes navigate to our TAC deployment example .","title":"Deployment using Kubernetes"},{"location":"aea/design-principles/","text":"The AEA framework development is guided by the following 8 principles: Accessibility : ease of use. Modularity : encourages module creation, sharing and reuse. Openness : easily extensible with third-party libraries. Conciseness : conceptually simple. Value-driven : drives immediate value. Low entry barriers : leverages existing programming languages and web protocols. Safety : safe for the user (economically speaking). Goal-alignment : seamless facilitation of users' preferences and goals.","title":"Design principles"},{"location":"aea/development-setup/","text":"An AEA consists of packages . When developing, it helps to be able to save packages in a local package registry, rather than pushing them to remote registry . This guide helps you set up a local package registry and configure the working directory for development. There are two ways to write code for an AEA: independent of a concrete AEA project, write individual packages from within an AEA project, write packages for that AEA Approach 1 To prepare a directory (henceforth working directory) for development with the AEA framework you can take a few steps: Either, manually: Ensure you start with an empty working directory to avoid any unnecessary side effects. In your working directory, create an empty folder called packages . This folder will act as the local registry for packages. In your working directory, create a .env file with the constant PYTHONPATH=$PYTHONPATH:path_to_packages_dir where path_to_packages_dir is the path to the packages folder in your working directory. Or, automated: Fork our template repo for AEA development. Then clone it to your machine. Depending on your editor, you might take further steps: VS Code: The Python Extension in VS Code can be configured to include additional paths in the Python path. The extension has a setting for python.envFile which specifies the path to a file containing environment variable definitions. The default is set to \"python.envFile\": \"${workspaceFolder}/.env\" . Provide the path to the .env file in the above settings. In the .env file, add the PYTHONPATH constant defined above. Then close VS Code and re-open it for the settings to take effect. After developing a package, you can add it to an AEA project in the working directory (e.g. aea create AGENT_NAME && cd AGENT_NAME && aea add --local PACKAGE_TYPE PUBLIC_ID will create a new AEA project AGENT_NAME and add the package of type PACKAGE_TYPE with public id PUBLIC_ID to it.) Approach 2 It is also possible to develop directly in an AEA project: Prepare a directory (henceforth working directory) for development. Create a new project aea create AGENT_NAME && cd AGENT_NAME Scaffold a new package aea scaffold --with-symlinks PACKAGE_TYPE PACKAGE_NAME . This will create the package scaffold under the directory {PACKAGE_TYPE}s and create symlinks to ensure package import paths line up with the folder structure. The symlinks are not needed to run the AEA. They are purely for your IDE. In your working directory, create a .env file with the constant PYTHONPATH=$PYTHONPATH:path_to_project_dir where path_to_project_dir is the path to the AEA project contained in your working directory. Depending on your editor, you might take further steps: VS Code: The Python Extension in VS Code can be configured to include additional paths in the Python path. The extension has a setting for python.envFile which specifies the path to a file containing environment variable definitions. The default is set to \"python.envFile\": \"${workspaceFolder}/.env\" . Provide the path to the .env file in the above settings. In the .env file, add the PYTHONPATH constant defined above. Then close VS Code and re-open it for the settings to take effect. General advice This advice partially overlaps with the previous two sections: When developing a specific AEA, it might be helpful to publish/push or fetch/add from local registry. From your working directory/AEA project, simply execute the usual AEA CLI commands. The CLI will first search in the packages directory, then in the remote AEA registry. You can explicitly point to local registry by providing flag --local or --remote to only point to remote registry (see here for more details on CLI commands). When working on an AEA, it may help to provide a symbolic link to the packages directory, so that the import paths are detected by your editor. Simply create an empty file with touch packages in your AEA project, then create a symbolic link to the packages directory with ln -s ../packages packages . Alternatively, it can help to provide symbolic links within an AEA to align import paths with folder structure. Simply create an empty file with touch packages in your AEA project, then create a symbolic link to ln -s vendor packages .","title":"Development setup"},{"location":"aea/development-setup/#approach-1","text":"To prepare a directory (henceforth working directory) for development with the AEA framework you can take a few steps: Either, manually: Ensure you start with an empty working directory to avoid any unnecessary side effects. In your working directory, create an empty folder called packages . This folder will act as the local registry for packages. In your working directory, create a .env file with the constant PYTHONPATH=$PYTHONPATH:path_to_packages_dir where path_to_packages_dir is the path to the packages folder in your working directory. Or, automated: Fork our template repo for AEA development. Then clone it to your machine. Depending on your editor, you might take further steps: VS Code: The Python Extension in VS Code can be configured to include additional paths in the Python path. The extension has a setting for python.envFile which specifies the path to a file containing environment variable definitions. The default is set to \"python.envFile\": \"${workspaceFolder}/.env\" . Provide the path to the .env file in the above settings. In the .env file, add the PYTHONPATH constant defined above. Then close VS Code and re-open it for the settings to take effect. After developing a package, you can add it to an AEA project in the working directory (e.g. aea create AGENT_NAME && cd AGENT_NAME && aea add --local PACKAGE_TYPE PUBLIC_ID will create a new AEA project AGENT_NAME and add the package of type PACKAGE_TYPE with public id PUBLIC_ID to it.)","title":"Approach 1"},{"location":"aea/development-setup/#approach-2","text":"It is also possible to develop directly in an AEA project: Prepare a directory (henceforth working directory) for development. Create a new project aea create AGENT_NAME && cd AGENT_NAME Scaffold a new package aea scaffold --with-symlinks PACKAGE_TYPE PACKAGE_NAME . This will create the package scaffold under the directory {PACKAGE_TYPE}s and create symlinks to ensure package import paths line up with the folder structure. The symlinks are not needed to run the AEA. They are purely for your IDE. In your working directory, create a .env file with the constant PYTHONPATH=$PYTHONPATH:path_to_project_dir where path_to_project_dir is the path to the AEA project contained in your working directory. Depending on your editor, you might take further steps: VS Code: The Python Extension in VS Code can be configured to include additional paths in the Python path. The extension has a setting for python.envFile which specifies the path to a file containing environment variable definitions. The default is set to \"python.envFile\": \"${workspaceFolder}/.env\" . Provide the path to the .env file in the above settings. In the .env file, add the PYTHONPATH constant defined above. Then close VS Code and re-open it for the settings to take effect.","title":"Approach 2"},{"location":"aea/development-setup/#general-advice","text":"This advice partially overlaps with the previous two sections: When developing a specific AEA, it might be helpful to publish/push or fetch/add from local registry. From your working directory/AEA project, simply execute the usual AEA CLI commands. The CLI will first search in the packages directory, then in the remote AEA registry. You can explicitly point to local registry by providing flag --local or --remote to only point to remote registry (see here for more details on CLI commands). When working on an AEA, it may help to provide a symbolic link to the packages directory, so that the import paths are detected by your editor. Simply create an empty file with touch packages in your AEA project, then create a symbolic link to the packages directory with ln -s ../packages packages . Alternatively, it can help to provide symbolic links within an AEA to align import paths with folder structure. Simply create an empty file with touch packages in your AEA project, then create a symbolic link to ln -s vendor packages .","title":"General advice"},{"location":"aea/diagram/","text":"The framework has two distinctive parts. A core that is developed by the Fetch.ai team as well as external contributors. Extensions (also known as packages ) developed by any developer. Currently, the framework supports four types of packages which can be added to the core as modules: Skills encapsulate logic that deliver economic value to the AEA. Skills are the main focus of the framework's extensibility. Protocols define the structure of agent-to-agent and component-to-component interactions (messages and dialogues) for agents. Connections provide interfaces for the agent to connect with the outside world. They wrap SDKs or APIs and provide interfaces to networks, ledgers and other services. Contracts wrap smart contracts for Fetch.ai and third-party decentralized ledgers. The following figure illustrates the framework's architecture: The execution is broken down in more detail below: The agent operation breaks down into three parts: Setup : calls the setup() method of all registered resources Operation : Agent loop (Thread 1 - Asynchronous agent loop): react() : this function grabs all Envelopes waiting in the InBox queue and calls the handle() method on the Handler(s) responsible for them. act() : this function calls the act() method of all registered Behaviours. update() : this function enqueues scheduled tasks for execution with the TaskManager and executes the decision maker. Task loop (Thread 2- Synchronous): executes available tasks Decision maker loop (Thread 3- Synchronous): processes internal messages Multiplexer (Thread 4 - Asynchronous event loop): processes incoming and outgoing messages across several connections asynchronously. Teardown : calls the teardown() method of all registered resources To prevent a developer from blocking the main loop with custom skill code, an execution time limit is applied to every Behaviour.act and Handler.handle call. By default, the execution limit is set to 0 seconds, which disables the feature. You can set the limit to a strictly positive value (e.g. 0.1 seconds) to test your AEA for production readiness. If the act or handle time exceed this limit, the call will be terminated. An appropriate message is added to the logs in the case of some code execution being terminated.","title":"Architectural diagram"},{"location":"aea/erc1155-skills/","text":"The AEA erc1155_deploy and erc1155_client skills demonstrate an interaction between two AEAs which use a smart contract. The erc1155_deploy skill deploys the smart contract, creates and mints items. The erc1155_client skill signs a transaction to complete a trustless trade with its counterparty. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Discussion The scope of this guide is demonstrating how you can deploy a smart contract and interact with it using AEAs. In this specific demo, you create two AEAs. One deploys and creates tokens inside a smart contract. The other signs a transaction to complete an atomic swap. The smart contract used is ERC1155 with a one-step atomic swap functionality. This means the trade between the two AEAs can be trustless. Note This is only for demonstrative purposes since the AEA deploying the contract also has the ability to mint tokens. In reality, the transfer of tokens from the AEA signing the transaction is worthless. Demo Create the deployer AEA Fetch the AEA that will deploy the contract: aea fetch fetchai/erc1155_deployer:0.33.0 cd erc1155_deployer aea install aea build Alternatively, create from scratch. Create the AEA that will deploy the contract. aea create erc1155_deployer cd erc1155_deployer aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/erc1155_deploy:0.30.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-cosmos\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' aea install aea build And change the default ledger: aea config set agent.default_ledger ethereum Create a private key for the deployer AEA and add it for Ethereum use: aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt Create a private key for the P2P connection: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Create the client AEA In another terminal, fetch the client AEA which will receive some tokens from the deployer. aea fetch fetchai/erc1155_client:0.33.0 cd erc1155_client aea install aea build Alternatively, create from scratch. Create the AEA that will get some tokens from the deployer. aea create erc1155_client cd erc1155_client aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/erc1155_client:0.28.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-cosmos\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' aea install aea build And change the default ledger: aea config set agent.default_ledger ethereum Create a private key for the client AEA and add it for Ethereum use: aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt Create a private key for the P2P connection: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Run Ganache Execute the following command to run Ganache: docker run -p 8545 :8545 trufflesuite/ganache-cli:latest --verbose --gasPrice = 0 --gasLimit = 0x1fffffffffffff --account = \" $( cat erc1155_deployer/ethereum_private_key.txt ) ,1000000000000000000000\" --account = \" $( cat erc1155_client/ethereum_private_key.txt ) ,1000000000000000000000\" Wait some time for the wealth creation to be mined on Ropsten. Check your wealth: aea get-wealth ethereum You should get 1000000000000000000000 . Note If no wealth appears after a while, then try funding the private key directly using a web faucet. Update SOEF configurations for both AEAs Update the SOEF configuration in both AEA projects: aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum Run the AEAs First, run the deployer AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of this address. Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address. The output will be something like /dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAm2JPsUX1Su59YVDXJQizYkNSe8JCusqRpLeeTbvY76fE5 . This is the entry peer address for the local agent communication network created by the deployer. This AEA then performs the following steps: deploys the smart contract creates a batch of items in the smart contract mints a batch of items in the smart contract At some point you should see the log output: registering service on SOEF. At this point, configure the client AEA to connect to the same local ACN created by the deployer by running the following command in the client's terminal, replacing SOME_ADDRESS with the value you noted above: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Then, run the client AEA: aea run You will see that after discovery, the two AEAs exchange information about the transaction and the client at the end signs and sends the signature to the deployer AEA to send it to the network. Note Transactions on Ropsten can take a significant amount of time! If you run the example a second time, and the previous transaction is still pending, it can lead to a failure. The warning message `Cannot verify whether transaction improves utility. Assuming it does!` can be ignored. Delete the AEAs When you're done, stop the agents ( CTRL+C ), go up a level and delete the AEAs. cd .. aea delete erc1155_deployer aea delete erc1155_client Communication This diagram shows the communication between the various entities in this interaction: sequenceDiagram participant Search participant Erc1155_contract participant Client_AEA participant Deployer_AEA participant Blockchain activate Search activate Erc1155_contract activate Client_AEA activate Deployer_AEA activate Blockchain Deployer_AEA->>Blockchain: deployes smart contract Deployer_AEA->>ERC1155_contract: creates tokens Deployer_AEA->>ERC1155_contract: mint tokens Deployer_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Deployer_AEA: call_for_proposal Deployer_AEA->>Client_AEA: inform_message Client_AEA->>Deployer_AEA: signature Deployer_AEA->>Blockchain: send_transaction Client_AEA->>ERC1155_contract: asks_balance deactivate Search deactivate Erc1155_contract deactivate Client_AEA deactivate Deployer_AEA deactivate Blockchain","title":"Contract deploy and interact"},{"location":"aea/erc1155-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/erc1155-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/erc1155-skills/#discussion","text":"The scope of this guide is demonstrating how you can deploy a smart contract and interact with it using AEAs. In this specific demo, you create two AEAs. One deploys and creates tokens inside a smart contract. The other signs a transaction to complete an atomic swap. The smart contract used is ERC1155 with a one-step atomic swap functionality. This means the trade between the two AEAs can be trustless. Note This is only for demonstrative purposes since the AEA deploying the contract also has the ability to mint tokens. In reality, the transfer of tokens from the AEA signing the transaction is worthless.","title":"Discussion"},{"location":"aea/erc1155-skills/#demo","text":"","title":"Demo"},{"location":"aea/erc1155-skills/#create-the-deployer-aea","text":"Fetch the AEA that will deploy the contract: aea fetch fetchai/erc1155_deployer:0.33.0 cd erc1155_deployer aea install aea build Alternatively, create from scratch. Create the AEA that will deploy the contract. aea create erc1155_deployer cd erc1155_deployer aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/erc1155_deploy:0.30.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-cosmos\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' aea install aea build And change the default ledger: aea config set agent.default_ledger ethereum Create a private key for the deployer AEA and add it for Ethereum use: aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt Create a private key for the P2P connection: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Create the deployer AEA"},{"location":"aea/erc1155-skills/#create-the-client-aea","text":"In another terminal, fetch the client AEA which will receive some tokens from the deployer. aea fetch fetchai/erc1155_client:0.33.0 cd erc1155_client aea install aea build Alternatively, create from scratch. Create the AEA that will get some tokens from the deployer. aea create erc1155_client cd erc1155_client aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/erc1155_client:0.28.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-cosmos\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' aea install aea build And change the default ledger: aea config set agent.default_ledger ethereum Create a private key for the client AEA and add it for Ethereum use: aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt Create a private key for the P2P connection: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Create the client AEA"},{"location":"aea/erc1155-skills/#run-ganache","text":"Execute the following command to run Ganache: docker run -p 8545 :8545 trufflesuite/ganache-cli:latest --verbose --gasPrice = 0 --gasLimit = 0x1fffffffffffff --account = \" $( cat erc1155_deployer/ethereum_private_key.txt ) ,1000000000000000000000\" --account = \" $( cat erc1155_client/ethereum_private_key.txt ) ,1000000000000000000000\" Wait some time for the wealth creation to be mined on Ropsten. Check your wealth: aea get-wealth ethereum You should get 1000000000000000000000 . Note If no wealth appears after a while, then try funding the private key directly using a web faucet.","title":"Run Ganache"},{"location":"aea/erc1155-skills/#update-soef-configurations-for-both-aeas","text":"Update the SOEF configuration in both AEA projects: aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum","title":"Update SOEF configurations for both AEAs"},{"location":"aea/erc1155-skills/#run-the-aeas","text":"First, run the deployer AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of this address. Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address. The output will be something like /dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAm2JPsUX1Su59YVDXJQizYkNSe8JCusqRpLeeTbvY76fE5 . This is the entry peer address for the local agent communication network created by the deployer. This AEA then performs the following steps: deploys the smart contract creates a batch of items in the smart contract mints a batch of items in the smart contract At some point you should see the log output: registering service on SOEF. At this point, configure the client AEA to connect to the same local ACN created by the deployer by running the following command in the client's terminal, replacing SOME_ADDRESS with the value you noted above: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Then, run the client AEA: aea run You will see that after discovery, the two AEAs exchange information about the transaction and the client at the end signs and sends the signature to the deployer AEA to send it to the network. Note Transactions on Ropsten can take a significant amount of time! If you run the example a second time, and the previous transaction is still pending, it can lead to a failure. The warning message `Cannot verify whether transaction improves utility. Assuming it does!` can be ignored.","title":"Run the AEAs"},{"location":"aea/erc1155-skills/#delete-the-aeas","text":"When you're done, stop the agents ( CTRL+C ), go up a level and delete the AEAs. cd .. aea delete erc1155_deployer aea delete erc1155_client","title":"Delete the AEAs"},{"location":"aea/erc1155-skills/#communication","text":"This diagram shows the communication between the various entities in this interaction: sequenceDiagram participant Search participant Erc1155_contract participant Client_AEA participant Deployer_AEA participant Blockchain activate Search activate Erc1155_contract activate Client_AEA activate Deployer_AEA activate Blockchain Deployer_AEA->>Blockchain: deployes smart contract Deployer_AEA->>ERC1155_contract: creates tokens Deployer_AEA->>ERC1155_contract: mint tokens Deployer_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Deployer_AEA: call_for_proposal Deployer_AEA->>Client_AEA: inform_message Client_AEA->>Deployer_AEA: signature Deployer_AEA->>Blockchain: send_transaction Client_AEA->>ERC1155_contract: asks_balance deactivate Search deactivate Erc1155_contract deactivate Client_AEA deactivate Deployer_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/generic-skills-step-by-step/","text":"This guide is a step-by-step introduction to building AEAs that advertise their static and dynamic data, find other AEAs with required data, negotiate terms of trade, and carry out trades via ledger transactions. If you simply want to run the resulting AEAs go here . Dependencies (Required) Follow the Preliminaries and Installation sections from the AEA quick start. Reference code (Optional) This step-by-step guide goes through the creation of two AEAs which are already developed by Fetch.ai. You can get the finished AEAs, and compare your code against them, by following the next steps: aea fetch fetchai/generic_seller:0.28.0 cd generic_seller aea eject skill fetchai/generic_seller:0.27.0 cd .. aea fetch fetchai/generic_buyer:0.29.0 cd generic_buyer aea eject skill fetchai/generic_buyer:0.26.0 cd .. Simplification step To keep file paths consistent with the reference code, we suggest you initialize your local author as fetchai for the purpose of this demo only: aea init --reset --local --author fetchai Generic Seller AEA Step 1: Create the AEA Create a new AEA by typing the following command in the terminal: aea create my_generic_seller cd my_generic_seller aea install Our newly created AEA is inside the current working directory. Let\u2019s create our new skill that will handle the sale of data. Type the following command: aea scaffold skill generic_seller The scaffold skill command creates the correct structure for a new skill inside our AEA project. You can locate the newly created skill under the \"skills\" folder ( my_generic_seller/skills/generic_seller/ ), and it must contain the following files: __init__.py behaviours.py handlers.py my_model.py skills.yaml Step 2: Create the behaviour A Behaviour class contains the business logic specific to actions initiated by the AEA, rather than reactions to other events. Open the behaviours.py file ( my_generic_seller/skills/generic_seller/behaviours.py ) and replace the stub code with the following: from typing import Any , Optional , cast from aea.helpers.search.models import Description from aea.skills.behaviours import TickerBehaviour from packages.fetchai.connections.ledger.base import ( CONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID , ) from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.generic_seller.dialogues import ( LedgerApiDialogues , OefSearchDialogues , ) from packages.fetchai.skills.generic_seller.strategy import GenericStrategy DEFAULT_SERVICES_INTERVAL = 60.0 DEFAULT_MAX_SOEF_REGISTRATION_RETRIES = 5 LEDGER_API_ADDRESS = str ( LEDGER_CONNECTION_PUBLIC_ID ) class GenericServiceRegistrationBehaviour ( TickerBehaviour ): \"\"\"This class implements a behaviour.\"\"\" def __init__ ( self , ** kwargs : Any ): \"\"\"Initialise the behaviour.\"\"\" services_interval = kwargs . pop ( \"services_interval\" , DEFAULT_SERVICES_INTERVAL ) # type: int self . _max_soef_registration_retries = kwargs . pop ( \"max_soef_registration_retries\" , DEFAULT_MAX_SOEF_REGISTRATION_RETRIES ) # type: int super () . __init__ ( tick_interval = services_interval , ** kwargs ) self . failed_registration_msg = None # type: Optional[OefSearchMessage] self . _nb_retries = 0 def setup ( self ) -> None : \"\"\"Implement the setup.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_ledger_tx : ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_msg , _ = ledger_api_dialogues . create ( counterparty = LEDGER_API_ADDRESS , performative = LedgerApiMessage . Performative . GET_BALANCE , ledger_id = strategy . ledger_id , address = cast ( str , self . context . agent_addresses . get ( strategy . ledger_id )), ) self . context . outbox . put_message ( message = ledger_api_msg ) self . _register_agent () def act ( self ) -> None : \"\"\"Implement the act.\"\"\" self . _retry_failed_registration () def teardown ( self ) -> None : \"\"\"Implement the task teardown.\"\"\" self . _unregister_service () self . _unregister_agent () def _retry_failed_registration ( self ) -> None : \"\"\"Retry a failed registration.\"\"\" if self . failed_registration_msg is not None : self . _nb_retries += 1 if self . _nb_retries > self . _max_soef_registration_retries : self . context . is_active = False return oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . failed_registration_msg . to , performative = self . failed_registration_msg . performative , service_description = self . failed_registration_msg . service_description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( f \"Retrying registration on SOEF. Retry { self . _nb_retries } out of { self . _max_soef_registration_retries } .\" ) self . failed_registration_msg = None def _register ( self , description : Description , logger_msg : str ) -> None : \"\"\" Register something on the SOEF. :param description: the description of what is being registered :param logger_msg: the logger message to print after the registration \"\"\" oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . REGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( logger_msg ) def _register_agent ( self ) -> None : \"\"\"Register the agent's location.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_location_description () self . _register ( description , \"registering agent on SOEF.\" ) def register_service ( self ) -> None : \"\"\"Register the agent's service.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_register_service_description () self . _register ( description , \"registering agent's service on the SOEF.\" ) def register_genus ( self ) -> None : \"\"\"Register the agent's personality genus.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_register_personality_description () self . _register ( description , \"registering agent's personality genus on the SOEF.\" ) def register_classification ( self ) -> None : \"\"\"Register the agent's personality classification.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_register_classification_description () self . _register ( description , \"registering agent's personality classification on the SOEF.\" ) def _unregister_service ( self ) -> None : \"\"\"Unregister service from the SOEF.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_unregister_service_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"unregistering service from SOEF.\" ) def _unregister_agent ( self ) -> None : \"\"\"Unregister agent from the SOEF.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_location_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"unregistering agent from SOEF.\" ) This TickerBehaviour registers (see setup method) and deregisters (see teardown method) our AEA\u2019s service on the SOEF search node at regular tick intervals (here 60 seconds). By registering, the AEA becomes discoverable to other AEAs. In setup , prior to registrations, we send a message to the ledger connection to check the account balance for the AEA's address on the configured ledger. Step 3: Create the handler So far, we have tasked the AEA with sending register/unregister requests to the SOEF search node . However at present, the AEA has no way of handling the responses it receives from the search node, or in fact messages sent by any other AEA. We have to specify the logic to negotiate with another AEA based on the strategy we want our AEA to follow. The following diagram illustrates the negotiation flow that we want this AEA to use, as well as interactions with a search node and the blockchain between a seller_AEA and a buyer_AEA . sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept loop Once with LedgerConnection Buyer_AEA->>Buyer_AEA: Get raw transaction from ledger api end loop Once with DecisionMaker Buyer_AEA->>Buyer_AEA: Get signed transaction from decision maker end loop Once with LedgerConnection Buyer_AEA->>Buyer_AEA: Send transaction and get digest from ledger api Buyer_AEA->>Blockchain: transfer_funds end Buyer_AEA->>Seller_AEA: send_transaction_digest Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain In our case, my_generic_seller is the Seller_AEA in the above figure. Let us now implement a Handler to deal with incoming messages. Open the handlers.py file ( my_generic_seller/skills/generic_seller/handlers.py ) and replace the stub code with the following: from typing import Optional , cast from aea.configurations.base import PublicId from aea.crypto.ledger_apis import LedgerApis from aea.helpers.transaction.base import TransactionDigest from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.connections.ledger.base import ( CONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID , ) from packages.fetchai.protocols.default.message import DefaultMessage from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.generic_seller.behaviours import ( GenericServiceRegistrationBehaviour , ) from packages.fetchai.skills.generic_seller.dialogues import ( DefaultDialogues , FipaDialogue , FipaDialogues , LedgerApiDialogue , LedgerApiDialogues , OefSearchDialogue , OefSearchDialogues , ) from packages.fetchai.skills.generic_seller.strategy import GenericStrategy LEDGER_API_ADDRESS = str ( LEDGER_CONNECTION_PUBLIC_ID ) class GenericFipaHandler ( Handler ): \"\"\"This class implements a FIPA handler.\"\"\" SUPPORTED_PROTOCOL = FipaMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message \"\"\" fipa_msg = cast ( FipaMessage , message ) # recover dialogue fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) fipa_dialogue = cast ( FipaDialogue , fipa_dialogues . update ( fipa_msg )) if fipa_dialogue is None : self . _handle_unidentified_dialogue ( fipa_msg ) return # handle message if fipa_msg . performative == FipaMessage . Performative . CFP : self . _handle_cfp ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . DECLINE : self . _handle_decline ( fipa_msg , fipa_dialogue , fipa_dialogues ) elif fipa_msg . performative == FipaMessage . Performative . ACCEPT : self . _handle_accept ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . INFORM : self . _handle_inform ( fipa_msg , fipa_dialogue ) else : self . _handle_invalid ( fipa_msg , fipa_dialogue ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" The code above contains the logic for handling FipaMessages received by the my_generic_seller AEA. We use FipaDialogues (more on this below ) to keep track of the progress of the negotiation dialogue between the my_generic_seller AEA and the my_generic_buyer AEA. In the above handle method, we first check if a received message belongs to an existing dialogue or if we have to create a new dialogue (the recover dialogue part). Once this is done, we break down the AEA's response to each type of negotiation message, as indicated by the message's performative (the handle message part). Therefore, we implement the AEA's response to each negotiation message type in a different handler function. Below the unused teardown function, we continue by adding the following function: def _handle_unidentified_dialogue ( self , fipa_msg : FipaMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param fipa_msg: the message \"\"\" self . context . logger . info ( \"received invalid fipa message= {} , unidentified dialogue.\" . format ( fipa_msg ) ) default_dialogues = cast ( DefaultDialogues , self . context . default_dialogues ) default_msg , _ = default_dialogues . create ( counterparty = fipa_msg . sender , performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE , error_msg = \"Invalid dialogue.\" , error_data = { \"fipa_message\" : fipa_msg . encode ()}, ) self . context . outbox . put_message ( message = default_msg ) The above code handles an unidentified dialogue by responding to the sender with a DefaultMessage containing the appropriate error information. The next code block handles CFP (call-for-proposal) negotiation messages. Paste the following code below the _handle_unidentified_dialogue function: def _handle_cfp ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the CFP. If the CFP matches the supplied services then send a PROPOSE, otherwise send a DECLINE. :param fipa_msg: the message :param fipa_dialogue: the dialogue object \"\"\" self . context . logger . info ( \"received CFP from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_matching_supply ( fipa_msg . query ): proposal , terms , data_for_sale = strategy . generate_proposal_terms_and_data ( fipa_msg . query , fipa_msg . sender ) fipa_dialogue . data_for_sale = data_for_sale fipa_dialogue . terms = terms self . context . logger . info ( \"sending a PROPOSE with proposal= {} to sender= {} \" . format ( proposal . values , fipa_msg . sender [ - 5 :] ) ) proposal_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . PROPOSE , target_message = fipa_msg , proposal = proposal , ) self . context . outbox . put_message ( message = proposal_msg ) else : self . context . logger . info ( \"declined the CFP from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) decline_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . DECLINE , target_message = fipa_msg , ) self . context . outbox . put_message ( message = decline_msg ) The above code sends a PROPOSE message back to the buyer as a response to its CFP if the requested services match our seller agent's supplied services, otherwise it will respond with a DECLINE message. The next code-block handles the decline message we receive from the buyer. Add the following code below the _handle_cfp function: def _handle_decline ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue , fipa_dialogues : FipaDialogues , ) -> None : \"\"\" Handle the DECLINE. Close the dialogue. :param fipa_msg: the message :param fipa_dialogue: the dialogue object :param fipa_dialogues: the dialogues object \"\"\" self . context . logger . info ( \"received DECLINE from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . DECLINED_PROPOSE , fipa_dialogue . is_self_initiated ) If we receive a decline message from the buyer we close the dialogue and terminate this conversation with my_generic_buyer . Alternatively, we might receive an ACCEPT message. In order to handle this option add the following code below the _handle_decline function: def _handle_accept ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the ACCEPT. Respond with a MATCH_ACCEPT_W_INFORM which contains the address to send the funds to. :param fipa_msg: the message :param fipa_dialogue: the dialogue object \"\"\" self . context . logger . info ( \"received ACCEPT from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) info = { \"address\" : fipa_dialogue . terms . sender_address } match_accept_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . MATCH_ACCEPT_W_INFORM , target_message = fipa_msg , info = info , ) self . context . logger . info ( \"sending MATCH_ACCEPT_W_INFORM to sender= {} with info= {} \" . format ( fipa_msg . sender [ - 5 :], info , ) ) self . context . outbox . put_message ( message = match_accept_msg ) When my_generic_buyer accepts the Proposal we send it and sends an ACCEPT message, we have to respond with another message ( MATCH_ACCEPT_W_INFORM ) to match the acceptance of the terms of trade and to inform the buyer of the address we would like it to send the funds to. Lastly, we must handle an INFORM message, which the buyer uses to inform us that it has indeed sent the funds to the provided address. Add the following code at the end of the file: def _handle_inform ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the INFORM. If the INFORM message contains the transaction_digest then verify that it is settled, otherwise do nothing. If the transaction is settled, send the data, otherwise do nothing. :param fipa_msg: the message :param fipa_dialogue: the dialogue object \"\"\" self . context . logger . info ( \"received INFORM from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_ledger_tx and \"transaction_digest\" in fipa_msg . info . keys (): self . context . logger . info ( \"checking whether transaction= {} has been received ...\" . format ( fipa_msg . info [ \"transaction_digest\" ] ) ) ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_msg , ledger_api_dialogue = ledger_api_dialogues . create ( counterparty = LEDGER_API_ADDRESS , performative = LedgerApiMessage . Performative . GET_TRANSACTION_RECEIPT , transaction_digest = TransactionDigest ( fipa_dialogue . terms . ledger_id , fipa_msg . info [ \"transaction_digest\" ] ), ) ledger_api_dialogue = cast ( LedgerApiDialogue , ledger_api_dialogue ) ledger_api_dialogue . associated_fipa_dialogue = fipa_dialogue self . context . outbox . put_message ( message = ledger_api_msg ) elif strategy . is_ledger_tx : self . context . logger . warning ( \"did not receive transaction digest from sender= {} .\" . format ( fipa_msg . sender [ - 5 :] ) ) elif not strategy . is_ledger_tx and \"Done\" in fipa_msg . info . keys (): inform_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . INFORM , target_message = fipa_msg , info = fipa_dialogue . data_for_sale , ) self . context . outbox . put_message ( message = inform_msg ) fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . SUCCESSFUL , fipa_dialogue . is_self_initiated ) self . context . logger . info ( \"transaction confirmed, sending data= {} to buyer= {} .\" . format ( fipa_dialogue . data_for_sale , fipa_msg . sender [ - 5 :], ) ) else : self . context . logger . warning ( \"did not receive transaction confirmation from sender= {} .\" . format ( fipa_msg . sender [ - 5 :] ) ) In the above code, we check the INFORM message. If it contains a transaction digest, then we verify that the transaction matches the proposal the buyer accepted. If the transaction is valid and we received the funds then we send the data to the buyer. Otherwise, we do not send the data. The remaining handlers are as follows: def _handle_invalid ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle a fipa message of invalid performative. :param fipa_msg: the message :param fipa_dialogue: the dialogue object \"\"\" self . context . logger . warning ( \"cannot handle fipa message of performative= {} in dialogue= {} .\" . format ( fipa_msg . performative , fipa_dialogue ) ) class GenericLedgerApiHandler ( Handler ): \"\"\"Implement the ledger handler.\"\"\" SUPPORTED_PROTOCOL = LedgerApiMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message \"\"\" ledger_api_msg = cast ( LedgerApiMessage , message ) # recover dialogue ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_dialogue = cast ( Optional [ LedgerApiDialogue ], ledger_api_dialogues . update ( ledger_api_msg ) ) if ledger_api_dialogue is None : self . _handle_unidentified_dialogue ( ledger_api_msg ) return # handle message if ledger_api_msg . performative is LedgerApiMessage . Performative . BALANCE : self . _handle_balance ( ledger_api_msg ) elif ( ledger_api_msg . performative is LedgerApiMessage . Performative . TRANSACTION_RECEIPT ): self . _handle_transaction_receipt ( ledger_api_msg , ledger_api_dialogue ) elif ledger_api_msg . performative == LedgerApiMessage . Performative . ERROR : self . _handle_error ( ledger_api_msg , ledger_api_dialogue ) else : self . _handle_invalid ( ledger_api_msg , ledger_api_dialogue ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" def _handle_unidentified_dialogue ( self , ledger_api_msg : LedgerApiMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param ledger_api_msg: the message \"\"\" self . context . logger . info ( \"received invalid ledger_api message= {} , unidentified dialogue.\" . format ( ledger_api_msg ) ) def _handle_balance ( self , ledger_api_msg : LedgerApiMessage ) -> None : \"\"\" Handle a message of balance performative. :param ledger_api_msg: the ledger api message \"\"\" self . context . logger . info ( \"starting balance on {} ledger= {} .\" . format ( ledger_api_msg . ledger_id , ledger_api_msg . balance , ) ) def _handle_transaction_receipt ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of balance performative. :param ledger_api_msg: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" fipa_dialogue = ledger_api_dialogue . associated_fipa_dialogue is_settled = LedgerApis . is_transaction_settled ( fipa_dialogue . terms . ledger_id , ledger_api_msg . transaction_receipt . receipt ) is_valid = LedgerApis . is_transaction_valid ( fipa_dialogue . terms . ledger_id , ledger_api_msg . transaction_receipt . transaction , fipa_dialogue . terms . sender_address , fipa_dialogue . terms . counterparty_address , fipa_dialogue . terms . nonce , fipa_dialogue . terms . counterparty_payable_amount , ) if is_settled and is_valid : last_message = cast ( Optional [ FipaMessage ], fipa_dialogue . last_incoming_message ) if last_message is None : raise ValueError ( \"Cannot retrieve last fipa message.\" ) inform_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . INFORM , target_message = last_message , info = fipa_dialogue . data_for_sale , ) self . context . outbox . put_message ( message = inform_msg ) fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . SUCCESSFUL , fipa_dialogue . is_self_initiated ) self . context . logger . info ( \"transaction confirmed, sending data= {} to buyer= {} .\" . format ( fipa_dialogue . data_for_sale , last_message . sender [ - 5 :], ) ) else : self . context . logger . info ( \"transaction_receipt= {} not settled or not valid, aborting\" . format ( ledger_api_msg . transaction_receipt ) ) def _handle_error ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of error performative. :param ledger_api_msg: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . info ( \"received ledger_api error message= {} in dialogue= {} .\" . format ( ledger_api_msg , ledger_api_dialogue ) ) def _handle_invalid ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of invalid performative. :param ledger_api_msg: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . warning ( \"cannot handle ledger_api message of performative= {} in dialogue= {} .\" . format ( ledger_api_msg . performative , ledger_api_dialogue , ) ) class GenericOefSearchHandler ( Handler ): \"\"\"This class implements an OEF search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Call to setup the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message \"\"\" oef_search_msg = cast ( OefSearchMessage , message ) # recover dialogue oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_dialogue = cast ( Optional [ OefSearchDialogue ], oef_search_dialogues . update ( oef_search_msg ) ) if oef_search_dialogue is None : self . _handle_unidentified_dialogue ( oef_search_msg ) return # handle message if oef_search_msg . performative == OefSearchMessage . Performative . SUCCESS : self . _handle_success ( oef_search_msg , oef_search_dialogue ) elif oef_search_msg . performative == OefSearchMessage . Performative . OEF_ERROR : self . _handle_error ( oef_search_msg , oef_search_dialogue ) else : self . _handle_invalid ( oef_search_msg , oef_search_dialogue ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" def _handle_unidentified_dialogue ( self , oef_search_msg : OefSearchMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param oef_search_msg: the message \"\"\" self . context . logger . info ( \"received invalid oef_search message= {} , unidentified dialogue.\" . format ( oef_search_msg ) ) def _handle_success ( self , oef_search_success_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue , ) -> None : \"\"\" Handle an oef search message. :param oef_search_success_msg: the oef search message :param oef_search_dialogue: the dialogue \"\"\" self . context . logger . info ( \"received oef_search success message= {} in dialogue= {} .\" . format ( oef_search_success_msg , oef_search_dialogue ) ) target_message = cast ( OefSearchMessage , oef_search_dialogue . get_message_by_id ( oef_search_success_msg . target ), ) if ( target_message . performative == OefSearchMessage . Performative . REGISTER_SERVICE ): description = target_message . service_description data_model_name = description . data_model . name registration_behaviour = cast ( GenericServiceRegistrationBehaviour , self . context . behaviours . service_registration , ) if \"location_agent\" in data_model_name : registration_behaviour . register_service () elif \"set_service_key\" in data_model_name : registration_behaviour . register_genus () elif ( \"personality_agent\" in data_model_name and description . values [ \"piece\" ] == \"genus\" ): registration_behaviour . register_classification () elif ( \"personality_agent\" in data_model_name and description . values [ \"piece\" ] == \"classification\" ): self . context . logger . info ( \"the agent, with its genus and classification, and its service are successfully registered on the SOEF.\" ) else : self . context . logger . warning ( f \"received soef SUCCESS message as a reply to the following unexpected message: { target_message } \" ) def _handle_error ( self , oef_search_error_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue , ) -> None : \"\"\" Handle an oef search message. :param oef_search_error_msg: the oef search message :param oef_search_dialogue: the dialogue \"\"\" self . context . logger . info ( \"received oef_search error message= {} in dialogue= {} .\" . format ( oef_search_error_msg , oef_search_dialogue ) ) target_message = cast ( OefSearchMessage , oef_search_dialogue . get_message_by_id ( oef_search_error_msg . target ), ) if ( target_message . performative == OefSearchMessage . Performative . REGISTER_SERVICE ): registration_behaviour = cast ( GenericServiceRegistrationBehaviour , self . context . behaviours . service_registration , ) registration_behaviour . failed_registration_msg = target_message def _handle_invalid ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue \"\"\" self . context . logger . warning ( \"cannot handle oef_search message of performative= {} in dialogue= {} .\" . format ( oef_search_msg . performative , oef_search_dialogue , ) ) The GenericLedgerApiHandler deals with LedgerApiMessages from the ledger connection and the GenericOefSearchHandler handles OefSearchMessages from the SOEF connection. Step 4: Create the strategy Next, we are going to create the strategy that we want our my_generic_seller AEA to follow. Rename the my_model.py file ( my_generic_seller/skills/generic_seller/my_model.py ) to strategy.py and replace the stub code with the following: import uuid from typing import Any , Dict , Optional , Tuple from aea.common import Address from aea.crypto.ledger_apis import LedgerApis from aea.exceptions import enforce from aea.helpers.search.generic import ( AGENT_LOCATION_MODEL , AGENT_PERSONALITY_MODEL , AGENT_REMOVE_SERVICE_MODEL , AGENT_SET_SERVICE_MODEL , SIMPLE_SERVICE_MODEL , ) from aea.helpers.search.models import Description , Location , Query from aea.helpers.transaction.base import Terms from aea.skills.base import Model DEFAULT_IS_LEDGER_TX = True DEFAULT_UNIT_PRICE = 4 DEFAULT_SERVICE_ID = \"generic_service\" DEFAULT_LOCATION = { \"longitude\" : 0.1270 , \"latitude\" : 51.5194 } DEFAULT_SERVICE_DATA = { \"key\" : \"seller_service\" , \"value\" : \"generic_service\" } DEFAULT_PERSONALITY_DATA = { \"piece\" : \"genus\" , \"value\" : \"data\" } DEFAULT_CLASSIFICATION = { \"piece\" : \"classification\" , \"value\" : \"seller\" } DEFAULT_HAS_DATA_SOURCE = False DEFAULT_DATA_FOR_SALE = { \"some_generic_data_key\" : \"some_generic_data_value\" } # type: Optional[Dict[str, Any]] class GenericStrategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize the strategy of the agent. :param kwargs: keyword arguments \"\"\" ledger_id = kwargs . pop ( \"ledger_id\" , None ) currency_id = kwargs . pop ( \"currency_id\" , None ) self . _is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) self . _unit_price = kwargs . pop ( \"unit_price\" , DEFAULT_UNIT_PRICE ) self . _service_id = kwargs . pop ( \"service_id\" , DEFAULT_SERVICE_ID ) location = kwargs . pop ( \"location\" , DEFAULT_LOCATION ) self . _agent_location = { \"location\" : Location ( latitude = location [ \"latitude\" ], longitude = location [ \"longitude\" ] ) } self . _set_personality_data = kwargs . pop ( \"personality_data\" , DEFAULT_PERSONALITY_DATA ) enforce ( len ( self . _set_personality_data ) == 2 and \"piece\" in self . _set_personality_data and \"value\" in self . _set_personality_data , \"personality_data must contain keys `key` and `value`\" , ) self . _set_classification = kwargs . pop ( \"classification\" , DEFAULT_CLASSIFICATION ) enforce ( len ( self . _set_classification ) == 2 and \"piece\" in self . _set_classification and \"value\" in self . _set_classification , \"classification must contain keys `key` and `value`\" , ) self . _set_service_data = kwargs . pop ( \"service_data\" , DEFAULT_SERVICE_DATA ) enforce ( len ( self . _set_service_data ) == 2 and \"key\" in self . _set_service_data and \"value\" in self . _set_service_data , \"service_data must contain keys `key` and `value`\" , ) self . _remove_service_data = { \"key\" : self . _set_service_data [ \"key\" ]} self . _simple_service_data = { self . _set_service_data [ \"key\" ]: self . _set_service_data [ \"value\" ] } self . _has_data_source = kwargs . pop ( \"has_data_source\" , DEFAULT_HAS_DATA_SOURCE ) data_for_sale_ordered = kwargs . pop ( \"data_for_sale\" , DEFAULT_DATA_FOR_SALE ) data_for_sale = { str ( key ): str ( value ) for key , value in data_for_sale_ordered . items () } super () . __init__ ( ** kwargs ) self . _ledger_id = ( ledger_id if ledger_id is not None else self . context . default_ledger_id ) if currency_id is None : currency_id = self . context . currency_denominations . get ( self . _ledger_id , None ) enforce ( currency_id is not None , f \"Currency denomination for ledger_id= { self . _ledger_id } not specified.\" , ) self . _currency_id = currency_id enforce ( self . context . agent_addresses . get ( self . _ledger_id , None ) is not None , \"Wallet does not contain cryptos for provided ledger id.\" , ) self . _data_for_sale = data_for_sale In the above code snippet, we initialise the strategy class by trying to read the variables specific to the strategy from a YAML configuration file. If any variable is not provided, some default values will be used. The following properties and methods deal with different aspects of the strategy. They should be relatively self-descriptive. Add them under the initialization of the strategy class: @property def data_for_sale ( self ) -> Dict [ str , str ]: \"\"\"Get the data for sale.\"\"\" if self . _has_data_source : return self . collect_from_data_source () # pragma: nocover return self . _data_for_sale @property def ledger_id ( self ) -> str : \"\"\"Get the ledger id.\"\"\" return self . _ledger_id @property def is_ledger_tx ( self ) -> bool : \"\"\"Check whether or not tx are settled on a ledger.\"\"\" return self . _is_ledger_tx def get_location_description ( self ) -> Description : \"\"\" Get the location description. :return: a description of the agent's location \"\"\" description = Description ( self . _agent_location , data_model = AGENT_LOCATION_MODEL , ) return description def get_register_service_description ( self ) -> Description : \"\"\" Get the register service description. :return: a description of the offered services \"\"\" description = Description ( self . _set_service_data , data_model = AGENT_SET_SERVICE_MODEL , ) return description def get_register_personality_description ( self ) -> Description : \"\"\" Get the register personality description. :return: a description of the personality \"\"\" description = Description ( self . _set_personality_data , data_model = AGENT_PERSONALITY_MODEL , ) return description def get_register_classification_description ( self ) -> Description : \"\"\" Get the register classification description. :return: a description of the classification \"\"\" description = Description ( self . _set_classification , data_model = AGENT_PERSONALITY_MODEL , ) return description def get_service_description ( self ) -> Description : \"\"\" Get the simple service description. :return: a description of the offered services \"\"\" description = Description ( self . _simple_service_data , data_model = SIMPLE_SERVICE_MODEL , ) return description def get_unregister_service_description ( self ) -> Description : \"\"\" Get the unregister service description. :return: a description of the to be removed service \"\"\" description = Description ( self . _remove_service_data , data_model = AGENT_REMOVE_SERVICE_MODEL , ) return description def is_matching_supply ( self , query : Query ) -> bool : \"\"\" Check if the query matches the supply. :param query: the query :return: bool indicating whether matches or not \"\"\" return query . check ( self . get_service_description ()) def generate_proposal_terms_and_data ( # pylint: disable=unused-argument self , query : Query , counterparty_address : Address ) -> Tuple [ Description , Terms , Dict [ str , str ]]: \"\"\" Generate a proposal matching the query. :param query: the query :param counterparty_address: the counterparty of the proposal. :return: a tuple of proposal, terms and the weather data \"\"\" data_for_sale = self . data_for_sale sale_quantity = len ( data_for_sale ) seller_address = self . context . agent_addresses [ self . ledger_id ] total_price = sale_quantity * self . _unit_price if self . is_ledger_tx : tx_nonce = LedgerApis . generate_tx_nonce ( identifier = self . ledger_id , seller = seller_address , client = counterparty_address , ) else : tx_nonce = uuid . uuid4 () . hex # pragma: nocover proposal = Description ( { \"ledger_id\" : self . ledger_id , \"price\" : total_price , \"currency_id\" : self . _currency_id , \"service_id\" : self . _service_id , \"quantity\" : sale_quantity , \"tx_nonce\" : tx_nonce , } ) terms = Terms ( ledger_id = self . ledger_id , sender_address = seller_address , counterparty_address = counterparty_address , amount_by_currency_id = { self . _currency_id : total_price }, quantities_by_good_id = { self . _service_id : - sale_quantity }, is_sender_payable_tx_fee = False , nonce = tx_nonce , fee_by_currency_id = { self . _currency_id : 0 }, ) return proposal , terms , data_for_sale def collect_from_data_source ( self ) -> Dict [ str , str ]: \"\"\"Implement the logic to communicate with the sensor.\"\"\" raise NotImplementedError The helper private function collect_from_data_source is where we read data from a sensor or if there are no sensor we use some default data provided (see the data_for_sale property). Step 5: Create the dialogues To keep track of the structure and progress of interactions, including negotiations with a buyer AEA and interactions with search nodes and ledgers, we use dialogues. Create a new file in the skill folder ( my_generic_seller/skills/generic_seller/ ) and name it dialogues.py . Inside this file add the following code: from typing import Any , Dict , Optional , Type from aea.common import Address from aea.exceptions import AEAEnforceError , enforce from aea.helpers.transaction.base import Terms from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.protocols.dialogue.base import DialogueLabel as BaseDialogueLabel from aea.skills.base import Model from packages.fetchai.protocols.default.dialogues import ( DefaultDialogue as BaseDefaultDialogue , ) from packages.fetchai.protocols.default.dialogues import ( DefaultDialogues as BaseDefaultDialogues , ) from packages.fetchai.protocols.fipa.dialogues import FipaDialogue as BaseFipaDialogue from packages.fetchai.protocols.fipa.dialogues import FipaDialogues as BaseFipaDialogues from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.ledger_api.dialogues import ( LedgerApiDialogue as BaseLedgerApiDialogue , ) from packages.fetchai.protocols.ledger_api.dialogues import ( LedgerApiDialogues as BaseLedgerApiDialogues , ) from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogue as BaseOefSearchDialogue , ) from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogues as BaseOefSearchDialogues , ) DefaultDialogue = BaseDefaultDialogue class DefaultDialogues ( Model , BaseDefaultDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return DefaultDialogue . Role . AGENT BaseDefaultDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) class FipaDialogue ( BaseFipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" __slots__ = ( \"data_for_sale\" , \"_terms\" ) def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ FipaMessage ] = FipaMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :param message_class: the message class \"\"\" BaseFipaDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . data_for_sale = None # type: Optional[Dict[str, str]] self . _terms = None # type: Optional[Terms] @property def terms ( self ) -> Terms : \"\"\"Get terms.\"\"\" if self . _terms is None : raise AEAEnforceError ( \"Terms not set!\" ) return self . _terms @terms . setter def terms ( self , terms : Terms ) -> None : \"\"\"Set terms.\"\"\" enforce ( self . _terms is None , \"Terms already set!\" ) self . _terms = terms class FipaDialogues ( Model , BaseFipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return FipaDialogue . Role . SELLER BaseFipaDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , dialogue_class = FipaDialogue , ) class LedgerApiDialogue ( BaseLedgerApiDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" __slots__ = ( \"_associated_fipa_dialogue\" ,) def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ LedgerApiMessage ] = LedgerApiMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :param message_class: the message class \"\"\" BaseLedgerApiDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . _associated_fipa_dialogue = None # type: Optional[FipaDialogue] @property def associated_fipa_dialogue ( self ) -> FipaDialogue : \"\"\"Get associated_fipa_dialogue.\"\"\" if self . _associated_fipa_dialogue is None : raise AEAEnforceError ( \"FipaDialogue not set!\" ) return self . _associated_fipa_dialogue @associated_fipa_dialogue . setter def associated_fipa_dialogue ( self , fipa_dialogue : FipaDialogue ) -> None : \"\"\"Set associated_fipa_dialogue\"\"\" enforce ( self . _associated_fipa_dialogue is None , \"FipaDialogue already set!\" ) self . _associated_fipa_dialogue = fipa_dialogue class LedgerApiDialogues ( Model , BaseLedgerApiDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseLedgerApiDialogue . Role . AGENT BaseLedgerApiDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , dialogue_class = LedgerApiDialogue , ) OefSearchDialogue = BaseOefSearchDialogue class OefSearchDialogues ( Model , BaseOefSearchDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseOefSearchDialogue . Role . AGENT BaseOefSearchDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , ) The FipaDialogues class contains negotiation dialogues with each my_generic_buyer AEA (and other AEAs) and exposes a number of helpful methods to manage them. This helps us match messages to the dialogues they belong to, access previous messages and enable us to identify possible communications problems between the my_generic_seller AEA and the my_generic_buyer AEA. It also keeps track of the data that we offer for sale during the proposal phase. The FipaDialogues class extends BaseFipaDialogues , which itself derives from the base Dialogues class. Similarly, the FipaDialogue class extends BaseFipaDialogue which itself derives from the base Dialogue class. To learn more about dialogues have a look here . Step 6: Update the YAML files Since we made so many changes to our AEA we have to update the skill.yaml (at my_generic_seller/skills/generic_seller/skill.yaml ). Make sure you update your skill.yaml with the following configuration: name : generic_seller author : fetchai version : 0.1.0 type : skill description : The weather station skill implements the functionality to sell weather data. license : Apache-2.0 aea_version : '>=1.0.0, <2.0.0' fingerprint : README.md : QmPb5kHYZyhUN87EKmuahyGqDGgqVdGPyfC1KpGC3xfmcP __init__.py : QmTSEedzQySy2nzRCY3F66CBSX52f8s3pWHZTejX4hKC9h behaviours.py : QmS9sPCv2yBnhWsmHeaCptpApMtYZipbR39TXixeGK64Ks dialogues.py : QmdTW8q1xQ7ajFVsWmuV62ypoT5J2b6Hkyz52LFaWuMEtd handlers.py : QmQnQhSaHPUYaJut8bMe2LHEqiZqokMSVfCthVaqrvPbdi strategy.py : QmYTUsfv64eRQDevCfMUDQPx2GCtiMLFdacN4sS1E4Fdfx fingerprint_ignore_patterns : [] connections : - fetchai/ledger:0.19.0 contracts : [] protocols : - fetchai/default:1.0.0 - fetchai/fipa:1.0.0 - fetchai/ledger_api:1.0.0 - fetchai/oef_search:1.0.0 skills : [] behaviours : service_registration : args : services_interval : 20 class_name : GenericServiceRegistrationBehaviour handlers : fipa : args : {} class_name : GenericFipaHandler ledger_api : args : {} class_name : GenericLedgerApiHandler oef_search : args : {} class_name : GenericOefSearchHandler models : default_dialogues : args : {} class_name : DefaultDialogues fipa_dialogues : args : {} class_name : FipaDialogues ledger_api_dialogues : args : {} class_name : LedgerApiDialogues oef_search_dialogues : args : {} class_name : OefSearchDialogues strategy : args : data_for_sale : generic : data has_data_source : false is_ledger_tx : true location : latitude : 51.5194 longitude : 0.127 service_data : key : seller_service value : generic_service service_id : generic_service unit_price : 10 class_name : GenericStrategy is_abstract : false dependencies : {} We must pay attention to the models and in particular the strategy\u2019s variables. Here we can change the price we would like to sell each data reading for, or the currency we would like to transact with. Lastly, the dependencies are the third party packages we need to install in order to get readings from the sensor. Finally, we fingerprint our new skill: aea fingerprint skill fetchai/generic_seller:0.1.0 This will hash each file and save the hash in the fingerprint. This way, in the future we can easily track if any of the files have changed. Generic Buyer AEA Step 1: Create the AEA In a new terminal, create a new AEA by typing the following command in the terminal: aea create my_generic_buyer cd my_generic_buyer aea install Our newly created AEA is inside the current working directory. Let\u2019s create a new skill for purchasing data. Type the following command: aea scaffold skill generic_buyer This command creates the correct structure for a new skill inside our AEA project. You can locate the newly created skill under the skills folder ( my_generic_buyer/skills/generic_buyer/ ) and it must contain the following files: __init__.py behaviours.py handlers.py my_model.py skills.yaml Step 2: Create the behaviour Open the behaviours.py file ( my_generic_buyer/skills/generic_buyer/behaviours.py ) and replace the stub code with the following: from typing import Any , List , Optional , Set , cast from aea.protocols.dialogue.base import DialogueLabel from aea.skills.behaviours import TickerBehaviour from packages.fetchai.connections.ledger.base import ( CONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID , ) from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.generic_buyer.dialogues import ( FipaDialogue , LedgerApiDialogue , LedgerApiDialogues , OefSearchDialogues , ) from packages.fetchai.skills.generic_buyer.strategy import GenericStrategy DEFAULT_MAX_PROCESSING = 120 DEFAULT_TX_INTERVAL = 2.0 DEFAULT_SEARCH_INTERVAL = 5.0 LEDGER_API_ADDRESS = str ( LEDGER_CONNECTION_PUBLIC_ID ) class GenericSearchBehaviour ( TickerBehaviour ): \"\"\"This class implements a search behaviour.\"\"\" def __init__ ( self , ** kwargs : Any ): \"\"\"Initialize the search behaviour.\"\"\" search_interval = cast ( float , kwargs . pop ( \"search_interval\" , DEFAULT_SEARCH_INTERVAL ) ) super () . __init__ ( tick_interval = search_interval , ** kwargs ) def setup ( self ) -> None : \"\"\"Implement the setup for the behaviour.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_ledger_tx : ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_msg , _ = ledger_api_dialogues . create ( counterparty = LEDGER_API_ADDRESS , performative = LedgerApiMessage . Performative . GET_BALANCE , ledger_id = strategy . ledger_id , address = cast ( str , self . context . agent_addresses . get ( strategy . ledger_id )), ) self . context . outbox . put_message ( message = ledger_api_msg ) else : strategy . is_searching = True def act ( self ) -> None : \"\"\"Implement the act.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) if not strategy . is_searching : return transaction_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) remaining_transactions_count = len ( transaction_behaviour . waiting ) if remaining_transactions_count > 0 : self . context . logger . info ( f \"Transaction behaviour has { remaining_transactions_count } transactions remaining. Skipping search!\" ) return strategy . update_search_query_params () query = strategy . get_location_and_service_query () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . SEARCH_SERVICES , query = query , ) self . context . outbox . put_message ( message = oef_search_msg ) def teardown ( self ) -> None : \"\"\"Implement the task teardown.\"\"\" class GenericTransactionBehaviour ( TickerBehaviour ): \"\"\"A behaviour to sequentially submit transactions to the blockchain.\"\"\" def __init__ ( self , ** kwargs : Any ): \"\"\"Initialize the transaction behaviour.\"\"\" tx_interval = cast ( float , kwargs . pop ( \"transaction_interval\" , DEFAULT_TX_INTERVAL ) ) self . max_processing = cast ( float , kwargs . pop ( \"max_processing\" , DEFAULT_MAX_PROCESSING ) ) self . processing_time = 0.0 self . waiting : List [ FipaDialogue ] = [] self . processing : Optional [ LedgerApiDialogue ] = None self . timedout : Set [ DialogueLabel ] = set () super () . __init__ ( tick_interval = tx_interval , ** kwargs ) def setup ( self ) -> None : \"\"\"Setup behaviour.\"\"\" def act ( self ) -> None : \"\"\"Implement the act.\"\"\" if self . processing is not None : if self . processing_time <= self . max_processing : # already processing self . processing_time += self . tick_interval return self . _timeout_processing () if len ( self . waiting ) == 0 : # nothing to process return self . _start_processing () def _start_processing ( self ) -> None : \"\"\"Process the next transaction.\"\"\" fipa_dialogue = self . waiting . pop ( 0 ) self . context . logger . info ( f \"Processing transaction, { len ( self . waiting ) } transactions remaining\" ) ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_msg , ledger_api_dialogue = ledger_api_dialogues . create ( counterparty = LEDGER_API_ADDRESS , performative = LedgerApiMessage . Performative . GET_RAW_TRANSACTION , terms = fipa_dialogue . terms , ) ledger_api_dialogue = cast ( LedgerApiDialogue , ledger_api_dialogue ) ledger_api_dialogue . associated_fipa_dialogue = fipa_dialogue self . processing_time = 0.0 self . processing = ledger_api_dialogue self . context . logger . info ( f \"requesting transfer transaction from ledger api for message= { ledger_api_msg } ...\" ) self . context . outbox . put_message ( message = ledger_api_msg ) def teardown ( self ) -> None : \"\"\"Teardown behaviour.\"\"\" def _timeout_processing ( self ) -> None : \"\"\"Timeout processing.\"\"\" if self . processing is None : return self . timedout . add ( self . processing . dialogue_label ) self . waiting . append ( self . processing . associated_fipa_dialogue ) self . processing_time = 0.0 self . processing = None def finish_processing ( self , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Finish processing. :param ledger_api_dialogue: the ledger api dialogue \"\"\" if self . processing == ledger_api_dialogue : self . processing_time = 0.0 self . processing = None return if ledger_api_dialogue . dialogue_label not in self . timedout : raise ValueError ( f \"Non-matching dialogues in transaction behaviour: { self . processing } and { ledger_api_dialogue } \" ) self . timedout . remove ( ledger_api_dialogue . dialogue_label ) self . context . logger . debug ( f \"Timeout dialogue in transaction processing: { ledger_api_dialogue } \" ) # don't reset, as another might be processing def failed_processing ( self , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Failed processing. Currently, we retry processing indefinitely. :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . finish_processing ( ledger_api_dialogue ) self . waiting . append ( ledger_api_dialogue . associated_fipa_dialogue ) This TickerBehaviour will send a search query to the SOEF search node at regular tick intervals. Step 3: Create the handler So far, the AEA is tasked with sending search queries to the SOEF search node . However, currently the AEA has no way of handling the responses it receives from the SOEF or messages from other agents. Let us now implement Handlers to deal with the expected incoming messages. Open the handlers.py file ( my_generic_buyer/skills/generic_buyer/handlers.py ) and add the following code (replacing the stub code already present in the file): import pprint from typing import Optional , cast from aea.configurations.base import PublicId from aea.crypto.ledger_apis import LedgerApis from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.connections.ledger.base import ( CONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID , ) from packages.fetchai.protocols.default.message import DefaultMessage from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.signing.message import SigningMessage from packages.fetchai.skills.generic_buyer.behaviours import GenericTransactionBehaviour from packages.fetchai.skills.generic_buyer.dialogues import ( DefaultDialogues , FipaDialogue , FipaDialogues , LedgerApiDialogue , LedgerApiDialogues , OefSearchDialogue , OefSearchDialogues , SigningDialogue , SigningDialogues , ) from packages.fetchai.skills.generic_buyer.strategy import GenericStrategy LEDGER_API_ADDRESS = str ( LEDGER_CONNECTION_PUBLIC_ID ) class GenericFipaHandler ( Handler ): \"\"\"This class implements a FIPA handler.\"\"\" SUPPORTED_PROTOCOL = FipaMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message \"\"\" fipa_msg = cast ( FipaMessage , message ) # recover dialogue fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) fipa_dialogue = cast ( FipaDialogue , fipa_dialogues . update ( fipa_msg )) if fipa_dialogue is None : self . _handle_unidentified_dialogue ( fipa_msg ) return # handle message if fipa_msg . performative == FipaMessage . Performative . PROPOSE : self . _handle_propose ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . DECLINE : self . _handle_decline ( fipa_msg , fipa_dialogue , fipa_dialogues ) elif fipa_msg . performative == FipaMessage . Performative . MATCH_ACCEPT_W_INFORM : self . _handle_match_accept ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . INFORM : self . _handle_inform ( fipa_msg , fipa_dialogue , fipa_dialogues ) else : self . _handle_invalid ( fipa_msg , fipa_dialogue ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" You will see that we are following similar logic to the generic_seller when we develop the generic_buyer \u2019s side of the negotiation. First, we create a new dialogue and store it in the dialogues class. Then we are checking what kind of message we received by checking its performative. So lets start creating our handlers: def _handle_unidentified_dialogue ( self , fipa_msg : FipaMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param fipa_msg: the message \"\"\" self . context . logger . info ( \"received invalid fipa message= {} , unidentified dialogue.\" . format ( fipa_msg ) ) default_dialogues = cast ( DefaultDialogues , self . context . default_dialogues ) default_msg , _ = default_dialogues . create ( counterparty = fipa_msg . sender , performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE , error_msg = \"Invalid dialogue.\" , error_data = { \"fipa_message\" : fipa_msg . encode ()}, ) self . context . outbox . put_message ( message = default_msg ) The above code handles messages referencing unidentified dialogues and responds with an error message to the sender. Next we will handle the PROPOSE message received from the my_generic_seller AEA: def _handle_propose ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the propose. :param fipa_msg: the message :param fipa_dialogue: the dialogue object \"\"\" self . context . logger . info ( \"received proposal= {} from sender= {} \" . format ( fipa_msg . proposal . values , fipa_msg . sender [ - 5 :], ) ) strategy = cast ( GenericStrategy , self . context . strategy ) acceptable = strategy . is_acceptable_proposal ( fipa_msg . proposal ) affordable = strategy . is_affordable_proposal ( fipa_msg . proposal ) if acceptable and affordable : self . context . logger . info ( \"accepting the proposal from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) terms = strategy . terms_from_proposal ( fipa_msg . proposal , fipa_msg . sender ) fipa_dialogue . terms = terms accept_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . ACCEPT , target_message = fipa_msg , ) self . context . outbox . put_message ( message = accept_msg ) else : self . context . logger . info ( \"declining the proposal from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) decline_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . DECLINE , target_message = fipa_msg , ) self . context . outbox . put_message ( message = decline_msg ) When we receive a proposal, we have to check if we have the funds to complete the transaction and if the proposal is acceptable based on our strategy. If the proposal is not affordable or acceptable, we respond with a DECLINE message. Otherwise, we send an ACCEPT message to the seller. The next code-block handles the DECLINE message that we may receive from the seller as a response to our CFP or ACCEPT messages: def _handle_decline ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue , fipa_dialogues : FipaDialogues , ) -> None : \"\"\" Handle the decline. :param fipa_msg: the message :param fipa_dialogue: the fipa dialogue :param fipa_dialogues: the fipa dialogues \"\"\" self . context . logger . info ( \"received DECLINE from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) target_message = fipa_dialogue . get_message_by_id ( fipa_msg . target ) if not target_message : raise ValueError ( \"Can not find target message!\" ) # pragma: nocover declined_performative = target_message . performative if declined_performative == FipaMessage . Performative . CFP : fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . DECLINED_CFP , fipa_dialogue . is_self_initiated ) if declined_performative == FipaMessage . Performative . ACCEPT : fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . DECLINED_ACCEPT , fipa_dialogue . is_self_initiated ) The above code terminates each dialogue with the specific AEA and stores the state of the terminated dialogue (whether it was terminated after a CFP or an ACCEPT ). If my_generic_seller AEA wants to move on with the sale, it will send a MATCH_ACCEPT message. In order to handle this we add the following code: def _handle_match_accept ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the match accept. :param fipa_msg: the message :param fipa_dialogue: the dialogue object \"\"\" self . context . logger . info ( \"received MATCH_ACCEPT_W_INFORM from sender= {} with info= {} \" . format ( fipa_msg . sender [ - 5 :], fipa_msg . info ) ) strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_ledger_tx : transfer_address = fipa_msg . info . get ( \"address\" , None ) if transfer_address is not None and isinstance ( transfer_address , str ): fipa_dialogue . terms . counterparty_address = ( # pragma: nocover transfer_address ) tx_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) tx_behaviour . waiting . append ( fipa_dialogue ) else : inform_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . INFORM , target_message = fipa_msg , info = { \"Done\" : \"Sending payment via bank transfer\" }, ) self . context . outbox . put_message ( message = inform_msg ) self . context . logger . info ( \"informing counterparty= {} of payment.\" . format ( fipa_msg . sender [ - 5 :]) ) The first thing we are checking is if we enabled our AEA to transact with a ledger. If so, we add this negotiation to the queue of transactions to be processed. If not, we simulate non-ledger payment by sending an inform to the seller that the payment is done (say via bank transfer). Lastly, we need to handle INFORM messages. This is the message that will have our data: def _handle_inform ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue , fipa_dialogues : FipaDialogues , ) -> None : \"\"\" Handle the match inform. :param fipa_msg: the message :param fipa_dialogue: the fipa dialogue :param fipa_dialogues: the fipa dialogues \"\"\" self . context . logger . info ( \"received INFORM from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) if len ( fipa_msg . info . keys ()) >= 1 : data = fipa_msg . info data_string = pprint . pformat ( data )[: 1000 ] self . context . logger . info ( f \"received the following data= { data_string } \" ) fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . SUCCESSFUL , fipa_dialogue . is_self_initiated ) strategy = cast ( GenericStrategy , self . context . strategy ) strategy . successful_trade_with_counterparty ( fipa_msg . sender , data ) else : self . context . logger . info ( \"received no data from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) def _handle_invalid ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle a fipa message of invalid performative. :param fipa_msg: the message :param fipa_dialogue: the fipa dialogue \"\"\" self . context . logger . warning ( \"cannot handle fipa message of performative= {} in dialogue= {} .\" . format ( fipa_msg . performative , fipa_dialogue ) ) We now need to add handlers for messages received from the DecisionMaker and the SOEF search node . We need one handler for each type of protocol we use. To handle the messages in the oef_search protocol used by the SOEF search node we add the following code in the same file ( my_generic_buyer/skills/generic_buyer/handlers.py ): class GenericOefSearchHandler ( Handler ): \"\"\"This class implements an OEF search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Call to setup the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message \"\"\" oef_search_msg = cast ( OefSearchMessage , message ) # recover dialogue oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_dialogue = cast ( Optional [ OefSearchDialogue ], oef_search_dialogues . update ( oef_search_msg ) ) if oef_search_dialogue is None : self . _handle_unidentified_dialogue ( oef_search_msg ) return # handle message if oef_search_msg . performative is OefSearchMessage . Performative . OEF_ERROR : self . _handle_error ( oef_search_msg , oef_search_dialogue ) elif oef_search_msg . performative is OefSearchMessage . Performative . SEARCH_RESULT : self . _handle_search ( oef_search_msg , oef_search_dialogue ) else : self . _handle_invalid ( oef_search_msg , oef_search_dialogue ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" def _handle_unidentified_dialogue ( self , oef_search_msg : OefSearchMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param oef_search_msg: the message \"\"\" self . context . logger . info ( \"received invalid oef_search message= {} , unidentified dialogue.\" . format ( oef_search_msg ) ) def _handle_error ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue \"\"\" self . context . logger . info ( \"received oef_search error message= {} in dialogue= {} .\" . format ( oef_search_msg , oef_search_dialogue ) ) def _handle_search ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle the search response. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue \"\"\" if len ( oef_search_msg . agents ) == 0 : self . context . logger . info ( f \"found no agents in dialogue= { oef_search_dialogue } , continue searching.\" ) return strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_stop_searching_on_result : self . context . logger . info ( \"found agents= {} , stopping search.\" . format ( list ( map ( lambda x : x [ - 5 :], oef_search_msg . agents )), ) ) strategy . is_searching = False # stopping search else : self . context . logger . info ( \"found agents= {} .\" . format ( list ( map ( lambda x : x [ - 5 :], oef_search_msg . agents )), ) ) query = strategy . get_service_query () fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) counterparties = strategy . get_acceptable_counterparties ( oef_search_msg . agents ) for counterparty in counterparties : cfp_msg , _ = fipa_dialogues . create ( counterparty = counterparty , performative = FipaMessage . Performative . CFP , query = query , ) self . context . outbox . put_message ( message = cfp_msg ) self . context . logger . info ( \"sending CFP to agent= {} \" . format ( counterparty [ - 5 :]) ) def _handle_invalid ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue \"\"\" self . context . logger . warning ( \"cannot handle oef_search message of performative= {} in dialogue= {} .\" . format ( oef_search_msg . performative , oef_search_dialogue , ) ) When we receive a message from the SOEF search node of a type OefSearchMessage.Performative.SEARCH_RESULT , we are passing the details to the relevant handler method. In the _handle_search function we are checking that the response contains some agents and we stop the search if it does. We pick our first agent and we send a CFP message. The last handlers we need are the GenericSigningHandler and the GenericLedgerApiHandler . These handlers are responsible for SigningMessages that we receive from the DecisionMaker , and LedgerApiMessages that we receive from the ledger connection, respectively. class GenericSigningHandler ( Handler ): \"\"\"Implement the signing handler.\"\"\" SUPPORTED_PROTOCOL = SigningMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message \"\"\" signing_msg = cast ( SigningMessage , message ) # recover dialogue signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . update ( signing_msg ) ) if signing_dialogue is None : self . _handle_unidentified_dialogue ( signing_msg ) return # handle message if signing_msg . performative is SigningMessage . Performative . SIGNED_TRANSACTION : self . _handle_signed_transaction ( signing_msg , signing_dialogue ) elif signing_msg . performative is SigningMessage . Performative . ERROR : self . _handle_error ( signing_msg , signing_dialogue ) else : self . _handle_invalid ( signing_msg , signing_dialogue ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" def _handle_unidentified_dialogue ( self , signing_msg : SigningMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param signing_msg: the message \"\"\" self . context . logger . info ( \"received invalid signing message= {} , unidentified dialogue.\" . format ( signing_msg ) ) def _handle_signed_transaction ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue \"\"\" self . context . logger . info ( \"transaction signing was successful.\" ) ledger_api_dialogue = signing_dialogue . associated_ledger_api_dialogue last_ledger_api_msg = ledger_api_dialogue . last_incoming_message if last_ledger_api_msg is None : raise ValueError ( \"Could not retrieve last message in ledger api dialogue\" ) ledger_api_msg = ledger_api_dialogue . reply ( performative = LedgerApiMessage . Performative . SEND_SIGNED_TRANSACTION , target_message = last_ledger_api_msg , signed_transaction = signing_msg . signed_transaction , ) self . context . outbox . put_message ( message = ledger_api_msg ) self . context . logger . info ( \"sending transaction to ledger.\" ) def _handle_error ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue \"\"\" self . context . logger . info ( \"transaction signing was not successful. Error_code= {} in dialogue= {} \" . format ( signing_msg . error_code , signing_dialogue ) ) signing_msg_ = cast ( Optional [ SigningMessage ], signing_dialogue . last_outgoing_message ) if ( signing_msg_ is not None and signing_msg_ . performative == SigningMessage . Performative . SIGN_TRANSACTION ): tx_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) ledger_api_dialogue = signing_dialogue . associated_ledger_api_dialogue tx_behaviour . failed_processing ( ledger_api_dialogue ) def _handle_invalid ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue \"\"\" self . context . logger . warning ( \"cannot handle signing message of performative= {} in dialogue= {} .\" . format ( signing_msg . performative , signing_dialogue ) ) class GenericLedgerApiHandler ( Handler ): \"\"\"Implement the ledger handler.\"\"\" SUPPORTED_PROTOCOL = LedgerApiMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message \"\"\" ledger_api_msg = cast ( LedgerApiMessage , message ) # recover dialogue ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_dialogue = cast ( Optional [ LedgerApiDialogue ], ledger_api_dialogues . update ( ledger_api_msg ) ) if ledger_api_dialogue is None : self . _handle_unidentified_dialogue ( ledger_api_msg ) return # handle message if ledger_api_msg . performative is LedgerApiMessage . Performative . BALANCE : self . _handle_balance ( ledger_api_msg ) elif ( ledger_api_msg . performative is LedgerApiMessage . Performative . RAW_TRANSACTION ): self . _handle_raw_transaction ( ledger_api_msg , ledger_api_dialogue ) elif ( ledger_api_msg . performative == LedgerApiMessage . Performative . TRANSACTION_DIGEST ): self . _handle_transaction_digest ( ledger_api_msg , ledger_api_dialogue ) elif ( ledger_api_msg . performative == LedgerApiMessage . Performative . TRANSACTION_RECEIPT ): self . _handle_transaction_receipt ( ledger_api_msg , ledger_api_dialogue ) elif ledger_api_msg . performative == LedgerApiMessage . Performative . ERROR : self . _handle_error ( ledger_api_msg , ledger_api_dialogue ) else : self . _handle_invalid ( ledger_api_msg , ledger_api_dialogue ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" def _handle_unidentified_dialogue ( self , ledger_api_msg : LedgerApiMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param ledger_api_msg: the message \"\"\" self . context . logger . info ( \"received invalid ledger_api message= {} , unidentified dialogue.\" . format ( ledger_api_msg ) ) def _handle_balance ( self , ledger_api_msg : LedgerApiMessage ) -> None : \"\"\" Handle a message of balance performative. :param ledger_api_msg: the ledger api message \"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) if ledger_api_msg . balance > 0 : self . context . logger . info ( \"starting balance on {} ledger= {} .\" . format ( strategy . ledger_id , ledger_api_msg . balance , ) ) strategy . balance = ledger_api_msg . balance strategy . is_searching = True else : self . context . logger . warning ( f \"you have no starting balance on { strategy . ledger_id } ledger! Stopping skill { self . skill_id } .\" ) self . context . is_active = False def _handle_raw_transaction ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of raw_transaction performative. :param ledger_api_msg: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . info ( \"received raw transaction= {} \" . format ( ledger_api_msg )) signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_msg , signing_dialogue = signing_dialogues . create ( counterparty = self . context . decision_maker_address , performative = SigningMessage . Performative . SIGN_TRANSACTION , raw_transaction = ledger_api_msg . raw_transaction , terms = ledger_api_dialogue . associated_fipa_dialogue . terms , ) signing_dialogue = cast ( SigningDialogue , signing_dialogue ) signing_dialogue . associated_ledger_api_dialogue = ledger_api_dialogue self . context . decision_maker_message_queue . put_nowait ( signing_msg ) self . context . logger . info ( \"proposing the transaction to the decision maker. Waiting for confirmation ...\" ) def _handle_transaction_digest ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of transaction_digest performative. :param ledger_api_msg: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . info ( \"transaction was successfully submitted. Transaction digest= {} \" . format ( ledger_api_msg . transaction_digest ) ) ledger_api_msg_ = ledger_api_dialogue . reply ( performative = LedgerApiMessage . Performative . GET_TRANSACTION_RECEIPT , target_message = ledger_api_msg , transaction_digest = ledger_api_msg . transaction_digest , ) self . context . logger . info ( \"checking transaction is settled.\" ) self . context . outbox . put_message ( message = ledger_api_msg_ ) def _handle_transaction_receipt ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of balance performative. :param ledger_api_msg: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" fipa_dialogue = ledger_api_dialogue . associated_fipa_dialogue is_settled = LedgerApis . is_transaction_settled ( fipa_dialogue . terms . ledger_id , ledger_api_msg . transaction_receipt . receipt ) tx_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) if is_settled : tx_behaviour . finish_processing ( ledger_api_dialogue ) ledger_api_msg_ = cast ( Optional [ LedgerApiMessage ], ledger_api_dialogue . last_outgoing_message ) if ledger_api_msg_ is None : raise ValueError ( # pragma: nocover \"Could not retrieve last ledger_api message\" ) fipa_msg = cast ( Optional [ FipaMessage ], fipa_dialogue . last_incoming_message ) if fipa_msg is None : raise ValueError ( \"Could not retrieve last fipa message\" ) inform_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . INFORM , target_message = fipa_msg , info = { \"transaction_digest\" : ledger_api_msg_ . transaction_digest . body }, ) self . context . outbox . put_message ( message = inform_msg ) self . context . logger . info ( \"transaction confirmed, informing counterparty= {} of transaction digest.\" . format ( fipa_dialogue . dialogue_label . dialogue_opponent_addr [ - 5 :], ) ) else : tx_behaviour . failed_processing ( ledger_api_dialogue ) self . context . logger . info ( \"transaction_receipt= {} not settled or not valid, aborting\" . format ( ledger_api_msg . transaction_receipt ) ) def _handle_error ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of error performative. :param ledger_api_msg: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . info ( \"received ledger_api error message= {} in dialogue= {} .\" . format ( ledger_api_msg , ledger_api_dialogue ) ) ledger_api_msg_ = cast ( Optional [ LedgerApiMessage ], ledger_api_dialogue . last_outgoing_message ) if ( ledger_api_msg_ is not None and ledger_api_msg_ . performative != LedgerApiMessage . Performative . GET_BALANCE ): tx_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) tx_behaviour . failed_processing ( ledger_api_dialogue ) def _handle_invalid ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of invalid performative. :param ledger_api_msg: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . warning ( \"cannot handle ledger_api message of performative= {} in dialogue= {} .\" . format ( ledger_api_msg . performative , ledger_api_dialogue , ) ) Step 4: Create the strategy We are going to create the strategy that we want our AEA to follow. Rename the my_model.py file (in my_generic_buyer/skills/generic_buyer/ ) to strategy.py and replace the stub code with the following: from typing import Any , Dict , List , Tuple from aea.common import Address from aea.exceptions import enforce from aea.helpers.search.generic import SIMPLE_SERVICE_MODEL from aea.helpers.search.models import ( Constraint , ConstraintType , Description , Location , Query , ) from aea.helpers.transaction.base import Terms from aea.skills.base import Model DEFAULT_IS_LEDGER_TX = True DEFAULT_MAX_UNIT_PRICE = 5 DEFAULT_MAX_TX_FEE = 2 DEFAULT_SERVICE_ID = \"generic_service\" DEFAULT_MIN_QUANTITY = 1 DEFAULT_MAX_QUANTITY = 100 DEFAULT_LOCATION = { \"longitude\" : 0.1270 , \"latitude\" : 51.5194 } DEFAULT_SEARCH_QUERY = { \"search_key\" : \"seller_service\" , \"search_value\" : \"generic_service\" , \"constraint_type\" : \"==\" , } DEFAULT_SEARCH_RADIUS = 5.0 DEFAULT_MAX_NEGOTIATIONS = 2 class GenericStrategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize the strategy of the agent. :param kwargs: keyword arguments \"\"\" ledger_id = kwargs . pop ( \"ledger_id\" , None ) currency_id = kwargs . pop ( \"currency_id\" , None ) self . _is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) self . _max_unit_price = kwargs . pop ( \"max_unit_price\" , DEFAULT_MAX_UNIT_PRICE ) self . _min_quantity = kwargs . pop ( \"min_quantity\" , DEFAULT_MIN_QUANTITY ) self . _max_quantity = kwargs . pop ( \"max_quantity\" , DEFAULT_MAX_QUANTITY ) self . _max_tx_fee = kwargs . pop ( \"max_tx_fee\" , DEFAULT_MAX_TX_FEE ) self . _service_id = kwargs . pop ( \"service_id\" , DEFAULT_SERVICE_ID ) self . _search_query = kwargs . pop ( \"search_query\" , DEFAULT_SEARCH_QUERY ) location = kwargs . pop ( \"location\" , DEFAULT_LOCATION ) self . _agent_location = Location ( latitude = location [ \"latitude\" ], longitude = location [ \"longitude\" ] ) self . _radius = kwargs . pop ( \"search_radius\" , DEFAULT_SEARCH_RADIUS ) self . _max_negotiations = kwargs . pop ( \"max_negotiations\" , DEFAULT_MAX_NEGOTIATIONS ) self . _is_stop_searching_on_result = kwargs . pop ( \"stop_searching_on_result\" , True ) super () . __init__ ( ** kwargs ) self . _ledger_id = ( ledger_id if ledger_id is not None else self . context . default_ledger_id ) if currency_id is None : currency_id = self . context . currency_denominations . get ( self . _ledger_id , None ) enforce ( currency_id is not None , f \"Currency denomination for ledger_id= { self . _ledger_id } not specified.\" , ) self . _currency_id = currency_id self . _is_searching = False self . _balance = 0 Similar to the seller AEA, we initialize the strategy class by trying to read the strategy variables from the YAML file, and if not possible, use some default values. In the following snippet, the two methods after the properties are related to the OEF search service. Add this snippet under the initialization of the strategy class: @property def ledger_id ( self ) -> str : \"\"\"Get the ledger id.\"\"\" return self . _ledger_id @property def is_ledger_tx ( self ) -> bool : \"\"\"Check whether or not tx are settled on a ledger.\"\"\" return self . _is_ledger_tx @property def is_stop_searching_on_result ( self ) -> bool : \"\"\"Check if search is stopped on result.\"\"\" return self . _is_stop_searching_on_result @property def is_searching ( self ) -> bool : \"\"\"Check if the agent is searching.\"\"\" return self . _is_searching @is_searching . setter def is_searching ( self , is_searching : bool ) -> None : \"\"\"Check if the agent is searching.\"\"\" enforce ( isinstance ( is_searching , bool ), \"Can only set bool on is_searching!\" ) self . _is_searching = is_searching @property def balance ( self ) -> int : \"\"\"Get the balance.\"\"\" return self . _balance @balance . setter def balance ( self , balance : int ) -> None : \"\"\"Set the balance.\"\"\" self . _balance = balance @property def max_negotiations ( self ) -> int : \"\"\"Get the maximum number of negotiations the agent can start.\"\"\" return self . _max_negotiations def get_location_and_service_query ( self ) -> Query : \"\"\" Get the location and service query of the agent. :return: the query \"\"\" close_to_my_service = Constraint ( \"location\" , ConstraintType ( \"distance\" , ( self . _agent_location , self . _radius )) ) service_key_filter = Constraint ( self . _search_query [ \"search_key\" ], ConstraintType ( self . _search_query [ \"constraint_type\" ], self . _search_query [ \"search_value\" ], ), ) query = Query ([ close_to_my_service , service_key_filter ],) return query def get_service_query ( self ) -> Query : \"\"\" Get the service query of the agent. :return: the query \"\"\" service_key_filter = Constraint ( self . _search_query [ \"search_key\" ], ConstraintType ( self . _search_query [ \"constraint_type\" ], self . _search_query [ \"search_value\" ], ), ) query = Query ([ service_key_filter ], model = SIMPLE_SERVICE_MODEL ) return query The following code block checks if the proposal that we received is acceptable according to a strategy: def is_acceptable_proposal ( self , proposal : Description ) -> bool : \"\"\" Check whether it is an acceptable proposal. :param proposal: a description :return: whether it is acceptable \"\"\" result = ( all ( [ key in proposal . values for key in [ \"ledger_id\" , \"currency_id\" , \"price\" , \"service_id\" , \"quantity\" , \"tx_nonce\" , ] ] ) and proposal . values [ \"ledger_id\" ] == self . ledger_id and proposal . values [ \"price\" ] > 0 and proposal . values [ \"quantity\" ] >= self . _min_quantity and proposal . values [ \"quantity\" ] <= self . _max_quantity and proposal . values [ \"price\" ] <= proposal . values [ \"quantity\" ] * self . _max_unit_price and proposal . values [ \"currency_id\" ] == self . _currency_id and proposal . values [ \"service_id\" ] == self . _service_id and isinstance ( proposal . values [ \"tx_nonce\" ], str ) and proposal . values [ \"tx_nonce\" ] != \"\" ) return result The is_affordable_proposal method in the following code block checks if we can afford the transaction based on the funds we have in our wallet on the ledger. The rest of the methods are self-explanatory. def is_affordable_proposal ( self , proposal : Description ) -> bool : \"\"\" Check whether it is an affordable proposal. :param proposal: a description :return: whether it is affordable \"\"\" if self . is_ledger_tx : payable = proposal . values . get ( \"price\" , 0 ) + self . _max_tx_fee result = self . balance >= payable else : result = True return result def get_acceptable_counterparties ( self , counterparties : Tuple [ str , ... ] ) -> Tuple [ str , ... ]: \"\"\" Process counterparties and drop unacceptable ones. :param counterparties: a tuple of counterparties :return: list of counterparties \"\"\" valid_counterparties : List [ str ] = [] for idx , counterparty in enumerate ( counterparties ): if idx < self . max_negotiations : valid_counterparties . append ( counterparty ) return tuple ( valid_counterparties ) def terms_from_proposal ( self , proposal : Description , counterparty_address : Address ) -> Terms : \"\"\" Get the terms from a proposal. :param proposal: the proposal :param counterparty_address: the counterparty :return: terms \"\"\" buyer_address = self . context . agent_addresses [ proposal . values [ \"ledger_id\" ]] terms = Terms ( ledger_id = proposal . values [ \"ledger_id\" ], sender_address = buyer_address , counterparty_address = counterparty_address , amount_by_currency_id = { proposal . values [ \"currency_id\" ]: - proposal . values [ \"price\" ] }, quantities_by_good_id = { proposal . values [ \"service_id\" ]: proposal . values [ \"quantity\" ] }, is_sender_payable_tx_fee = True , nonce = proposal . values [ \"tx_nonce\" ], fee_by_currency_id = { proposal . values [ \"currency_id\" ]: self . _max_tx_fee }, ) return terms def successful_trade_with_counterparty ( self , counterparty : str , data : Dict [ str , str ] ) -> None : \"\"\" Do something on successful trade. :param counterparty: the counterparty address :param data: the data \"\"\" def update_search_query_params ( self ) -> None : \"\"\"Update agent location and query for search.\"\"\" Step 5: Create the dialogues As mentioned during the creation of the seller AEA, we should keep track of the various interactions an AEA has with others and this is done via dialogues. Create a new file and name it dialogues.py (in my_generic_buyer/skills/generic_buyer/ ). Inside this file add the following code: from typing import Any , Optional , Type from aea.common import Address from aea.exceptions import AEAEnforceError , enforce from aea.helpers.transaction.base import Terms from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.protocols.dialogue.base import DialogueLabel as BaseDialogueLabel from aea.skills.base import Model from packages.fetchai.protocols.default.dialogues import ( DefaultDialogue as BaseDefaultDialogue , ) from packages.fetchai.protocols.default.dialogues import ( DefaultDialogues as BaseDefaultDialogues , ) from packages.fetchai.protocols.fipa.dialogues import FipaDialogue as BaseFipaDialogue from packages.fetchai.protocols.fipa.dialogues import FipaDialogues as BaseFipaDialogues from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.ledger_api.dialogues import ( LedgerApiDialogue as BaseLedgerApiDialogue , ) from packages.fetchai.protocols.ledger_api.dialogues import ( LedgerApiDialogues as BaseLedgerApiDialogues , ) from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogue as BaseOefSearchDialogue , ) from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogues as BaseOefSearchDialogues , ) from packages.fetchai.protocols.signing.dialogues import ( SigningDialogue as BaseSigningDialogue , ) from packages.fetchai.protocols.signing.dialogues import ( SigningDialogues as BaseSigningDialogues , ) from packages.fetchai.protocols.signing.message import SigningMessage DefaultDialogue = BaseDefaultDialogue class DefaultDialogues ( Model , BaseDefaultDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return DefaultDialogue . Role . AGENT BaseDefaultDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) class FipaDialogue ( BaseFipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" __slots__ = ( \"_terms\" , \"_associated_ledger_api_dialogue\" , ) def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ FipaMessage ] = FipaMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :param message_class: the message class \"\"\" BaseFipaDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . _terms = None # type: Optional[Terms] @property def terms ( self ) -> Terms : \"\"\"Get terms.\"\"\" if self . _terms is None : raise AEAEnforceError ( \"Terms not set!\" ) return self . _terms @terms . setter def terms ( self , terms : Terms ) -> None : \"\"\"Set terms.\"\"\" enforce ( self . _terms is None , \"Terms already set!\" ) self . _terms = terms class FipaDialogues ( Model , BaseFipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseFipaDialogue . Role . BUYER BaseFipaDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , dialogue_class = FipaDialogue , ) class LedgerApiDialogue ( BaseLedgerApiDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" __slots__ = ( \"_associated_fipa_dialogue\" ,) def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ LedgerApiMessage ] = LedgerApiMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :param message_class: the message class \"\"\" BaseLedgerApiDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . _associated_fipa_dialogue = None # type: Optional[FipaDialogue] @property def associated_fipa_dialogue ( self ) -> FipaDialogue : \"\"\"Get associated_fipa_dialogue.\"\"\" if self . _associated_fipa_dialogue is None : raise AEAEnforceError ( \"FipaDialogue not set!\" ) return self . _associated_fipa_dialogue @associated_fipa_dialogue . setter def associated_fipa_dialogue ( self , fipa_dialogue : FipaDialogue ) -> None : \"\"\"Set associated_fipa_dialogue\"\"\" enforce ( self . _associated_fipa_dialogue is None , \"FipaDialogue already set!\" ) self . _associated_fipa_dialogue = fipa_dialogue class LedgerApiDialogues ( Model , BaseLedgerApiDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseLedgerApiDialogue . Role . AGENT BaseLedgerApiDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , dialogue_class = LedgerApiDialogue , ) OefSearchDialogue = BaseOefSearchDialogue class OefSearchDialogues ( Model , BaseOefSearchDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseOefSearchDialogue . Role . AGENT BaseOefSearchDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , ) class SigningDialogue ( BaseSigningDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" __slots__ = ( \"_associated_ledger_api_dialogue\" ,) def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ SigningMessage ] = SigningMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :param message_class: the message class \"\"\" BaseSigningDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . _associated_ledger_api_dialogue = None # type: Optional[LedgerApiDialogue] @property def associated_ledger_api_dialogue ( self ) -> LedgerApiDialogue : \"\"\"Get associated_ledger_api_dialogue.\"\"\" if self . _associated_ledger_api_dialogue is None : raise AEAEnforceError ( \"LedgerApiDialogue not set!\" ) return self . _associated_ledger_api_dialogue @associated_ledger_api_dialogue . setter def associated_ledger_api_dialogue ( self , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\"Set associated_ledger_api_dialogue\"\"\" enforce ( self . _associated_ledger_api_dialogue is None , \"LedgerApiDialogue already set!\" , ) self . _associated_ledger_api_dialogue = ledger_api_dialogue class SigningDialogues ( Model , BaseSigningDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseSigningDialogue . Role . SKILL BaseSigningDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , dialogue_class = SigningDialogue , ) The various dialogues classes in the above code snippet store dialogues with other AEAs, services and components, (e.g. SOEF search node via the fetchai/soef connection, ledgers via the fetchai/ledger connection and the decision maker). They expose useful methods to manipulate these interactions, access previous messages, and enable us to identify possible communications problems between my_generic_seller and my_generic_buyer AEAs. Step 6: Update the YAML files After making so many changes to our skill, we have to update the skill.yaml configuration file so it reflects our newly created classes, and contains the values used by the strategy. Make sure skill.yaml contains the following configuration: name : generic_buyer author : fetchai version : 0.1.0 type : skill description : The weather client skill implements the skill to purchase weather data. license : Apache-2.0 aea_version : '>=1.0.0, <2.0.0' fingerprint : README.md : QmTR91jm7WfJpmabisy74NR5mc35YXjDU1zQAUKZeHRw8L __init__.py : QmU5vrC8FipyjfS5biNa6qDWdp4aeH5h4YTtbFDmCg8Chj behaviours.py : QmNwvSjEz4kzM3gWtnKbZVFJc2Z85Nb748CWAK4C4Sa4nT dialogues.py : QmNen91qQDWy4bNBKrB3LabAP5iRf29B8iwYss4NB13iNU handlers.py : QmZfudXXbdiREiViuwPZDXoQQyXT2ySQHdF7psQsohZXQy strategy.py : QmcrwaEWvKHDCNti8QjRhB4utJBJn5L8GpD27Uy9zHwKhY fingerprint_ignore_patterns : [] connections : - fetchai/ledger:0.19.0 contracts : [] protocols : - fetchai/default:1.0.0 - fetchai/fipa:1.0.0 - fetchai/ledger_api:1.0.0 - fetchai/oef_search:1.0.0 - fetchai/signing:1.0.0 skills : [] behaviours : search : args : search_interval : 5 class_name : GenericSearchBehaviour transaction : args : max_processing : 420 transaction_interval : 2 class_name : GenericTransactionBehaviour handlers : fipa : args : {} class_name : GenericFipaHandler ledger_api : args : {} class_name : GenericLedgerApiHandler oef_search : args : {} class_name : GenericOefSearchHandler signing : args : {} class_name : GenericSigningHandler models : default_dialogues : args : {} class_name : DefaultDialogues fipa_dialogues : args : {} class_name : FipaDialogues ledger_api_dialogues : args : {} class_name : LedgerApiDialogues oef_search_dialogues : args : {} class_name : OefSearchDialogues signing_dialogues : args : {} class_name : SigningDialogues strategy : args : is_ledger_tx : true location : latitude : 51.5194 longitude : 0.127 max_negotiations : 1 max_tx_fee : 1 max_unit_price : 20 min_quantity : 1 search_query : constraint_type : == search_key : seller_service search_value : generic_service search_radius : 5.0 service_id : generic_service stop_searching_on_result : true class_name : GenericStrategy is_abstract : false dependencies : {} We must pay attention to the models and the strategy\u2019s variables. Here we can change the price we would like to buy each reading at, the maximum transaction fee we are prepared to pay, and so on. Finally, we fingerprint our new skill: aea fingerprint skill fetchai/generic_buyer:0.1.0 This will hash each file and save the hash in the fingerprint. This way, in the future we can easily track if any of the files have changed. Run the AEAs Create private keys For each AEA, create a private key: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Update the AEA configurations In both AEAs run: aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' Fund the buyer AEA Create some wealth for your buyer on the Fetch.ai testnet (this operation might take a while). aea generate-wealth fetchai --sync Run seller AEA Add the remaining packages for the seller AEA, then run it: aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add protocol fetchai/fipa:1.0.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea run Once you see a message of the form To join its network use multiaddr: ['SOME_ADDRESS'] take note of the address. Run buyer AEA Add the remaining packages for the buyer AEA: aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add protocol fetchai/fipa:1.0.0 aea add protocol fetchai/signing:1.0.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 Then, update the configuration of the buyer AEA's P2P connection: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' where SOME_ADDRESS is replaced accordingly. Then run the buyer AEA: aea run You will see that the AEAs negotiate and then transact using the StargateWorld testnet. Delete the AEAs When you are done, go up a level and delete the AEAs. cd .. aea delete my_generic_seller aea delete my_generic_buyer Next steps You have completed the \"Getting Started\" series. Congratulations! The following guide provides some hints on AEA development setup . Recommended We recommend you build your own AEA next. There are many helpful guides and demos in the documentation, and a developer community on Discord . Speak to you there!","title":"Trade between two AEAs"},{"location":"aea/generic-skills-step-by-step/#dependencies-required","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies (Required)"},{"location":"aea/generic-skills-step-by-step/#reference-code-optional","text":"This step-by-step guide goes through the creation of two AEAs which are already developed by Fetch.ai. You can get the finished AEAs, and compare your code against them, by following the next steps: aea fetch fetchai/generic_seller:0.28.0 cd generic_seller aea eject skill fetchai/generic_seller:0.27.0 cd .. aea fetch fetchai/generic_buyer:0.29.0 cd generic_buyer aea eject skill fetchai/generic_buyer:0.26.0 cd ..","title":"Reference code (Optional)"},{"location":"aea/generic-skills-step-by-step/#simplification-step","text":"To keep file paths consistent with the reference code, we suggest you initialize your local author as fetchai for the purpose of this demo only: aea init --reset --local --author fetchai","title":"Simplification step"},{"location":"aea/generic-skills-step-by-step/#generic-seller-aea","text":"","title":"Generic Seller AEA"},{"location":"aea/generic-skills-step-by-step/#step-1-create-the-aea","text":"Create a new AEA by typing the following command in the terminal: aea create my_generic_seller cd my_generic_seller aea install Our newly created AEA is inside the current working directory. Let\u2019s create our new skill that will handle the sale of data. Type the following command: aea scaffold skill generic_seller The scaffold skill command creates the correct structure for a new skill inside our AEA project. You can locate the newly created skill under the \"skills\" folder ( my_generic_seller/skills/generic_seller/ ), and it must contain the following files: __init__.py behaviours.py handlers.py my_model.py skills.yaml","title":"Step 1: Create the AEA"},{"location":"aea/generic-skills-step-by-step/#step-2-create-the-behaviour","text":"A Behaviour class contains the business logic specific to actions initiated by the AEA, rather than reactions to other events. Open the behaviours.py file ( my_generic_seller/skills/generic_seller/behaviours.py ) and replace the stub code with the following: from typing import Any , Optional , cast from aea.helpers.search.models import Description from aea.skills.behaviours import TickerBehaviour from packages.fetchai.connections.ledger.base import ( CONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID , ) from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.generic_seller.dialogues import ( LedgerApiDialogues , OefSearchDialogues , ) from packages.fetchai.skills.generic_seller.strategy import GenericStrategy DEFAULT_SERVICES_INTERVAL = 60.0 DEFAULT_MAX_SOEF_REGISTRATION_RETRIES = 5 LEDGER_API_ADDRESS = str ( LEDGER_CONNECTION_PUBLIC_ID ) class GenericServiceRegistrationBehaviour ( TickerBehaviour ): \"\"\"This class implements a behaviour.\"\"\" def __init__ ( self , ** kwargs : Any ): \"\"\"Initialise the behaviour.\"\"\" services_interval = kwargs . pop ( \"services_interval\" , DEFAULT_SERVICES_INTERVAL ) # type: int self . _max_soef_registration_retries = kwargs . pop ( \"max_soef_registration_retries\" , DEFAULT_MAX_SOEF_REGISTRATION_RETRIES ) # type: int super () . __init__ ( tick_interval = services_interval , ** kwargs ) self . failed_registration_msg = None # type: Optional[OefSearchMessage] self . _nb_retries = 0 def setup ( self ) -> None : \"\"\"Implement the setup.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_ledger_tx : ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_msg , _ = ledger_api_dialogues . create ( counterparty = LEDGER_API_ADDRESS , performative = LedgerApiMessage . Performative . GET_BALANCE , ledger_id = strategy . ledger_id , address = cast ( str , self . context . agent_addresses . get ( strategy . ledger_id )), ) self . context . outbox . put_message ( message = ledger_api_msg ) self . _register_agent () def act ( self ) -> None : \"\"\"Implement the act.\"\"\" self . _retry_failed_registration () def teardown ( self ) -> None : \"\"\"Implement the task teardown.\"\"\" self . _unregister_service () self . _unregister_agent () def _retry_failed_registration ( self ) -> None : \"\"\"Retry a failed registration.\"\"\" if self . failed_registration_msg is not None : self . _nb_retries += 1 if self . _nb_retries > self . _max_soef_registration_retries : self . context . is_active = False return oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . failed_registration_msg . to , performative = self . failed_registration_msg . performative , service_description = self . failed_registration_msg . service_description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( f \"Retrying registration on SOEF. Retry { self . _nb_retries } out of { self . _max_soef_registration_retries } .\" ) self . failed_registration_msg = None def _register ( self , description : Description , logger_msg : str ) -> None : \"\"\" Register something on the SOEF. :param description: the description of what is being registered :param logger_msg: the logger message to print after the registration \"\"\" oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . REGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( logger_msg ) def _register_agent ( self ) -> None : \"\"\"Register the agent's location.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_location_description () self . _register ( description , \"registering agent on SOEF.\" ) def register_service ( self ) -> None : \"\"\"Register the agent's service.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_register_service_description () self . _register ( description , \"registering agent's service on the SOEF.\" ) def register_genus ( self ) -> None : \"\"\"Register the agent's personality genus.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_register_personality_description () self . _register ( description , \"registering agent's personality genus on the SOEF.\" ) def register_classification ( self ) -> None : \"\"\"Register the agent's personality classification.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_register_classification_description () self . _register ( description , \"registering agent's personality classification on the SOEF.\" ) def _unregister_service ( self ) -> None : \"\"\"Unregister service from the SOEF.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_unregister_service_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"unregistering service from SOEF.\" ) def _unregister_agent ( self ) -> None : \"\"\"Unregister agent from the SOEF.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) description = strategy . get_location_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"unregistering agent from SOEF.\" ) This TickerBehaviour registers (see setup method) and deregisters (see teardown method) our AEA\u2019s service on the SOEF search node at regular tick intervals (here 60 seconds). By registering, the AEA becomes discoverable to other AEAs. In setup , prior to registrations, we send a message to the ledger connection to check the account balance for the AEA's address on the configured ledger.","title":"Step 2: Create the behaviour"},{"location":"aea/generic-skills-step-by-step/#step-3-create-the-handler","text":"So far, we have tasked the AEA with sending register/unregister requests to the SOEF search node . However at present, the AEA has no way of handling the responses it receives from the search node, or in fact messages sent by any other AEA. We have to specify the logic to negotiate with another AEA based on the strategy we want our AEA to follow. The following diagram illustrates the negotiation flow that we want this AEA to use, as well as interactions with a search node and the blockchain between a seller_AEA and a buyer_AEA . sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept loop Once with LedgerConnection Buyer_AEA->>Buyer_AEA: Get raw transaction from ledger api end loop Once with DecisionMaker Buyer_AEA->>Buyer_AEA: Get signed transaction from decision maker end loop Once with LedgerConnection Buyer_AEA->>Buyer_AEA: Send transaction and get digest from ledger api Buyer_AEA->>Blockchain: transfer_funds end Buyer_AEA->>Seller_AEA: send_transaction_digest Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain In our case, my_generic_seller is the Seller_AEA in the above figure. Let us now implement a Handler to deal with incoming messages. Open the handlers.py file ( my_generic_seller/skills/generic_seller/handlers.py ) and replace the stub code with the following: from typing import Optional , cast from aea.configurations.base import PublicId from aea.crypto.ledger_apis import LedgerApis from aea.helpers.transaction.base import TransactionDigest from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.connections.ledger.base import ( CONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID , ) from packages.fetchai.protocols.default.message import DefaultMessage from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.generic_seller.behaviours import ( GenericServiceRegistrationBehaviour , ) from packages.fetchai.skills.generic_seller.dialogues import ( DefaultDialogues , FipaDialogue , FipaDialogues , LedgerApiDialogue , LedgerApiDialogues , OefSearchDialogue , OefSearchDialogues , ) from packages.fetchai.skills.generic_seller.strategy import GenericStrategy LEDGER_API_ADDRESS = str ( LEDGER_CONNECTION_PUBLIC_ID ) class GenericFipaHandler ( Handler ): \"\"\"This class implements a FIPA handler.\"\"\" SUPPORTED_PROTOCOL = FipaMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message \"\"\" fipa_msg = cast ( FipaMessage , message ) # recover dialogue fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) fipa_dialogue = cast ( FipaDialogue , fipa_dialogues . update ( fipa_msg )) if fipa_dialogue is None : self . _handle_unidentified_dialogue ( fipa_msg ) return # handle message if fipa_msg . performative == FipaMessage . Performative . CFP : self . _handle_cfp ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . DECLINE : self . _handle_decline ( fipa_msg , fipa_dialogue , fipa_dialogues ) elif fipa_msg . performative == FipaMessage . Performative . ACCEPT : self . _handle_accept ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . INFORM : self . _handle_inform ( fipa_msg , fipa_dialogue ) else : self . _handle_invalid ( fipa_msg , fipa_dialogue ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" The code above contains the logic for handling FipaMessages received by the my_generic_seller AEA. We use FipaDialogues (more on this below ) to keep track of the progress of the negotiation dialogue between the my_generic_seller AEA and the my_generic_buyer AEA. In the above handle method, we first check if a received message belongs to an existing dialogue or if we have to create a new dialogue (the recover dialogue part). Once this is done, we break down the AEA's response to each type of negotiation message, as indicated by the message's performative (the handle message part). Therefore, we implement the AEA's response to each negotiation message type in a different handler function. Below the unused teardown function, we continue by adding the following function: def _handle_unidentified_dialogue ( self , fipa_msg : FipaMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param fipa_msg: the message \"\"\" self . context . logger . info ( \"received invalid fipa message= {} , unidentified dialogue.\" . format ( fipa_msg ) ) default_dialogues = cast ( DefaultDialogues , self . context . default_dialogues ) default_msg , _ = default_dialogues . create ( counterparty = fipa_msg . sender , performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE , error_msg = \"Invalid dialogue.\" , error_data = { \"fipa_message\" : fipa_msg . encode ()}, ) self . context . outbox . put_message ( message = default_msg ) The above code handles an unidentified dialogue by responding to the sender with a DefaultMessage containing the appropriate error information. The next code block handles CFP (call-for-proposal) negotiation messages. Paste the following code below the _handle_unidentified_dialogue function: def _handle_cfp ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the CFP. If the CFP matches the supplied services then send a PROPOSE, otherwise send a DECLINE. :param fipa_msg: the message :param fipa_dialogue: the dialogue object \"\"\" self . context . logger . info ( \"received CFP from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_matching_supply ( fipa_msg . query ): proposal , terms , data_for_sale = strategy . generate_proposal_terms_and_data ( fipa_msg . query , fipa_msg . sender ) fipa_dialogue . data_for_sale = data_for_sale fipa_dialogue . terms = terms self . context . logger . info ( \"sending a PROPOSE with proposal= {} to sender= {} \" . format ( proposal . values , fipa_msg . sender [ - 5 :] ) ) proposal_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . PROPOSE , target_message = fipa_msg , proposal = proposal , ) self . context . outbox . put_message ( message = proposal_msg ) else : self . context . logger . info ( \"declined the CFP from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) decline_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . DECLINE , target_message = fipa_msg , ) self . context . outbox . put_message ( message = decline_msg ) The above code sends a PROPOSE message back to the buyer as a response to its CFP if the requested services match our seller agent's supplied services, otherwise it will respond with a DECLINE message. The next code-block handles the decline message we receive from the buyer. Add the following code below the _handle_cfp function: def _handle_decline ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue , fipa_dialogues : FipaDialogues , ) -> None : \"\"\" Handle the DECLINE. Close the dialogue. :param fipa_msg: the message :param fipa_dialogue: the dialogue object :param fipa_dialogues: the dialogues object \"\"\" self . context . logger . info ( \"received DECLINE from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . DECLINED_PROPOSE , fipa_dialogue . is_self_initiated ) If we receive a decline message from the buyer we close the dialogue and terminate this conversation with my_generic_buyer . Alternatively, we might receive an ACCEPT message. In order to handle this option add the following code below the _handle_decline function: def _handle_accept ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the ACCEPT. Respond with a MATCH_ACCEPT_W_INFORM which contains the address to send the funds to. :param fipa_msg: the message :param fipa_dialogue: the dialogue object \"\"\" self . context . logger . info ( \"received ACCEPT from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) info = { \"address\" : fipa_dialogue . terms . sender_address } match_accept_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . MATCH_ACCEPT_W_INFORM , target_message = fipa_msg , info = info , ) self . context . logger . info ( \"sending MATCH_ACCEPT_W_INFORM to sender= {} with info= {} \" . format ( fipa_msg . sender [ - 5 :], info , ) ) self . context . outbox . put_message ( message = match_accept_msg ) When my_generic_buyer accepts the Proposal we send it and sends an ACCEPT message, we have to respond with another message ( MATCH_ACCEPT_W_INFORM ) to match the acceptance of the terms of trade and to inform the buyer of the address we would like it to send the funds to. Lastly, we must handle an INFORM message, which the buyer uses to inform us that it has indeed sent the funds to the provided address. Add the following code at the end of the file: def _handle_inform ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the INFORM. If the INFORM message contains the transaction_digest then verify that it is settled, otherwise do nothing. If the transaction is settled, send the data, otherwise do nothing. :param fipa_msg: the message :param fipa_dialogue: the dialogue object \"\"\" self . context . logger . info ( \"received INFORM from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_ledger_tx and \"transaction_digest\" in fipa_msg . info . keys (): self . context . logger . info ( \"checking whether transaction= {} has been received ...\" . format ( fipa_msg . info [ \"transaction_digest\" ] ) ) ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_msg , ledger_api_dialogue = ledger_api_dialogues . create ( counterparty = LEDGER_API_ADDRESS , performative = LedgerApiMessage . Performative . GET_TRANSACTION_RECEIPT , transaction_digest = TransactionDigest ( fipa_dialogue . terms . ledger_id , fipa_msg . info [ \"transaction_digest\" ] ), ) ledger_api_dialogue = cast ( LedgerApiDialogue , ledger_api_dialogue ) ledger_api_dialogue . associated_fipa_dialogue = fipa_dialogue self . context . outbox . put_message ( message = ledger_api_msg ) elif strategy . is_ledger_tx : self . context . logger . warning ( \"did not receive transaction digest from sender= {} .\" . format ( fipa_msg . sender [ - 5 :] ) ) elif not strategy . is_ledger_tx and \"Done\" in fipa_msg . info . keys (): inform_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . INFORM , target_message = fipa_msg , info = fipa_dialogue . data_for_sale , ) self . context . outbox . put_message ( message = inform_msg ) fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . SUCCESSFUL , fipa_dialogue . is_self_initiated ) self . context . logger . info ( \"transaction confirmed, sending data= {} to buyer= {} .\" . format ( fipa_dialogue . data_for_sale , fipa_msg . sender [ - 5 :], ) ) else : self . context . logger . warning ( \"did not receive transaction confirmation from sender= {} .\" . format ( fipa_msg . sender [ - 5 :] ) ) In the above code, we check the INFORM message. If it contains a transaction digest, then we verify that the transaction matches the proposal the buyer accepted. If the transaction is valid and we received the funds then we send the data to the buyer. Otherwise, we do not send the data. The remaining handlers are as follows: def _handle_invalid ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle a fipa message of invalid performative. :param fipa_msg: the message :param fipa_dialogue: the dialogue object \"\"\" self . context . logger . warning ( \"cannot handle fipa message of performative= {} in dialogue= {} .\" . format ( fipa_msg . performative , fipa_dialogue ) ) class GenericLedgerApiHandler ( Handler ): \"\"\"Implement the ledger handler.\"\"\" SUPPORTED_PROTOCOL = LedgerApiMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message \"\"\" ledger_api_msg = cast ( LedgerApiMessage , message ) # recover dialogue ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_dialogue = cast ( Optional [ LedgerApiDialogue ], ledger_api_dialogues . update ( ledger_api_msg ) ) if ledger_api_dialogue is None : self . _handle_unidentified_dialogue ( ledger_api_msg ) return # handle message if ledger_api_msg . performative is LedgerApiMessage . Performative . BALANCE : self . _handle_balance ( ledger_api_msg ) elif ( ledger_api_msg . performative is LedgerApiMessage . Performative . TRANSACTION_RECEIPT ): self . _handle_transaction_receipt ( ledger_api_msg , ledger_api_dialogue ) elif ledger_api_msg . performative == LedgerApiMessage . Performative . ERROR : self . _handle_error ( ledger_api_msg , ledger_api_dialogue ) else : self . _handle_invalid ( ledger_api_msg , ledger_api_dialogue ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" def _handle_unidentified_dialogue ( self , ledger_api_msg : LedgerApiMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param ledger_api_msg: the message \"\"\" self . context . logger . info ( \"received invalid ledger_api message= {} , unidentified dialogue.\" . format ( ledger_api_msg ) ) def _handle_balance ( self , ledger_api_msg : LedgerApiMessage ) -> None : \"\"\" Handle a message of balance performative. :param ledger_api_msg: the ledger api message \"\"\" self . context . logger . info ( \"starting balance on {} ledger= {} .\" . format ( ledger_api_msg . ledger_id , ledger_api_msg . balance , ) ) def _handle_transaction_receipt ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of balance performative. :param ledger_api_msg: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" fipa_dialogue = ledger_api_dialogue . associated_fipa_dialogue is_settled = LedgerApis . is_transaction_settled ( fipa_dialogue . terms . ledger_id , ledger_api_msg . transaction_receipt . receipt ) is_valid = LedgerApis . is_transaction_valid ( fipa_dialogue . terms . ledger_id , ledger_api_msg . transaction_receipt . transaction , fipa_dialogue . terms . sender_address , fipa_dialogue . terms . counterparty_address , fipa_dialogue . terms . nonce , fipa_dialogue . terms . counterparty_payable_amount , ) if is_settled and is_valid : last_message = cast ( Optional [ FipaMessage ], fipa_dialogue . last_incoming_message ) if last_message is None : raise ValueError ( \"Cannot retrieve last fipa message.\" ) inform_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . INFORM , target_message = last_message , info = fipa_dialogue . data_for_sale , ) self . context . outbox . put_message ( message = inform_msg ) fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . SUCCESSFUL , fipa_dialogue . is_self_initiated ) self . context . logger . info ( \"transaction confirmed, sending data= {} to buyer= {} .\" . format ( fipa_dialogue . data_for_sale , last_message . sender [ - 5 :], ) ) else : self . context . logger . info ( \"transaction_receipt= {} not settled or not valid, aborting\" . format ( ledger_api_msg . transaction_receipt ) ) def _handle_error ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of error performative. :param ledger_api_msg: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . info ( \"received ledger_api error message= {} in dialogue= {} .\" . format ( ledger_api_msg , ledger_api_dialogue ) ) def _handle_invalid ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of invalid performative. :param ledger_api_msg: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . warning ( \"cannot handle ledger_api message of performative= {} in dialogue= {} .\" . format ( ledger_api_msg . performative , ledger_api_dialogue , ) ) class GenericOefSearchHandler ( Handler ): \"\"\"This class implements an OEF search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Call to setup the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message \"\"\" oef_search_msg = cast ( OefSearchMessage , message ) # recover dialogue oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_dialogue = cast ( Optional [ OefSearchDialogue ], oef_search_dialogues . update ( oef_search_msg ) ) if oef_search_dialogue is None : self . _handle_unidentified_dialogue ( oef_search_msg ) return # handle message if oef_search_msg . performative == OefSearchMessage . Performative . SUCCESS : self . _handle_success ( oef_search_msg , oef_search_dialogue ) elif oef_search_msg . performative == OefSearchMessage . Performative . OEF_ERROR : self . _handle_error ( oef_search_msg , oef_search_dialogue ) else : self . _handle_invalid ( oef_search_msg , oef_search_dialogue ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" def _handle_unidentified_dialogue ( self , oef_search_msg : OefSearchMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param oef_search_msg: the message \"\"\" self . context . logger . info ( \"received invalid oef_search message= {} , unidentified dialogue.\" . format ( oef_search_msg ) ) def _handle_success ( self , oef_search_success_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue , ) -> None : \"\"\" Handle an oef search message. :param oef_search_success_msg: the oef search message :param oef_search_dialogue: the dialogue \"\"\" self . context . logger . info ( \"received oef_search success message= {} in dialogue= {} .\" . format ( oef_search_success_msg , oef_search_dialogue ) ) target_message = cast ( OefSearchMessage , oef_search_dialogue . get_message_by_id ( oef_search_success_msg . target ), ) if ( target_message . performative == OefSearchMessage . Performative . REGISTER_SERVICE ): description = target_message . service_description data_model_name = description . data_model . name registration_behaviour = cast ( GenericServiceRegistrationBehaviour , self . context . behaviours . service_registration , ) if \"location_agent\" in data_model_name : registration_behaviour . register_service () elif \"set_service_key\" in data_model_name : registration_behaviour . register_genus () elif ( \"personality_agent\" in data_model_name and description . values [ \"piece\" ] == \"genus\" ): registration_behaviour . register_classification () elif ( \"personality_agent\" in data_model_name and description . values [ \"piece\" ] == \"classification\" ): self . context . logger . info ( \"the agent, with its genus and classification, and its service are successfully registered on the SOEF.\" ) else : self . context . logger . warning ( f \"received soef SUCCESS message as a reply to the following unexpected message: { target_message } \" ) def _handle_error ( self , oef_search_error_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue , ) -> None : \"\"\" Handle an oef search message. :param oef_search_error_msg: the oef search message :param oef_search_dialogue: the dialogue \"\"\" self . context . logger . info ( \"received oef_search error message= {} in dialogue= {} .\" . format ( oef_search_error_msg , oef_search_dialogue ) ) target_message = cast ( OefSearchMessage , oef_search_dialogue . get_message_by_id ( oef_search_error_msg . target ), ) if ( target_message . performative == OefSearchMessage . Performative . REGISTER_SERVICE ): registration_behaviour = cast ( GenericServiceRegistrationBehaviour , self . context . behaviours . service_registration , ) registration_behaviour . failed_registration_msg = target_message def _handle_invalid ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue \"\"\" self . context . logger . warning ( \"cannot handle oef_search message of performative= {} in dialogue= {} .\" . format ( oef_search_msg . performative , oef_search_dialogue , ) ) The GenericLedgerApiHandler deals with LedgerApiMessages from the ledger connection and the GenericOefSearchHandler handles OefSearchMessages from the SOEF connection.","title":"Step 3: Create the handler"},{"location":"aea/generic-skills-step-by-step/#step-4-create-the-strategy","text":"Next, we are going to create the strategy that we want our my_generic_seller AEA to follow. Rename the my_model.py file ( my_generic_seller/skills/generic_seller/my_model.py ) to strategy.py and replace the stub code with the following: import uuid from typing import Any , Dict , Optional , Tuple from aea.common import Address from aea.crypto.ledger_apis import LedgerApis from aea.exceptions import enforce from aea.helpers.search.generic import ( AGENT_LOCATION_MODEL , AGENT_PERSONALITY_MODEL , AGENT_REMOVE_SERVICE_MODEL , AGENT_SET_SERVICE_MODEL , SIMPLE_SERVICE_MODEL , ) from aea.helpers.search.models import Description , Location , Query from aea.helpers.transaction.base import Terms from aea.skills.base import Model DEFAULT_IS_LEDGER_TX = True DEFAULT_UNIT_PRICE = 4 DEFAULT_SERVICE_ID = \"generic_service\" DEFAULT_LOCATION = { \"longitude\" : 0.1270 , \"latitude\" : 51.5194 } DEFAULT_SERVICE_DATA = { \"key\" : \"seller_service\" , \"value\" : \"generic_service\" } DEFAULT_PERSONALITY_DATA = { \"piece\" : \"genus\" , \"value\" : \"data\" } DEFAULT_CLASSIFICATION = { \"piece\" : \"classification\" , \"value\" : \"seller\" } DEFAULT_HAS_DATA_SOURCE = False DEFAULT_DATA_FOR_SALE = { \"some_generic_data_key\" : \"some_generic_data_value\" } # type: Optional[Dict[str, Any]] class GenericStrategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize the strategy of the agent. :param kwargs: keyword arguments \"\"\" ledger_id = kwargs . pop ( \"ledger_id\" , None ) currency_id = kwargs . pop ( \"currency_id\" , None ) self . _is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) self . _unit_price = kwargs . pop ( \"unit_price\" , DEFAULT_UNIT_PRICE ) self . _service_id = kwargs . pop ( \"service_id\" , DEFAULT_SERVICE_ID ) location = kwargs . pop ( \"location\" , DEFAULT_LOCATION ) self . _agent_location = { \"location\" : Location ( latitude = location [ \"latitude\" ], longitude = location [ \"longitude\" ] ) } self . _set_personality_data = kwargs . pop ( \"personality_data\" , DEFAULT_PERSONALITY_DATA ) enforce ( len ( self . _set_personality_data ) == 2 and \"piece\" in self . _set_personality_data and \"value\" in self . _set_personality_data , \"personality_data must contain keys `key` and `value`\" , ) self . _set_classification = kwargs . pop ( \"classification\" , DEFAULT_CLASSIFICATION ) enforce ( len ( self . _set_classification ) == 2 and \"piece\" in self . _set_classification and \"value\" in self . _set_classification , \"classification must contain keys `key` and `value`\" , ) self . _set_service_data = kwargs . pop ( \"service_data\" , DEFAULT_SERVICE_DATA ) enforce ( len ( self . _set_service_data ) == 2 and \"key\" in self . _set_service_data and \"value\" in self . _set_service_data , \"service_data must contain keys `key` and `value`\" , ) self . _remove_service_data = { \"key\" : self . _set_service_data [ \"key\" ]} self . _simple_service_data = { self . _set_service_data [ \"key\" ]: self . _set_service_data [ \"value\" ] } self . _has_data_source = kwargs . pop ( \"has_data_source\" , DEFAULT_HAS_DATA_SOURCE ) data_for_sale_ordered = kwargs . pop ( \"data_for_sale\" , DEFAULT_DATA_FOR_SALE ) data_for_sale = { str ( key ): str ( value ) for key , value in data_for_sale_ordered . items () } super () . __init__ ( ** kwargs ) self . _ledger_id = ( ledger_id if ledger_id is not None else self . context . default_ledger_id ) if currency_id is None : currency_id = self . context . currency_denominations . get ( self . _ledger_id , None ) enforce ( currency_id is not None , f \"Currency denomination for ledger_id= { self . _ledger_id } not specified.\" , ) self . _currency_id = currency_id enforce ( self . context . agent_addresses . get ( self . _ledger_id , None ) is not None , \"Wallet does not contain cryptos for provided ledger id.\" , ) self . _data_for_sale = data_for_sale In the above code snippet, we initialise the strategy class by trying to read the variables specific to the strategy from a YAML configuration file. If any variable is not provided, some default values will be used. The following properties and methods deal with different aspects of the strategy. They should be relatively self-descriptive. Add them under the initialization of the strategy class: @property def data_for_sale ( self ) -> Dict [ str , str ]: \"\"\"Get the data for sale.\"\"\" if self . _has_data_source : return self . collect_from_data_source () # pragma: nocover return self . _data_for_sale @property def ledger_id ( self ) -> str : \"\"\"Get the ledger id.\"\"\" return self . _ledger_id @property def is_ledger_tx ( self ) -> bool : \"\"\"Check whether or not tx are settled on a ledger.\"\"\" return self . _is_ledger_tx def get_location_description ( self ) -> Description : \"\"\" Get the location description. :return: a description of the agent's location \"\"\" description = Description ( self . _agent_location , data_model = AGENT_LOCATION_MODEL , ) return description def get_register_service_description ( self ) -> Description : \"\"\" Get the register service description. :return: a description of the offered services \"\"\" description = Description ( self . _set_service_data , data_model = AGENT_SET_SERVICE_MODEL , ) return description def get_register_personality_description ( self ) -> Description : \"\"\" Get the register personality description. :return: a description of the personality \"\"\" description = Description ( self . _set_personality_data , data_model = AGENT_PERSONALITY_MODEL , ) return description def get_register_classification_description ( self ) -> Description : \"\"\" Get the register classification description. :return: a description of the classification \"\"\" description = Description ( self . _set_classification , data_model = AGENT_PERSONALITY_MODEL , ) return description def get_service_description ( self ) -> Description : \"\"\" Get the simple service description. :return: a description of the offered services \"\"\" description = Description ( self . _simple_service_data , data_model = SIMPLE_SERVICE_MODEL , ) return description def get_unregister_service_description ( self ) -> Description : \"\"\" Get the unregister service description. :return: a description of the to be removed service \"\"\" description = Description ( self . _remove_service_data , data_model = AGENT_REMOVE_SERVICE_MODEL , ) return description def is_matching_supply ( self , query : Query ) -> bool : \"\"\" Check if the query matches the supply. :param query: the query :return: bool indicating whether matches or not \"\"\" return query . check ( self . get_service_description ()) def generate_proposal_terms_and_data ( # pylint: disable=unused-argument self , query : Query , counterparty_address : Address ) -> Tuple [ Description , Terms , Dict [ str , str ]]: \"\"\" Generate a proposal matching the query. :param query: the query :param counterparty_address: the counterparty of the proposal. :return: a tuple of proposal, terms and the weather data \"\"\" data_for_sale = self . data_for_sale sale_quantity = len ( data_for_sale ) seller_address = self . context . agent_addresses [ self . ledger_id ] total_price = sale_quantity * self . _unit_price if self . is_ledger_tx : tx_nonce = LedgerApis . generate_tx_nonce ( identifier = self . ledger_id , seller = seller_address , client = counterparty_address , ) else : tx_nonce = uuid . uuid4 () . hex # pragma: nocover proposal = Description ( { \"ledger_id\" : self . ledger_id , \"price\" : total_price , \"currency_id\" : self . _currency_id , \"service_id\" : self . _service_id , \"quantity\" : sale_quantity , \"tx_nonce\" : tx_nonce , } ) terms = Terms ( ledger_id = self . ledger_id , sender_address = seller_address , counterparty_address = counterparty_address , amount_by_currency_id = { self . _currency_id : total_price }, quantities_by_good_id = { self . _service_id : - sale_quantity }, is_sender_payable_tx_fee = False , nonce = tx_nonce , fee_by_currency_id = { self . _currency_id : 0 }, ) return proposal , terms , data_for_sale def collect_from_data_source ( self ) -> Dict [ str , str ]: \"\"\"Implement the logic to communicate with the sensor.\"\"\" raise NotImplementedError The helper private function collect_from_data_source is where we read data from a sensor or if there are no sensor we use some default data provided (see the data_for_sale property).","title":"Step 4: Create the strategy"},{"location":"aea/generic-skills-step-by-step/#step-5-create-the-dialogues","text":"To keep track of the structure and progress of interactions, including negotiations with a buyer AEA and interactions with search nodes and ledgers, we use dialogues. Create a new file in the skill folder ( my_generic_seller/skills/generic_seller/ ) and name it dialogues.py . Inside this file add the following code: from typing import Any , Dict , Optional , Type from aea.common import Address from aea.exceptions import AEAEnforceError , enforce from aea.helpers.transaction.base import Terms from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.protocols.dialogue.base import DialogueLabel as BaseDialogueLabel from aea.skills.base import Model from packages.fetchai.protocols.default.dialogues import ( DefaultDialogue as BaseDefaultDialogue , ) from packages.fetchai.protocols.default.dialogues import ( DefaultDialogues as BaseDefaultDialogues , ) from packages.fetchai.protocols.fipa.dialogues import FipaDialogue as BaseFipaDialogue from packages.fetchai.protocols.fipa.dialogues import FipaDialogues as BaseFipaDialogues from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.ledger_api.dialogues import ( LedgerApiDialogue as BaseLedgerApiDialogue , ) from packages.fetchai.protocols.ledger_api.dialogues import ( LedgerApiDialogues as BaseLedgerApiDialogues , ) from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogue as BaseOefSearchDialogue , ) from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogues as BaseOefSearchDialogues , ) DefaultDialogue = BaseDefaultDialogue class DefaultDialogues ( Model , BaseDefaultDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return DefaultDialogue . Role . AGENT BaseDefaultDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) class FipaDialogue ( BaseFipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" __slots__ = ( \"data_for_sale\" , \"_terms\" ) def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ FipaMessage ] = FipaMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :param message_class: the message class \"\"\" BaseFipaDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . data_for_sale = None # type: Optional[Dict[str, str]] self . _terms = None # type: Optional[Terms] @property def terms ( self ) -> Terms : \"\"\"Get terms.\"\"\" if self . _terms is None : raise AEAEnforceError ( \"Terms not set!\" ) return self . _terms @terms . setter def terms ( self , terms : Terms ) -> None : \"\"\"Set terms.\"\"\" enforce ( self . _terms is None , \"Terms already set!\" ) self . _terms = terms class FipaDialogues ( Model , BaseFipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return FipaDialogue . Role . SELLER BaseFipaDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , dialogue_class = FipaDialogue , ) class LedgerApiDialogue ( BaseLedgerApiDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" __slots__ = ( \"_associated_fipa_dialogue\" ,) def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ LedgerApiMessage ] = LedgerApiMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :param message_class: the message class \"\"\" BaseLedgerApiDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . _associated_fipa_dialogue = None # type: Optional[FipaDialogue] @property def associated_fipa_dialogue ( self ) -> FipaDialogue : \"\"\"Get associated_fipa_dialogue.\"\"\" if self . _associated_fipa_dialogue is None : raise AEAEnforceError ( \"FipaDialogue not set!\" ) return self . _associated_fipa_dialogue @associated_fipa_dialogue . setter def associated_fipa_dialogue ( self , fipa_dialogue : FipaDialogue ) -> None : \"\"\"Set associated_fipa_dialogue\"\"\" enforce ( self . _associated_fipa_dialogue is None , \"FipaDialogue already set!\" ) self . _associated_fipa_dialogue = fipa_dialogue class LedgerApiDialogues ( Model , BaseLedgerApiDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseLedgerApiDialogue . Role . AGENT BaseLedgerApiDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , dialogue_class = LedgerApiDialogue , ) OefSearchDialogue = BaseOefSearchDialogue class OefSearchDialogues ( Model , BaseOefSearchDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseOefSearchDialogue . Role . AGENT BaseOefSearchDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , ) The FipaDialogues class contains negotiation dialogues with each my_generic_buyer AEA (and other AEAs) and exposes a number of helpful methods to manage them. This helps us match messages to the dialogues they belong to, access previous messages and enable us to identify possible communications problems between the my_generic_seller AEA and the my_generic_buyer AEA. It also keeps track of the data that we offer for sale during the proposal phase. The FipaDialogues class extends BaseFipaDialogues , which itself derives from the base Dialogues class. Similarly, the FipaDialogue class extends BaseFipaDialogue which itself derives from the base Dialogue class. To learn more about dialogues have a look here .","title":"Step 5: Create the dialogues"},{"location":"aea/generic-skills-step-by-step/#step-6-update-the-yaml-files","text":"Since we made so many changes to our AEA we have to update the skill.yaml (at my_generic_seller/skills/generic_seller/skill.yaml ). Make sure you update your skill.yaml with the following configuration: name : generic_seller author : fetchai version : 0.1.0 type : skill description : The weather station skill implements the functionality to sell weather data. license : Apache-2.0 aea_version : '>=1.0.0, <2.0.0' fingerprint : README.md : QmPb5kHYZyhUN87EKmuahyGqDGgqVdGPyfC1KpGC3xfmcP __init__.py : QmTSEedzQySy2nzRCY3F66CBSX52f8s3pWHZTejX4hKC9h behaviours.py : QmS9sPCv2yBnhWsmHeaCptpApMtYZipbR39TXixeGK64Ks dialogues.py : QmdTW8q1xQ7ajFVsWmuV62ypoT5J2b6Hkyz52LFaWuMEtd handlers.py : QmQnQhSaHPUYaJut8bMe2LHEqiZqokMSVfCthVaqrvPbdi strategy.py : QmYTUsfv64eRQDevCfMUDQPx2GCtiMLFdacN4sS1E4Fdfx fingerprint_ignore_patterns : [] connections : - fetchai/ledger:0.19.0 contracts : [] protocols : - fetchai/default:1.0.0 - fetchai/fipa:1.0.0 - fetchai/ledger_api:1.0.0 - fetchai/oef_search:1.0.0 skills : [] behaviours : service_registration : args : services_interval : 20 class_name : GenericServiceRegistrationBehaviour handlers : fipa : args : {} class_name : GenericFipaHandler ledger_api : args : {} class_name : GenericLedgerApiHandler oef_search : args : {} class_name : GenericOefSearchHandler models : default_dialogues : args : {} class_name : DefaultDialogues fipa_dialogues : args : {} class_name : FipaDialogues ledger_api_dialogues : args : {} class_name : LedgerApiDialogues oef_search_dialogues : args : {} class_name : OefSearchDialogues strategy : args : data_for_sale : generic : data has_data_source : false is_ledger_tx : true location : latitude : 51.5194 longitude : 0.127 service_data : key : seller_service value : generic_service service_id : generic_service unit_price : 10 class_name : GenericStrategy is_abstract : false dependencies : {} We must pay attention to the models and in particular the strategy\u2019s variables. Here we can change the price we would like to sell each data reading for, or the currency we would like to transact with. Lastly, the dependencies are the third party packages we need to install in order to get readings from the sensor. Finally, we fingerprint our new skill: aea fingerprint skill fetchai/generic_seller:0.1.0 This will hash each file and save the hash in the fingerprint. This way, in the future we can easily track if any of the files have changed.","title":"Step 6: Update the YAML files"},{"location":"aea/generic-skills-step-by-step/#generic-buyer-aea","text":"","title":"Generic Buyer AEA"},{"location":"aea/generic-skills-step-by-step/#step-1-create-the-aea_1","text":"In a new terminal, create a new AEA by typing the following command in the terminal: aea create my_generic_buyer cd my_generic_buyer aea install Our newly created AEA is inside the current working directory. Let\u2019s create a new skill for purchasing data. Type the following command: aea scaffold skill generic_buyer This command creates the correct structure for a new skill inside our AEA project. You can locate the newly created skill under the skills folder ( my_generic_buyer/skills/generic_buyer/ ) and it must contain the following files: __init__.py behaviours.py handlers.py my_model.py skills.yaml","title":"Step 1: Create the AEA"},{"location":"aea/generic-skills-step-by-step/#step-2-create-the-behaviour_1","text":"Open the behaviours.py file ( my_generic_buyer/skills/generic_buyer/behaviours.py ) and replace the stub code with the following: from typing import Any , List , Optional , Set , cast from aea.protocols.dialogue.base import DialogueLabel from aea.skills.behaviours import TickerBehaviour from packages.fetchai.connections.ledger.base import ( CONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID , ) from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.generic_buyer.dialogues import ( FipaDialogue , LedgerApiDialogue , LedgerApiDialogues , OefSearchDialogues , ) from packages.fetchai.skills.generic_buyer.strategy import GenericStrategy DEFAULT_MAX_PROCESSING = 120 DEFAULT_TX_INTERVAL = 2.0 DEFAULT_SEARCH_INTERVAL = 5.0 LEDGER_API_ADDRESS = str ( LEDGER_CONNECTION_PUBLIC_ID ) class GenericSearchBehaviour ( TickerBehaviour ): \"\"\"This class implements a search behaviour.\"\"\" def __init__ ( self , ** kwargs : Any ): \"\"\"Initialize the search behaviour.\"\"\" search_interval = cast ( float , kwargs . pop ( \"search_interval\" , DEFAULT_SEARCH_INTERVAL ) ) super () . __init__ ( tick_interval = search_interval , ** kwargs ) def setup ( self ) -> None : \"\"\"Implement the setup for the behaviour.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_ledger_tx : ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_msg , _ = ledger_api_dialogues . create ( counterparty = LEDGER_API_ADDRESS , performative = LedgerApiMessage . Performative . GET_BALANCE , ledger_id = strategy . ledger_id , address = cast ( str , self . context . agent_addresses . get ( strategy . ledger_id )), ) self . context . outbox . put_message ( message = ledger_api_msg ) else : strategy . is_searching = True def act ( self ) -> None : \"\"\"Implement the act.\"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) if not strategy . is_searching : return transaction_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) remaining_transactions_count = len ( transaction_behaviour . waiting ) if remaining_transactions_count > 0 : self . context . logger . info ( f \"Transaction behaviour has { remaining_transactions_count } transactions remaining. Skipping search!\" ) return strategy . update_search_query_params () query = strategy . get_location_and_service_query () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . SEARCH_SERVICES , query = query , ) self . context . outbox . put_message ( message = oef_search_msg ) def teardown ( self ) -> None : \"\"\"Implement the task teardown.\"\"\" class GenericTransactionBehaviour ( TickerBehaviour ): \"\"\"A behaviour to sequentially submit transactions to the blockchain.\"\"\" def __init__ ( self , ** kwargs : Any ): \"\"\"Initialize the transaction behaviour.\"\"\" tx_interval = cast ( float , kwargs . pop ( \"transaction_interval\" , DEFAULT_TX_INTERVAL ) ) self . max_processing = cast ( float , kwargs . pop ( \"max_processing\" , DEFAULT_MAX_PROCESSING ) ) self . processing_time = 0.0 self . waiting : List [ FipaDialogue ] = [] self . processing : Optional [ LedgerApiDialogue ] = None self . timedout : Set [ DialogueLabel ] = set () super () . __init__ ( tick_interval = tx_interval , ** kwargs ) def setup ( self ) -> None : \"\"\"Setup behaviour.\"\"\" def act ( self ) -> None : \"\"\"Implement the act.\"\"\" if self . processing is not None : if self . processing_time <= self . max_processing : # already processing self . processing_time += self . tick_interval return self . _timeout_processing () if len ( self . waiting ) == 0 : # nothing to process return self . _start_processing () def _start_processing ( self ) -> None : \"\"\"Process the next transaction.\"\"\" fipa_dialogue = self . waiting . pop ( 0 ) self . context . logger . info ( f \"Processing transaction, { len ( self . waiting ) } transactions remaining\" ) ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_msg , ledger_api_dialogue = ledger_api_dialogues . create ( counterparty = LEDGER_API_ADDRESS , performative = LedgerApiMessage . Performative . GET_RAW_TRANSACTION , terms = fipa_dialogue . terms , ) ledger_api_dialogue = cast ( LedgerApiDialogue , ledger_api_dialogue ) ledger_api_dialogue . associated_fipa_dialogue = fipa_dialogue self . processing_time = 0.0 self . processing = ledger_api_dialogue self . context . logger . info ( f \"requesting transfer transaction from ledger api for message= { ledger_api_msg } ...\" ) self . context . outbox . put_message ( message = ledger_api_msg ) def teardown ( self ) -> None : \"\"\"Teardown behaviour.\"\"\" def _timeout_processing ( self ) -> None : \"\"\"Timeout processing.\"\"\" if self . processing is None : return self . timedout . add ( self . processing . dialogue_label ) self . waiting . append ( self . processing . associated_fipa_dialogue ) self . processing_time = 0.0 self . processing = None def finish_processing ( self , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Finish processing. :param ledger_api_dialogue: the ledger api dialogue \"\"\" if self . processing == ledger_api_dialogue : self . processing_time = 0.0 self . processing = None return if ledger_api_dialogue . dialogue_label not in self . timedout : raise ValueError ( f \"Non-matching dialogues in transaction behaviour: { self . processing } and { ledger_api_dialogue } \" ) self . timedout . remove ( ledger_api_dialogue . dialogue_label ) self . context . logger . debug ( f \"Timeout dialogue in transaction processing: { ledger_api_dialogue } \" ) # don't reset, as another might be processing def failed_processing ( self , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Failed processing. Currently, we retry processing indefinitely. :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . finish_processing ( ledger_api_dialogue ) self . waiting . append ( ledger_api_dialogue . associated_fipa_dialogue ) This TickerBehaviour will send a search query to the SOEF search node at regular tick intervals.","title":"Step 2: Create the behaviour"},{"location":"aea/generic-skills-step-by-step/#step-3-create-the-handler_1","text":"So far, the AEA is tasked with sending search queries to the SOEF search node . However, currently the AEA has no way of handling the responses it receives from the SOEF or messages from other agents. Let us now implement Handlers to deal with the expected incoming messages. Open the handlers.py file ( my_generic_buyer/skills/generic_buyer/handlers.py ) and add the following code (replacing the stub code already present in the file): import pprint from typing import Optional , cast from aea.configurations.base import PublicId from aea.crypto.ledger_apis import LedgerApis from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.connections.ledger.base import ( CONNECTION_ID as LEDGER_CONNECTION_PUBLIC_ID , ) from packages.fetchai.protocols.default.message import DefaultMessage from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.protocols.signing.message import SigningMessage from packages.fetchai.skills.generic_buyer.behaviours import GenericTransactionBehaviour from packages.fetchai.skills.generic_buyer.dialogues import ( DefaultDialogues , FipaDialogue , FipaDialogues , LedgerApiDialogue , LedgerApiDialogues , OefSearchDialogue , OefSearchDialogues , SigningDialogue , SigningDialogues , ) from packages.fetchai.skills.generic_buyer.strategy import GenericStrategy LEDGER_API_ADDRESS = str ( LEDGER_CONNECTION_PUBLIC_ID ) class GenericFipaHandler ( Handler ): \"\"\"This class implements a FIPA handler.\"\"\" SUPPORTED_PROTOCOL = FipaMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message \"\"\" fipa_msg = cast ( FipaMessage , message ) # recover dialogue fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) fipa_dialogue = cast ( FipaDialogue , fipa_dialogues . update ( fipa_msg )) if fipa_dialogue is None : self . _handle_unidentified_dialogue ( fipa_msg ) return # handle message if fipa_msg . performative == FipaMessage . Performative . PROPOSE : self . _handle_propose ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . DECLINE : self . _handle_decline ( fipa_msg , fipa_dialogue , fipa_dialogues ) elif fipa_msg . performative == FipaMessage . Performative . MATCH_ACCEPT_W_INFORM : self . _handle_match_accept ( fipa_msg , fipa_dialogue ) elif fipa_msg . performative == FipaMessage . Performative . INFORM : self . _handle_inform ( fipa_msg , fipa_dialogue , fipa_dialogues ) else : self . _handle_invalid ( fipa_msg , fipa_dialogue ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" You will see that we are following similar logic to the generic_seller when we develop the generic_buyer \u2019s side of the negotiation. First, we create a new dialogue and store it in the dialogues class. Then we are checking what kind of message we received by checking its performative. So lets start creating our handlers: def _handle_unidentified_dialogue ( self , fipa_msg : FipaMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param fipa_msg: the message \"\"\" self . context . logger . info ( \"received invalid fipa message= {} , unidentified dialogue.\" . format ( fipa_msg ) ) default_dialogues = cast ( DefaultDialogues , self . context . default_dialogues ) default_msg , _ = default_dialogues . create ( counterparty = fipa_msg . sender , performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE , error_msg = \"Invalid dialogue.\" , error_data = { \"fipa_message\" : fipa_msg . encode ()}, ) self . context . outbox . put_message ( message = default_msg ) The above code handles messages referencing unidentified dialogues and responds with an error message to the sender. Next we will handle the PROPOSE message received from the my_generic_seller AEA: def _handle_propose ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the propose. :param fipa_msg: the message :param fipa_dialogue: the dialogue object \"\"\" self . context . logger . info ( \"received proposal= {} from sender= {} \" . format ( fipa_msg . proposal . values , fipa_msg . sender [ - 5 :], ) ) strategy = cast ( GenericStrategy , self . context . strategy ) acceptable = strategy . is_acceptable_proposal ( fipa_msg . proposal ) affordable = strategy . is_affordable_proposal ( fipa_msg . proposal ) if acceptable and affordable : self . context . logger . info ( \"accepting the proposal from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) terms = strategy . terms_from_proposal ( fipa_msg . proposal , fipa_msg . sender ) fipa_dialogue . terms = terms accept_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . ACCEPT , target_message = fipa_msg , ) self . context . outbox . put_message ( message = accept_msg ) else : self . context . logger . info ( \"declining the proposal from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) decline_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . DECLINE , target_message = fipa_msg , ) self . context . outbox . put_message ( message = decline_msg ) When we receive a proposal, we have to check if we have the funds to complete the transaction and if the proposal is acceptable based on our strategy. If the proposal is not affordable or acceptable, we respond with a DECLINE message. Otherwise, we send an ACCEPT message to the seller. The next code-block handles the DECLINE message that we may receive from the seller as a response to our CFP or ACCEPT messages: def _handle_decline ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue , fipa_dialogues : FipaDialogues , ) -> None : \"\"\" Handle the decline. :param fipa_msg: the message :param fipa_dialogue: the fipa dialogue :param fipa_dialogues: the fipa dialogues \"\"\" self . context . logger . info ( \"received DECLINE from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) target_message = fipa_dialogue . get_message_by_id ( fipa_msg . target ) if not target_message : raise ValueError ( \"Can not find target message!\" ) # pragma: nocover declined_performative = target_message . performative if declined_performative == FipaMessage . Performative . CFP : fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . DECLINED_CFP , fipa_dialogue . is_self_initiated ) if declined_performative == FipaMessage . Performative . ACCEPT : fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . DECLINED_ACCEPT , fipa_dialogue . is_self_initiated ) The above code terminates each dialogue with the specific AEA and stores the state of the terminated dialogue (whether it was terminated after a CFP or an ACCEPT ). If my_generic_seller AEA wants to move on with the sale, it will send a MATCH_ACCEPT message. In order to handle this we add the following code: def _handle_match_accept ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle the match accept. :param fipa_msg: the message :param fipa_dialogue: the dialogue object \"\"\" self . context . logger . info ( \"received MATCH_ACCEPT_W_INFORM from sender= {} with info= {} \" . format ( fipa_msg . sender [ - 5 :], fipa_msg . info ) ) strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_ledger_tx : transfer_address = fipa_msg . info . get ( \"address\" , None ) if transfer_address is not None and isinstance ( transfer_address , str ): fipa_dialogue . terms . counterparty_address = ( # pragma: nocover transfer_address ) tx_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) tx_behaviour . waiting . append ( fipa_dialogue ) else : inform_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . INFORM , target_message = fipa_msg , info = { \"Done\" : \"Sending payment via bank transfer\" }, ) self . context . outbox . put_message ( message = inform_msg ) self . context . logger . info ( \"informing counterparty= {} of payment.\" . format ( fipa_msg . sender [ - 5 :]) ) The first thing we are checking is if we enabled our AEA to transact with a ledger. If so, we add this negotiation to the queue of transactions to be processed. If not, we simulate non-ledger payment by sending an inform to the seller that the payment is done (say via bank transfer). Lastly, we need to handle INFORM messages. This is the message that will have our data: def _handle_inform ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue , fipa_dialogues : FipaDialogues , ) -> None : \"\"\" Handle the match inform. :param fipa_msg: the message :param fipa_dialogue: the fipa dialogue :param fipa_dialogues: the fipa dialogues \"\"\" self . context . logger . info ( \"received INFORM from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) if len ( fipa_msg . info . keys ()) >= 1 : data = fipa_msg . info data_string = pprint . pformat ( data )[: 1000 ] self . context . logger . info ( f \"received the following data= { data_string } \" ) fipa_dialogues . dialogue_stats . add_dialogue_endstate ( FipaDialogue . EndState . SUCCESSFUL , fipa_dialogue . is_self_initiated ) strategy = cast ( GenericStrategy , self . context . strategy ) strategy . successful_trade_with_counterparty ( fipa_msg . sender , data ) else : self . context . logger . info ( \"received no data from sender= {} \" . format ( fipa_msg . sender [ - 5 :]) ) def _handle_invalid ( self , fipa_msg : FipaMessage , fipa_dialogue : FipaDialogue ) -> None : \"\"\" Handle a fipa message of invalid performative. :param fipa_msg: the message :param fipa_dialogue: the fipa dialogue \"\"\" self . context . logger . warning ( \"cannot handle fipa message of performative= {} in dialogue= {} .\" . format ( fipa_msg . performative , fipa_dialogue ) ) We now need to add handlers for messages received from the DecisionMaker and the SOEF search node . We need one handler for each type of protocol we use. To handle the messages in the oef_search protocol used by the SOEF search node we add the following code in the same file ( my_generic_buyer/skills/generic_buyer/handlers.py ): class GenericOefSearchHandler ( Handler ): \"\"\"This class implements an OEF search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Call to setup the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message \"\"\" oef_search_msg = cast ( OefSearchMessage , message ) # recover dialogue oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_dialogue = cast ( Optional [ OefSearchDialogue ], oef_search_dialogues . update ( oef_search_msg ) ) if oef_search_dialogue is None : self . _handle_unidentified_dialogue ( oef_search_msg ) return # handle message if oef_search_msg . performative is OefSearchMessage . Performative . OEF_ERROR : self . _handle_error ( oef_search_msg , oef_search_dialogue ) elif oef_search_msg . performative is OefSearchMessage . Performative . SEARCH_RESULT : self . _handle_search ( oef_search_msg , oef_search_dialogue ) else : self . _handle_invalid ( oef_search_msg , oef_search_dialogue ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" def _handle_unidentified_dialogue ( self , oef_search_msg : OefSearchMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param oef_search_msg: the message \"\"\" self . context . logger . info ( \"received invalid oef_search message= {} , unidentified dialogue.\" . format ( oef_search_msg ) ) def _handle_error ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue \"\"\" self . context . logger . info ( \"received oef_search error message= {} in dialogue= {} .\" . format ( oef_search_msg , oef_search_dialogue ) ) def _handle_search ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle the search response. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue \"\"\" if len ( oef_search_msg . agents ) == 0 : self . context . logger . info ( f \"found no agents in dialogue= { oef_search_dialogue } , continue searching.\" ) return strategy = cast ( GenericStrategy , self . context . strategy ) if strategy . is_stop_searching_on_result : self . context . logger . info ( \"found agents= {} , stopping search.\" . format ( list ( map ( lambda x : x [ - 5 :], oef_search_msg . agents )), ) ) strategy . is_searching = False # stopping search else : self . context . logger . info ( \"found agents= {} .\" . format ( list ( map ( lambda x : x [ - 5 :], oef_search_msg . agents )), ) ) query = strategy . get_service_query () fipa_dialogues = cast ( FipaDialogues , self . context . fipa_dialogues ) counterparties = strategy . get_acceptable_counterparties ( oef_search_msg . agents ) for counterparty in counterparties : cfp_msg , _ = fipa_dialogues . create ( counterparty = counterparty , performative = FipaMessage . Performative . CFP , query = query , ) self . context . outbox . put_message ( message = cfp_msg ) self . context . logger . info ( \"sending CFP to agent= {} \" . format ( counterparty [ - 5 :]) ) def _handle_invalid ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue \"\"\" self . context . logger . warning ( \"cannot handle oef_search message of performative= {} in dialogue= {} .\" . format ( oef_search_msg . performative , oef_search_dialogue , ) ) When we receive a message from the SOEF search node of a type OefSearchMessage.Performative.SEARCH_RESULT , we are passing the details to the relevant handler method. In the _handle_search function we are checking that the response contains some agents and we stop the search if it does. We pick our first agent and we send a CFP message. The last handlers we need are the GenericSigningHandler and the GenericLedgerApiHandler . These handlers are responsible for SigningMessages that we receive from the DecisionMaker , and LedgerApiMessages that we receive from the ledger connection, respectively. class GenericSigningHandler ( Handler ): \"\"\"Implement the signing handler.\"\"\" SUPPORTED_PROTOCOL = SigningMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message \"\"\" signing_msg = cast ( SigningMessage , message ) # recover dialogue signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_dialogue = cast ( Optional [ SigningDialogue ], signing_dialogues . update ( signing_msg ) ) if signing_dialogue is None : self . _handle_unidentified_dialogue ( signing_msg ) return # handle message if signing_msg . performative is SigningMessage . Performative . SIGNED_TRANSACTION : self . _handle_signed_transaction ( signing_msg , signing_dialogue ) elif signing_msg . performative is SigningMessage . Performative . ERROR : self . _handle_error ( signing_msg , signing_dialogue ) else : self . _handle_invalid ( signing_msg , signing_dialogue ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" def _handle_unidentified_dialogue ( self , signing_msg : SigningMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param signing_msg: the message \"\"\" self . context . logger . info ( \"received invalid signing message= {} , unidentified dialogue.\" . format ( signing_msg ) ) def _handle_signed_transaction ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue \"\"\" self . context . logger . info ( \"transaction signing was successful.\" ) ledger_api_dialogue = signing_dialogue . associated_ledger_api_dialogue last_ledger_api_msg = ledger_api_dialogue . last_incoming_message if last_ledger_api_msg is None : raise ValueError ( \"Could not retrieve last message in ledger api dialogue\" ) ledger_api_msg = ledger_api_dialogue . reply ( performative = LedgerApiMessage . Performative . SEND_SIGNED_TRANSACTION , target_message = last_ledger_api_msg , signed_transaction = signing_msg . signed_transaction , ) self . context . outbox . put_message ( message = ledger_api_msg ) self . context . logger . info ( \"sending transaction to ledger.\" ) def _handle_error ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue \"\"\" self . context . logger . info ( \"transaction signing was not successful. Error_code= {} in dialogue= {} \" . format ( signing_msg . error_code , signing_dialogue ) ) signing_msg_ = cast ( Optional [ SigningMessage ], signing_dialogue . last_outgoing_message ) if ( signing_msg_ is not None and signing_msg_ . performative == SigningMessage . Performative . SIGN_TRANSACTION ): tx_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) ledger_api_dialogue = signing_dialogue . associated_ledger_api_dialogue tx_behaviour . failed_processing ( ledger_api_dialogue ) def _handle_invalid ( self , signing_msg : SigningMessage , signing_dialogue : SigningDialogue ) -> None : \"\"\" Handle an oef search message. :param signing_msg: the signing message :param signing_dialogue: the dialogue \"\"\" self . context . logger . warning ( \"cannot handle signing message of performative= {} in dialogue= {} .\" . format ( signing_msg . performative , signing_dialogue ) ) class GenericLedgerApiHandler ( Handler ): \"\"\"Implement the ledger handler.\"\"\" SUPPORTED_PROTOCOL = LedgerApiMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Implement the setup for the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message \"\"\" ledger_api_msg = cast ( LedgerApiMessage , message ) # recover dialogue ledger_api_dialogues = cast ( LedgerApiDialogues , self . context . ledger_api_dialogues ) ledger_api_dialogue = cast ( Optional [ LedgerApiDialogue ], ledger_api_dialogues . update ( ledger_api_msg ) ) if ledger_api_dialogue is None : self . _handle_unidentified_dialogue ( ledger_api_msg ) return # handle message if ledger_api_msg . performative is LedgerApiMessage . Performative . BALANCE : self . _handle_balance ( ledger_api_msg ) elif ( ledger_api_msg . performative is LedgerApiMessage . Performative . RAW_TRANSACTION ): self . _handle_raw_transaction ( ledger_api_msg , ledger_api_dialogue ) elif ( ledger_api_msg . performative == LedgerApiMessage . Performative . TRANSACTION_DIGEST ): self . _handle_transaction_digest ( ledger_api_msg , ledger_api_dialogue ) elif ( ledger_api_msg . performative == LedgerApiMessage . Performative . TRANSACTION_RECEIPT ): self . _handle_transaction_receipt ( ledger_api_msg , ledger_api_dialogue ) elif ledger_api_msg . performative == LedgerApiMessage . Performative . ERROR : self . _handle_error ( ledger_api_msg , ledger_api_dialogue ) else : self . _handle_invalid ( ledger_api_msg , ledger_api_dialogue ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" def _handle_unidentified_dialogue ( self , ledger_api_msg : LedgerApiMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param ledger_api_msg: the message \"\"\" self . context . logger . info ( \"received invalid ledger_api message= {} , unidentified dialogue.\" . format ( ledger_api_msg ) ) def _handle_balance ( self , ledger_api_msg : LedgerApiMessage ) -> None : \"\"\" Handle a message of balance performative. :param ledger_api_msg: the ledger api message \"\"\" strategy = cast ( GenericStrategy , self . context . strategy ) if ledger_api_msg . balance > 0 : self . context . logger . info ( \"starting balance on {} ledger= {} .\" . format ( strategy . ledger_id , ledger_api_msg . balance , ) ) strategy . balance = ledger_api_msg . balance strategy . is_searching = True else : self . context . logger . warning ( f \"you have no starting balance on { strategy . ledger_id } ledger! Stopping skill { self . skill_id } .\" ) self . context . is_active = False def _handle_raw_transaction ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of raw_transaction performative. :param ledger_api_msg: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . info ( \"received raw transaction= {} \" . format ( ledger_api_msg )) signing_dialogues = cast ( SigningDialogues , self . context . signing_dialogues ) signing_msg , signing_dialogue = signing_dialogues . create ( counterparty = self . context . decision_maker_address , performative = SigningMessage . Performative . SIGN_TRANSACTION , raw_transaction = ledger_api_msg . raw_transaction , terms = ledger_api_dialogue . associated_fipa_dialogue . terms , ) signing_dialogue = cast ( SigningDialogue , signing_dialogue ) signing_dialogue . associated_ledger_api_dialogue = ledger_api_dialogue self . context . decision_maker_message_queue . put_nowait ( signing_msg ) self . context . logger . info ( \"proposing the transaction to the decision maker. Waiting for confirmation ...\" ) def _handle_transaction_digest ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of transaction_digest performative. :param ledger_api_msg: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . info ( \"transaction was successfully submitted. Transaction digest= {} \" . format ( ledger_api_msg . transaction_digest ) ) ledger_api_msg_ = ledger_api_dialogue . reply ( performative = LedgerApiMessage . Performative . GET_TRANSACTION_RECEIPT , target_message = ledger_api_msg , transaction_digest = ledger_api_msg . transaction_digest , ) self . context . logger . info ( \"checking transaction is settled.\" ) self . context . outbox . put_message ( message = ledger_api_msg_ ) def _handle_transaction_receipt ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of balance performative. :param ledger_api_msg: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" fipa_dialogue = ledger_api_dialogue . associated_fipa_dialogue is_settled = LedgerApis . is_transaction_settled ( fipa_dialogue . terms . ledger_id , ledger_api_msg . transaction_receipt . receipt ) tx_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) if is_settled : tx_behaviour . finish_processing ( ledger_api_dialogue ) ledger_api_msg_ = cast ( Optional [ LedgerApiMessage ], ledger_api_dialogue . last_outgoing_message ) if ledger_api_msg_ is None : raise ValueError ( # pragma: nocover \"Could not retrieve last ledger_api message\" ) fipa_msg = cast ( Optional [ FipaMessage ], fipa_dialogue . last_incoming_message ) if fipa_msg is None : raise ValueError ( \"Could not retrieve last fipa message\" ) inform_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . INFORM , target_message = fipa_msg , info = { \"transaction_digest\" : ledger_api_msg_ . transaction_digest . body }, ) self . context . outbox . put_message ( message = inform_msg ) self . context . logger . info ( \"transaction confirmed, informing counterparty= {} of transaction digest.\" . format ( fipa_dialogue . dialogue_label . dialogue_opponent_addr [ - 5 :], ) ) else : tx_behaviour . failed_processing ( ledger_api_dialogue ) self . context . logger . info ( \"transaction_receipt= {} not settled or not valid, aborting\" . format ( ledger_api_msg . transaction_receipt ) ) def _handle_error ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of error performative. :param ledger_api_msg: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . info ( \"received ledger_api error message= {} in dialogue= {} .\" . format ( ledger_api_msg , ledger_api_dialogue ) ) ledger_api_msg_ = cast ( Optional [ LedgerApiMessage ], ledger_api_dialogue . last_outgoing_message ) if ( ledger_api_msg_ is not None and ledger_api_msg_ . performative != LedgerApiMessage . Performative . GET_BALANCE ): tx_behaviour = cast ( GenericTransactionBehaviour , self . context . behaviours . transaction ) tx_behaviour . failed_processing ( ledger_api_dialogue ) def _handle_invalid ( self , ledger_api_msg : LedgerApiMessage , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\" Handle a message of invalid performative. :param ledger_api_msg: the ledger api message :param ledger_api_dialogue: the ledger api dialogue \"\"\" self . context . logger . warning ( \"cannot handle ledger_api message of performative= {} in dialogue= {} .\" . format ( ledger_api_msg . performative , ledger_api_dialogue , ) )","title":"Step 3: Create the handler"},{"location":"aea/generic-skills-step-by-step/#step-4-create-the-strategy_1","text":"We are going to create the strategy that we want our AEA to follow. Rename the my_model.py file (in my_generic_buyer/skills/generic_buyer/ ) to strategy.py and replace the stub code with the following: from typing import Any , Dict , List , Tuple from aea.common import Address from aea.exceptions import enforce from aea.helpers.search.generic import SIMPLE_SERVICE_MODEL from aea.helpers.search.models import ( Constraint , ConstraintType , Description , Location , Query , ) from aea.helpers.transaction.base import Terms from aea.skills.base import Model DEFAULT_IS_LEDGER_TX = True DEFAULT_MAX_UNIT_PRICE = 5 DEFAULT_MAX_TX_FEE = 2 DEFAULT_SERVICE_ID = \"generic_service\" DEFAULT_MIN_QUANTITY = 1 DEFAULT_MAX_QUANTITY = 100 DEFAULT_LOCATION = { \"longitude\" : 0.1270 , \"latitude\" : 51.5194 } DEFAULT_SEARCH_QUERY = { \"search_key\" : \"seller_service\" , \"search_value\" : \"generic_service\" , \"constraint_type\" : \"==\" , } DEFAULT_SEARCH_RADIUS = 5.0 DEFAULT_MAX_NEGOTIATIONS = 2 class GenericStrategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize the strategy of the agent. :param kwargs: keyword arguments \"\"\" ledger_id = kwargs . pop ( \"ledger_id\" , None ) currency_id = kwargs . pop ( \"currency_id\" , None ) self . _is_ledger_tx = kwargs . pop ( \"is_ledger_tx\" , DEFAULT_IS_LEDGER_TX ) self . _max_unit_price = kwargs . pop ( \"max_unit_price\" , DEFAULT_MAX_UNIT_PRICE ) self . _min_quantity = kwargs . pop ( \"min_quantity\" , DEFAULT_MIN_QUANTITY ) self . _max_quantity = kwargs . pop ( \"max_quantity\" , DEFAULT_MAX_QUANTITY ) self . _max_tx_fee = kwargs . pop ( \"max_tx_fee\" , DEFAULT_MAX_TX_FEE ) self . _service_id = kwargs . pop ( \"service_id\" , DEFAULT_SERVICE_ID ) self . _search_query = kwargs . pop ( \"search_query\" , DEFAULT_SEARCH_QUERY ) location = kwargs . pop ( \"location\" , DEFAULT_LOCATION ) self . _agent_location = Location ( latitude = location [ \"latitude\" ], longitude = location [ \"longitude\" ] ) self . _radius = kwargs . pop ( \"search_radius\" , DEFAULT_SEARCH_RADIUS ) self . _max_negotiations = kwargs . pop ( \"max_negotiations\" , DEFAULT_MAX_NEGOTIATIONS ) self . _is_stop_searching_on_result = kwargs . pop ( \"stop_searching_on_result\" , True ) super () . __init__ ( ** kwargs ) self . _ledger_id = ( ledger_id if ledger_id is not None else self . context . default_ledger_id ) if currency_id is None : currency_id = self . context . currency_denominations . get ( self . _ledger_id , None ) enforce ( currency_id is not None , f \"Currency denomination for ledger_id= { self . _ledger_id } not specified.\" , ) self . _currency_id = currency_id self . _is_searching = False self . _balance = 0 Similar to the seller AEA, we initialize the strategy class by trying to read the strategy variables from the YAML file, and if not possible, use some default values. In the following snippet, the two methods after the properties are related to the OEF search service. Add this snippet under the initialization of the strategy class: @property def ledger_id ( self ) -> str : \"\"\"Get the ledger id.\"\"\" return self . _ledger_id @property def is_ledger_tx ( self ) -> bool : \"\"\"Check whether or not tx are settled on a ledger.\"\"\" return self . _is_ledger_tx @property def is_stop_searching_on_result ( self ) -> bool : \"\"\"Check if search is stopped on result.\"\"\" return self . _is_stop_searching_on_result @property def is_searching ( self ) -> bool : \"\"\"Check if the agent is searching.\"\"\" return self . _is_searching @is_searching . setter def is_searching ( self , is_searching : bool ) -> None : \"\"\"Check if the agent is searching.\"\"\" enforce ( isinstance ( is_searching , bool ), \"Can only set bool on is_searching!\" ) self . _is_searching = is_searching @property def balance ( self ) -> int : \"\"\"Get the balance.\"\"\" return self . _balance @balance . setter def balance ( self , balance : int ) -> None : \"\"\"Set the balance.\"\"\" self . _balance = balance @property def max_negotiations ( self ) -> int : \"\"\"Get the maximum number of negotiations the agent can start.\"\"\" return self . _max_negotiations def get_location_and_service_query ( self ) -> Query : \"\"\" Get the location and service query of the agent. :return: the query \"\"\" close_to_my_service = Constraint ( \"location\" , ConstraintType ( \"distance\" , ( self . _agent_location , self . _radius )) ) service_key_filter = Constraint ( self . _search_query [ \"search_key\" ], ConstraintType ( self . _search_query [ \"constraint_type\" ], self . _search_query [ \"search_value\" ], ), ) query = Query ([ close_to_my_service , service_key_filter ],) return query def get_service_query ( self ) -> Query : \"\"\" Get the service query of the agent. :return: the query \"\"\" service_key_filter = Constraint ( self . _search_query [ \"search_key\" ], ConstraintType ( self . _search_query [ \"constraint_type\" ], self . _search_query [ \"search_value\" ], ), ) query = Query ([ service_key_filter ], model = SIMPLE_SERVICE_MODEL ) return query The following code block checks if the proposal that we received is acceptable according to a strategy: def is_acceptable_proposal ( self , proposal : Description ) -> bool : \"\"\" Check whether it is an acceptable proposal. :param proposal: a description :return: whether it is acceptable \"\"\" result = ( all ( [ key in proposal . values for key in [ \"ledger_id\" , \"currency_id\" , \"price\" , \"service_id\" , \"quantity\" , \"tx_nonce\" , ] ] ) and proposal . values [ \"ledger_id\" ] == self . ledger_id and proposal . values [ \"price\" ] > 0 and proposal . values [ \"quantity\" ] >= self . _min_quantity and proposal . values [ \"quantity\" ] <= self . _max_quantity and proposal . values [ \"price\" ] <= proposal . values [ \"quantity\" ] * self . _max_unit_price and proposal . values [ \"currency_id\" ] == self . _currency_id and proposal . values [ \"service_id\" ] == self . _service_id and isinstance ( proposal . values [ \"tx_nonce\" ], str ) and proposal . values [ \"tx_nonce\" ] != \"\" ) return result The is_affordable_proposal method in the following code block checks if we can afford the transaction based on the funds we have in our wallet on the ledger. The rest of the methods are self-explanatory. def is_affordable_proposal ( self , proposal : Description ) -> bool : \"\"\" Check whether it is an affordable proposal. :param proposal: a description :return: whether it is affordable \"\"\" if self . is_ledger_tx : payable = proposal . values . get ( \"price\" , 0 ) + self . _max_tx_fee result = self . balance >= payable else : result = True return result def get_acceptable_counterparties ( self , counterparties : Tuple [ str , ... ] ) -> Tuple [ str , ... ]: \"\"\" Process counterparties and drop unacceptable ones. :param counterparties: a tuple of counterparties :return: list of counterparties \"\"\" valid_counterparties : List [ str ] = [] for idx , counterparty in enumerate ( counterparties ): if idx < self . max_negotiations : valid_counterparties . append ( counterparty ) return tuple ( valid_counterparties ) def terms_from_proposal ( self , proposal : Description , counterparty_address : Address ) -> Terms : \"\"\" Get the terms from a proposal. :param proposal: the proposal :param counterparty_address: the counterparty :return: terms \"\"\" buyer_address = self . context . agent_addresses [ proposal . values [ \"ledger_id\" ]] terms = Terms ( ledger_id = proposal . values [ \"ledger_id\" ], sender_address = buyer_address , counterparty_address = counterparty_address , amount_by_currency_id = { proposal . values [ \"currency_id\" ]: - proposal . values [ \"price\" ] }, quantities_by_good_id = { proposal . values [ \"service_id\" ]: proposal . values [ \"quantity\" ] }, is_sender_payable_tx_fee = True , nonce = proposal . values [ \"tx_nonce\" ], fee_by_currency_id = { proposal . values [ \"currency_id\" ]: self . _max_tx_fee }, ) return terms def successful_trade_with_counterparty ( self , counterparty : str , data : Dict [ str , str ] ) -> None : \"\"\" Do something on successful trade. :param counterparty: the counterparty address :param data: the data \"\"\" def update_search_query_params ( self ) -> None : \"\"\"Update agent location and query for search.\"\"\"","title":"Step 4: Create the strategy"},{"location":"aea/generic-skills-step-by-step/#step-5-create-the-dialogues_1","text":"As mentioned during the creation of the seller AEA, we should keep track of the various interactions an AEA has with others and this is done via dialogues. Create a new file and name it dialogues.py (in my_generic_buyer/skills/generic_buyer/ ). Inside this file add the following code: from typing import Any , Optional , Type from aea.common import Address from aea.exceptions import AEAEnforceError , enforce from aea.helpers.transaction.base import Terms from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.protocols.dialogue.base import DialogueLabel as BaseDialogueLabel from aea.skills.base import Model from packages.fetchai.protocols.default.dialogues import ( DefaultDialogue as BaseDefaultDialogue , ) from packages.fetchai.protocols.default.dialogues import ( DefaultDialogues as BaseDefaultDialogues , ) from packages.fetchai.protocols.fipa.dialogues import FipaDialogue as BaseFipaDialogue from packages.fetchai.protocols.fipa.dialogues import FipaDialogues as BaseFipaDialogues from packages.fetchai.protocols.fipa.message import FipaMessage from packages.fetchai.protocols.ledger_api.dialogues import ( LedgerApiDialogue as BaseLedgerApiDialogue , ) from packages.fetchai.protocols.ledger_api.dialogues import ( LedgerApiDialogues as BaseLedgerApiDialogues , ) from packages.fetchai.protocols.ledger_api.message import LedgerApiMessage from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogue as BaseOefSearchDialogue , ) from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogues as BaseOefSearchDialogues , ) from packages.fetchai.protocols.signing.dialogues import ( SigningDialogue as BaseSigningDialogue , ) from packages.fetchai.protocols.signing.dialogues import ( SigningDialogues as BaseSigningDialogues , ) from packages.fetchai.protocols.signing.message import SigningMessage DefaultDialogue = BaseDefaultDialogue class DefaultDialogues ( Model , BaseDefaultDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return DefaultDialogue . Role . AGENT BaseDefaultDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) class FipaDialogue ( BaseFipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" __slots__ = ( \"_terms\" , \"_associated_ledger_api_dialogue\" , ) def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ FipaMessage ] = FipaMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :param message_class: the message class \"\"\" BaseFipaDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . _terms = None # type: Optional[Terms] @property def terms ( self ) -> Terms : \"\"\"Get terms.\"\"\" if self . _terms is None : raise AEAEnforceError ( \"Terms not set!\" ) return self . _terms @terms . setter def terms ( self , terms : Terms ) -> None : \"\"\"Set terms.\"\"\" enforce ( self . _terms is None , \"Terms already set!\" ) self . _terms = terms class FipaDialogues ( Model , BaseFipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseFipaDialogue . Role . BUYER BaseFipaDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , dialogue_class = FipaDialogue , ) class LedgerApiDialogue ( BaseLedgerApiDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" __slots__ = ( \"_associated_fipa_dialogue\" ,) def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ LedgerApiMessage ] = LedgerApiMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :param message_class: the message class \"\"\" BaseLedgerApiDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . _associated_fipa_dialogue = None # type: Optional[FipaDialogue] @property def associated_fipa_dialogue ( self ) -> FipaDialogue : \"\"\"Get associated_fipa_dialogue.\"\"\" if self . _associated_fipa_dialogue is None : raise AEAEnforceError ( \"FipaDialogue not set!\" ) return self . _associated_fipa_dialogue @associated_fipa_dialogue . setter def associated_fipa_dialogue ( self , fipa_dialogue : FipaDialogue ) -> None : \"\"\"Set associated_fipa_dialogue\"\"\" enforce ( self . _associated_fipa_dialogue is None , \"FipaDialogue already set!\" ) self . _associated_fipa_dialogue = fipa_dialogue class LedgerApiDialogues ( Model , BaseLedgerApiDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseLedgerApiDialogue . Role . AGENT BaseLedgerApiDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , dialogue_class = LedgerApiDialogue , ) OefSearchDialogue = BaseOefSearchDialogue class OefSearchDialogues ( Model , BaseOefSearchDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseOefSearchDialogue . Role . AGENT BaseOefSearchDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , ) class SigningDialogue ( BaseSigningDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" __slots__ = ( \"_associated_ledger_api_dialogue\" ,) def __init__ ( self , dialogue_label : BaseDialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ SigningMessage ] = SigningMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :param message_class: the message class \"\"\" BaseSigningDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . _associated_ledger_api_dialogue = None # type: Optional[LedgerApiDialogue] @property def associated_ledger_api_dialogue ( self ) -> LedgerApiDialogue : \"\"\"Get associated_ledger_api_dialogue.\"\"\" if self . _associated_ledger_api_dialogue is None : raise AEAEnforceError ( \"LedgerApiDialogue not set!\" ) return self . _associated_ledger_api_dialogue @associated_ledger_api_dialogue . setter def associated_ledger_api_dialogue ( self , ledger_api_dialogue : LedgerApiDialogue ) -> None : \"\"\"Set associated_ledger_api_dialogue\"\"\" enforce ( self . _associated_ledger_api_dialogue is None , \"LedgerApiDialogue already set!\" , ) self . _associated_ledger_api_dialogue = ledger_api_dialogue class SigningDialogues ( Model , BaseSigningDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseSigningDialogue . Role . SKILL BaseSigningDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , dialogue_class = SigningDialogue , ) The various dialogues classes in the above code snippet store dialogues with other AEAs, services and components, (e.g. SOEF search node via the fetchai/soef connection, ledgers via the fetchai/ledger connection and the decision maker). They expose useful methods to manipulate these interactions, access previous messages, and enable us to identify possible communications problems between my_generic_seller and my_generic_buyer AEAs.","title":"Step 5: Create the dialogues"},{"location":"aea/generic-skills-step-by-step/#step-6-update-the-yaml-files_1","text":"After making so many changes to our skill, we have to update the skill.yaml configuration file so it reflects our newly created classes, and contains the values used by the strategy. Make sure skill.yaml contains the following configuration: name : generic_buyer author : fetchai version : 0.1.0 type : skill description : The weather client skill implements the skill to purchase weather data. license : Apache-2.0 aea_version : '>=1.0.0, <2.0.0' fingerprint : README.md : QmTR91jm7WfJpmabisy74NR5mc35YXjDU1zQAUKZeHRw8L __init__.py : QmU5vrC8FipyjfS5biNa6qDWdp4aeH5h4YTtbFDmCg8Chj behaviours.py : QmNwvSjEz4kzM3gWtnKbZVFJc2Z85Nb748CWAK4C4Sa4nT dialogues.py : QmNen91qQDWy4bNBKrB3LabAP5iRf29B8iwYss4NB13iNU handlers.py : QmZfudXXbdiREiViuwPZDXoQQyXT2ySQHdF7psQsohZXQy strategy.py : QmcrwaEWvKHDCNti8QjRhB4utJBJn5L8GpD27Uy9zHwKhY fingerprint_ignore_patterns : [] connections : - fetchai/ledger:0.19.0 contracts : [] protocols : - fetchai/default:1.0.0 - fetchai/fipa:1.0.0 - fetchai/ledger_api:1.0.0 - fetchai/oef_search:1.0.0 - fetchai/signing:1.0.0 skills : [] behaviours : search : args : search_interval : 5 class_name : GenericSearchBehaviour transaction : args : max_processing : 420 transaction_interval : 2 class_name : GenericTransactionBehaviour handlers : fipa : args : {} class_name : GenericFipaHandler ledger_api : args : {} class_name : GenericLedgerApiHandler oef_search : args : {} class_name : GenericOefSearchHandler signing : args : {} class_name : GenericSigningHandler models : default_dialogues : args : {} class_name : DefaultDialogues fipa_dialogues : args : {} class_name : FipaDialogues ledger_api_dialogues : args : {} class_name : LedgerApiDialogues oef_search_dialogues : args : {} class_name : OefSearchDialogues signing_dialogues : args : {} class_name : SigningDialogues strategy : args : is_ledger_tx : true location : latitude : 51.5194 longitude : 0.127 max_negotiations : 1 max_tx_fee : 1 max_unit_price : 20 min_quantity : 1 search_query : constraint_type : == search_key : seller_service search_value : generic_service search_radius : 5.0 service_id : generic_service stop_searching_on_result : true class_name : GenericStrategy is_abstract : false dependencies : {} We must pay attention to the models and the strategy\u2019s variables. Here we can change the price we would like to buy each reading at, the maximum transaction fee we are prepared to pay, and so on. Finally, we fingerprint our new skill: aea fingerprint skill fetchai/generic_buyer:0.1.0 This will hash each file and save the hash in the fingerprint. This way, in the future we can easily track if any of the files have changed.","title":"Step 6: Update the YAML files"},{"location":"aea/generic-skills-step-by-step/#run-the-aeas","text":"","title":"Run the AEAs"},{"location":"aea/generic-skills-step-by-step/#create-private-keys","text":"For each AEA, create a private key: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Create private keys"},{"location":"aea/generic-skills-step-by-step/#update-the-aea-configurations","text":"In both AEAs run: aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }'","title":"Update the AEA configurations"},{"location":"aea/generic-skills-step-by-step/#fund-the-buyer-aea","text":"Create some wealth for your buyer on the Fetch.ai testnet (this operation might take a while). aea generate-wealth fetchai --sync","title":"Fund the buyer AEA"},{"location":"aea/generic-skills-step-by-step/#run-seller-aea","text":"Add the remaining packages for the seller AEA, then run it: aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add protocol fetchai/fipa:1.0.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea run Once you see a message of the form To join its network use multiaddr: ['SOME_ADDRESS'] take note of the address.","title":"Run seller AEA"},{"location":"aea/generic-skills-step-by-step/#run-buyer-aea","text":"Add the remaining packages for the buyer AEA: aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add protocol fetchai/fipa:1.0.0 aea add protocol fetchai/signing:1.0.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 Then, update the configuration of the buyer AEA's P2P connection: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' where SOME_ADDRESS is replaced accordingly. Then run the buyer AEA: aea run You will see that the AEAs negotiate and then transact using the StargateWorld testnet.","title":"Run buyer AEA"},{"location":"aea/generic-skills-step-by-step/#delete-the-aeas","text":"When you are done, go up a level and delete the AEAs. cd .. aea delete my_generic_seller aea delete my_generic_buyer","title":"Delete the AEAs"},{"location":"aea/generic-skills-step-by-step/#next-steps","text":"You have completed the \"Getting Started\" series. Congratulations! The following guide provides some hints on AEA development setup .","title":"Next steps"},{"location":"aea/generic-skills-step-by-step/#recommended","text":"We recommend you build your own AEA next. There are many helpful guides and demos in the documentation, and a developer community on Discord . Speak to you there!","title":"Recommended"},{"location":"aea/generic-skills/","text":"The AEA generic buyer and seller skills demonstrate an interaction between two AEAs: An AEA that provides a (data selling) service. An AEA that demands this service. Discussion The scope of this guide is demonstrating how to create easily configurable AEAs. The buyer AEA finds the seller, negotiates the terms of trade, and if successful purchases the data by sending payment. The seller AEA sells the service specified in its skill.yaml file, delivering it to the buyer upon receiving payment. Note that these agents do not utilize a smart contract but interact with a ledger to complete a transaction. Moreover, in this setup, the buyer agent has to trust the seller to send the data upon successful payment. The corresponding packages can be customised to allow for a database or sensor to be defined from which data is loaded. This is done by first modifying the has_data_source variable in skill.yaml file of the generic_seller skill to True . Then you have to provide an implementation for the collect_from_data_source(self) method in the strategy.py file. More detailed instructions is beyond the scope of this guide. Communication The following diagram shows the communication between various entities in this interaction. sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search_agents Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept Buyer_AEA->>Blockchain: transfer_funds Buyer_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions Create the seller AEA First, fetch the seller AEA: aea fetch fetchai/generic_seller:0.28.0 --alias my_seller_aea cd my_seller_aea aea install aea build Alternatively, create from scratch. The following steps create the seller from scratch: aea create my_seller_aea cd my_seller_aea aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/generic_seller:0.27.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build Create the buyer AEA Then, in another terminal fetch the buyer AEA: aea fetch fetchai/generic_buyer:0.29.0 --alias my_buyer_aea cd my_buyer_aea aea install aea build Alternatively, create from scratch. The following steps create the buyer from scratch: aea create my_buyer_aea cd my_buyer_aea aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/generic_buyer:0.26.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build Add keys for the seller AEA Create the private key for the seller AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Add keys and generate wealth for the buyer AEA The buyer needs to have some wealth to purchase the data from the seller. First, create the private key for the buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your buyer based on the network you want to transact with. On the Fetch.ai StargateWorld network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Update the skill configurations The default skill configurations assume that the transaction is settled against the Fetch.ai ledger. In the generic seller's skill configuration file ( my_seller_aea/vendor/fetchai/skills/generi_seller/skill.yaml ) the data_for_sale is the data the seller AEA is offering for sale. In the following case, this is a one item dictionary where key is generic and value is data . Furthermore, the service_data is used to register the seller's service in the SOEF search node and make your agent discoverable. models : ... strategy : args : currency_id : FET data_for_sale : generic : data has_data_source : false is_ledger_tx : true ledger_id : fetchai location : latitude : 51.5194 longitude : 0.127 service_data : key : seller_service value : generic_service service_id : generic_service unit_price : 10 class_name : GenericStrategy The generic buyer skill configuration file ( my_buyer_aea/vendor/fetchai/skills/generic_buyer/skill.yaml ) includes the search_query which has to match the service_data of the seller. models : ... strategy : args : currency_id : FET is_ledger_tx : true ledger_id : fetchai location : latitude : 51.5194 longitude : 0.127 max_negotiations : 1 max_tx_fee : 1 max_unit_price : 20 search_query : constraint_type : == search_key : seller_service search_value : generic_service search_radius : 5.0 service_id : generic_service class_name : GenericStrategy Update the skill configurations Both skills are abstract skills, make them instantiable: cd my_seller_aea aea config set vendor.fetchai.skills.generic_seller.is_abstract false --type bool cd my_buyer_aea aea config set vendor.fetchai.skills.generic_buyer.is_abstract false --type bool Run the AEAs First, run the seller AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of this address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the seller. Then, configure the buyer to connect to this same local ACN by running the following command in the buyer terminal, replacing SOME_ADDRESS with the value you noted above: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Then run the buyer AEA: aea run You will see that the AEAs negotiate and then transact using the Fetch.ai testnet. Delete the AEAs When you're done, stop the agents ( CTRL+C ), go up a level and delete the AEAs. cd .. aea delete my_seller_aea aea delete my_buyer_aea","title":"Generic skills"},{"location":"aea/generic-skills/#discussion","text":"The scope of this guide is demonstrating how to create easily configurable AEAs. The buyer AEA finds the seller, negotiates the terms of trade, and if successful purchases the data by sending payment. The seller AEA sells the service specified in its skill.yaml file, delivering it to the buyer upon receiving payment. Note that these agents do not utilize a smart contract but interact with a ledger to complete a transaction. Moreover, in this setup, the buyer agent has to trust the seller to send the data upon successful payment. The corresponding packages can be customised to allow for a database or sensor to be defined from which data is loaded. This is done by first modifying the has_data_source variable in skill.yaml file of the generic_seller skill to True . Then you have to provide an implementation for the collect_from_data_source(self) method in the strategy.py file. More detailed instructions is beyond the scope of this guide.","title":"Discussion"},{"location":"aea/generic-skills/#communication","text":"The following diagram shows the communication between various entities in this interaction. sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search_agents Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept Buyer_AEA->>Blockchain: transfer_funds Buyer_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/generic-skills/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/generic-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/generic-skills/#demo-instructions","text":"","title":"Demo instructions"},{"location":"aea/generic-skills/#create-the-seller-aea","text":"First, fetch the seller AEA: aea fetch fetchai/generic_seller:0.28.0 --alias my_seller_aea cd my_seller_aea aea install aea build Alternatively, create from scratch. The following steps create the seller from scratch: aea create my_seller_aea cd my_seller_aea aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/generic_seller:0.27.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build","title":"Create the seller AEA"},{"location":"aea/generic-skills/#create-the-buyer-aea","text":"Then, in another terminal fetch the buyer AEA: aea fetch fetchai/generic_buyer:0.29.0 --alias my_buyer_aea cd my_buyer_aea aea install aea build Alternatively, create from scratch. The following steps create the buyer from scratch: aea create my_buyer_aea cd my_buyer_aea aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/generic_buyer:0.26.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build","title":"Create the buyer AEA"},{"location":"aea/generic-skills/#add-keys-for-the-seller-aea","text":"Create the private key for the seller AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for the seller AEA"},{"location":"aea/generic-skills/#add-keys-and-generate-wealth-for-the-buyer-aea","text":"The buyer needs to have some wealth to purchase the data from the seller. First, create the private key for the buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your buyer based on the network you want to transact with. On the Fetch.ai StargateWorld network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys and generate wealth for the buyer AEA"},{"location":"aea/generic-skills/#update-the-skill-configurations","text":"The default skill configurations assume that the transaction is settled against the Fetch.ai ledger. In the generic seller's skill configuration file ( my_seller_aea/vendor/fetchai/skills/generi_seller/skill.yaml ) the data_for_sale is the data the seller AEA is offering for sale. In the following case, this is a one item dictionary where key is generic and value is data . Furthermore, the service_data is used to register the seller's service in the SOEF search node and make your agent discoverable. models : ... strategy : args : currency_id : FET data_for_sale : generic : data has_data_source : false is_ledger_tx : true ledger_id : fetchai location : latitude : 51.5194 longitude : 0.127 service_data : key : seller_service value : generic_service service_id : generic_service unit_price : 10 class_name : GenericStrategy The generic buyer skill configuration file ( my_buyer_aea/vendor/fetchai/skills/generic_buyer/skill.yaml ) includes the search_query which has to match the service_data of the seller. models : ... strategy : args : currency_id : FET is_ledger_tx : true ledger_id : fetchai location : latitude : 51.5194 longitude : 0.127 max_negotiations : 1 max_tx_fee : 1 max_unit_price : 20 search_query : constraint_type : == search_key : seller_service search_value : generic_service search_radius : 5.0 service_id : generic_service class_name : GenericStrategy","title":"Update the skill configurations"},{"location":"aea/generic-skills/#update-the-skill-configurations_1","text":"Both skills are abstract skills, make them instantiable: cd my_seller_aea aea config set vendor.fetchai.skills.generic_seller.is_abstract false --type bool cd my_buyer_aea aea config set vendor.fetchai.skills.generic_buyer.is_abstract false --type bool","title":"Update the skill configurations"},{"location":"aea/generic-skills/#run-the-aeas","text":"First, run the seller AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of this address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the seller. Then, configure the buyer to connect to this same local ACN by running the following command in the buyer terminal, replacing SOME_ADDRESS with the value you noted above: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Then run the buyer AEA: aea run You will see that the AEAs negotiate and then transact using the Fetch.ai testnet.","title":"Run the AEAs"},{"location":"aea/generic-skills/#delete-the-aeas","text":"When you're done, stop the agents ( CTRL+C ), go up a level and delete the AEAs. cd .. aea delete my_seller_aea aea delete my_buyer_aea","title":"Delete the AEAs"},{"location":"aea/generic-storage/","text":"The AEA generic storage: description and usage. AEA Generic Storage AEA generic storage allows AEA skill's components to store data permanently and use it any time. The primary scenario: to save AEA data on shutdown and load back on startup. Generic storage provides an API for general data manipulation in key-object style. Configuration Storage is enabled by providing in the agent configuration ( aea-config.yaml ) an optional storage_uri . The storage URI consists of the backend name and string data provided to selected backend. The storage URI schema is <BACKEND_NAME>://[Optional string] Example: storage_uri: sqlite://./some_file.db tells the AEA to use SQLite backend and store data in ./some_file.db . Supported backends: * SQLite - bundled with python simple SQL engine that uses file or in-memory storage. Dialogues and Storage integration One of the most useful cases is the integration of the dialogues subsystem and storage. It helps maintain dialogues state during agent restarts and reduced memory requirements due to the offloading feature. Keep terminal state dialogues The Dialogues class has the optional boolean argument keep_terminal_state_dialogues which specifies whether a dialogue which has reached its terminal state is kept in memory or not. If keep_terminal_state_dialogues is False , dialogues that reach a terminal state are removed from memory and can not be used any more. If keep_terminal_state_dialogues is True , dialogues that reach a terminal state are kept in memory or storage (if configured). If storage is configured, all dialogues in memory are stored on agent stop and restored on agent start. It useful to save memory with dialogues that are in terminal state and probably will be never used again. Default behaviour on keep terminals state dialogues is set according to the protocol specification but can be set explicitly with skill configuration section. Skill configuration to keep terminated dialogues for DefaultDialogues . Example: Dialogues dump/restore on agent restart If storage is enabled then all the dialogues present in memory will be stored on agent's teardown and loaded on agent's start. Offload terminal state dialogues If keep options is set and storage is available dialogues in terminal state will be dumped to generic storage and removed from memory. This option helps to save memory and handle terminated dialogues with the same functionality as when they are kept in memory. All the active dialogues will be stored and loaded during agent restart. All the terminated offloaded dialogues will stay in storage on agent restart. To enable dialogues offloading keep_terminal_state_dialogues has to be enabled and storage configured. Manual usage with skill components Handlers, Behaviours and Models are able to use storage if enabled. Storage is available with skill context: self.context.storage if self.context.storage is not None, storage is enabled and ready to use. Generic storage consists of two parts: objects and collections. Objects consist of the object_id (unique string) and object body. The object body is any JSON friendly python data type: list , dict , int , float , string , bool . Collection is a group of the objects, objects data types can vary in the same collection. Collection name is name consists of letters, numbers and _ . To get/put specific object collection instance should be used. my_collection = self . context . storage . get_sync_connection ( 'my_collection' ) Collection instance provide set of methods to handle data objects. List of collection methods: def put ( self , object_id : str , object_body : JSON_TYPES ) -> None : \"\"\" Put object into collection. :param object_id: str object id :param object_body: python dict, json compatible. :return: None \"\"\" def get ( self , object_id : str ) -> Optional [ JSON_TYPES ]: \"\"\" Get object from the collection. :param object_id: str object id :return: dict if object exists in collection otherwise None \"\"\" def remove ( self , object_id : str ) -> None : \"\"\" Remove object from the collection. :param object_id: str object id :return: None \"\"\" def find ( self , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ]: \"\"\" Get objects from the collection by filtering by field value. :param field: field name to search: example \"parent.field\" :param equals: value field should be equal to :return: List of object bodies \"\"\" def list ( self ) -> List [ OBJECT_ID_AND_BODY ]: \"\"\" List all objects with keys from the collection. :return: Tuple of objects keys, bodies. \"\"\" Simple behaviour example: It saves the datetime string of the first act and print it to stdout. class TestBehaviour ( TickerBehaviour ): \"\"\"Simple behaviour to count how many acts were called.\"\"\" def setup ( self ) -> None : \"\"\"Set up behaviour.\"\"\" def act ( self ) -> None : \"\"\"Make an action.\"\"\" if not ( self . context . storage and self . context . storage . is_connected ): return collection = self . context . storage . get_sync_collection ( 'my_collection' ) first_call_datetime = collection . get ( \"first_call_ts\" ) if not first_call_ts : # there is no object with \"first_call_ts\" id. first_call_datetime = str ( datetime . datetime . now ()) col . put ( first_call_ts , first_call_datetime ) print ( \"Act was called for the first time on:\" , first_call_datetime ) Please, pay attention: datetime object is not JSON friendly and can not be stored directly. it should be transformed to timestamp or string before put into the storage.","title":"Generic Storage"},{"location":"aea/generic-storage/#aea-generic-storage","text":"AEA generic storage allows AEA skill's components to store data permanently and use it any time. The primary scenario: to save AEA data on shutdown and load back on startup. Generic storage provides an API for general data manipulation in key-object style.","title":"AEA Generic Storage"},{"location":"aea/generic-storage/#configuration","text":"Storage is enabled by providing in the agent configuration ( aea-config.yaml ) an optional storage_uri . The storage URI consists of the backend name and string data provided to selected backend. The storage URI schema is <BACKEND_NAME>://[Optional string] Example: storage_uri: sqlite://./some_file.db tells the AEA to use SQLite backend and store data in ./some_file.db . Supported backends: * SQLite - bundled with python simple SQL engine that uses file or in-memory storage.","title":"Configuration"},{"location":"aea/generic-storage/#dialogues-and-storage-integration","text":"One of the most useful cases is the integration of the dialogues subsystem and storage. It helps maintain dialogues state during agent restarts and reduced memory requirements due to the offloading feature.","title":"Dialogues and Storage integration"},{"location":"aea/generic-storage/#keep-terminal-state-dialogues","text":"The Dialogues class has the optional boolean argument keep_terminal_state_dialogues which specifies whether a dialogue which has reached its terminal state is kept in memory or not. If keep_terminal_state_dialogues is False , dialogues that reach a terminal state are removed from memory and can not be used any more. If keep_terminal_state_dialogues is True , dialogues that reach a terminal state are kept in memory or storage (if configured). If storage is configured, all dialogues in memory are stored on agent stop and restored on agent start. It useful to save memory with dialogues that are in terminal state and probably will be never used again. Default behaviour on keep terminals state dialogues is set according to the protocol specification but can be set explicitly with skill configuration section. Skill configuration to keep terminated dialogues for DefaultDialogues . Example:","title":"Keep terminal state dialogues"},{"location":"aea/generic-storage/#dialogues-dumprestore-on-agent-restart","text":"If storage is enabled then all the dialogues present in memory will be stored on agent's teardown and loaded on agent's start.","title":"Dialogues dump/restore on agent restart"},{"location":"aea/generic-storage/#offload-terminal-state-dialogues","text":"If keep options is set and storage is available dialogues in terminal state will be dumped to generic storage and removed from memory. This option helps to save memory and handle terminated dialogues with the same functionality as when they are kept in memory. All the active dialogues will be stored and loaded during agent restart. All the terminated offloaded dialogues will stay in storage on agent restart. To enable dialogues offloading keep_terminal_state_dialogues has to be enabled and storage configured.","title":"Offload terminal state dialogues"},{"location":"aea/generic-storage/#manual-usage-with-skill-components","text":"Handlers, Behaviours and Models are able to use storage if enabled. Storage is available with skill context: self.context.storage if self.context.storage is not None, storage is enabled and ready to use. Generic storage consists of two parts: objects and collections. Objects consist of the object_id (unique string) and object body. The object body is any JSON friendly python data type: list , dict , int , float , string , bool . Collection is a group of the objects, objects data types can vary in the same collection. Collection name is name consists of letters, numbers and _ . To get/put specific object collection instance should be used. my_collection = self . context . storage . get_sync_connection ( 'my_collection' ) Collection instance provide set of methods to handle data objects. List of collection methods: def put ( self , object_id : str , object_body : JSON_TYPES ) -> None : \"\"\" Put object into collection. :param object_id: str object id :param object_body: python dict, json compatible. :return: None \"\"\" def get ( self , object_id : str ) -> Optional [ JSON_TYPES ]: \"\"\" Get object from the collection. :param object_id: str object id :return: dict if object exists in collection otherwise None \"\"\" def remove ( self , object_id : str ) -> None : \"\"\" Remove object from the collection. :param object_id: str object id :return: None \"\"\" def find ( self , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ]: \"\"\" Get objects from the collection by filtering by field value. :param field: field name to search: example \"parent.field\" :param equals: value field should be equal to :return: List of object bodies \"\"\" def list ( self ) -> List [ OBJECT_ID_AND_BODY ]: \"\"\" List all objects with keys from the collection. :return: Tuple of objects keys, bodies. \"\"\" Simple behaviour example: It saves the datetime string of the first act and print it to stdout. class TestBehaviour ( TickerBehaviour ): \"\"\"Simple behaviour to count how many acts were called.\"\"\" def setup ( self ) -> None : \"\"\"Set up behaviour.\"\"\" def act ( self ) -> None : \"\"\"Make an action.\"\"\" if not ( self . context . storage and self . context . storage . is_connected ): return collection = self . context . storage . get_sync_collection ( 'my_collection' ) first_call_datetime = collection . get ( \"first_call_ts\" ) if not first_call_ts : # there is no object with \"first_call_ts\" id. first_call_datetime = str ( datetime . datetime . now ()) col . put ( first_call_ts , first_call_datetime ) print ( \"Act was called for the first time on:\" , first_call_datetime ) Please, pay attention: datetime object is not JSON friendly and can not be stored directly. it should be transformed to timestamp or string before put into the storage.","title":"Manual usage with skill components"},{"location":"aea/glossary/","text":"This glossary defines a number of terms commonly used across the documentation. For the definitions of framework components consult the API docs. AEA (Autonomous Economic Agent) : An AEA is \"an intelligent agent acting on an owner's behalf, with limited or no interference, and whose goal is to generate economic value to its owner\". AEAs are a special type of agent. [ more ] Software Agent : a software agent is a computer program that acts on behalf of an entity (e.g. individual, organisation, business). [ more ] sOEF (Simple Open Economic Framework) : The simple-OEF, or sOEF, is a search and discovery service for autonomous economic agents. [ more ] ACN (Agent Communication Network) : The ACN is a peer-to-peer communication network for autonomous economic agents. [ more ]","title":"Glossary"},{"location":"aea/gym-example/","text":"The gym example demonstrates the AEA framework's flexibility with respect to Reinforcement Learning using OpenAI's gym framework. Discussion There is no immediate use case for this example as you can train an RL agent without the AEA proxy layer just fine (and faster). However, the example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Download the necessary directories into your working directory: svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/packages Install the gym and numpy library. pip install numpy gym Demo instructions Run the example python examples/gym_ex/train.py Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how train.py demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment! from gyms.env import BanditNArmedRandom from proxy.env import ProxyEnv from rl.agent import RLAgent if __name__ == \"__main__\" : NB_GOODS = 10 NB_PRICES_PER_GOOD = 100 NB_STEPS = 4000 # Use any gym.Env compatible environment: gym_env = BanditNArmedRandom ( nb_bandits = NB_GOODS , nb_prices_per_bandit = NB_PRICES_PER_GOOD ) # Pass the gym environment to a proxy environment: proxy_env = ProxyEnv ( gym_env ) # Use any RL agent compatible with the gym environment and call the fit method: rl_agent = RLAgent ( nb_goods = NB_GOODS ) rl_agent . fit ( env = proxy_env , nb_steps = NB_STEPS )","title":"Gym example"},{"location":"aea/gym-example/#discussion","text":"There is no immediate use case for this example as you can train an RL agent without the AEA proxy layer just fine (and faster). However, the example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities.","title":"Discussion"},{"location":"aea/gym-example/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/gym-example/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start. Download the necessary directories into your working directory: svn export https://github.com/fetchai/agents-aea.git/trunk/examples svn export https://github.com/fetchai/agents-aea.git/trunk/packages Install the gym and numpy library. pip install numpy gym","title":"Dependencies"},{"location":"aea/gym-example/#demo-instructions","text":"","title":"Demo instructions"},{"location":"aea/gym-example/#run-the-example","text":"python examples/gym_ex/train.py Notice the usual RL setup, i.e. the fit method of the RL agent has the typical signature and a familiar implementation. Note how train.py demonstrates how easy it is to use an AEA agent as a proxy layer between an OpenAI gym.Env and a standard RL agent. It is just one line of code to introduce the proxy agent and proxy environment! from gyms.env import BanditNArmedRandom from proxy.env import ProxyEnv from rl.agent import RLAgent if __name__ == \"__main__\" : NB_GOODS = 10 NB_PRICES_PER_GOOD = 100 NB_STEPS = 4000 # Use any gym.Env compatible environment: gym_env = BanditNArmedRandom ( nb_bandits = NB_GOODS , nb_prices_per_bandit = NB_PRICES_PER_GOOD ) # Pass the gym environment to a proxy environment: proxy_env = ProxyEnv ( gym_env ) # Use any RL agent compatible with the gym environment and call the fit method: rl_agent = RLAgent ( nb_goods = NB_GOODS ) rl_agent . fit ( env = proxy_env , nb_steps = NB_STEPS )","title":"Run the example"},{"location":"aea/gym-skill/","text":"The AEA gym skill demonstrates how a custom Reinforcement Learning agent, that uses OpenAI's gym library, may be embedded into an AEA skill and connection. Discussion The gym skills demonstrate how to wrap a Reinforcement Learning agent in a skill. The example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions Create the AEA First, fetch the gym AEA: aea fetch fetchai/gym_aea:0.25.0 --alias my_gym_aea cd my_gym_aea aea install Alternatively, create from scratch. ### Create the AEA In the root directory, create the gym AEA and enter the project. aea create my_gym_aea cd my_gym_aea ### Add the gym skill aea add skill fetchai/gym:0.20.0 ### Set gym connection as default aea config set agent.default_connection fetchai/gym:0.19.0 ### Install the skill dependencies To install the `gym` package, a dependency of the gym skill, from PyPI run aea install Set up the training environment Copy the gym environment to the AEA directory mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/ Update the connection configuration aea config set vendor.fetchai.connections.gym.config.env 'gyms.env.BanditNArmedRandom' Create and add a private key aea generate-key fetchai aea add-key fetchai Run the AEA with the gym connection aea run You will see the gym training logs. Delete the AEA When you're done, you can go up a level and delete the AEA. cd .. aea delete my_gym_aea Communication This diagram shows the communication between the AEA and the gym environment sequenceDiagram participant AEA participant Environment activate AEA activate Environment AEA->>Environment: reset loop learn AEA->>Environment: act Environment->>AEA: percept end AEA->>Environment: close deactivate AEA deactivate Environment Skill Architecture The skill consists of two core components: GymHandler and GymTask . In the setup method of the GymHandler the GymTask is initialized, as well as its setup and execute methods called. The handler, which is registered against the GymMessage.protocol_id then filters for messages of that protocol with the performative GymMessage.Performative.PERCEPT . These messages are passed to the proxy_env_queue of the task. The GymTask is responsible for training the RL agent. In particular, MyRLAgent is initialized and trained against ProxyEnv . The ProxyEnv instantiates a gym.Env class and therefore implements its API. This means the proxy environment is compatible with any gym compatible RL agent. However, unlike other environments it only acts as a proxy and does not implement an environment of its own. It allows for the decoupling of the process environment of the gym.env from the process environment of the RL agent. The actual gym.env against which the agent is trained is wrapped by the gym connection. The proxy environment and gym connection communicate via a protocol, the gym protocol. Note, it would trivially be possible to implement the gym environment in another AEA; this way one AEA could provide gym environments as a service. Naturally, the overhead created by the introduction of the extra layers causes a higher latency when training the RL agent. In this particular skill, which chiefly serves for demonstration purposes, we implement a very basic RL agent. The agent trains a model of price of n goods: it aims to discover the most likely price of each good. To this end, the agent randomly selects one of the n goods on each training step and then chooses as an action the price which it deems is most likely accepted. Each good is represented by an id and the possible price range [1,100] divided into 100 integer bins. For each price bin, a PriceBandit is created which models the likelihood of this price. In particular, a price bandit maintains a beta distribution . The beta distribution is initialized to the uniform distribution. Each time the price associated with a given PriceBandit is accepted or rejected the distribution maintained by the PriceBandit is updated. For each good, the agent can therefore over time learn which price is most likely. The illustration shows how the RL agent only interacts with the proxy environment by sending it action (A) and receiving observation (O) , reward (R) , done (D) and info (I) .","title":"Gym skill"},{"location":"aea/gym-skill/#discussion","text":"The gym skills demonstrate how to wrap a Reinforcement Learning agent in a skill. The example decouples the RL agent from the gym.Env allowing them to run in separate execution environments, potentially owned by different entities.","title":"Discussion"},{"location":"aea/gym-skill/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/gym-skill/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/gym-skill/#demo-instructions","text":"","title":"Demo instructions"},{"location":"aea/gym-skill/#create-the-aea","text":"First, fetch the gym AEA: aea fetch fetchai/gym_aea:0.25.0 --alias my_gym_aea cd my_gym_aea aea install Alternatively, create from scratch. ### Create the AEA In the root directory, create the gym AEA and enter the project. aea create my_gym_aea cd my_gym_aea ### Add the gym skill aea add skill fetchai/gym:0.20.0 ### Set gym connection as default aea config set agent.default_connection fetchai/gym:0.19.0 ### Install the skill dependencies To install the `gym` package, a dependency of the gym skill, from PyPI run aea install","title":"Create the AEA"},{"location":"aea/gym-skill/#set-up-the-training-environment","text":"","title":"Set up the training environment"},{"location":"aea/gym-skill/#copy-the-gym-environment-to-the-aea-directory","text":"mkdir gyms cp -a ../examples/gym_ex/gyms/. gyms/","title":"Copy the gym environment to the AEA directory"},{"location":"aea/gym-skill/#update-the-connection-configuration","text":"aea config set vendor.fetchai.connections.gym.config.env 'gyms.env.BanditNArmedRandom'","title":"Update the connection configuration"},{"location":"aea/gym-skill/#create-and-add-a-private-key","text":"aea generate-key fetchai aea add-key fetchai","title":"Create and add a private key"},{"location":"aea/gym-skill/#run-the-aea-with-the-gym-connection","text":"aea run You will see the gym training logs.","title":"Run the AEA with the gym connection"},{"location":"aea/gym-skill/#delete-the-aea","text":"When you're done, you can go up a level and delete the AEA. cd .. aea delete my_gym_aea","title":"Delete the AEA"},{"location":"aea/gym-skill/#communication","text":"This diagram shows the communication between the AEA and the gym environment sequenceDiagram participant AEA participant Environment activate AEA activate Environment AEA->>Environment: reset loop learn AEA->>Environment: act Environment->>AEA: percept end AEA->>Environment: close deactivate AEA deactivate Environment","title":"Communication"},{"location":"aea/gym-skill/#skill-architecture","text":"The skill consists of two core components: GymHandler and GymTask . In the setup method of the GymHandler the GymTask is initialized, as well as its setup and execute methods called. The handler, which is registered against the GymMessage.protocol_id then filters for messages of that protocol with the performative GymMessage.Performative.PERCEPT . These messages are passed to the proxy_env_queue of the task. The GymTask is responsible for training the RL agent. In particular, MyRLAgent is initialized and trained against ProxyEnv . The ProxyEnv instantiates a gym.Env class and therefore implements its API. This means the proxy environment is compatible with any gym compatible RL agent. However, unlike other environments it only acts as a proxy and does not implement an environment of its own. It allows for the decoupling of the process environment of the gym.env from the process environment of the RL agent. The actual gym.env against which the agent is trained is wrapped by the gym connection. The proxy environment and gym connection communicate via a protocol, the gym protocol. Note, it would trivially be possible to implement the gym environment in another AEA; this way one AEA could provide gym environments as a service. Naturally, the overhead created by the introduction of the extra layers causes a higher latency when training the RL agent. In this particular skill, which chiefly serves for demonstration purposes, we implement a very basic RL agent. The agent trains a model of price of n goods: it aims to discover the most likely price of each good. To this end, the agent randomly selects one of the n goods on each training step and then chooses as an action the price which it deems is most likely accepted. Each good is represented by an id and the possible price range [1,100] divided into 100 integer bins. For each price bin, a PriceBandit is created which models the likelihood of this price. In particular, a price bandit maintains a beta distribution . The beta distribution is initialized to the uniform distribution. Each time the price associated with a given PriceBandit is accepted or rejected the distribution maintained by the PriceBandit is updated. For each good, the agent can therefore over time learn which price is most likely. The illustration shows how the RL agent only interacts with the proxy environment by sending it action (A) and receiving observation (O) , reward (R) , done (D) and info (I) .","title":"Skill Architecture"},{"location":"aea/http-connection-and-skill/","text":"Description The HTTP client and HTTP server connections enable an AEA to communicate with external servers, respectively clients, via HTTP. The HTTP client connection receives request envelops from an agent's skill, translates each into an HTTP request and sends it to a server external to the agent. If it receives an HTTP response from the server within a timeout window, it translates it into a response envelope, and sends this back to the relevant skill inside the agent. The HTTP server connection allows you to run a server inside the connection itself which accepts requests from clients external to the agent. The HTTP server connection validates requests it receives against a provided OpenAPI file. It translates each valid request into an envelope and sends it to the skill specified in the connections configuration. If it receives a valid response envelope from the skill within a timeout window, the connection translates the response envelope into an HTTP response and serves it to the client. HTTP Client The fetchai/simple_data_request:0.13.0 skill demonstrates a simple use case of the HTTP Client connection. The HttpRequestBehaviour in behaviours.py periodically sends HTTP envelops to the HTTP client connection. Its act() method, periodically called, simply calls _generate_http_request which contains the logic for enqueueing an HTTP request envelop. The HttpHandler in handler.py is a basic handler for dealing with HTTP response envelops received from the HTTP client connection. In the handle() method, the responses are dealt with by the private _handle_response method which essentially logs the response and adds the body of the response into the skill's shared state. HTTP Server Create a new AEA: aea create my_aea cd my_aea Add the http server connection package: aea add connection fetchai/http_server:0.22.0 Update the default connection: aea config set agent.default_connection fetchai/http_server:0.22.0 Modify the api_spec_path : aea config set vendor.fetchai.connections.http_server.config.api_spec_path \"../examples/http_ex/petstore.yaml\" Ensure the file exists under the specified path! Create and add a private key: aea generate-key fetchai aea add-key fetchai Install the dependencies: aea install Write and add your skill: aea scaffold skill http_echo You can implement a simple http echo skill (modelled after the standard echo skill) which prints out the content of received messages and responds with success. First, delete the my_model.py and behaviour.py files (in my_aea/skills/http_echo/ ). The server will be purely reactive, so you only need the handlers.py file, and the dialogues.py to record the state of the dialogues. Update skill.yaml accordingly, so set models: {} and behaviours: {} . Next implement a basic handler which prints the received envelopes and responds. Then, replace the content of handlers.py with the following code snippet, after having replaced the placeholder YOUR_USERNAME with the author username (i.e. the output of aea config get agent.author ): import json from typing import cast from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.default import DefaultMessage from packages.fetchai.protocols.http.message import HttpMessage from packages.YOUR_USERNAME.skills.http_echo.dialogues import ( DefaultDialogues , HttpDialogue , HttpDialogues , ) class HttpHandler ( Handler ): \"\"\"This implements the echo handler.\"\"\" SUPPORTED_PROTOCOL = HttpMessage . protocol_id def setup ( self ) -> None : \"\"\"Implement the setup.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to an envelope. :param message: the message \"\"\" http_msg = cast ( HttpMessage , message ) # recover dialogue http_dialogues = cast ( HttpDialogues , self . context . http_dialogues ) http_dialogue = cast ( HttpDialogue , http_dialogues . update ( http_msg )) if http_dialogue is None : self . _handle_unidentified_dialogue ( http_msg ) return # handle message if http_msg . performative == HttpMessage . Performative . REQUEST : self . _handle_request ( http_msg , http_dialogue ) else : self . _handle_invalid ( http_msg , http_dialogue ) def _handle_unidentified_dialogue ( self , http_msg : HttpMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param http_msg: the message \"\"\" self . context . logger . info ( \"received invalid http message= {} , unidentified dialogue.\" . format ( http_msg ) ) default_dialogues = cast ( DefaultDialogues , self . context . default_dialogues ) default_msg , _ = default_dialogues . create ( counterparty = http_msg . sender , performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE , error_msg = \"Invalid dialogue.\" , error_data = { \"http_message\" : http_msg . encode ()}, ) self . context . outbox . put_message ( message = default_msg ) def _handle_request ( self , http_msg : HttpMessage , http_dialogue : HttpDialogue ) -> None : \"\"\" Handle a Http request. :param http_msg: the http message :param http_dialogue: the http dialogue \"\"\" self . context . logger . info ( \"received http request with method= {} , url= {} and body= {!r} \" . format ( http_msg . method , http_msg . url , http_msg . body , ) ) if http_msg . method == \"get\" : self . _handle_get ( http_msg , http_dialogue ) elif http_msg . method == \"post\" : self . _handle_post ( http_msg , http_dialogue ) def _handle_get ( self , http_msg : HttpMessage , http_dialogue : HttpDialogue ) -> None : \"\"\" Handle a Http request of verb GET. :param http_msg: the http message :param http_dialogue: the http dialogue \"\"\" http_response = http_dialogue . reply ( performative = HttpMessage . Performative . RESPONSE , target_message = http_msg , version = http_msg . version , status_code = 200 , status_text = \"Success\" , headers = http_msg . headers , body = json . dumps ({ \"tom\" : { \"type\" : \"cat\" , \"age\" : 10 }}) . encode ( \"utf-8\" ), ) self . context . logger . info ( \"responding with: {} \" . format ( http_response )) self . context . outbox . put_message ( message = http_response ) def _handle_post ( self , http_msg : HttpMessage , http_dialogue : HttpDialogue ) -> None : \"\"\" Handle a Http request of verb POST. :param http_msg: the http message :param http_dialogue: the http dialogue \"\"\" http_response = http_dialogue . reply ( performative = HttpMessage . Performative . RESPONSE , target_message = http_msg , version = http_msg . version , status_code = 200 , status_text = \"Success\" , headers = http_msg . headers , body = http_msg . body , ) self . context . logger . info ( \"responding with: {} \" . format ( http_response )) self . context . outbox . put_message ( message = http_response ) def _handle_invalid ( self , http_msg : HttpMessage , http_dialogue : HttpDialogue ) -> None : \"\"\" Handle an invalid http message. :param http_msg: the http message :param http_dialogue: the http dialogue \"\"\" self . context . logger . warning ( \"cannot handle http message of performative= {} in dialogue= {} .\" . format ( http_msg . performative , http_dialogue ) ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" Moreover, add a dialogues.py file with the following code: from typing import Any from aea.protocols.base import Address , Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.skills.base import Model from packages.fetchai.protocols.default.dialogues import ( DefaultDialogue as BaseDefaultDialogue , ) from packages.fetchai.protocols.default.dialogues import ( DefaultDialogues as BaseDefaultDialogues , ) from packages.fetchai.protocols.http.dialogues import HttpDialogue as BaseHttpDialogue from packages.fetchai.protocols.http.dialogues import HttpDialogues as BaseHttpDialogues DefaultDialogue = BaseDefaultDialogue class DefaultDialogues ( Model , BaseDefaultDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return DefaultDialogue . Role . AGENT BaseDefaultDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) HttpDialogue = BaseHttpDialogue class HttpDialogues ( Model , BaseHttpDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseHttpDialogue . Role . SERVER BaseHttpDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , ) Then, update the skill.yaml accordingly: handlers : http_handler : args : {} class_name : HttpHandler models : default_dialogues : args : {} class_name : DefaultDialogues http_dialogues : args : {} class_name : HttpDialogues Run the fingerprinter (note, you will have to replace the author name with your author handle): aea fingerprint skill fetchai/http_echo:0.20.0 Moreover, we need to tell to the http_server connection to what skill the HTTP requests should be forwarded. In our case, this is the http_echo that you have just scaffolded. Its public id will be <your-author-name>/http_echo:0.1.0 . aea config set vendor.fetchai.connections.http_server.config.target_skill_id \" $( aea config get agent.author ) /http_echo:0.1.0\" You can now run the AEA: aea run In a separate terminal, you can create a client and communicate with the server: import requests response = requests . get ( 'http://127.0.0.1:8000' ) response . status_code # >>> 404 # we receive a not found since the path is not available in the api spec response = requests . get ( 'http://127.0.0.1:8000/pets' ) response . status_code # >>> 200 response . content # >>> b'{\"tom\": {\"type\": \"cat\", \"age\": 10}}' response = requests . post ( 'http://127.0.0.1:8000/pets' ) response . status_code # >>> 200 response . content # >>> b''","title":"HTTP Connection"},{"location":"aea/http-connection-and-skill/#description","text":"The HTTP client and HTTP server connections enable an AEA to communicate with external servers, respectively clients, via HTTP. The HTTP client connection receives request envelops from an agent's skill, translates each into an HTTP request and sends it to a server external to the agent. If it receives an HTTP response from the server within a timeout window, it translates it into a response envelope, and sends this back to the relevant skill inside the agent. The HTTP server connection allows you to run a server inside the connection itself which accepts requests from clients external to the agent. The HTTP server connection validates requests it receives against a provided OpenAPI file. It translates each valid request into an envelope and sends it to the skill specified in the connections configuration. If it receives a valid response envelope from the skill within a timeout window, the connection translates the response envelope into an HTTP response and serves it to the client.","title":"Description"},{"location":"aea/http-connection-and-skill/#http-client","text":"The fetchai/simple_data_request:0.13.0 skill demonstrates a simple use case of the HTTP Client connection. The HttpRequestBehaviour in behaviours.py periodically sends HTTP envelops to the HTTP client connection. Its act() method, periodically called, simply calls _generate_http_request which contains the logic for enqueueing an HTTP request envelop. The HttpHandler in handler.py is a basic handler for dealing with HTTP response envelops received from the HTTP client connection. In the handle() method, the responses are dealt with by the private _handle_response method which essentially logs the response and adds the body of the response into the skill's shared state.","title":"HTTP Client"},{"location":"aea/http-connection-and-skill/#http-server","text":"Create a new AEA: aea create my_aea cd my_aea Add the http server connection package: aea add connection fetchai/http_server:0.22.0 Update the default connection: aea config set agent.default_connection fetchai/http_server:0.22.0 Modify the api_spec_path : aea config set vendor.fetchai.connections.http_server.config.api_spec_path \"../examples/http_ex/petstore.yaml\" Ensure the file exists under the specified path! Create and add a private key: aea generate-key fetchai aea add-key fetchai Install the dependencies: aea install Write and add your skill: aea scaffold skill http_echo You can implement a simple http echo skill (modelled after the standard echo skill) which prints out the content of received messages and responds with success. First, delete the my_model.py and behaviour.py files (in my_aea/skills/http_echo/ ). The server will be purely reactive, so you only need the handlers.py file, and the dialogues.py to record the state of the dialogues. Update skill.yaml accordingly, so set models: {} and behaviours: {} . Next implement a basic handler which prints the received envelopes and responds. Then, replace the content of handlers.py with the following code snippet, after having replaced the placeholder YOUR_USERNAME with the author username (i.e. the output of aea config get agent.author ): import json from typing import cast from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.default import DefaultMessage from packages.fetchai.protocols.http.message import HttpMessage from packages.YOUR_USERNAME.skills.http_echo.dialogues import ( DefaultDialogues , HttpDialogue , HttpDialogues , ) class HttpHandler ( Handler ): \"\"\"This implements the echo handler.\"\"\" SUPPORTED_PROTOCOL = HttpMessage . protocol_id def setup ( self ) -> None : \"\"\"Implement the setup.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to an envelope. :param message: the message \"\"\" http_msg = cast ( HttpMessage , message ) # recover dialogue http_dialogues = cast ( HttpDialogues , self . context . http_dialogues ) http_dialogue = cast ( HttpDialogue , http_dialogues . update ( http_msg )) if http_dialogue is None : self . _handle_unidentified_dialogue ( http_msg ) return # handle message if http_msg . performative == HttpMessage . Performative . REQUEST : self . _handle_request ( http_msg , http_dialogue ) else : self . _handle_invalid ( http_msg , http_dialogue ) def _handle_unidentified_dialogue ( self , http_msg : HttpMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param http_msg: the message \"\"\" self . context . logger . info ( \"received invalid http message= {} , unidentified dialogue.\" . format ( http_msg ) ) default_dialogues = cast ( DefaultDialogues , self . context . default_dialogues ) default_msg , _ = default_dialogues . create ( counterparty = http_msg . sender , performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . INVALID_DIALOGUE , error_msg = \"Invalid dialogue.\" , error_data = { \"http_message\" : http_msg . encode ()}, ) self . context . outbox . put_message ( message = default_msg ) def _handle_request ( self , http_msg : HttpMessage , http_dialogue : HttpDialogue ) -> None : \"\"\" Handle a Http request. :param http_msg: the http message :param http_dialogue: the http dialogue \"\"\" self . context . logger . info ( \"received http request with method= {} , url= {} and body= {!r} \" . format ( http_msg . method , http_msg . url , http_msg . body , ) ) if http_msg . method == \"get\" : self . _handle_get ( http_msg , http_dialogue ) elif http_msg . method == \"post\" : self . _handle_post ( http_msg , http_dialogue ) def _handle_get ( self , http_msg : HttpMessage , http_dialogue : HttpDialogue ) -> None : \"\"\" Handle a Http request of verb GET. :param http_msg: the http message :param http_dialogue: the http dialogue \"\"\" http_response = http_dialogue . reply ( performative = HttpMessage . Performative . RESPONSE , target_message = http_msg , version = http_msg . version , status_code = 200 , status_text = \"Success\" , headers = http_msg . headers , body = json . dumps ({ \"tom\" : { \"type\" : \"cat\" , \"age\" : 10 }}) . encode ( \"utf-8\" ), ) self . context . logger . info ( \"responding with: {} \" . format ( http_response )) self . context . outbox . put_message ( message = http_response ) def _handle_post ( self , http_msg : HttpMessage , http_dialogue : HttpDialogue ) -> None : \"\"\" Handle a Http request of verb POST. :param http_msg: the http message :param http_dialogue: the http dialogue \"\"\" http_response = http_dialogue . reply ( performative = HttpMessage . Performative . RESPONSE , target_message = http_msg , version = http_msg . version , status_code = 200 , status_text = \"Success\" , headers = http_msg . headers , body = http_msg . body , ) self . context . logger . info ( \"responding with: {} \" . format ( http_response )) self . context . outbox . put_message ( message = http_response ) def _handle_invalid ( self , http_msg : HttpMessage , http_dialogue : HttpDialogue ) -> None : \"\"\" Handle an invalid http message. :param http_msg: the http message :param http_dialogue: the http dialogue \"\"\" self . context . logger . warning ( \"cannot handle http message of performative= {} in dialogue= {} .\" . format ( http_msg . performative , http_dialogue ) ) def teardown ( self ) -> None : \"\"\"Implement the handler teardown.\"\"\" Moreover, add a dialogues.py file with the following code: from typing import Any from aea.protocols.base import Address , Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.skills.base import Model from packages.fetchai.protocols.default.dialogues import ( DefaultDialogue as BaseDefaultDialogue , ) from packages.fetchai.protocols.default.dialogues import ( DefaultDialogues as BaseDefaultDialogues , ) from packages.fetchai.protocols.http.dialogues import HttpDialogue as BaseHttpDialogue from packages.fetchai.protocols.http.dialogues import HttpDialogues as BaseHttpDialogues DefaultDialogue = BaseDefaultDialogue class DefaultDialogues ( Model , BaseDefaultDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return DefaultDialogue . Role . AGENT BaseDefaultDialogues . __init__ ( self , self_address = self . context . agent_address , role_from_first_message = role_from_first_message , ) HttpDialogue = BaseHttpDialogue class HttpDialogues ( Model , BaseHttpDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param kwargs: keyword arguments \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseHttpDialogue . Role . SERVER BaseHttpDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , ) Then, update the skill.yaml accordingly: handlers : http_handler : args : {} class_name : HttpHandler models : default_dialogues : args : {} class_name : DefaultDialogues http_dialogues : args : {} class_name : HttpDialogues Run the fingerprinter (note, you will have to replace the author name with your author handle): aea fingerprint skill fetchai/http_echo:0.20.0 Moreover, we need to tell to the http_server connection to what skill the HTTP requests should be forwarded. In our case, this is the http_echo that you have just scaffolded. Its public id will be <your-author-name>/http_echo:0.1.0 . aea config set vendor.fetchai.connections.http_server.config.target_skill_id \" $( aea config get agent.author ) /http_echo:0.1.0\" You can now run the AEA: aea run In a separate terminal, you can create a client and communicate with the server: import requests response = requests . get ( 'http://127.0.0.1:8000' ) response . status_code # >>> 404 # we receive a not found since the path is not available in the api spec response = requests . get ( 'http://127.0.0.1:8000/pets' ) response . status_code # >>> 200 response . content # >>> b'{\"tom\": {\"type\": \"cat\", \"age\": 10}}' response = requests . post ( 'http://127.0.0.1:8000/pets' ) response . status_code # >>> 200 response . content # >>> b''","title":"HTTP Server"},{"location":"aea/identity/","text":"Note This section is incomplete and will soon be updated. The AEAs currently use the addresses associated with their private-public key pairs to identify themselves. To learn how to generate a private-public key pair check out the relevant CLI commands . To learn more about public-key cryptography check out Wikipedia . An AEA can provide evidence of its identity using third-party solutions. We have implemented a demo using Aries Hyperledger Cloud Agent which is available here and another demo using Yoti which is available here .","title":"Identity"},{"location":"aea/interaction-protocol/","text":"Although one can imagine scenarios where single AEAs pursue their goals in isolation without interacting with other AEAs, there is no doubt that by working together, AEAs have the potential of achieving much more, especially when taking into account agents' heterogeneity, specialisations, and differing and often complimentary local views of the environment. Interactions in the AEA world are in the form of communication. This is influenced by established practices in the field of multi-agent systems and the prominent speech-act theory which suggests that a communicative expression is not only about transferring information from the speaker to the hearer, but that there may be meanings and commitments beyond the statement's appearance. Therefore, speech may more suitably be considered as action. For example, \"I hereby appoint you as chairman\" is not just a sequence of words, but an action done by the speaker with wide-ranging consequences for the hearer and any other audience to that sentence. Interaction protocols are thus possible communication scenarios between agents or agent components (specifically, skills and connections). There are multiple types of interactions an AEA can have: AEA-to-AEA interactions. You can find some examples in the demo section . Interactions between an AEA's internal components. Usually, an interaction involves three types of framework packages: skills , protocols and connections . Example 1: negotiation The generic buyer/seller skills use the fetchai/fipa protocol which defines the negotiation dialogue between two AEAs. The fetchai/generic_buyer and fetchai/generic_seller skills implement specific strategies for engaging in such negotiations, by providing the logic for producing negotiation messages to be sent, handling negotiation messages received. The fetchai/p2p_libp2p connection is then used for connecting to the agent communication network enabling two AEAs with these skills to deliver negotiation messages to each other. Example 2: AEA <> web client In the http connection guide we demonstrate how an AEA with an http server connection (e.g. fetchai/http_server ) receives http payloads from web clients, translates them to messages conforming with the fetchai/http protocol and passes it to a skill (e.g. fetchai/http_echo ) to process. The fetchai/http protocol in this case is used for communication between the connection and the skill. Example 3 : AEA <> 3rd party server The fetchai/http_client connection can be used to make requests to third party servers. In this case, a skill containing the logic for the production of http requests would create messages conforming with the fetchai/http protocol and sends it to the fetchai/http_client connection which in turn translates it into http payload and sends it to the destination server. Note that in general, third party SDKs can be wrapped in a connection and shared with other developers as a package. Often this also involves creating a custom protocol to enforce the type of interactions permitted between skills and the connection wrapping the SDK. Next steps Recommended We recommend you continue with the next step in the 'Getting Started' series: Trade between two AEAs Relevant deep-dives Most AEA development focuses on developing the Skills and Protocols necessary for an AEA to deliver against its economic objectives and implement interaction protocols. Understanding Protocols is core to developing your own agent. You can learn more about the Protocols agents use to communicate with each other and how they are created in the following section: Protocols Most of an AEA developer's time is spent on Skill development. Skills are the core business logic components of an AEA. Check out the following guide to learn more: Skills In most cases, one of the available Connection packages can be used. Occasionally, you might develop your own Connection : Connections","title":"How AEAs talk to each other - interaction protocols"},{"location":"aea/interaction-protocol/#example-1-negotiation","text":"The generic buyer/seller skills use the fetchai/fipa protocol which defines the negotiation dialogue between two AEAs. The fetchai/generic_buyer and fetchai/generic_seller skills implement specific strategies for engaging in such negotiations, by providing the logic for producing negotiation messages to be sent, handling negotiation messages received. The fetchai/p2p_libp2p connection is then used for connecting to the agent communication network enabling two AEAs with these skills to deliver negotiation messages to each other.","title":"Example 1: negotiation"},{"location":"aea/interaction-protocol/#example-2-aea-web-client","text":"In the http connection guide we demonstrate how an AEA with an http server connection (e.g. fetchai/http_server ) receives http payloads from web clients, translates them to messages conforming with the fetchai/http protocol and passes it to a skill (e.g. fetchai/http_echo ) to process. The fetchai/http protocol in this case is used for communication between the connection and the skill.","title":"Example 2: AEA &lt;&gt; web client"},{"location":"aea/interaction-protocol/#example-3-aea-3rd-party-server","text":"The fetchai/http_client connection can be used to make requests to third party servers. In this case, a skill containing the logic for the production of http requests would create messages conforming with the fetchai/http protocol and sends it to the fetchai/http_client connection which in turn translates it into http payload and sends it to the destination server. Note that in general, third party SDKs can be wrapped in a connection and shared with other developers as a package. Often this also involves creating a custom protocol to enforce the type of interactions permitted between skills and the connection wrapping the SDK.","title":"Example 3 : AEA &lt;&gt; 3rd party server"},{"location":"aea/interaction-protocol/#next-steps","text":"","title":"Next steps"},{"location":"aea/interaction-protocol/#recommended","text":"We recommend you continue with the next step in the 'Getting Started' series: Trade between two AEAs","title":"Recommended"},{"location":"aea/interaction-protocol/#relevant-deep-dives","text":"Most AEA development focuses on developing the Skills and Protocols necessary for an AEA to deliver against its economic objectives and implement interaction protocols. Understanding Protocols is core to developing your own agent. You can learn more about the Protocols agents use to communicate with each other and how they are created in the following section: Protocols Most of an AEA developer's time is spent on Skill development. Skills are the core business logic components of an AEA. Check out the following guide to learn more: Skills In most cases, one of the available Connection packages can be used. Occasionally, you might develop your own Connection : Connections","title":"Relevant deep-dives"},{"location":"aea/known-limits/","text":"The AEA framework makes a multitude of tradeoffs. Here we present an incomplete list of known limitations: The AEABuilder checks the consistency of packages at the add stage. However, it does not currently check the consistency again at the load stage. This means, if a package is tampered with after it is added to the AEABuilder then these inconsistencies might not be detected by the AEABuilder . The AEABuilder assumes that packages with public ids of identical author and package name have a matching version. As a result, if a developer uses a package with matching author and package name but different version in the public id, then the AEABuilder will not detect this and simply use the last loaded package. The order in which setup and teardown are called on the skills, and act is called on the behaviours, is not guaranteed. Skills should be designed to work independently. Where skills use the shared_context to exchange information they must do so safely.","title":"Known limitations"},{"location":"aea/language-agnostic-definition/","text":"Currently, there is an implementation of the AEA framework in Python which enables the development of AEAs in Python, and allows AEAs which are built with it to run. However, AEAs can be developed in different programming languages. This is further backed by the idea that agent-based solutions are suited for multi-stakeholder environments where the different AEAs may be developed independently of one another, resulting in heterogeneous systems. This means that in principle, there could be different implementations of the AEA framework, in various programming languages and for different platforms. However, to ensure that AEAs under any implementation are compatible with one another and able to interact, they must satisfy specific definitions. In this page, we compile a set of definitions which any AEA independent of its implementation must satisfy in order to be able to interact with other AEAs. An AEA, in technical terms, must satisfy the following requirements: It MUST be capable of receiving and sending Envelopes which satisfy the following protobuf schema: syntax = \"proto3\" ; package aea . base.v0_1_0 ; message Envelope { string to = 1 ; string sender = 2 ; string protocol_id = 3 ; bytes message = 4 ; string uri = 5 ; } The format for the above fields are as follows: to and sender : an address derived from the private key of a secp256k1 -compatible elliptic curve protocol_id : this must match a defined regular expression (see below) message : a bytes string representing a serialized message in the specified protocol URI : follows this syntax It MUST implement each protocol's message with the required meta-fields: syntax = \"proto3\" ; package aea . base.v0_1_0 ; import \"google/protobuf/struct.proto\" ; message DialogueMessage { int32 message_id = 1 ; string dialogue_starter_reference = 2 ; string dialogue_responder_reference = 3 ; int32 target = 4 ; bytes content = 5 ; } message Message { oneof message { google.protobuf.Struct body = 1 ; DialogueMessage dialogue_message = 2 ; } } message Envelope { string to = 1 ; string sender = 2 ; string protocol_id = 3 ; bytes message = 4 ; string uri = 5 ; } where content is replaced with the protocol specific content (see here for details). It MUST implement protocols according to their specification (see here for details). It SHOULD implement the fetchai/default:1.0.0 protocol which satisfies the following protobuf schema: syntax = \"proto3\" ; package aea . fetchai.default.v1_0_0 ; message DefaultMessage { // Custom Types message ErrorCode { enum ErrorCodeEnum { UNSUPPORTED_PROTOCOL = 0 ; DECODING_ERROR = 1 ; INVALID_MESSAGE = 2 ; UNSUPPORTED_SKILL = 3 ; INVALID_DIALOGUE = 4 ; } ErrorCodeEnum error_code = 1 ; } // Performatives and contents message Bytes_Performative { bytes content = 1 ; } message Error_Performative { ErrorCode error_code = 1 ; string error_msg = 2 ; map < string , bytes > error_data = 3 ; } message End_Performative { } oneof performative { Bytes_Performative bytes = 5 ; End_Performative end = 6 ; Error_Performative error = 7 ; } } The protocol id MUST match the following regular expression: ^([a-zA-Z_][a-zA-Z0-9_]{0,127})/([a-zA-Z_][a-zA-Z0-9_]{0,127})(:((any|latest|((0|[1-9]\\d*))\\.((0|[1-9]\\d*))\\.((0|[1-9]\\d*))(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?)))?$ It is recommended that it processes Envelopes asynchronously. Note, the specification regarding the processing of messages does not impose any particular implementation, and the AEA can be designed to process envelopes either synchronously and asynchronously. However, asynchronous message handling enables the agent to be more responsive and scalable in maintaining many concurrent dialogues with its peers. It MUST have an identity in the form of, at a minimum, an address derived from a public key and its associated private key (where the elliptic curve must be of type SECP256k1 ). It SHOULD implement handling of errors using the fetchai/default:1.0.0 protocol. The protobuf schema is given above. It MUST implement the following principles when handling messages: It MUST ALWAYS handle incoming envelopes/messages and NEVER raise an exception when decoding and validating the message. This ensures another AEA cannot cause the agent to fail by sending a malicious envelope/message. It MUST NEVER handle outgoing messages and ALWAYS raise an exception when validating the message. An exception implies that the handler is resolving a bug in the implementation. Note Additional constraints will be added soon!","title":"Language Agnostic Definition"},{"location":"aea/ledger-integration/","text":"In this section, we show you how to integrate the AEA with the Fetch.ai and third-party ledgers. Ledger support For a ledger to be considered supported in the framework, three abstract base classes need to be implemented: the LedgerApi class wraps the API to talk to the ledger and its helper methods the Crypto class wraps the API to perform cryptographic operations for the relevant ledger the FaucetApi class wraps the API to talk to a faucet on a testnet These three classes have their own registries, which allow the developer to import the relevant object where needed. Ledger plug-in architecture The AEA framework provides a plug-in mechanism to support ledger functionalities in an easily extendible way. At import time, the framework will load all the crypto plug-ins available in the current Python environment. A crypto plug-in is a Python package which declares some specific setuptools \"entry points\" in its setup.py script. In particular, there are three types of entry points the framework looks up: aea.ledger_apis , which points to instantiable classes implementing the LedgerApi interface; aea.cryptos , which points to instantiable classes implementing the Crypto interface; aea.faucet_apis , which points to instantiable classes implementing the FaucetApi interface. This is an example of setup.py script for a ledger plug-in aea-ledger-myledger : # sample ./setup.py file from setuptools import setup setup ( name = \"aea-ledger-myledger\" , packages = [ \"aea_ledger_myledger\" ], # plugins must depend on 'aea' install_requires = [ \"aea\" ], # add other dependencies... # the following makes a plugin available to aea entry_points = { \"aea.cryptos\" : [ \"myledger = aea_ledger_myledger:MyLedgerCrypto\" ], \"aea.ledger_apis\" : [ \"myledger = aea_ledger_myledger:MyLedgerApi\" ], \"aea.faucet_apis\" : [ \"myledger = aea_ledger_myledger:MyLedgerFaucetApi\" ], }, # PyPI classifier for AEA plugins classifiers = [ \"Framework :: AEA\" ], ) By convention, such plug-in packages should be named aea-ledger-${LEDGER_ID} , and the importable package name aea_ledger_${LEDGER_ID} . In the example above, the package name is aea-ledger-myledger , and the importable package name is aea_ledger_myledger . You can search for AEA ledger plug-ins on PyPI: https://pypi.org/search/?q=aea-ledger Maintained plug-ins At the moment, the framework natively supports the following three ledgers: Fetch.ai: PyPI package: aea-ledger-fetchai , and source code . Ethereum: PyPI package: aea-ledger-ethereum , and source code . Cosmos: PyPI package: aea-ledger-cosmos , and source code . However, support for additional ledgers can be added to the framework at runtime. Examples Examples of how to interact with the crypto registry: from aea.crypto.registries import crypto_registry , make_crypto , register_crypto # by default we can use the native cryptos fetchai_crypto = make_crypto ( \"fetchai\" ) # we can check what cryptos are registered crypto_registry . supported_ids # we can also add a new crypto to the registry register_crypto ( id_ = \"my_ledger_id\" , entry_point = \"some.dotted.path:MyLedgerCrypto\" ) # and then make it anywhere my_ledger_crypto = make_crypto ( \"my_ledger_id\" ) Examples of how to interact with the ledger API registry: from aea.crypto.registries import ledger_apis_registry , make_ledger_api , register_ledger_api # by default we can use the native ledger apis CONFIG = { \"network\" : \"testnet\" } fetchai_ledger_api = make_ledger_api ( \"fetchai\" , ** CONFIG ) # we can check what ledger apis are registered ledger_apis_registry . supported_ids # we can also add a new ledger api to the registry register_ledger_api ( id_ = \"my_ledger_id\" , entry_point = \"some.dotted.path:MyLedgerApi\" ) # and then make it anywhere my_ledger_api = make_ledger_api ( \"my_ledger_id\" ) Examples of how to interact with the faucet API registry: from aea.crypto.registries import faucet_apis_registry , make_faucet_api , register_faucet_api # by default we can use the native faucet apis CONFIG = dict ( poll_interval = 1.0 ) fetchai_faucet_api = make_faucet_api ( \"fetchai\" , ** CONFIG ) # we can check what faucet apis are registered faucet_apis_registry . supported_ids # we can also add a new faucet api to the registry register_faucet_api ( id_ = \"my_ledger_id\" , entry_point = \"some.dotted.path:MyLedgerFaucetApi\" ) # and then make it anywhere my_faucet_api = make_faucet_api ( \"my_ledger_id\" ) The framework wraps all LedgerApi classes and exposes them in the LedgerApis classes. The framework also wraps the crypto APIs to create identities on both ledgers and exposes them in the Wallet . The separation between the Crypto and LedgerApi is fundamental to the framework design. In particular, the object which holds the private key is separated from the object which interacts with the ledger. This design pattern is repeated throughout the framework: the decision maker is the only entity with access to the AEA's Wallet whilst LedgerApis are accessible by all skills. Stargate World - Fetch.ai testnet for agents Stargate World is our stable, public testnet for the Fetch Ledger v2. As such, most developers will be interacting with this testnet. This is specifically designed and supported for AEA development. Parameter Value Chain ID stargateworld-3 Denomination atestfet Decimals 18 Version v0.8.x RPC Endpoint https://rpc-stargateworld.fetch.ai:443 REST Endpoint https://rest-stargateworld.fetch.ai:443 Block Explorer https://explore-stargateworld.fetch.ai Token Faucet Use block explorer You can access more details on GitHub . The configurations can be specified for the fetchai/ledger:0.19.0 connection. CosmWasm supporting chains The Fetch.ai networks use CosmWasm for smart contract support.","title":"Ledger & Crypto APIs"},{"location":"aea/ledger-integration/#ledger-support","text":"For a ledger to be considered supported in the framework, three abstract base classes need to be implemented: the LedgerApi class wraps the API to talk to the ledger and its helper methods the Crypto class wraps the API to perform cryptographic operations for the relevant ledger the FaucetApi class wraps the API to talk to a faucet on a testnet These three classes have their own registries, which allow the developer to import the relevant object where needed.","title":"Ledger support"},{"location":"aea/ledger-integration/#ledger-plug-in-architecture","text":"The AEA framework provides a plug-in mechanism to support ledger functionalities in an easily extendible way. At import time, the framework will load all the crypto plug-ins available in the current Python environment. A crypto plug-in is a Python package which declares some specific setuptools \"entry points\" in its setup.py script. In particular, there are three types of entry points the framework looks up: aea.ledger_apis , which points to instantiable classes implementing the LedgerApi interface; aea.cryptos , which points to instantiable classes implementing the Crypto interface; aea.faucet_apis , which points to instantiable classes implementing the FaucetApi interface. This is an example of setup.py script for a ledger plug-in aea-ledger-myledger : # sample ./setup.py file from setuptools import setup setup ( name = \"aea-ledger-myledger\" , packages = [ \"aea_ledger_myledger\" ], # plugins must depend on 'aea' install_requires = [ \"aea\" ], # add other dependencies... # the following makes a plugin available to aea entry_points = { \"aea.cryptos\" : [ \"myledger = aea_ledger_myledger:MyLedgerCrypto\" ], \"aea.ledger_apis\" : [ \"myledger = aea_ledger_myledger:MyLedgerApi\" ], \"aea.faucet_apis\" : [ \"myledger = aea_ledger_myledger:MyLedgerFaucetApi\" ], }, # PyPI classifier for AEA plugins classifiers = [ \"Framework :: AEA\" ], ) By convention, such plug-in packages should be named aea-ledger-${LEDGER_ID} , and the importable package name aea_ledger_${LEDGER_ID} . In the example above, the package name is aea-ledger-myledger , and the importable package name is aea_ledger_myledger . You can search for AEA ledger plug-ins on PyPI: https://pypi.org/search/?q=aea-ledger","title":"Ledger plug-in architecture"},{"location":"aea/ledger-integration/#maintained-plug-ins","text":"At the moment, the framework natively supports the following three ledgers: Fetch.ai: PyPI package: aea-ledger-fetchai , and source code . Ethereum: PyPI package: aea-ledger-ethereum , and source code . Cosmos: PyPI package: aea-ledger-cosmos , and source code . However, support for additional ledgers can be added to the framework at runtime.","title":"Maintained plug-ins"},{"location":"aea/ledger-integration/#examples","text":"Examples of how to interact with the crypto registry: from aea.crypto.registries import crypto_registry , make_crypto , register_crypto # by default we can use the native cryptos fetchai_crypto = make_crypto ( \"fetchai\" ) # we can check what cryptos are registered crypto_registry . supported_ids # we can also add a new crypto to the registry register_crypto ( id_ = \"my_ledger_id\" , entry_point = \"some.dotted.path:MyLedgerCrypto\" ) # and then make it anywhere my_ledger_crypto = make_crypto ( \"my_ledger_id\" ) Examples of how to interact with the ledger API registry: from aea.crypto.registries import ledger_apis_registry , make_ledger_api , register_ledger_api # by default we can use the native ledger apis CONFIG = { \"network\" : \"testnet\" } fetchai_ledger_api = make_ledger_api ( \"fetchai\" , ** CONFIG ) # we can check what ledger apis are registered ledger_apis_registry . supported_ids # we can also add a new ledger api to the registry register_ledger_api ( id_ = \"my_ledger_id\" , entry_point = \"some.dotted.path:MyLedgerApi\" ) # and then make it anywhere my_ledger_api = make_ledger_api ( \"my_ledger_id\" ) Examples of how to interact with the faucet API registry: from aea.crypto.registries import faucet_apis_registry , make_faucet_api , register_faucet_api # by default we can use the native faucet apis CONFIG = dict ( poll_interval = 1.0 ) fetchai_faucet_api = make_faucet_api ( \"fetchai\" , ** CONFIG ) # we can check what faucet apis are registered faucet_apis_registry . supported_ids # we can also add a new faucet api to the registry register_faucet_api ( id_ = \"my_ledger_id\" , entry_point = \"some.dotted.path:MyLedgerFaucetApi\" ) # and then make it anywhere my_faucet_api = make_faucet_api ( \"my_ledger_id\" ) The framework wraps all LedgerApi classes and exposes them in the LedgerApis classes. The framework also wraps the crypto APIs to create identities on both ledgers and exposes them in the Wallet . The separation between the Crypto and LedgerApi is fundamental to the framework design. In particular, the object which holds the private key is separated from the object which interacts with the ledger. This design pattern is repeated throughout the framework: the decision maker is the only entity with access to the AEA's Wallet whilst LedgerApis are accessible by all skills.","title":"Examples"},{"location":"aea/ledger-integration/#stargate-world-fetchai-testnet-for-agents","text":"Stargate World is our stable, public testnet for the Fetch Ledger v2. As such, most developers will be interacting with this testnet. This is specifically designed and supported for AEA development. Parameter Value Chain ID stargateworld-3 Denomination atestfet Decimals 18 Version v0.8.x RPC Endpoint https://rpc-stargateworld.fetch.ai:443 REST Endpoint https://rest-stargateworld.fetch.ai:443 Block Explorer https://explore-stargateworld.fetch.ai Token Faucet Use block explorer You can access more details on GitHub . The configurations can be specified for the fetchai/ledger:0.19.0 connection.","title":"Stargate World - Fetch.ai testnet for agents"},{"location":"aea/ledger-integration/#cosmwasm-supporting-chains","text":"The Fetch.ai networks use CosmWasm for smart contract support.","title":"CosmWasm supporting chains"},{"location":"aea/limits/","text":"This document describes some of the limitations of v1 of the AEA framework and tradeoffs made in its design. Rejected ideas: Handlers implemented as behaviours: Handlers can be considered a special cases of a \"behaviour that listens for specific events to happen\". One could implement Handler classes in terms of Behaviours , after having implemented the feature that behaviours can be activated after an event happens (e.g. receiving a message of a certain protocol). This was rejected in favour of a clear separation of concerns, and to avoid purely reactive (handlers) and proactive (behaviours) components to be conflated into one concept. The proposal would also add complexity to behaviour development. Multiple versions of the same package The framework does not allow for the usage of multiple versions of the same package in a given project. Although one could re-engineer the project to allow for this, it does introduce significant additional complexities. Furthermore, Python modules are by design only allowed to exist as one version in a given process. Hence, it seems sensible to maintain this approach in the AEA. Potential extensions, considered yet not decided: Alternative skill design For very simple skills, the splitting of skills into Behaviour , Handler , Model and Task classes can add unnecessary complexity to the framework and a counter-intuitive responsibility split. The splitting also implies the framework needs to introduce the SkillContext object to allow for access to data across the skill. Furthermore, the framework requires implementing all functionality in SkillComponent classes Handler , Behaviour or Model . This approach is consistent and transparent, however it creates a lot of boiler plate code for simple skills. Hence, for some use cases it would be useful to have a single Skill class with abstract methods setup , act , handle and teardown . Then the developer can decide how to split up their code. class SkillTemplate(SimpleSkill): protocol_ids: Optional[List[PublicId]] = None def setup(): # setup skill def handle(message: Message): # handle messages def act(): for b in behaviours: b.act() def teardown(): # teardown skill Alternatively, we could use decorators to let a developer define whether a function is part of a handler or behaviour. That way, a single file with a number of functions could implement a skill. (Behind the scenes this would utilise a number of virtual Behaviour and Handler classes provided by the framework). The downside of this approach is that it does not advocate for much modularity on the skill level. Part of the role of a framework is to propose a common way to do things. The above approach can cause for a larger degree of heterogeneity in the skill design which makes it harder for developers to understand each others' code. The separation between all four base classes does exist both in convention and at the code level. Handlers deal with skill-external events (messages), behaviours deal with scheduled events (ticks), models represent data and tasks are used to manage long-running business logic. By adopting strong convention around skill development we allow for the framework to take a more active role in providing guarantees. E.g. handlers' and behaviours' execution can be limited to avoid them being blocking, models can be persisted and recreated, tasks can be executed with different task backends. The opinionated approach is thought to allow for better scaling. Further modularity for skill level code Currently we have three levels of modularity: PyPI packages framework packages: protocols, contracts, connections and skills framework plugins: CLI, ledger We could consider having a fourth level: common behaviours, handlers, models exposed as modules which can then speed up skill development. \"promise\" pattern: Given the asynchronous nature of the framework, it is often hard to implement reactions to specific messages, without making a \"fat\" handler. Take the example of a handler for a certain type of message A for a certain protocol p . The handler for protocol p would look something like this: class PHandler: ... def handle(msg): if message type is A: self._handle_a(msg) However, it could be helpful to overwrite this handler reaction with another callback (e.g. consider this in context ): # callable that handles the reply def my_callback(msg): # handle reply self.context.outbox.put_message(message, handler_func=my_callback, failure_func=...) This feature would introduce additional complexity for the framework to correctly wire up the callbacks and messages with the dialogues. CLI using standard lib Removing the click dependency from the CLI would further reduce the dependencies in the AEA framework which is overall desirable. Meta data vs configurations The current approach uses yaml files to specify both meta data and component configuration. It would be desirable to introduce the following separation: package metadata package default developer configuration package default user configuration A user can only configure a subset of the configuration. The developer should be able to define these constraints for the user. Similarly, a developer cannot modify all fields in a package, some of them are determined by the framework. Configuring agent goal setup By default, the agent's goals are implicitly defined by its skills and the configurations thereof. This is because the default decision maker signs every message and transaction presented to it. It is already possible to design a custom decision maker. However, more work needs to be done to understand how to improve the usability and configuration of the decision maker. In this context different types of decision makers can be implemented for the developer/user. Connection status monitoring Currently, connections are responsible for managing their own status after they have been \"connected\" by the Multiplexer . Developers writing connections must take care to properly set its connection status at all times and manage any disconnection. It would potentially be desirable to offer different policies to deal with connection problems on the multiplexer level: disconnect one, keep others alive disconnect all try reconnect indefinitely Agent snapshots on teardown or error Currently, the developer must implement snapshots on the component level. It would be desirable if the framework offered more help to persist the agent state on teardown or error. Dialogues management The current implementation of Dialogues is verbose. Developers often need to subclass Dialogues and Dialogue classes. More effort can be made to simplify and streamline dialogues management. Instantiate multiple instances of the same class of SkillComponent Currently, configuration and metadata of a package are conflated making it not straightforward to run one package component with multiple sets of configuration. It could be desirable to configure an agent to run a given package with multiple different configurations. This feature could be problematic with respect to component to component messaging which currently relies on component ids, which are bound to the package and not its instance. Containerized Agents Agent management, especially when many of them live on the same host, can be cumbersome. The framework should provide more utilities for these large-scale use cases. But a proper isolation of the agent environment is something that helps also simple use cases. A new software architecture, somehow inspired to the Docker system. The CLI only involves the initialization of the building of the agent (think of it as the specification of the Dockerfile : the Agentfile ), but the actual build and run are done by the AEA engine, a daemon process analogous of the Docker Engine, which exposes APIs for these operations. Users and developers would potentially like to run many AEAs of different versions and with differences in the versions of their dependencies. It is not possible to import different versions of the same Python (PyPI) package in the same process in a clean way. However, in different processes this is trivial with virtual environments. It would be desirable to consider this in the context of a container solution for agents. Dependency light version of the AEA framework The v1 of the Python AEA implementation makes every effort to minimise the amount of third-party dependencies. However, some dependencies remain to lower development time. It would be desirable to further reduce the dependencies, and potentially have an implementation that only relies on the Python standard library. This could be taken further, and a reduced spec version for micropython could be designed. Compiled AEA Python is not a compiled language. However, various projects attempt this, e.g. Nuitka and it would be desirable to explore how useful and practical this would be in the context of AEA. DID integration It would be great to integrate DID in the framework design, specifically identification of packages (most urgently protocols). Other projects and standards worth reviewing in the context (in particular with respect to identity): ERC 725: Ethereum Identity Standard and here . ERC 735: Claim Holder Optimise protocol schemas and messages The focus of protocol development was on extensibility and compatibility, not on optimisation. For instance, the dialogue references use inefficient string representations. Constraints on primitive types in protocols The protocol generator currently does not support custom constraints. The framework could add support for custom constraints for the protocol generator and specification. There are many types of constraints that could be supported in specification and generator. One could perhaps add support based on the popularity of specific constraints from users/developers. Example constraints: strings following specific regular expression format (e.g. all lower case, any arbitrary regex format) max number of elements on lists/sets keys in one dict type be equal to keys in another dict type other logical constraints, e.g. as supported in ontological languages support for bounds (i.e. min, max) for numerical types (i.e. int and float ) in protocol specification. Example syntax: pt:int[0, ] pt:float[1.0, 10.0] pt:int[-1000, 1000] pt:float[, 0] This would automatically enable support for signed/unsigned int and float . This syntax would allow for unbounded positive/negative/both, or arbitrary bounds to be placed on numerical types. Currently, the developer has to specify a custom type to implement any constraints on primitive types. Subprotocols & multi-party interactions Protocols can be allowed to depend on each other. Similarly, protocols might have multiple parties. Furthermore, a turn-taking function that specifies who's turn it is at any given point in the dialogue could be added. Then the current fipa setup is a specific case of turn-taking where the turn shifts after a player sends a single move (unique-reply). But generally, it does not have to be like this. Players could be allowed to send multiple messages until the turn shifts, or until they send specific speech-acts (multiple-replies). Timeouts in protocols Protocols currently do not implement the concept of timeouts. We leave it to the skill developer to implement any time-specific protocol rules. Framework internal messages The activation/deactivation of skills and addition/removal of components is implemented in a \"passive\" way - the skill posts a request in its skill context queue (in the case of new behaviours), or it just sets a flag (in case of activation/deactivation of skills). One could consider that a skill can send requests to the framework, via the internal protocol, to modify its resources or its status. The DecisionMaker or the Filter can be the components that take such actions. This is a further small but meaningful step toward an actor-based model for agent internals. Ledger transaction management Currently, the framework does not manage any aspect of submitting multiple transactions to the ledgers. This responsibility is left to skills. Additionally, the ledger APIs/contract APIs take the ledger as a reference to determine the nonce for a transaction. If a new transaction is sent before a previous transaction has been processed then the nonce will not be incremented correctly for the second transaction. This can lead to submissions of multiple transactions with the same nonce, and therefore failure of subsequent transactions. A naive approach would involve manually incrementing the nonce and then submitting transactions into the pool with the correct nonce for eventual inclusion. The problem with this approach is that any failure of a transaction will cause non of the subsequent transactions to be processed for some ledgers (https://ethereum.stackexchange.com/questions/2808/what-happens-when-a-transaction-nonce-is-too-high). To recover from a transaction failure not only the failed transaction would need to be handled, but potentially also all subsequent transactions. It is easy to see that logic required to recover from a transaction failure early in a sequence can be arbitrarily complex (involving potentially new negotiations between agents, new signatures having to be generated etc.). A further problem with the naive approach is that it (imperfectly) replicates the ledger state (with respect to (subset of state of) a specific account). A simple solution looks as follows: each time a transaction is constructed (requiring a new nonce) the transaction construction is queued until all previous transactions have been included in the ledger or failed. This way, at any one time the agent has only at most one transaction pending with the ledger. Benefits: simple to understand and maintain, transaction only enter the mempool when they are ready for inclusion which has privacy benefits over submitting a whole sequence of transaction at once. Downside: at most one transaction per block. This approach is currently used and implemented across all the reference skills. Related, the topic of latency in transactions. State channels provide a solution. E.g. Perun . There could also be an interesting overlap with our protocols here. Unsolved problems in Multiplexer - AgentLoop interplay Problem 1: connection generates too many messages in a short amount of time, that are not consumed by the multiplexer Solution: Can be solved by slowing down connections receive method called, controlled by the inbox messages amount Side effects: Most of the connections should have an internal queue because there is no synchronization between internal logic and multiplexer connection receive calls. Problem 2: the send method can take a long time (because send retries logic in connection) Solution: Currently, we apply timeouts on send. Other solutions could be considered, like parallelisation. Problem 3: too many messages are produced by a skill. Solution: Raise an exception on outbox is full or slow down agent loop? ACN Agent mobility on ACN If a peer-client or full client switches peer, then the DHT is not updated properly at the moment under certain conditions. Mailbox connection The two available connections p2p_libp2p and p2p_libp2p_client imply that the agent is continuously connected and therefore must have uninterrupted network access and the resources to maintain a connection. For more lightweight implementations, a mailbox connection is desirable, as outlined in the ACN documentation.","title":"Limitations of v1"},{"location":"aea/limits/#rejected-ideas","text":"","title":"Rejected ideas:"},{"location":"aea/limits/#handlers-implemented-as-behaviours","text":"Handlers can be considered a special cases of a \"behaviour that listens for specific events to happen\". One could implement Handler classes in terms of Behaviours , after having implemented the feature that behaviours can be activated after an event happens (e.g. receiving a message of a certain protocol). This was rejected in favour of a clear separation of concerns, and to avoid purely reactive (handlers) and proactive (behaviours) components to be conflated into one concept. The proposal would also add complexity to behaviour development.","title":"Handlers implemented as behaviours:"},{"location":"aea/limits/#multiple-versions-of-the-same-package","text":"The framework does not allow for the usage of multiple versions of the same package in a given project. Although one could re-engineer the project to allow for this, it does introduce significant additional complexities. Furthermore, Python modules are by design only allowed to exist as one version in a given process. Hence, it seems sensible to maintain this approach in the AEA.","title":"Multiple versions of the same package"},{"location":"aea/limits/#potential-extensions-considered-yet-not-decided","text":"","title":"Potential extensions, considered yet not decided:"},{"location":"aea/limits/#alternative-skill-design","text":"For very simple skills, the splitting of skills into Behaviour , Handler , Model and Task classes can add unnecessary complexity to the framework and a counter-intuitive responsibility split. The splitting also implies the framework needs to introduce the SkillContext object to allow for access to data across the skill. Furthermore, the framework requires implementing all functionality in SkillComponent classes Handler , Behaviour or Model . This approach is consistent and transparent, however it creates a lot of boiler plate code for simple skills. Hence, for some use cases it would be useful to have a single Skill class with abstract methods setup , act , handle and teardown . Then the developer can decide how to split up their code. class SkillTemplate(SimpleSkill): protocol_ids: Optional[List[PublicId]] = None def setup(): # setup skill def handle(message: Message): # handle messages def act(): for b in behaviours: b.act() def teardown(): # teardown skill Alternatively, we could use decorators to let a developer define whether a function is part of a handler or behaviour. That way, a single file with a number of functions could implement a skill. (Behind the scenes this would utilise a number of virtual Behaviour and Handler classes provided by the framework). The downside of this approach is that it does not advocate for much modularity on the skill level. Part of the role of a framework is to propose a common way to do things. The above approach can cause for a larger degree of heterogeneity in the skill design which makes it harder for developers to understand each others' code. The separation between all four base classes does exist both in convention and at the code level. Handlers deal with skill-external events (messages), behaviours deal with scheduled events (ticks), models represent data and tasks are used to manage long-running business logic. By adopting strong convention around skill development we allow for the framework to take a more active role in providing guarantees. E.g. handlers' and behaviours' execution can be limited to avoid them being blocking, models can be persisted and recreated, tasks can be executed with different task backends. The opinionated approach is thought to allow for better scaling.","title":"Alternative skill design"},{"location":"aea/limits/#further-modularity-for-skill-level-code","text":"Currently we have three levels of modularity: PyPI packages framework packages: protocols, contracts, connections and skills framework plugins: CLI, ledger We could consider having a fourth level: common behaviours, handlers, models exposed as modules which can then speed up skill development.","title":"Further modularity for skill level code"},{"location":"aea/limits/#promise-pattern","text":"Given the asynchronous nature of the framework, it is often hard to implement reactions to specific messages, without making a \"fat\" handler. Take the example of a handler for a certain type of message A for a certain protocol p . The handler for protocol p would look something like this: class PHandler: ... def handle(msg): if message type is A: self._handle_a(msg) However, it could be helpful to overwrite this handler reaction with another callback (e.g. consider this in context ): # callable that handles the reply def my_callback(msg): # handle reply self.context.outbox.put_message(message, handler_func=my_callback, failure_func=...) This feature would introduce additional complexity for the framework to correctly wire up the callbacks and messages with the dialogues.","title":"\"promise\" pattern:"},{"location":"aea/limits/#cli-using-standard-lib","text":"Removing the click dependency from the CLI would further reduce the dependencies in the AEA framework which is overall desirable.","title":"CLI using standard lib"},{"location":"aea/limits/#meta-data-vs-configurations","text":"The current approach uses yaml files to specify both meta data and component configuration. It would be desirable to introduce the following separation: package metadata package default developer configuration package default user configuration A user can only configure a subset of the configuration. The developer should be able to define these constraints for the user. Similarly, a developer cannot modify all fields in a package, some of them are determined by the framework.","title":"Meta data vs configurations"},{"location":"aea/limits/#configuring-agent-goal-setup","text":"By default, the agent's goals are implicitly defined by its skills and the configurations thereof. This is because the default decision maker signs every message and transaction presented to it. It is already possible to design a custom decision maker. However, more work needs to be done to understand how to improve the usability and configuration of the decision maker. In this context different types of decision makers can be implemented for the developer/user.","title":"Configuring agent goal setup"},{"location":"aea/limits/#connection-status-monitoring","text":"Currently, connections are responsible for managing their own status after they have been \"connected\" by the Multiplexer . Developers writing connections must take care to properly set its connection status at all times and manage any disconnection. It would potentially be desirable to offer different policies to deal with connection problems on the multiplexer level: disconnect one, keep others alive disconnect all try reconnect indefinitely","title":"Connection status monitoring"},{"location":"aea/limits/#agent-snapshots-on-teardown-or-error","text":"Currently, the developer must implement snapshots on the component level. It would be desirable if the framework offered more help to persist the agent state on teardown or error.","title":"Agent snapshots on teardown or error"},{"location":"aea/limits/#dialogues-management","text":"The current implementation of Dialogues is verbose. Developers often need to subclass Dialogues and Dialogue classes. More effort can be made to simplify and streamline dialogues management.","title":"Dialogues management"},{"location":"aea/limits/#instantiate-multiple-instances-of-the-same-class-of-skillcomponent","text":"Currently, configuration and metadata of a package are conflated making it not straightforward to run one package component with multiple sets of configuration. It could be desirable to configure an agent to run a given package with multiple different configurations. This feature could be problematic with respect to component to component messaging which currently relies on component ids, which are bound to the package and not its instance.","title":"Instantiate multiple instances of the same class of SkillComponent"},{"location":"aea/limits/#containerized-agents","text":"Agent management, especially when many of them live on the same host, can be cumbersome. The framework should provide more utilities for these large-scale use cases. But a proper isolation of the agent environment is something that helps also simple use cases. A new software architecture, somehow inspired to the Docker system. The CLI only involves the initialization of the building of the agent (think of it as the specification of the Dockerfile : the Agentfile ), but the actual build and run are done by the AEA engine, a daemon process analogous of the Docker Engine, which exposes APIs for these operations. Users and developers would potentially like to run many AEAs of different versions and with differences in the versions of their dependencies. It is not possible to import different versions of the same Python (PyPI) package in the same process in a clean way. However, in different processes this is trivial with virtual environments. It would be desirable to consider this in the context of a container solution for agents.","title":"Containerized Agents"},{"location":"aea/limits/#dependency-light-version-of-the-aea-framework","text":"The v1 of the Python AEA implementation makes every effort to minimise the amount of third-party dependencies. However, some dependencies remain to lower development time. It would be desirable to further reduce the dependencies, and potentially have an implementation that only relies on the Python standard library. This could be taken further, and a reduced spec version for micropython could be designed.","title":"Dependency light version of the AEA framework"},{"location":"aea/limits/#compiled-aea","text":"Python is not a compiled language. However, various projects attempt this, e.g. Nuitka and it would be desirable to explore how useful and practical this would be in the context of AEA.","title":"Compiled AEA"},{"location":"aea/limits/#did-integration","text":"It would be great to integrate DID in the framework design, specifically identification of packages (most urgently protocols). Other projects and standards worth reviewing in the context (in particular with respect to identity): ERC 725: Ethereum Identity Standard and here . ERC 735: Claim Holder","title":"DID integration"},{"location":"aea/limits/#optimise-protocol-schemas-and-messages","text":"The focus of protocol development was on extensibility and compatibility, not on optimisation. For instance, the dialogue references use inefficient string representations.","title":"Optimise protocol schemas and messages"},{"location":"aea/limits/#constraints-on-primitive-types-in-protocols","text":"The protocol generator currently does not support custom constraints. The framework could add support for custom constraints for the protocol generator and specification. There are many types of constraints that could be supported in specification and generator. One could perhaps add support based on the popularity of specific constraints from users/developers. Example constraints: strings following specific regular expression format (e.g. all lower case, any arbitrary regex format) max number of elements on lists/sets keys in one dict type be equal to keys in another dict type other logical constraints, e.g. as supported in ontological languages support for bounds (i.e. min, max) for numerical types (i.e. int and float ) in protocol specification. Example syntax: pt:int[0, ] pt:float[1.0, 10.0] pt:int[-1000, 1000] pt:float[, 0] This would automatically enable support for signed/unsigned int and float . This syntax would allow for unbounded positive/negative/both, or arbitrary bounds to be placed on numerical types. Currently, the developer has to specify a custom type to implement any constraints on primitive types.","title":"Constraints on primitive types in protocols"},{"location":"aea/limits/#subprotocols-multi-party-interactions","text":"Protocols can be allowed to depend on each other. Similarly, protocols might have multiple parties. Furthermore, a turn-taking function that specifies who's turn it is at any given point in the dialogue could be added. Then the current fipa setup is a specific case of turn-taking where the turn shifts after a player sends a single move (unique-reply). But generally, it does not have to be like this. Players could be allowed to send multiple messages until the turn shifts, or until they send specific speech-acts (multiple-replies).","title":"Subprotocols &amp; multi-party interactions"},{"location":"aea/limits/#timeouts-in-protocols","text":"Protocols currently do not implement the concept of timeouts. We leave it to the skill developer to implement any time-specific protocol rules.","title":"Timeouts in protocols"},{"location":"aea/limits/#framework-internal-messages","text":"The activation/deactivation of skills and addition/removal of components is implemented in a \"passive\" way - the skill posts a request in its skill context queue (in the case of new behaviours), or it just sets a flag (in case of activation/deactivation of skills). One could consider that a skill can send requests to the framework, via the internal protocol, to modify its resources or its status. The DecisionMaker or the Filter can be the components that take such actions. This is a further small but meaningful step toward an actor-based model for agent internals.","title":"Framework internal messages"},{"location":"aea/limits/#ledger-transaction-management","text":"Currently, the framework does not manage any aspect of submitting multiple transactions to the ledgers. This responsibility is left to skills. Additionally, the ledger APIs/contract APIs take the ledger as a reference to determine the nonce for a transaction. If a new transaction is sent before a previous transaction has been processed then the nonce will not be incremented correctly for the second transaction. This can lead to submissions of multiple transactions with the same nonce, and therefore failure of subsequent transactions. A naive approach would involve manually incrementing the nonce and then submitting transactions into the pool with the correct nonce for eventual inclusion. The problem with this approach is that any failure of a transaction will cause non of the subsequent transactions to be processed for some ledgers (https://ethereum.stackexchange.com/questions/2808/what-happens-when-a-transaction-nonce-is-too-high). To recover from a transaction failure not only the failed transaction would need to be handled, but potentially also all subsequent transactions. It is easy to see that logic required to recover from a transaction failure early in a sequence can be arbitrarily complex (involving potentially new negotiations between agents, new signatures having to be generated etc.). A further problem with the naive approach is that it (imperfectly) replicates the ledger state (with respect to (subset of state of) a specific account). A simple solution looks as follows: each time a transaction is constructed (requiring a new nonce) the transaction construction is queued until all previous transactions have been included in the ledger or failed. This way, at any one time the agent has only at most one transaction pending with the ledger. Benefits: simple to understand and maintain, transaction only enter the mempool when they are ready for inclusion which has privacy benefits over submitting a whole sequence of transaction at once. Downside: at most one transaction per block. This approach is currently used and implemented across all the reference skills. Related, the topic of latency in transactions. State channels provide a solution. E.g. Perun . There could also be an interesting overlap with our protocols here.","title":"Ledger transaction management"},{"location":"aea/limits/#unsolved-problems-in-multiplexer-agentloop-interplay","text":"Problem 1: connection generates too many messages in a short amount of time, that are not consumed by the multiplexer Solution: Can be solved by slowing down connections receive method called, controlled by the inbox messages amount Side effects: Most of the connections should have an internal queue because there is no synchronization between internal logic and multiplexer connection receive calls. Problem 2: the send method can take a long time (because send retries logic in connection) Solution: Currently, we apply timeouts on send. Other solutions could be considered, like parallelisation. Problem 3: too many messages are produced by a skill. Solution: Raise an exception on outbox is full or slow down agent loop?","title":"Unsolved problems in Multiplexer - AgentLoop interplay"},{"location":"aea/limits/#acn","text":"","title":"ACN"},{"location":"aea/limits/#agent-mobility-on-acn","text":"If a peer-client or full client switches peer, then the DHT is not updated properly at the moment under certain conditions.","title":"Agent mobility on ACN"},{"location":"aea/limits/#mailbox-connection","text":"The two available connections p2p_libp2p and p2p_libp2p_client imply that the agent is continuously connected and therefore must have uninterrupted network access and the resources to maintain a connection. For more lightweight implementations, a mailbox connection is desirable, as outlined in the ACN documentation.","title":"Mailbox connection"},{"location":"aea/logging/","text":"The AEA framework supports flexible logging capabilities with the standard Python logging library . In this tutorial, we configure logging for an AEA. First of all, create your AEA. aea create my_aea cd my_aea The aea-config.yaml file should look like this. agent_name : my_aea author : fetchai version : 0.1.0 description : '' license : Apache-2.0 aea_version : 0.6.0 fingerprint : {} fingerprint_ignore_patterns : [] connections : - fetchai/stub:0.21.0 contracts : [] protocols : - fetchai/default:1.0.0 skills : - fetchai/error:0.17.0 default_connection : fetchai/stub:0.21.0 default_ledger : fetchai required_ledgers : - fetchai logging_config : disable_existing_loggers : false version : 1 private_key_paths : {} By updating the logging_config section, you can configure the loggers of your application. The format of this section is specified in the logging.config module. At this section you'll find the definition of the configuration dictionary schema. Below is an example of the logging_config value. logging_config : version : 1 disable_existing_loggers : False formatters : standard : format : '%(asctime)s [%(levelname)s] %(name)s: %(message)s' handlers : logfile : class : logging.FileHandler formatter : standard level : DEBUG filename : logconfig.log console : class : logging.StreamHandler formatter : standard level : DEBUG loggers : aea : handlers : - logfile - console level : DEBUG propagate : False This configuration will set up a logger with name aea . It prints both on console and on file with a format specified by the standard formatter. Streaming to browser It is possible to configure the AEA to stream logs to a browser. First, add the following configuration to your AEA: logging_config : version : 1 disable_existing_loggers : false formatters : standard : format : '%(asctime)s [%(levelname)s] %(name)s: %(message)s' handlers : http : class : logging.handlers.HTTPHandler formatter : standard level : INFO host : localhost:5000 url : /stream method : POST loggers : aea : handlers : - http level : INFO propagate : false Second, create a log server: # -*- coding: utf-8 -*- \"\"\"A simple flask server to serve logs.\"\"\" import datetime import itertools import queue from flask import Flask , Response , request , stream_with_context def format_log ( log_dict ): \"\"\"Format a log record.\"\"\" date = datetime . datetime . fromtimestamp ( float ( log_dict [ \"created\" ])) formatted_log = f \"[ { date . isoformat () } ] [ { log_dict [ 'levelname' ] } ] { log_dict [ 'name' ] } : { log_dict [ 'msg' ] } \" return formatted_log def create_app (): \"\"\"Create Flask app for streaming logs.\"\"\" all_logs = [] unread_logs = queue . Queue () app = Flask ( __name__ ) @app . route ( \"/\" ) def index (): \"\"\"Stream logs to client.\"\"\" def generate (): # stream old logs div = \"<div> {} </div>\" for old_row in all_logs : yield div . format ( old_row ) # stream unread logs while True : row = unread_logs . get () all_logs . append ( row ) yield f \"<div> { row } </div>\" rows = generate () title = \"<p>Waiting for logs...</p>\" return Response ( stream_with_context ( itertools . chain ([ title ], rows ))) @app . route ( \"/stream\" , methods = [ \"POST\" ]) def stream (): \"\"\"Save log record from AEA.\"\"\" log_record_formatted = format_log ( dict ( request . form )) unread_logs . put ( log_record_formatted ) return {}, 200 app . run () if __name__ == \"__main__\" : create_app () Save the script in a file called server.py , install flask with pip install flask and run the server with python server.py . Third, run your AEA and visit localhost:5000 in your browser.","title":"Logging"},{"location":"aea/logging/#streaming-to-browser","text":"It is possible to configure the AEA to stream logs to a browser. First, add the following configuration to your AEA: logging_config : version : 1 disable_existing_loggers : false formatters : standard : format : '%(asctime)s [%(levelname)s] %(name)s: %(message)s' handlers : http : class : logging.handlers.HTTPHandler formatter : standard level : INFO host : localhost:5000 url : /stream method : POST loggers : aea : handlers : - http level : INFO propagate : false Second, create a log server: # -*- coding: utf-8 -*- \"\"\"A simple flask server to serve logs.\"\"\" import datetime import itertools import queue from flask import Flask , Response , request , stream_with_context def format_log ( log_dict ): \"\"\"Format a log record.\"\"\" date = datetime . datetime . fromtimestamp ( float ( log_dict [ \"created\" ])) formatted_log = f \"[ { date . isoformat () } ] [ { log_dict [ 'levelname' ] } ] { log_dict [ 'name' ] } : { log_dict [ 'msg' ] } \" return formatted_log def create_app (): \"\"\"Create Flask app for streaming logs.\"\"\" all_logs = [] unread_logs = queue . Queue () app = Flask ( __name__ ) @app . route ( \"/\" ) def index (): \"\"\"Stream logs to client.\"\"\" def generate (): # stream old logs div = \"<div> {} </div>\" for old_row in all_logs : yield div . format ( old_row ) # stream unread logs while True : row = unread_logs . get () all_logs . append ( row ) yield f \"<div> { row } </div>\" rows = generate () title = \"<p>Waiting for logs...</p>\" return Response ( stream_with_context ( itertools . chain ([ title ], rows ))) @app . route ( \"/stream\" , methods = [ \"POST\" ]) def stream (): \"\"\"Save log record from AEA.\"\"\" log_record_formatted = format_log ( dict ( request . form )) unread_logs . put ( log_record_formatted ) return {}, 200 app . run () if __name__ == \"__main__\" : create_app () Save the script in a file called server.py , install flask with pip install flask and run the server with python server.py . Third, run your AEA and visit localhost:5000 in your browser.","title":"Streaming to browser"},{"location":"aea/message-routing/","text":"Message routing can be split up into the routing of incoming and outgoing Messages . It is important to keep in mind that interaction protocols can be maintained between agents (agent to agent) and between components of the AEA (component to component). In the former case, the to / sender fields of the Envelope are agent addresses which must follow the address standard of agents, in the latter case they are component public ids. Crucially, both addresses must reference the same type: agent or component. Incoming Messages Connections receive or create Envelopes which they deposit in the InBox for agent-to-agent communication only, the Multiplexer keeps track of the connection_id via which the Envelope was received. the AgentLoop picks Envelopes off the InBox the AEA tries to decode the message; errors are handled by the ErrorHandler Messages are dispatched based on two rules: checks if to field can be interpreted as skill_id , if so uses that together with the protocol_id to dispatch to the protocol's Handler in the specified Skill , else uses the protocol_id to dispatch to the protocol's Handler in all skills supporting the protocol. Note For agent-to-agent communication it is advisable to have a single skill implement a given protocol. Skills can then forward the messages via skill-to-skill communication to other skills where required. Otherwise, received agent-to-agent messages will be forwarded to all skills implementing a handler for the specified protocol and the developer needs to take care to handle them appropriately (e.g. avoid multiple replies to a single message). Outgoing Messages Skills deposit Messages in OutBox OutBox constructs an Envelope from the Message Multiplexer assigns messages to relevant Connection based on the following rules: Component to component messages are routed by their component_id Agent to agent messages are routed following four rules: checks if EnvelopeContext exists and specifies a Connection , if so uses that else checks which connection handled the last message from sender , if present uses that else checks if default routing is specified for the protocol_id referenced in the Envelope , if so uses that else sends to default Connection . Connections can process Envelopes directly or encode them for transport to another agent. Usage of the EnvelopeContext The EnvelopeContext is used to maintain agent-to-agent communication only and is managed almost entirely by the framework. The developer can set the EnvelopeContext explicitly for the first message in a dialogue to achieve targeted routing to connections (see 2. for outgoing messages). This is relevant when the same agent can be reached via multiple connections. The EnvelopeContext is not sent to another agent.","title":"Message routing"},{"location":"aea/message-routing/#incoming-messages","text":"Connections receive or create Envelopes which they deposit in the InBox for agent-to-agent communication only, the Multiplexer keeps track of the connection_id via which the Envelope was received. the AgentLoop picks Envelopes off the InBox the AEA tries to decode the message; errors are handled by the ErrorHandler Messages are dispatched based on two rules: checks if to field can be interpreted as skill_id , if so uses that together with the protocol_id to dispatch to the protocol's Handler in the specified Skill , else uses the protocol_id to dispatch to the protocol's Handler in all skills supporting the protocol. Note For agent-to-agent communication it is advisable to have a single skill implement a given protocol. Skills can then forward the messages via skill-to-skill communication to other skills where required. Otherwise, received agent-to-agent messages will be forwarded to all skills implementing a handler for the specified protocol and the developer needs to take care to handle them appropriately (e.g. avoid multiple replies to a single message).","title":"Incoming Messages"},{"location":"aea/message-routing/#outgoing-messages","text":"Skills deposit Messages in OutBox OutBox constructs an Envelope from the Message Multiplexer assigns messages to relevant Connection based on the following rules: Component to component messages are routed by their component_id Agent to agent messages are routed following four rules: checks if EnvelopeContext exists and specifies a Connection , if so uses that else checks which connection handled the last message from sender , if present uses that else checks if default routing is specified for the protocol_id referenced in the Envelope , if so uses that else sends to default Connection . Connections can process Envelopes directly or encode them for transport to another agent.","title":"Outgoing Messages"},{"location":"aea/message-routing/#usage-of-the-envelopecontext","text":"The EnvelopeContext is used to maintain agent-to-agent communication only and is managed almost entirely by the framework. The developer can set the EnvelopeContext explicitly for the first message in a dialogue to achieve targeted routing to connections (see 2. for outgoing messages). This is relevant when the same agent can be reached via multiple connections. The EnvelopeContext is not sent to another agent.","title":"Usage of the EnvelopeContext"},{"location":"aea/ml-skills/","text":"The AEA ML (machine learning) skills demonstrate an interaction between two AEAs, one purchasing data from the other and training a machine learning model with it. There are two types of AEAs: The ml_data_provider which sells training data. The ml_model_trainer which purchases data and trains a model Discussion This demo aims to demonstrate the integration of a simple AEA with machine learning using the AEA framework. The ml_data_provider AEA provides some sample data and delivers to the client upon payment. Once the client receives the data, it trains a model. This process can be found in tasks.py . This demo does not utilize a smart contract. As a result, the ledger interaction is only for completing a transaction. Since the AEA framework enables using third-party libraries from PyPI, we can directly reference any external dependencies. The aea install command installs all dependencies an AEA needs that is listed in one of its skills' YAML file. Communication This diagram shows the communication between the two AEAs. sequenceDiagram participant ml_model_trainer participant ml_data_provider participant Search participant Ledger activate ml_model_trainer activate ml_data_provider activate Search activate Ledger ml_data_provider->>Search: register_service ml_model_trainer->>Search: search Search-->>ml_model_trainer: list_of_agents ml_model_trainer->>ml_data_provider: call_for_terms ml_data_provider->>ml_model_trainer: terms ml_model_trainer->>Ledger: request_transaction ml_model_trainer->>ml_data_provider: accept (incl transaction_hash) ml_data_provider->>Ledger: check_transaction_status ml_data_provider->>ml_model_trainer: data loop train ml_model_trainer->>ml_model_trainer: tran_model end deactivate ml_model_trainer deactivate ml_data_provider deactivate Search deactivate Ledger Option 1: AEA Manager approach Follow this approach when using the AEA Manager Desktop app. Otherwise, skip and follow the CLI approach below. Preparation instructions Install the AEA Manager . Demo instructions The following steps assume you have launched the AEA Manager Desktop app. Add a new AEA called ml_data_provider with public id fetchai/ml_data_provider:0.28.0 . Add another new AEA called ml_model_trainer with public id fetchai/ml_model_trainer:0.29.0 . Copy the address from the ml_model_trainer into your clip board. Then go to the StargateWorld block explorer and request some test tokens via Get Funds . Run the ml_data_provider AEA. Navigate to its logs and copy the multiaddress displayed. Navigate to the settings of the ml_model_trainer and under components > connection > fetchai/p2p_libp2p:0.22.0 update as follows (make sure to replace the placeholder with the multiaddress): { \"delegate_uri\" : \"127.0.0.1:11001\" , \"entry_peers\" : [ \"REPLACE_WITH_MULTI_ADDRESS_HERE\" ] , \"local_uri\" : \"127.0.0.1:9001\" , \"log_file\" : \"libp2p_node.log\" , \"public_uri\" : \"127.0.0.1:9001\" } Run the ml_model_trainer . In the AEA's logs, you should see the agents trading successfully, and the training agent training its machine learning model using the data purchased. The trainer keeps purchasing data and training its model until stopped. Option 2: CLI approach Follow this approach when using the aea CLI. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions Create data provider AEA First, fetch the data provider AEA: aea fetch fetchai/ml_data_provider:0.31.0 cd ml_data_provider aea install aea build Alternatively, create from scratch. The following steps create the data provider from scratch: aea create ml_data_provider cd ml_data_provider aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/ml_data_provider:0.26.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build Create model trainer AEA Then, fetch the model trainer AEA: aea fetch fetchai/ml_model_trainer:0.32.0 cd ml_model_trainer aea install aea build Alternatively, create from scratch. The following steps create the model trainer from scratch: aea create ml_model_trainer cd ml_model_trainer aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/ml_train:0.28.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build Add keys for the data provider AEA First, create the private key for the data provider AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Add keys and generate wealth for the model trainer AEA The model trainer needs to have some wealth to purchase the data from the data provider. First, create the private key for the model trainer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your model trainer based on the network you want to transact with. On the Fetch.ai StargateWorld network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Run both AEAs Run both AEAs from their respective terminals. First, run the data provider AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the ML data provider. Then, in the ML model trainer, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the model trainer to connect to the same local agent communication network as the data provider. Then run the model trainer AEA: aea run You can see that the AEAs find each other, negotiate and eventually trade. After the trade, the model trainer AEA trains its ML model using the data it has purchased. This AEA keeps purchasing data and training its model until stopped. Cleaning up When you're finished, delete your AEAs: cd .. aea delete ml_data_provider aea delete ml_model_trainer","title":"ML skills"},{"location":"aea/ml-skills/#discussion","text":"This demo aims to demonstrate the integration of a simple AEA with machine learning using the AEA framework. The ml_data_provider AEA provides some sample data and delivers to the client upon payment. Once the client receives the data, it trains a model. This process can be found in tasks.py . This demo does not utilize a smart contract. As a result, the ledger interaction is only for completing a transaction. Since the AEA framework enables using third-party libraries from PyPI, we can directly reference any external dependencies. The aea install command installs all dependencies an AEA needs that is listed in one of its skills' YAML file.","title":"Discussion"},{"location":"aea/ml-skills/#communication","text":"This diagram shows the communication between the two AEAs. sequenceDiagram participant ml_model_trainer participant ml_data_provider participant Search participant Ledger activate ml_model_trainer activate ml_data_provider activate Search activate Ledger ml_data_provider->>Search: register_service ml_model_trainer->>Search: search Search-->>ml_model_trainer: list_of_agents ml_model_trainer->>ml_data_provider: call_for_terms ml_data_provider->>ml_model_trainer: terms ml_model_trainer->>Ledger: request_transaction ml_model_trainer->>ml_data_provider: accept (incl transaction_hash) ml_data_provider->>Ledger: check_transaction_status ml_data_provider->>ml_model_trainer: data loop train ml_model_trainer->>ml_model_trainer: tran_model end deactivate ml_model_trainer deactivate ml_data_provider deactivate Search deactivate Ledger","title":"Communication"},{"location":"aea/ml-skills/#option-1-aea-manager-approach","text":"Follow this approach when using the AEA Manager Desktop app. Otherwise, skip and follow the CLI approach below.","title":"Option 1: AEA Manager approach"},{"location":"aea/ml-skills/#preparation-instructions","text":"Install the AEA Manager .","title":"Preparation instructions"},{"location":"aea/ml-skills/#demo-instructions","text":"The following steps assume you have launched the AEA Manager Desktop app. Add a new AEA called ml_data_provider with public id fetchai/ml_data_provider:0.28.0 . Add another new AEA called ml_model_trainer with public id fetchai/ml_model_trainer:0.29.0 . Copy the address from the ml_model_trainer into your clip board. Then go to the StargateWorld block explorer and request some test tokens via Get Funds . Run the ml_data_provider AEA. Navigate to its logs and copy the multiaddress displayed. Navigate to the settings of the ml_model_trainer and under components > connection > fetchai/p2p_libp2p:0.22.0 update as follows (make sure to replace the placeholder with the multiaddress): { \"delegate_uri\" : \"127.0.0.1:11001\" , \"entry_peers\" : [ \"REPLACE_WITH_MULTI_ADDRESS_HERE\" ] , \"local_uri\" : \"127.0.0.1:9001\" , \"log_file\" : \"libp2p_node.log\" , \"public_uri\" : \"127.0.0.1:9001\" } Run the ml_model_trainer . In the AEA's logs, you should see the agents trading successfully, and the training agent training its machine learning model using the data purchased. The trainer keeps purchasing data and training its model until stopped.","title":"Demo instructions"},{"location":"aea/ml-skills/#option-2-cli-approach","text":"Follow this approach when using the aea CLI.","title":"Option 2: CLI approach"},{"location":"aea/ml-skills/#preparation-instructions_1","text":"","title":"Preparation instructions"},{"location":"aea/ml-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/ml-skills/#demo-instructions_1","text":"","title":"Demo instructions"},{"location":"aea/ml-skills/#create-data-provider-aea","text":"First, fetch the data provider AEA: aea fetch fetchai/ml_data_provider:0.31.0 cd ml_data_provider aea install aea build Alternatively, create from scratch. The following steps create the data provider from scratch: aea create ml_data_provider cd ml_data_provider aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/ml_data_provider:0.26.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build","title":"Create data provider AEA"},{"location":"aea/ml-skills/#create-model-trainer-aea","text":"Then, fetch the model trainer AEA: aea fetch fetchai/ml_model_trainer:0.32.0 cd ml_model_trainer aea install aea build Alternatively, create from scratch. The following steps create the model trainer from scratch: aea create ml_model_trainer cd ml_model_trainer aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/ml_train:0.28.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build","title":"Create model trainer AEA"},{"location":"aea/ml-skills/#add-keys-for-the-data-provider-aea","text":"First, create the private key for the data provider AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for the data provider AEA"},{"location":"aea/ml-skills/#add-keys-and-generate-wealth-for-the-model-trainer-aea","text":"The model trainer needs to have some wealth to purchase the data from the data provider. First, create the private key for the model trainer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your model trainer based on the network you want to transact with. On the Fetch.ai StargateWorld network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys and generate wealth for the model trainer AEA"},{"location":"aea/ml-skills/#run-both-aeas","text":"Run both AEAs from their respective terminals. First, run the data provider AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the ML data provider. Then, in the ML model trainer, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the model trainer to connect to the same local agent communication network as the data provider. Then run the model trainer AEA: aea run You can see that the AEAs find each other, negotiate and eventually trade. After the trade, the model trainer AEA trains its ML model using the data it has purchased. This AEA keeps purchasing data and training its model until stopped.","title":"Run both AEAs"},{"location":"aea/ml-skills/#cleaning-up","text":"When you're finished, delete your AEAs: cd .. aea delete ml_data_provider aea delete ml_model_trainer","title":"Cleaning up"},{"location":"aea/modes/","text":"We can run an AEA in multiple modes thanks to the configurable design of the framework. The AEA contains two runnable parts, the AgentLoop , which operates the skills, and the Multiplexer, which operates the connections. The AgentLoop can be configured to run in async or sync mode. The Multiplexer by default runs in async mode. The AEA itself, can be configured to run in async mode, if both the Multiplexer and AgentLoop have the same mode, or in threaded mode. The latter ensures that AgentLoop and Multiplexer are run in separate threads.","title":"Modes of running an AEA"},{"location":"aea/multi-agent-manager/","text":"The MultiAgentManager allows managing multiple agent projects programmatically. Setup We instantiate the manager by providing it with the working directory in which to operate and starting it: import os from pathlib import Path from aea.manager import MultiAgentManager WORKING_DIR = \"mam\" manager = MultiAgentManager ( WORKING_DIR ) manager . start_manager () Adding projects We first add a couple of finished AEA project: from aea.configurations.base import PublicId weather_station_id = PublicId . from_str ( \"fetchai/weather_station:0.31.0\" ) weather_client_id = PublicId . from_str ( \"fetchai/weather_client:0.32.0\" ) manager . add_project ( weather_station_id ) manager . add_project ( weather_client_id ) weather_station_name = weather_station_id . name weather_client_name = weather_client_id . name Adding agent instances Add the agent instances agent_overrides = { \"private_key_paths\" : { \"fetchai\" : \"fetchai_private_key.txt\" }, \"connection_private_key_paths\" : { \"fetchai\" : \"fetchai_connection_private_key.txt\" } } p2p_public_id = PublicId . from_str ( \"fetchai/p2p_libp2p:0.25.0\" ) soef_public_id = PublicId . from_str ( \"fetchai/soef:0.26.0\" ) component_overrides = [{ ** p2p_public_id . json , \"type\" : \"connection\" , \"cert_requests\" : [{ \"identifier\" : \"acn\" , \"ledger_id\" : \"fetchai\" , \"not_after\" : '2022-01-01' , \"not_before\" : '2021-01-01' , \"public_key\" : \"fetchai\" , \"message_format\" : \" {public_key} \" , \"save_path\" : \"conn_cert.txt\" }] }, { ** soef_public_id . json , \"type\" : \"connection\" , \"config\" : { \"token_storage_path\" : \"soef_token.txt\" } }] manager . add_agent ( weather_station_id , component_overrides = component_overrides , agent_overrides = agent_overrides ) agent_overrides = { \"private_key_paths\" : { \"fetchai\" : \"fetchai_private_key.txt\" }, \"connection_private_key_paths\" : { \"fetchai\" : \"fetchai_connection_private_key.txt\" } } component_overrides = [{ ** p2p_public_id . json , \"type\" : \"connection\" , \"config\" : { \"delegate_uri\" : \"127.0.0.1:11001\" , \"entry_peers\" : [ '/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAkzgZYyk25XjAhmgXcdMbahrHYi18uuAzHuxPn1KkdmLRw' ], \"local_uri\" : \"127.0.0.1:9001\" , \"public_uri\" : \"127.0.0.1:9001\" , }, \"cert_requests\" : [{ \"identifier\" : \"acn\" , \"ledger_id\" : \"fetchai\" , \"not_after\" : '2022-01-01' , \"not_before\" : '2021-01-01' , \"public_key\" : \"fetchai\" , \"message_format\" : \" {public_key} \" , \"save_path\" : \"conn_cert.txt\" }] }, { ** soef_public_id . json , \"type\" : \"connection\" , \"config\" : { \"token_storage_path\" : \"soef_token.txt\" } }] manager . add_agent ( weather_client_id , component_overrides = component_overrides , agent_overrides = agent_overrides ) Save the following private keys in the respective files. FET_PRIVATE_KEY_STATION = b \"72d3149f5689f0749eaec5ebf6dba5deeb1e89b93ae1c58c71fd43dfaa231e87\" FET_PRIVATE_KEY_PATH_STATION = Path ( manager . data_dir , weather_station_name , \"fetchai_private_key.txt\" ) . absolute () FET_PRIVATE_KEY_PATH_STATION . write_bytes ( FET_PRIVATE_KEY_STATION ) FET_CONNECTION_PRIVATE_KEY_STATION = b \"bf529acb2546e13615ef6004c48e393f0638a5dc0c4979631a9a4bc554079f6f\" FET_CONNECTION_PRIVATE_KEY_PATH_STATION = Path ( manager . data_dir , weather_station_name , \"fetchai_connection_private_key.txt\" ) . absolute () FET_CONNECTION_PRIVATE_KEY_PATH_STATION . write_bytes ( FET_CONNECTION_PRIVATE_KEY_STATION ) FET_PRIVATE_KEY_CLIENT = b \"589839ae54b71b8754a7fe96b52045364077c28705a1806b74441debcae16e0a\" FET_PRIVATE_KEY_PATH_CLIENT = Path ( manager . data_dir , weather_client_name , \"fetchai_private_key.txt\" ) . absolute () FET_PRIVATE_KEY_PATH_CLIENT . write_bytes ( FET_PRIVATE_KEY_CLIENT ) FET_CONNECTION_PRIVATE_KEY_CLIENT = b \"c9b38eff57f678f5ab5304447997351edb08eceb883267fa4ad849074bec07e4\" FET_CONNECTION_PRIVATE_KEY_PATH_CLIENT = Path ( manager . data_dir , weather_client_name , \"fetchai_connection_private_key.txt\" ) . absolute () FET_CONNECTION_PRIVATE_KEY_PATH_CLIENT . write_bytes ( FET_CONNECTION_PRIVATE_KEY_CLIENT ) Running the agents: import time manager . start_agent ( weather_station_id . name ) # wait for ~10 seconds for peer node to go live time . sleep ( 10.0 ) manager . start_agent ( weather_client_id . name ) time . sleep ( 5.0 ) Stopping the agents: manager . stop_all_agents () Cleaning up manager . stop_manager () Limitations The MultiAgentManager can only be used with compatible package versions, in particular the same package (with respect to author and name) cannot be used in different versions. If you want to run multiple agents with differing versions of the same package then use the aea launch command in the multi-processing mode, or simply launch each agent individually with aea run .","title":"Multi agent manager"},{"location":"aea/multi-agent-manager/#setup","text":"We instantiate the manager by providing it with the working directory in which to operate and starting it: import os from pathlib import Path from aea.manager import MultiAgentManager WORKING_DIR = \"mam\" manager = MultiAgentManager ( WORKING_DIR ) manager . start_manager ()","title":"Setup"},{"location":"aea/multi-agent-manager/#adding-projects","text":"We first add a couple of finished AEA project: from aea.configurations.base import PublicId weather_station_id = PublicId . from_str ( \"fetchai/weather_station:0.31.0\" ) weather_client_id = PublicId . from_str ( \"fetchai/weather_client:0.32.0\" ) manager . add_project ( weather_station_id ) manager . add_project ( weather_client_id ) weather_station_name = weather_station_id . name weather_client_name = weather_client_id . name","title":"Adding projects"},{"location":"aea/multi-agent-manager/#adding-agent-instances","text":"Add the agent instances agent_overrides = { \"private_key_paths\" : { \"fetchai\" : \"fetchai_private_key.txt\" }, \"connection_private_key_paths\" : { \"fetchai\" : \"fetchai_connection_private_key.txt\" } } p2p_public_id = PublicId . from_str ( \"fetchai/p2p_libp2p:0.25.0\" ) soef_public_id = PublicId . from_str ( \"fetchai/soef:0.26.0\" ) component_overrides = [{ ** p2p_public_id . json , \"type\" : \"connection\" , \"cert_requests\" : [{ \"identifier\" : \"acn\" , \"ledger_id\" : \"fetchai\" , \"not_after\" : '2022-01-01' , \"not_before\" : '2021-01-01' , \"public_key\" : \"fetchai\" , \"message_format\" : \" {public_key} \" , \"save_path\" : \"conn_cert.txt\" }] }, { ** soef_public_id . json , \"type\" : \"connection\" , \"config\" : { \"token_storage_path\" : \"soef_token.txt\" } }] manager . add_agent ( weather_station_id , component_overrides = component_overrides , agent_overrides = agent_overrides ) agent_overrides = { \"private_key_paths\" : { \"fetchai\" : \"fetchai_private_key.txt\" }, \"connection_private_key_paths\" : { \"fetchai\" : \"fetchai_connection_private_key.txt\" } } component_overrides = [{ ** p2p_public_id . json , \"type\" : \"connection\" , \"config\" : { \"delegate_uri\" : \"127.0.0.1:11001\" , \"entry_peers\" : [ '/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAkzgZYyk25XjAhmgXcdMbahrHYi18uuAzHuxPn1KkdmLRw' ], \"local_uri\" : \"127.0.0.1:9001\" , \"public_uri\" : \"127.0.0.1:9001\" , }, \"cert_requests\" : [{ \"identifier\" : \"acn\" , \"ledger_id\" : \"fetchai\" , \"not_after\" : '2022-01-01' , \"not_before\" : '2021-01-01' , \"public_key\" : \"fetchai\" , \"message_format\" : \" {public_key} \" , \"save_path\" : \"conn_cert.txt\" }] }, { ** soef_public_id . json , \"type\" : \"connection\" , \"config\" : { \"token_storage_path\" : \"soef_token.txt\" } }] manager . add_agent ( weather_client_id , component_overrides = component_overrides , agent_overrides = agent_overrides ) Save the following private keys in the respective files. FET_PRIVATE_KEY_STATION = b \"72d3149f5689f0749eaec5ebf6dba5deeb1e89b93ae1c58c71fd43dfaa231e87\" FET_PRIVATE_KEY_PATH_STATION = Path ( manager . data_dir , weather_station_name , \"fetchai_private_key.txt\" ) . absolute () FET_PRIVATE_KEY_PATH_STATION . write_bytes ( FET_PRIVATE_KEY_STATION ) FET_CONNECTION_PRIVATE_KEY_STATION = b \"bf529acb2546e13615ef6004c48e393f0638a5dc0c4979631a9a4bc554079f6f\" FET_CONNECTION_PRIVATE_KEY_PATH_STATION = Path ( manager . data_dir , weather_station_name , \"fetchai_connection_private_key.txt\" ) . absolute () FET_CONNECTION_PRIVATE_KEY_PATH_STATION . write_bytes ( FET_CONNECTION_PRIVATE_KEY_STATION ) FET_PRIVATE_KEY_CLIENT = b \"589839ae54b71b8754a7fe96b52045364077c28705a1806b74441debcae16e0a\" FET_PRIVATE_KEY_PATH_CLIENT = Path ( manager . data_dir , weather_client_name , \"fetchai_private_key.txt\" ) . absolute () FET_PRIVATE_KEY_PATH_CLIENT . write_bytes ( FET_PRIVATE_KEY_CLIENT ) FET_CONNECTION_PRIVATE_KEY_CLIENT = b \"c9b38eff57f678f5ab5304447997351edb08eceb883267fa4ad849074bec07e4\" FET_CONNECTION_PRIVATE_KEY_PATH_CLIENT = Path ( manager . data_dir , weather_client_name , \"fetchai_connection_private_key.txt\" ) . absolute () FET_CONNECTION_PRIVATE_KEY_PATH_CLIENT . write_bytes ( FET_CONNECTION_PRIVATE_KEY_CLIENT )","title":"Adding agent instances"},{"location":"aea/multi-agent-manager/#running-the-agents","text":"import time manager . start_agent ( weather_station_id . name ) # wait for ~10 seconds for peer node to go live time . sleep ( 10.0 ) manager . start_agent ( weather_client_id . name ) time . sleep ( 5.0 )","title":"Running the agents:"},{"location":"aea/multi-agent-manager/#stopping-the-agents","text":"manager . stop_all_agents ()","title":"Stopping the agents:"},{"location":"aea/multi-agent-manager/#cleaning-up","text":"manager . stop_manager ()","title":"Cleaning up"},{"location":"aea/multi-agent-manager/#limitations","text":"The MultiAgentManager can only be used with compatible package versions, in particular the same package (with respect to author and name) cannot be used in different versions. If you want to run multiple agents with differing versions of the same package then use the aea launch command in the multi-processing mode, or simply launch each agent individually with aea run .","title":"Limitations"},{"location":"aea/multiplexer-standalone/","text":"The Multiplexer can be used stand-alone. This way a developer can utilise the protocols and connections independent of the Agent or AEA classes. First, import the Python and application specific libraries and set the static variables. (Get the packages directory from the AEA repository svn export https://github.com/fetchai/agents-aea.git/trunk/packages .) import os import time from copy import copy from threading import Thread from typing import Optional from aea.configurations.base import ConnectionConfig from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from aea.multiplexer import Multiplexer from packages.fetchai.connections.stub.connection import StubConnection from packages.fetchai.protocols.default.message import DefaultMessage INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" Instantiate a Multiplexer A Multiplexer only needs a list of connections. The StubConnection is a simple connection which reads from and writes to file. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects configuration = ConnectionConfig ( input_file = INPUT_FILE , output_file = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , data_dir = \".\" , identity = Identity ( \"some_agent\" , \"some_address\" , \"some_public_key\" ), ) multiplexer = Multiplexer ([ stub_connection ], protocols = [ DefaultMessage ]) Start the Multiplexer We can run a multiplexer by calling, connect() which starts the receive and sending loops. We run the multiplexer from a different thread so that we can still use the main thread to pass it messages. try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up for _ in range ( 20 ): if multiplexer . is_connected : break time . sleep ( 1 ) else : raise Exception ( \"Not connected\" ) Send and receive an envelope We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:1.0.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed for _ in range ( 20 ): if not multiplexer . in_queue . empty (): break time . sleep ( 1 ) else : raise Exception ( \"No message!\" ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_specification_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_specification_id , envelope . message , ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ()) Shutdown Finally stop our multiplexer and wait for it to finish finally : # Shut down the multiplexer multiplexer . disconnect () t . join () Your turn Now it is your turn to develop a simple use case which utilises the Multiplexer to send and receive Envelopes. Entire code listing If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from copy import copy from threading import Thread from typing import Optional from aea.configurations.base import ConnectionConfig from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from aea.multiplexer import Multiplexer from packages.fetchai.connections.stub.connection import StubConnection from packages.fetchai.protocols.default.message import DefaultMessage INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" def run (): \"\"\"Run demo.\"\"\" # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects configuration = ConnectionConfig ( input_file = INPUT_FILE , output_file = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , data_dir = \".\" , identity = Identity ( \"some_agent\" , \"some_address\" , \"some_public_key\" ), ) multiplexer = Multiplexer ([ stub_connection ], protocols = [ DefaultMessage ]) try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up for _ in range ( 20 ): if multiplexer . is_connected : break time . sleep ( 1 ) else : raise Exception ( \"Not connected\" ) # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:1.0.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed for _ in range ( 20 ): if not multiplexer . in_queue . empty (): break time . sleep ( 1 ) else : raise Exception ( \"No message!\" ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_specification_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_specification_id , envelope . message , ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ()) finally : # Shut down the multiplexer multiplexer . disconnect () t . join () if __name__ == \"__main__\" : run ()","title":"Use multiplexer stand-alone"},{"location":"aea/multiplexer-standalone/#instantiate-a-multiplexer","text":"A Multiplexer only needs a list of connections. The StubConnection is a simple connection which reads from and writes to file. # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects configuration = ConnectionConfig ( input_file = INPUT_FILE , output_file = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , data_dir = \".\" , identity = Identity ( \"some_agent\" , \"some_address\" , \"some_public_key\" ), ) multiplexer = Multiplexer ([ stub_connection ], protocols = [ DefaultMessage ])","title":"Instantiate a Multiplexer"},{"location":"aea/multiplexer-standalone/#start-the-multiplexer","text":"We can run a multiplexer by calling, connect() which starts the receive and sending loops. We run the multiplexer from a different thread so that we can still use the main thread to pass it messages. try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up for _ in range ( 20 ): if multiplexer . is_connected : break time . sleep ( 1 ) else : raise Exception ( \"Not connected\" )","title":"Start the Multiplexer"},{"location":"aea/multiplexer-standalone/#send-and-receive-an-envelope","text":"We use the input and output text files to send an envelope to our agent and receive a response # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:1.0.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed for _ in range ( 20 ): if not multiplexer . in_queue . empty (): break time . sleep ( 1 ) else : raise Exception ( \"No message!\" ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_specification_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_specification_id , envelope . message , ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ())","title":"Send and receive an envelope"},{"location":"aea/multiplexer-standalone/#shutdown","text":"Finally stop our multiplexer and wait for it to finish finally : # Shut down the multiplexer multiplexer . disconnect () t . join ()","title":"Shutdown"},{"location":"aea/multiplexer-standalone/#your-turn","text":"Now it is your turn to develop a simple use case which utilises the Multiplexer to send and receive Envelopes.","title":"Your turn"},{"location":"aea/multiplexer-standalone/#entire-code-listing","text":"If you just want to copy and paste the entire script in you can find it here: Click here to see full listing import os import time from copy import copy from threading import Thread from typing import Optional from aea.configurations.base import ConnectionConfig from aea.helpers.file_io import write_with_lock from aea.identity.base import Identity from aea.mail.base import Envelope from aea.multiplexer import Multiplexer from packages.fetchai.connections.stub.connection import StubConnection from packages.fetchai.protocols.default.message import DefaultMessage INPUT_FILE = \"input.txt\" OUTPUT_FILE = \"output.txt\" def run (): \"\"\"Run demo.\"\"\" # Ensure the input and output files do not exist initially if os . path . isfile ( INPUT_FILE ): os . remove ( INPUT_FILE ) if os . path . isfile ( OUTPUT_FILE ): os . remove ( OUTPUT_FILE ) # create the connection and multiplexer objects configuration = ConnectionConfig ( input_file = INPUT_FILE , output_file = OUTPUT_FILE , connection_id = StubConnection . connection_id , ) stub_connection = StubConnection ( configuration = configuration , data_dir = \".\" , identity = Identity ( \"some_agent\" , \"some_address\" , \"some_public_key\" ), ) multiplexer = Multiplexer ([ stub_connection ], protocols = [ DefaultMessage ]) try : # Set the multiplexer running in a different thread t = Thread ( target = multiplexer . connect ) t . start () # Wait for everything to start up for _ in range ( 20 ): if multiplexer . is_connected : break time . sleep ( 1 ) else : raise Exception ( \"Not connected\" ) # Create a message inside an envelope and get the stub connection to pass it into the multiplexer message_text = ( \"multiplexer,some_agent,fetchai/default:1.0.0, \\x08\\x01 * \\x07\\n\\x05 hello,\" ) with open ( INPUT_FILE , \"w\" ) as f : write_with_lock ( f , message_text ) # Wait for the envelope to get processed for _ in range ( 20 ): if not multiplexer . in_queue . empty (): break time . sleep ( 1 ) else : raise Exception ( \"No message!\" ) # get the envelope envelope = multiplexer . get () # type: Optional[Envelope] assert envelope is not None # Inspect its contents print ( \"Envelope received by Multiplexer: sender= {} , to= {} , protocol_specification_id= {} , message= {} \" . format ( envelope . sender , envelope . to , envelope . protocol_specification_id , envelope . message , ) ) # Create a mirrored response envelope response_envelope = copy ( envelope ) response_envelope . to = envelope . sender response_envelope . sender = envelope . to # Send the envelope back multiplexer . put ( response_envelope ) # Read the output envelope generated by the multiplexer with open ( OUTPUT_FILE , \"r\" ) as f : print ( \"Envelope received from Multiplexer: \" + f . readline ()) finally : # Shut down the multiplexer multiplexer . disconnect () t . join () if __name__ == \"__main__\" : run ()","title":"Entire code listing"},{"location":"aea/oef-ledger/","text":"The Open Economic Framework (OEF) and Decentralized Ledger Technologies (DLTs) allow AEAs to create value through their interaction with other AEAs. The following diagram illustrates the relation of AEAs to the OEF and DLTs. Open Economic Framework (OEF) The Open Economic Framework (OEF) consists of protocols, languages and market mechanisms agents use to search and find each other, communicate with as well as trade with each other. As such the OEF defines the decentralised virtual environment that supplies and supports APIs for autonomous third-party software agents, also known as Autonomous Economic Agents (AEAs). Note The OEF is under development. Expect frequent changes. What follows is a description of the current implementation. At present, the OEF's capabilities are fulfilled by three components: a permissionless, public peer to peer (agent to agent) communication network, called the Agent Communication Network ; a set of agent interaction protocols ; and a centralized search and discovery system . The latter will be decentralized over time. Agent Communication Network (ACN) ACN is a peer-to-peer communication network for agents . It allows AEAs to send and receive envelopes between each other. The implementation builds on the open-source libp2p library. A distributed hash table is used by all participating peers to maintain a mapping between agents' cryptographic addresses and their network addresses. Agents can receive messages from other agents if they are both connected to the ACN (see here for an example). Search and Discovery A simple OEF (sOEF) node allows agents to discover each other. In particular, agents can register themselves and the services they offer, and can search for agents who offer specific services. For two agents to be able to find each other, at least one must register itself on the sOEF and the other must query the sOEF node for it. Detailed documentation is provided here . Ledgers Ledgers enable AEAs to store transactions, for example involving the transfer of funds to each other, or the execution of smart contracts. They optionally ensure the truth and integrity of agent to agent interactions. Whilst a ledger can, in principle, be used to store structured data (for instance, training data in a machine learning model) in most use cases the resulting costs and privacy implications do not make this an efficient use of the ledger. Instead, usually only references to structured data - often in the form of hashes - are stored on a ledger, and the actual data is stored off-chain. The Python implementation of the AEA Framework currently integrates with three ledgers: Fetch.ai ledger Ethereum ledger Cosmos ledger However, the framework makes it straightforward for any developer to add support for other ledgers. AEAs as second layer technology The following presentation discusses how AEAs can be seen as second layer technology to ledgers.","title":"Relation to OEF and Ledger"},{"location":"aea/oef-ledger/#open-economic-framework-oef","text":"The Open Economic Framework (OEF) consists of protocols, languages and market mechanisms agents use to search and find each other, communicate with as well as trade with each other. As such the OEF defines the decentralised virtual environment that supplies and supports APIs for autonomous third-party software agents, also known as Autonomous Economic Agents (AEAs). Note The OEF is under development. Expect frequent changes. What follows is a description of the current implementation. At present, the OEF's capabilities are fulfilled by three components: a permissionless, public peer to peer (agent to agent) communication network, called the Agent Communication Network ; a set of agent interaction protocols ; and a centralized search and discovery system . The latter will be decentralized over time.","title":"Open Economic Framework (OEF)"},{"location":"aea/oef-ledger/#agent-communication-network-acn","text":"ACN is a peer-to-peer communication network for agents . It allows AEAs to send and receive envelopes between each other. The implementation builds on the open-source libp2p library. A distributed hash table is used by all participating peers to maintain a mapping between agents' cryptographic addresses and their network addresses. Agents can receive messages from other agents if they are both connected to the ACN (see here for an example).","title":"Agent Communication Network (ACN)"},{"location":"aea/oef-ledger/#search-and-discovery","text":"A simple OEF (sOEF) node allows agents to discover each other. In particular, agents can register themselves and the services they offer, and can search for agents who offer specific services. For two agents to be able to find each other, at least one must register itself on the sOEF and the other must query the sOEF node for it. Detailed documentation is provided here .","title":"Search and Discovery"},{"location":"aea/oef-ledger/#ledgers","text":"Ledgers enable AEAs to store transactions, for example involving the transfer of funds to each other, or the execution of smart contracts. They optionally ensure the truth and integrity of agent to agent interactions. Whilst a ledger can, in principle, be used to store structured data (for instance, training data in a machine learning model) in most use cases the resulting costs and privacy implications do not make this an efficient use of the ledger. Instead, usually only references to structured data - often in the form of hashes - are stored on a ledger, and the actual data is stored off-chain. The Python implementation of the AEA Framework currently integrates with three ledgers: Fetch.ai ledger Ethereum ledger Cosmos ledger However, the framework makes it straightforward for any developer to add support for other ledgers.","title":"Ledgers"},{"location":"aea/oef-ledger/#aeas-as-second-layer-technology","text":"The following presentation discusses how AEAs can be seen as second layer technology to ledgers.","title":"AEAs as second layer technology"},{"location":"aea/oracle-demo/","text":"This demo shows how an AEA can be used to maintain an oracle and how another AEA can request the oracle value. Discussion Oracle agents are agents that have permission to update or validate updates to state variables in a smart contract and whose goal is to accurately estimate or predict some real world quantity or quantities. This demonstration shows how to set up a simple oracle agent who deploys an oracle contract and updates the contract with a token price fetched from a public API. It also shows how to create an oracle client agent that can request the value from the oracle contract. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo Create the oracle AEA Fetch the AEA that will deploy and update the oracle contract. aea fetch fetchai/coin_price_oracle:0.16.0 cd coin_price_oracle aea install aea build Alternatively, create from scratch. Create the AEA that will deploy the contract. aea create coin_price_oracle cd coin_price_oracle aea add connection fetchai/http_client:0.23.0 aea add connection fetchai/ledger:0.19.0 aea add connection fetchai/p2p_libp2p:0.25.0 aea add skill fetchai/advanced_data_request:0.6.0 aea add skill fetchai/simple_oracle:0.14.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea install aea build Set the URL for the data request skill: aea config set --type str vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.url \"https://api.coingecko.com/api/v3/simple/price?ids=fetch-ai&vs_currencies=usd\" Specify the name and JSON path of the data to fetch from the API: aea config set --type list vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.outputs '[{\"name\": \"price\", \"json_path\": \"fetch-ai.usd\"}]' Set the name of the oracle value in the simple oracle skill: aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.oracle_value_name price Then update the agent configuration with the default routing: aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/http:1.0.0\": \"fetchai/http_client:0.23.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\" }' The following steps depend on the type of ledger the oracle will be run on. Select a ledger type by setting a temporary variable to either fetchai or ethereum : LEDGER_ID = fetchai or LEDGER_ID = ethereum Update the default ledger and cert requests using the chosen ledger. aea config set agent.default_ledger $LEDGER_ID aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": ' \"\\\" $LEDGER_ID \\\"\" ', \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"message_format\": \"{public_key}\", \"save_path\": \".certs/conn_cert.txt\"}]' Set the following configuration for the oracle skill: aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.ledger_id $LEDGER_ID If running on the Fetch.ai ledger: aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.update_function update_oracle_value Otherwise, if running on an Ethereum-based ledger: aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.update_function updateOracleValue Additionally, create the private key for the oracle AEA. Generate and add a key for use with the ledger: aea generate-key $LEDGER_ID aea add-key $LEDGER_ID If running on a testnet (not including Ganache), generate some wealth for your AEA: aea generate-wealth $LEDGER_ID Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the keys for use by the connections that request them: aea issue-certificates Create the oracle client AEA From a new terminal (in the same top-level directory), fetch the AEA that will deploy the oracle client contract and call the function that requests the coin price from the oracle contract. aea fetch fetchai/coin_price_oracle_client:0.11.0 cd coin_price_oracle_client aea install Alternatively, create from scratch. Create the AEA that will deploy the contract. aea create coin_price_oracle_client cd coin_price_oracle_client aea add connection fetchai/http_client:0.23.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/simple_oracle_client:0.11.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/ledger:0.19.0 aea install aea build Then update the agent configuration with the default routing: aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/http:1.0.0\": \"fetchai/http_client:0.23.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\" }' Similar to above, set a temporary variable LEDGER_ID=fetchai or LEDGER_ID=ethereum . Set the default ledger: aea config set agent.default_ledger $LEDGER_ID Set the following configuration for the oracle client skill: aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.ledger_id $LEDGER_ID If running on the Fetch.ai ledger: aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.query_function query_oracle_value Otherwise, if running on an Ethereum-based ledger: aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.query_function queryOracleValue Create the private key for the oracle client AEA. Generate and add a key for use on the ledger: aea generate-key $LEDGER_ID aea add-key $LEDGER_ID If running on a testnet (not including Ganache), generate some wealth for your AEA: aea generate-wealth $LEDGER_ID The oracle AEAs require either a locally running test node or a connection to a remote testnet. Setting up with a local Ganache node (Ethereum ledger only) The easiest way to test the oracle agents on an Ethereum-based ledger to set up a local test node using Ganache. This can be done by running the following docker command from the directory you started from (in a new terminal). This command will also fund the accounts of the AEAs: docker run -p 8545 :8545 trufflesuite/ganache-cli:latest --verbose --gasPrice = 0 --gasLimit = 0x1fffffffffffff --account = \" $( cat coin_price_oracle/ethereum_private_key.txt ) ,1000000000000000000000\" --account = \" $( cat coin_price_oracle_client/ethereum_private_key.txt ) ,1000000000000000000000\" Run the enclosed Python script (with web3 installed) from the top-level directory to deploy a mock Fetch ERC20 contract and give some test FET to the client agent. import json import os from web3 import Web3 FILE_DIR = os . path . dirname ( os . path . realpath ( __file__ )) CONTRACT_PATH = os . path . join ( FILE_DIR , \"coin_price_oracle_client/vendor/fetchai/contracts/fet_erc20/build/FetERC20Mock.json\" ) ORACLE_PRIVATE_KEY_PATH = os . path . join ( FILE_DIR , \"coin_price_oracle/ethereum_private_key.txt\" ) CLIENT_PRIVATE_KEY_PATH = os . path . join ( FILE_DIR , \"coin_price_oracle_client/ethereum_private_key.txt\" ) # Solidity source code with open ( CONTRACT_PATH ) as file : compiled_sol = json . load ( file ) # web3.py instance w3 = Web3 ( Web3 . HTTPProvider ( 'http://127.0.0.1:8545' )) # Import oracle account from private key and set to default account with open ( ORACLE_PRIVATE_KEY_PATH ) as file : private_key = file . read () oracle_account = w3 . eth . account . privateKeyToAccount ( private_key ) w3 . eth . defaultAccount = oracle_account . address # Import client account from private key with open ( CLIENT_PRIVATE_KEY_PATH ) as file : private_key = file . read () client_account = w3 . eth . account . privateKeyToAccount ( private_key ) # Deploy mock Fetch ERC20 contract FetERC20Mock = w3 . eth . contract ( abi = compiled_sol [ 'abi' ], bytecode = compiled_sol [ 'bytecode' ]) # Submit the transaction that deploys the contract tx_hash = FetERC20Mock . constructor ( name = \"FetERC20Mock\" , symbol = \"MFET\" , initialSupply = int ( 1e23 ), decimals_ = 18 ) . transact () # Wait for the transaction to be mined, and get the transaction receipt tx_receipt = w3 . eth . waitForTransactionReceipt ( tx_hash ) # Print out the contract address print ( \"FetERC20Mock contract deployed at:\" , tx_receipt . contractAddress ) # Get deployed contract fet_erc20_mock = w3 . eth . contract ( address = tx_receipt . contractAddress , abi = compiled_sol [ 'abi' ]) # Transfer some test FET to oracle client account tx_hash = fet_erc20_mock . functions . transfer ( client_account . address , int ( 1e20 )) . transact () tx_receipt = w3 . eth . waitForTransactionReceipt ( tx_hash ) Set the ERC20 contract address for the oracle AEA (Ethereum ledger only): aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.erc20_address ERC20_ADDRESS where ERC20_ADDRESS is in the output of the script above. Run the oracle AEA Run the oracle agent. This will deploy a contract to the testnet, grant oracle permissions to the AEA's wallet address, and periodically update the contract with the latest price of FET (or whichever coin was specified). aea run After a few moments, you should see the following notices in the logs: info: [ coin_price_oracle ] Oracle contract successfully deployed at address: ... ... info: [ coin_price_oracle ] Oracle role successfully granted! ... info: [ coin_price_oracle ] Oracle value successfully updated! The oracle contract will continue to be updated with the latest retrieved coin price at the default time interval (every 15 seconds). Set the ERC20 and oracle contract addresses for the oracle client AEA: aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.erc20_address ERC20_ADDRESS aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.oracle_contract_address ORACLE_ADDRESS where ORACLE_ADDRESS should be set to the address shown in the oracle AEA logs: Oracle contract successfully deployed at address: ORACLE_ADDRESS Run the oracle client AEA Run the oracle client agent. This will deploy an oracle client contract to the testnet, approve the contract to spend tokens on behalf of the AEA, and periodically call the contract function that requests the latest price of FET (or whichever coin was specified). aea run After a few moments, you should see the following notices in the logs: info: [ coin_price_oracle_client ] Oracle client contract successfully deployed at address: ... ... info: [ coin_price_oracle_client ] Oracle value successfully requested! The AEA will continue to request the latest coin price at the default time interval (every 15 seconds).","title":"Oracle skills"},{"location":"aea/oracle-demo/#discussion","text":"Oracle agents are agents that have permission to update or validate updates to state variables in a smart contract and whose goal is to accurately estimate or predict some real world quantity or quantities. This demonstration shows how to set up a simple oracle agent who deploys an oracle contract and updates the contract with a token price fetched from a public API. It also shows how to create an oracle client agent that can request the value from the oracle contract.","title":"Discussion"},{"location":"aea/oracle-demo/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/oracle-demo/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/oracle-demo/#demo","text":"","title":"Demo"},{"location":"aea/oracle-demo/#create-the-oracle-aea","text":"Fetch the AEA that will deploy and update the oracle contract. aea fetch fetchai/coin_price_oracle:0.16.0 cd coin_price_oracle aea install aea build Alternatively, create from scratch. Create the AEA that will deploy the contract. aea create coin_price_oracle cd coin_price_oracle aea add connection fetchai/http_client:0.23.0 aea add connection fetchai/ledger:0.19.0 aea add connection fetchai/p2p_libp2p:0.25.0 aea add skill fetchai/advanced_data_request:0.6.0 aea add skill fetchai/simple_oracle:0.14.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea install aea build Set the URL for the data request skill: aea config set --type str vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.url \"https://api.coingecko.com/api/v3/simple/price?ids=fetch-ai&vs_currencies=usd\" Specify the name and JSON path of the data to fetch from the API: aea config set --type list vendor.fetchai.skills.advanced_data_request.models.advanced_data_request_model.args.outputs '[{\"name\": \"price\", \"json_path\": \"fetch-ai.usd\"}]' Set the name of the oracle value in the simple oracle skill: aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.oracle_value_name price Then update the agent configuration with the default routing: aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/http:1.0.0\": \"fetchai/http_client:0.23.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\" }' The following steps depend on the type of ledger the oracle will be run on. Select a ledger type by setting a temporary variable to either fetchai or ethereum : LEDGER_ID = fetchai or LEDGER_ID = ethereum Update the default ledger and cert requests using the chosen ledger. aea config set agent.default_ledger $LEDGER_ID aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": ' \"\\\" $LEDGER_ID \\\"\" ', \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"message_format\": \"{public_key}\", \"save_path\": \".certs/conn_cert.txt\"}]' Set the following configuration for the oracle skill: aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.ledger_id $LEDGER_ID If running on the Fetch.ai ledger: aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.update_function update_oracle_value Otherwise, if running on an Ethereum-based ledger: aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.update_function updateOracleValue Additionally, create the private key for the oracle AEA. Generate and add a key for use with the ledger: aea generate-key $LEDGER_ID aea add-key $LEDGER_ID If running on a testnet (not including Ganache), generate some wealth for your AEA: aea generate-wealth $LEDGER_ID Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the keys for use by the connections that request them: aea issue-certificates","title":"Create the oracle AEA"},{"location":"aea/oracle-demo/#create-the-oracle-client-aea","text":"From a new terminal (in the same top-level directory), fetch the AEA that will deploy the oracle client contract and call the function that requests the coin price from the oracle contract. aea fetch fetchai/coin_price_oracle_client:0.11.0 cd coin_price_oracle_client aea install Alternatively, create from scratch. Create the AEA that will deploy the contract. aea create coin_price_oracle_client cd coin_price_oracle_client aea add connection fetchai/http_client:0.23.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/simple_oracle_client:0.11.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/ledger:0.19.0 aea install aea build Then update the agent configuration with the default routing: aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/http:1.0.0\": \"fetchai/http_client:0.23.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\" }' Similar to above, set a temporary variable LEDGER_ID=fetchai or LEDGER_ID=ethereum . Set the default ledger: aea config set agent.default_ledger $LEDGER_ID Set the following configuration for the oracle client skill: aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.ledger_id $LEDGER_ID If running on the Fetch.ai ledger: aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.query_function query_oracle_value Otherwise, if running on an Ethereum-based ledger: aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.query_function queryOracleValue Create the private key for the oracle client AEA. Generate and add a key for use on the ledger: aea generate-key $LEDGER_ID aea add-key $LEDGER_ID If running on a testnet (not including Ganache), generate some wealth for your AEA: aea generate-wealth $LEDGER_ID The oracle AEAs require either a locally running test node or a connection to a remote testnet.","title":"Create the oracle client AEA"},{"location":"aea/oracle-demo/#setting-up-with-a-local-ganache-node-ethereum-ledger-only","text":"The easiest way to test the oracle agents on an Ethereum-based ledger to set up a local test node using Ganache. This can be done by running the following docker command from the directory you started from (in a new terminal). This command will also fund the accounts of the AEAs: docker run -p 8545 :8545 trufflesuite/ganache-cli:latest --verbose --gasPrice = 0 --gasLimit = 0x1fffffffffffff --account = \" $( cat coin_price_oracle/ethereum_private_key.txt ) ,1000000000000000000000\" --account = \" $( cat coin_price_oracle_client/ethereum_private_key.txt ) ,1000000000000000000000\" Run the enclosed Python script (with web3 installed) from the top-level directory to deploy a mock Fetch ERC20 contract and give some test FET to the client agent. import json import os from web3 import Web3 FILE_DIR = os . path . dirname ( os . path . realpath ( __file__ )) CONTRACT_PATH = os . path . join ( FILE_DIR , \"coin_price_oracle_client/vendor/fetchai/contracts/fet_erc20/build/FetERC20Mock.json\" ) ORACLE_PRIVATE_KEY_PATH = os . path . join ( FILE_DIR , \"coin_price_oracle/ethereum_private_key.txt\" ) CLIENT_PRIVATE_KEY_PATH = os . path . join ( FILE_DIR , \"coin_price_oracle_client/ethereum_private_key.txt\" ) # Solidity source code with open ( CONTRACT_PATH ) as file : compiled_sol = json . load ( file ) # web3.py instance w3 = Web3 ( Web3 . HTTPProvider ( 'http://127.0.0.1:8545' )) # Import oracle account from private key and set to default account with open ( ORACLE_PRIVATE_KEY_PATH ) as file : private_key = file . read () oracle_account = w3 . eth . account . privateKeyToAccount ( private_key ) w3 . eth . defaultAccount = oracle_account . address # Import client account from private key with open ( CLIENT_PRIVATE_KEY_PATH ) as file : private_key = file . read () client_account = w3 . eth . account . privateKeyToAccount ( private_key ) # Deploy mock Fetch ERC20 contract FetERC20Mock = w3 . eth . contract ( abi = compiled_sol [ 'abi' ], bytecode = compiled_sol [ 'bytecode' ]) # Submit the transaction that deploys the contract tx_hash = FetERC20Mock . constructor ( name = \"FetERC20Mock\" , symbol = \"MFET\" , initialSupply = int ( 1e23 ), decimals_ = 18 ) . transact () # Wait for the transaction to be mined, and get the transaction receipt tx_receipt = w3 . eth . waitForTransactionReceipt ( tx_hash ) # Print out the contract address print ( \"FetERC20Mock contract deployed at:\" , tx_receipt . contractAddress ) # Get deployed contract fet_erc20_mock = w3 . eth . contract ( address = tx_receipt . contractAddress , abi = compiled_sol [ 'abi' ]) # Transfer some test FET to oracle client account tx_hash = fet_erc20_mock . functions . transfer ( client_account . address , int ( 1e20 )) . transact () tx_receipt = w3 . eth . waitForTransactionReceipt ( tx_hash )","title":"Setting up with a local Ganache node (Ethereum ledger only)"},{"location":"aea/oracle-demo/#set-the-erc20-contract-address-for-the-oracle-aea-ethereum-ledger-only","text":"aea config set vendor.fetchai.skills.simple_oracle.models.strategy.args.erc20_address ERC20_ADDRESS where ERC20_ADDRESS is in the output of the script above.","title":"Set the ERC20 contract address for the oracle AEA (Ethereum ledger only):"},{"location":"aea/oracle-demo/#run-the-oracle-aea","text":"Run the oracle agent. This will deploy a contract to the testnet, grant oracle permissions to the AEA's wallet address, and periodically update the contract with the latest price of FET (or whichever coin was specified). aea run After a few moments, you should see the following notices in the logs: info: [ coin_price_oracle ] Oracle contract successfully deployed at address: ... ... info: [ coin_price_oracle ] Oracle role successfully granted! ... info: [ coin_price_oracle ] Oracle value successfully updated! The oracle contract will continue to be updated with the latest retrieved coin price at the default time interval (every 15 seconds).","title":"Run the oracle AEA"},{"location":"aea/oracle-demo/#set-the-erc20-and-oracle-contract-addresses-for-the-oracle-client-aea","text":"aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.erc20_address ERC20_ADDRESS aea config set vendor.fetchai.skills.simple_oracle_client.models.strategy.args.oracle_contract_address ORACLE_ADDRESS where ORACLE_ADDRESS should be set to the address shown in the oracle AEA logs: Oracle contract successfully deployed at address: ORACLE_ADDRESS","title":"Set the ERC20 and oracle contract addresses for the oracle client AEA:"},{"location":"aea/oracle-demo/#run-the-oracle-client-aea","text":"Run the oracle client agent. This will deploy an oracle client contract to the testnet, approve the contract to spend tokens on behalf of the AEA, and periodically call the contract function that requests the latest price of FET (or whichever coin was specified). aea run After a few moments, you should see the following notices in the logs: info: [ coin_price_oracle_client ] Oracle client contract successfully deployed at address: ... ... info: [ coin_price_oracle_client ] Oracle value successfully requested! The AEA will continue to request the latest coin price at the default time interval (every 15 seconds).","title":"Run the oracle client AEA"},{"location":"aea/orm-integration/","text":"This guide demonstrates how to configure an AEA to interact with a database using python-sql objects. Discussion Object-relational-mapping (ORM) is the idea of being able to write SQL queries, using the object-oriented paradigm of your preferred programming language. The scope of this guide is to demonstrate how you can create an easily configurable AEA that reads data from a database using ORMs. We assume, that you followed the guide for the thermometer-skills. We assume, that we have a database genericdb.db with table name data . This table contains the following columns timestamp and thermometer . We assume, that we have a hardware thermometer sensor that adds the readings in the genericdb database (although you can follow the guide without having access to a sensor). Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and which is listed in the skill's YAML file. Communication This diagram shows the communication between the various entities in the case where the thermometer data is successfully sold by the seller AEA to the buyer. sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept Buyer_AEA->>Blockchain: transfer_funds Buyer_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions This demo involves a true ledger transaction on Fetch.ai's testnet network or Ethereum's ropsten . This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Create the seller AEA First, fetch the seller AEA which provides thermometer data: aea fetch fetchai/thermometer_aea:0.29.0 --alias my_thermometer_aea cd my_thermometer_aea aea install aea build Alternatively, create from scratch. The following steps create the seller from scratch: aea create my_thermometer_aea cd my_thermometer_aea aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/thermometer:0.26.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build Create the buyer client In another terminal, fetch the buyer AEA: aea fetch fetchai/thermometer_client:0.30.0 --alias my_thermometer_client cd my_thermometer_client aea install aea build Alternatively, create from scratch. The following steps create the car data client from scratch: aea create my_thermometer_client cd my_thermometer_client aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/thermometer_client:0.25.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build Add keys for the seller AEA First, create the private key for the seller AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Add keys and generate wealth for the buyer AEA The buyer needs to have some wealth to purchase the thermometer data. First, create the private key for the buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for the buyer based on the network you want to transact with. On the Fetch.ai StargateWorld network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Update the seller and buyer AEA skill configurations In my_thermometer_aea/vendor/fetchai/skills/thermometer/skill.yaml , replace the data_for_sale with your data: models : ... strategy : args : currency_id : FET data_for_sale : temperature : 26 has_data_source : false is_ledger_tx : true ledger_id : fetchai location : latitude : 51.5194 longitude : 0.127 service_data : key : seller_service value : thermometer_data service_id : thermometer_data unit_price : 10 class_name : Strategy dependencies : SQLAlchemy : {} The service_data is used to register the service in the SOEF search node and make your agent discoverable. In my_thermometer_client/vendor/fetchai/skills/thermometer_client/skill.yaml ) ensure you have matching data. models : ... strategy : args : currency_id : FET is_ledger_tx : true ledger_id : fetchai location : latitude : 51.5194 longitude : 0.127 max_negotiations : 1 max_tx_fee : 1 max_unit_price : 20 search_query : constraint_type : == search_key : seller_service search_value : thermometer_data search_radius : 5.0 service_id : thermometer_data class_name : Strategy After changing the skill configuration files you should run the following command for both agents to install each dependency: aea install Modify the seller's strategy Before being able to modify a package we need to eject it from vendor: aea eject skill fetchai/thermometer:0.26.0 This will move the package to your skills directory and reset the version to 0.1.0 and the author to your author handle. Open strategy.py (in my_thermometer_aea/skills/thermometer/strategy.py ) and make the following modifications: Import the newly installed sqlalchemy library in your strategy. import sqlalchemy as db Then modify your strategy's __init__ function to match the following code: class Strategy ( GenericStrategy ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :param register_as: determines whether the agent registers as seller, buyer or both :param search_for: determines whether the agent searches for sellers, buyers or both :return: None \"\"\" self . _db_engine = db . create_engine ( \"sqlite:///genericdb.db\" ) self . _tbl = self . create_database_and_table () self . insert_data () super () . __init__ ( ** kwargs ) At the end of the file modify the collect_from_data_source function: def collect_from_data_source ( self ) -> Dict [ str , str ]: \"\"\"Implement the logic to collect data.\"\"\" connection = self . _db_engine . connect () query = db . select ([ self . _tbl ]) result_proxy = connection . execute ( query ) data_points = result_proxy . fetchall () return { \"data\" : json . dumps ( list ( map ( tuple , data_points )))} Also, create two new functions, one that creates a connection with the database, and another that populates the database with some fake data. This is needed in the case you do not have access to an actual thermometer sensor that inserts data in the database. def create_database_and_table ( self ): \"\"\"Creates a database and a table to store the data if not exists.\"\"\" metadata = db . MetaData () tbl = db . Table ( \"data\" , metadata , db . Column ( \"timestamp\" , db . Integer ()), db . Column ( \"temprature\" , db . String ( 255 ), nullable = False ), ) metadata . create_all ( self . _db_engine ) return tbl def insert_data ( self ): \"\"\"Insert data in the database.\"\"\" connection = self . _db_engine . connect () for _ in range ( 10 ): query = db . insert ( self . _tbl ) . values ( # nosec timestamp = time . time (), temprature = str ( random . randrange ( 10 , 25 )) ) connection . execute ( query ) After modifying the skill we need to fingerprint it: aea fingerprint skill { YOUR_AUTHOR_HANDLE } /thermometer:0.1.0 Run both AEAs First, run the thermometer (seller) AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of this address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the thermometer AEA. Then, configure the thermometer client (buyer) to connect to this same local ACN by running the following command in the buyer terminal, replacing SOME_ADDRESS with the value you noted above: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Then run the thermometer client AEA: aea run You will see that the AEAs negotiate and then transact using the configured testnet. Delete the AEAs When you're done, stop the agents ( CTRL+C ), go up a level and delete the AEAs. cd .. aea delete my_thermometer_aea aea delete my_thermometer_client","title":"ORM integration"},{"location":"aea/orm-integration/#discussion","text":"Object-relational-mapping (ORM) is the idea of being able to write SQL queries, using the object-oriented paradigm of your preferred programming language. The scope of this guide is to demonstrate how you can create an easily configurable AEA that reads data from a database using ORMs. We assume, that you followed the guide for the thermometer-skills. We assume, that we have a database genericdb.db with table name data . This table contains the following columns timestamp and thermometer . We assume, that we have a hardware thermometer sensor that adds the readings in the genericdb database (although you can follow the guide without having access to a sensor). Since the AEA framework enables us to use third-party libraries hosted on PyPI we can directly reference the external dependencies. The aea install command will install each dependency that the specific AEA needs and which is listed in the skill's YAML file.","title":"Discussion"},{"location":"aea/orm-integration/#communication","text":"This diagram shows the communication between the various entities in the case where the thermometer data is successfully sold by the seller AEA to the buyer. sequenceDiagram participant Search participant Buyer_AEA participant Seller_AEA participant Blockchain activate Buyer_AEA activate Search activate Seller_AEA activate Blockchain Seller_AEA->>Search: register_service Buyer_AEA->>Search: search Search-->>Buyer_AEA: list_of_agents Buyer_AEA->>Seller_AEA: call_for_proposal Seller_AEA->>Buyer_AEA: propose Buyer_AEA->>Seller_AEA: accept Seller_AEA->>Buyer_AEA: match_accept Buyer_AEA->>Blockchain: transfer_funds Buyer_AEA->>Seller_AEA: send_transaction_hash Seller_AEA->>Blockchain: check_transaction_status Seller_AEA->>Buyer_AEA: send_data deactivate Buyer_AEA deactivate Search deactivate Seller_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/orm-integration/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/orm-integration/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/orm-integration/#demo-instructions","text":"This demo involves a true ledger transaction on Fetch.ai's testnet network or Ethereum's ropsten . This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.","title":"Demo instructions"},{"location":"aea/orm-integration/#create-the-seller-aea","text":"First, fetch the seller AEA which provides thermometer data: aea fetch fetchai/thermometer_aea:0.29.0 --alias my_thermometer_aea cd my_thermometer_aea aea install aea build Alternatively, create from scratch. The following steps create the seller from scratch: aea create my_thermometer_aea cd my_thermometer_aea aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/thermometer:0.26.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build","title":"Create the seller AEA"},{"location":"aea/orm-integration/#create-the-buyer-client","text":"In another terminal, fetch the buyer AEA: aea fetch fetchai/thermometer_client:0.30.0 --alias my_thermometer_client cd my_thermometer_client aea install aea build Alternatively, create from scratch. The following steps create the car data client from scratch: aea create my_thermometer_client cd my_thermometer_client aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/thermometer_client:0.25.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build","title":"Create the buyer client"},{"location":"aea/orm-integration/#add-keys-for-the-seller-aea","text":"First, create the private key for the seller AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for the seller AEA"},{"location":"aea/orm-integration/#add-keys-and-generate-wealth-for-the-buyer-aea","text":"The buyer needs to have some wealth to purchase the thermometer data. First, create the private key for the buyer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for the buyer based on the network you want to transact with. On the Fetch.ai StargateWorld network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys and generate wealth for the buyer AEA"},{"location":"aea/orm-integration/#update-the-seller-and-buyer-aea-skill-configurations","text":"In my_thermometer_aea/vendor/fetchai/skills/thermometer/skill.yaml , replace the data_for_sale with your data: models : ... strategy : args : currency_id : FET data_for_sale : temperature : 26 has_data_source : false is_ledger_tx : true ledger_id : fetchai location : latitude : 51.5194 longitude : 0.127 service_data : key : seller_service value : thermometer_data service_id : thermometer_data unit_price : 10 class_name : Strategy dependencies : SQLAlchemy : {} The service_data is used to register the service in the SOEF search node and make your agent discoverable. In my_thermometer_client/vendor/fetchai/skills/thermometer_client/skill.yaml ) ensure you have matching data. models : ... strategy : args : currency_id : FET is_ledger_tx : true ledger_id : fetchai location : latitude : 51.5194 longitude : 0.127 max_negotiations : 1 max_tx_fee : 1 max_unit_price : 20 search_query : constraint_type : == search_key : seller_service search_value : thermometer_data search_radius : 5.0 service_id : thermometer_data class_name : Strategy After changing the skill configuration files you should run the following command for both agents to install each dependency: aea install","title":"Update the seller and buyer AEA skill configurations"},{"location":"aea/orm-integration/#modify-the-sellers-strategy","text":"Before being able to modify a package we need to eject it from vendor: aea eject skill fetchai/thermometer:0.26.0 This will move the package to your skills directory and reset the version to 0.1.0 and the author to your author handle. Open strategy.py (in my_thermometer_aea/skills/thermometer/strategy.py ) and make the following modifications: Import the newly installed sqlalchemy library in your strategy. import sqlalchemy as db Then modify your strategy's __init__ function to match the following code: class Strategy ( GenericStrategy ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize the strategy of the agent. :param register_as: determines whether the agent registers as seller, buyer or both :param search_for: determines whether the agent searches for sellers, buyers or both :return: None \"\"\" self . _db_engine = db . create_engine ( \"sqlite:///genericdb.db\" ) self . _tbl = self . create_database_and_table () self . insert_data () super () . __init__ ( ** kwargs ) At the end of the file modify the collect_from_data_source function: def collect_from_data_source ( self ) -> Dict [ str , str ]: \"\"\"Implement the logic to collect data.\"\"\" connection = self . _db_engine . connect () query = db . select ([ self . _tbl ]) result_proxy = connection . execute ( query ) data_points = result_proxy . fetchall () return { \"data\" : json . dumps ( list ( map ( tuple , data_points )))} Also, create two new functions, one that creates a connection with the database, and another that populates the database with some fake data. This is needed in the case you do not have access to an actual thermometer sensor that inserts data in the database. def create_database_and_table ( self ): \"\"\"Creates a database and a table to store the data if not exists.\"\"\" metadata = db . MetaData () tbl = db . Table ( \"data\" , metadata , db . Column ( \"timestamp\" , db . Integer ()), db . Column ( \"temprature\" , db . String ( 255 ), nullable = False ), ) metadata . create_all ( self . _db_engine ) return tbl def insert_data ( self ): \"\"\"Insert data in the database.\"\"\" connection = self . _db_engine . connect () for _ in range ( 10 ): query = db . insert ( self . _tbl ) . values ( # nosec timestamp = time . time (), temprature = str ( random . randrange ( 10 , 25 )) ) connection . execute ( query ) After modifying the skill we need to fingerprint it: aea fingerprint skill { YOUR_AUTHOR_HANDLE } /thermometer:0.1.0","title":"Modify the seller's strategy"},{"location":"aea/orm-integration/#run-both-aeas","text":"First, run the thermometer (seller) AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of this address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the thermometer AEA. Then, configure the thermometer client (buyer) to connect to this same local ACN by running the following command in the buyer terminal, replacing SOME_ADDRESS with the value you noted above: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Then run the thermometer client AEA: aea run You will see that the AEAs negotiate and then transact using the configured testnet.","title":"Run both AEAs"},{"location":"aea/orm-integration/#delete-the-aeas","text":"When you're done, stop the agents ( CTRL+C ), go up a level and delete the AEAs. cd .. aea delete my_thermometer_aea aea delete my_thermometer_client","title":"Delete the AEAs"},{"location":"aea/p2p-connection/","text":"The fetchai/p2p_libp2p:0.25.0 connection allows AEAs to create a peer-to-peer communication network. In particular, the connection creates an overlay network which maps agents' public keys to IP addresses. Local demo First, make sure you have installed the crypto plugin of the target test-net. E.g. for Fetch.AI: pip install aea-ledger-fetchai Create and run the genesis AEA Create one AEA as follows: aea create my_genesis_aea cd my_genesis_aea aea add connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea install aea build Establish the proof of representation : aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection aea issue-certificates Run the AEA: aea run --connections fetchai/p2p_libp2p:0.25.0 Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the genesis AEA. Create and run another AEA Create a second AEA: aea create my_other_aea cd my_other_aea aea add connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea install aea build Establish the proof of representation : aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection aea issue-certificates Provide the AEA with the information it needs to find the genesis: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Here SOME_ADDRESS needs to be replaced with the list of multi addresses displayed in the log output of the genesis AEA. Run the AEA: aea run --connections fetchai/p2p_libp2p:0.25.0 You can inspect the libp2p_node.log log files of the AEA to see how they discover each other. Note Currently p2p_libp2p connection limits the total message size to 3 MB. Local demo with skills Explore the demo section for further examples. Deployed agent communication network You can connect to the deployed public test network by adding one or multiple of the following addresses as the p2p_libp2p connection's entry_peers : /dns4/acn.fetch.ai/tcp/9000/p2p/16Uiu2HAkw1ypeQYQbRFV5hKUxGRHocwU5ohmVmCnyJNg36tnPFdx /dns4/acn.fetch.ai/tcp/9001/p2p/16Uiu2HAmVWnopQAqq4pniYLw44VRvYxBUoRHqjz1Hh2SoCyjbyRW Specifically, in an AEA's configuration aea-config.yaml add the above addresses for entry_peers as follows: --- public_id : fetchai/p2p_libp2p:0.25.0 type : connection config : delegate_uri : null entry_peers : [ /dns4/acn.fetch.ai/tcp/9000/p2p/16Uiu2HAkw1ypeQYQbRFV5hKUxGRHocwU5ohmVmCnyJNg36tnPFdx , /dns4/acn.fetch.ai/tcp/9001/p2p/16Uiu2HAmVWnopQAqq4pniYLw44VRvYxBUoRHqjz1Hh2SoCyjbyRW ] public_uri : null local_uri : 127.0.0.1:9001 Note, this configuration change must be made for all agents attempting to communicate with each other via the Agent Communication Network. For example, in demos involving two agents, both agents will need the above modifications to their respective aea-config.yaml file. However, remember to use different ports in local_uri. This will allow both agents to default to this communication network without the added overhead of opening ports and specifying hosts on the individual host machines running each agent. Configuring the connection.yaml entries: To learn more about how to configure your fetchai/p2p_libp2p:0.25.0 connection consult the README.md file supplied with the connection package. Running Go peer standalone You can run a peer node in standalone mode ; that is, as a Go process with no dependency on the AEA framework. To facilitate such a deployment, we provide a script run_acn_node_standalone.py and a corresponding Dockerfile . First, you need to build the node's binary ( libp2p_node ) either: locally svn export https://github.com/fetchai/agents-aea.git/trunk/packages/fetchai/connections/p2p_libp2p cd p2p_libp2p go build chmod +x libp2p_node Make sure you satisfy the system requirements . or within a docker image using the provided Dockerfile: docker build -t acn_node_standalone -f scripts/acn/Dockerfile . Next, to run the node binary in standalone mode, it requires values for the following entries: AEA_P2P_ID : the node's private key, will be used as its identity AEA_P2P_URI : the local host and port to use by node AEA_P2P_URI_PUBLIC : the URI under which the peer is publicly reachable AEA_P2P_DELEGATE_URI : the URI under which the peer receives delegate connections AEA_P2P_ENTRY_URIS : an optionally supplied list of comma-separated ( , ) entry Multiaddresses for the peer to bootstrap The script allows different methods to pass these values to the node: As environment variables exported in the format <ENTRY_KEYWORD>=<ENTRY_VALUE> for each entry. Then: python3 run_acn_node_standalone.py libp2p_node --config-from-env Using an environment file containing the entries and their values in the format <ENTRY_KEYWORD>=<ENTRY_VALUE> , one entry per line. Then: python3 run_acn_node_standalone.py libp2p_node --config-from-file <env-file-path> or docker run -v <acn_config_file>:/acn/acn_config -it acn_node_standalone --config-from-file /acn/acn_config Using command line arguments: python3 run_acn_node_standalone.py libp2p_node --key-file <node_private_key.txt> \\ --uri <AEA_P2P_URI> --uri-external <AEA_P2P_URI_PUBLIC> \\ --uri-delegate <AEA_P2P_DELEGATE_URI> \\ --entry-peers-maddrs <AEA_P2P_ENTRY_URI_1> <AEA_P2P_ENTRY_URI_2> ... or docker run -v <node_private_key.txt>:/acn/key.txt -it acn_node_standalone --key-file /acn/key.txt \\ --uri <AEA_P2P_URI> --uri-external <AEA_P2P_URI_PUBLIC> \\ --uri-delegate <AEA_P2P_DELEGATE_URI> \\ --entry-peers-maddrs <AEA_P2P_ENTRY_URI_1> <AEA_P2P_ENTRY_URI_2> ... Note that the script will always save the configuration of the running node as a file under the name .acn_config in the current working directory. This can be handy when you want the exact same configuration for future runs of the node.","title":"P2P Connection"},{"location":"aea/p2p-connection/#local-demo","text":"First, make sure you have installed the crypto plugin of the target test-net. E.g. for Fetch.AI: pip install aea-ledger-fetchai","title":"Local demo"},{"location":"aea/p2p-connection/#create-and-run-the-genesis-aea","text":"Create one AEA as follows: aea create my_genesis_aea cd my_genesis_aea aea add connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea install aea build Establish the proof of representation : aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection aea issue-certificates Run the AEA: aea run --connections fetchai/p2p_libp2p:0.25.0 Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the genesis AEA.","title":"Create and run the genesis AEA"},{"location":"aea/p2p-connection/#create-and-run-another-aea","text":"Create a second AEA: aea create my_other_aea cd my_other_aea aea add connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea install aea build Establish the proof of representation : aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection aea issue-certificates Provide the AEA with the information it needs to find the genesis: aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Here SOME_ADDRESS needs to be replaced with the list of multi addresses displayed in the log output of the genesis AEA. Run the AEA: aea run --connections fetchai/p2p_libp2p:0.25.0 You can inspect the libp2p_node.log log files of the AEA to see how they discover each other. Note Currently p2p_libp2p connection limits the total message size to 3 MB.","title":"Create and run another AEA"},{"location":"aea/p2p-connection/#local-demo-with-skills","text":"Explore the demo section for further examples.","title":"Local demo with skills"},{"location":"aea/p2p-connection/#deployed-agent-communication-network","text":"You can connect to the deployed public test network by adding one or multiple of the following addresses as the p2p_libp2p connection's entry_peers : /dns4/acn.fetch.ai/tcp/9000/p2p/16Uiu2HAkw1ypeQYQbRFV5hKUxGRHocwU5ohmVmCnyJNg36tnPFdx /dns4/acn.fetch.ai/tcp/9001/p2p/16Uiu2HAmVWnopQAqq4pniYLw44VRvYxBUoRHqjz1Hh2SoCyjbyRW Specifically, in an AEA's configuration aea-config.yaml add the above addresses for entry_peers as follows: --- public_id : fetchai/p2p_libp2p:0.25.0 type : connection config : delegate_uri : null entry_peers : [ /dns4/acn.fetch.ai/tcp/9000/p2p/16Uiu2HAkw1ypeQYQbRFV5hKUxGRHocwU5ohmVmCnyJNg36tnPFdx , /dns4/acn.fetch.ai/tcp/9001/p2p/16Uiu2HAmVWnopQAqq4pniYLw44VRvYxBUoRHqjz1Hh2SoCyjbyRW ] public_uri : null local_uri : 127.0.0.1:9001 Note, this configuration change must be made for all agents attempting to communicate with each other via the Agent Communication Network. For example, in demos involving two agents, both agents will need the above modifications to their respective aea-config.yaml file. However, remember to use different ports in local_uri. This will allow both agents to default to this communication network without the added overhead of opening ports and specifying hosts on the individual host machines running each agent.","title":"Deployed agent communication network"},{"location":"aea/p2p-connection/#configuring-the-connectionyaml-entries","text":"To learn more about how to configure your fetchai/p2p_libp2p:0.25.0 connection consult the README.md file supplied with the connection package.","title":"Configuring the connection.yaml entries:"},{"location":"aea/p2p-connection/#running-go-peer-standalone","text":"You can run a peer node in standalone mode ; that is, as a Go process with no dependency on the AEA framework. To facilitate such a deployment, we provide a script run_acn_node_standalone.py and a corresponding Dockerfile . First, you need to build the node's binary ( libp2p_node ) either: locally svn export https://github.com/fetchai/agents-aea.git/trunk/packages/fetchai/connections/p2p_libp2p cd p2p_libp2p go build chmod +x libp2p_node Make sure you satisfy the system requirements . or within a docker image using the provided Dockerfile: docker build -t acn_node_standalone -f scripts/acn/Dockerfile . Next, to run the node binary in standalone mode, it requires values for the following entries: AEA_P2P_ID : the node's private key, will be used as its identity AEA_P2P_URI : the local host and port to use by node AEA_P2P_URI_PUBLIC : the URI under which the peer is publicly reachable AEA_P2P_DELEGATE_URI : the URI under which the peer receives delegate connections AEA_P2P_ENTRY_URIS : an optionally supplied list of comma-separated ( , ) entry Multiaddresses for the peer to bootstrap The script allows different methods to pass these values to the node: As environment variables exported in the format <ENTRY_KEYWORD>=<ENTRY_VALUE> for each entry. Then: python3 run_acn_node_standalone.py libp2p_node --config-from-env Using an environment file containing the entries and their values in the format <ENTRY_KEYWORD>=<ENTRY_VALUE> , one entry per line. Then: python3 run_acn_node_standalone.py libp2p_node --config-from-file <env-file-path> or docker run -v <acn_config_file>:/acn/acn_config -it acn_node_standalone --config-from-file /acn/acn_config Using command line arguments: python3 run_acn_node_standalone.py libp2p_node --key-file <node_private_key.txt> \\ --uri <AEA_P2P_URI> --uri-external <AEA_P2P_URI_PUBLIC> \\ --uri-delegate <AEA_P2P_DELEGATE_URI> \\ --entry-peers-maddrs <AEA_P2P_ENTRY_URI_1> <AEA_P2P_ENTRY_URI_2> ... or docker run -v <node_private_key.txt>:/acn/key.txt -it acn_node_standalone --key-file /acn/key.txt \\ --uri <AEA_P2P_URI> --uri-external <AEA_P2P_URI_PUBLIC> \\ --uri-delegate <AEA_P2P_DELEGATE_URI> \\ --entry-peers-maddrs <AEA_P2P_ENTRY_URI_1> <AEA_P2P_ENTRY_URI_2> ... Note that the script will always save the configuration of the running node as a file under the name .acn_config in the current working directory. This can be handy when you want the exact same configuration for future runs of the node.","title":"Running Go peer standalone"},{"location":"aea/package-imports/","text":"An agent that is generated using the AEA framework is a modular system with different connections, contracts, protocols and skills. File structure The file structure of an AEA is fixed. The top level directory has the AEA's name. Below is a aea-config.yaml configuration file, then directories containing the connections, contracts, protocols, and skills developed by the developer as part of the given project. The connections, contracts, protocols and skills used from the registry (local or remote - added via aea fetch or aea add ) are located in vendor and sorted by author. Build artefacts are placed in the .build/ directory and certificates are placed in the .certs/ directory. Finally, there are files containing the private keys of the AEA. When we create a new agent with the command aea create my_aea we create the file structure that looks like the following: aea_name/ aea-config.yaml YAML configuration of the AEA fetchai_private_key.txt The private key file connections/ Directory containing all the connections developed as part of the given project. connection_1/ First connection ... ... connection_n/ nth connection contracts/ Directory containing all the contracts developed as part of the given project. connection_1/ First connection ... ... connection_n/ nth connection protocols/ Directory containing all the protocols developed as part of the given project. protocol_1/ First protocol ... ... protocol_m/ mth protocol skills/ Directory containing all the skills developed as part of the given project. skill_1/ First skill ... ... skill_k/ kth skill vendor/ Directory containing all the added resources from the registry, sorted by author. author_1/ Directory containing all the resources added from author_1 connections/ Directory containing all the added connections from author_1 ... ... protocols/ Directory containing all the added protocols from author_1 ... ... skills/ Directory containing all the added skills from author_1 ... ... The developer can create new directories where necessary but the core structure must remain the same. AEA Configuration YAML The aea-config.yaml is the top level configuration file of an AEA. It defines the global configurations as well as the component/package dependencies of the AEA. In some sense, the AEA can therefore be understood as an orchestrator of components. For the AEA to use a package, the public_id for the package must be listed in the aea-config.yaml file, e.g. connections : - fetchai/stub:0.21.0 The above shows a part of the aea-config.yaml . If you see the connections, you will see that we follow a pattern of author/name_package:version to identify each package, also referred to as public_id . Here the author is the author of the package. Vendor and package directories The vendor folder contains the packages from the registry (local or remote) which have been developed by ourselves, other authors or Fetch.ai and are namespaced by author name. The packages we develop as part of the given AEA project are in the respective connections/ , contracts/ , protocols/ , and skills/ folders. In the above configuration example, the package is authored by Fetch.ai and is located inside the vendor/fetchai/connections folder. Importing modules from packages The way we import modules from packages inside the agent is in the form of packages.{author}.{package_type}.{package_name}.{module_name} . So for the above example, the import path is packages.fetchai.connections.stub.{module_name} . The framework loads the modules from the local agent project and adds them to Python's sys.modules under the respective path. We use a custom package management approach for the AEAs rather than the default Python one as it provides us with more flexibility, especially when it comes to extension beyond the Python ecosystem. Python dependencies of packages Python dependencies of packages are specified in their respective configuration files under dependencies . They will be installed when aea install is run on an agent project. Create a package If you want to create a package, you can use the CLI command aea scaffold connection/contract/protocol/skill [name] and this will create the package and put it inside the respective folder based on the command for example if we scaffold skill with the name my_skill it will be located inside the folder skills in the root directory of the agent ( my_aea/skills/my_skill ). Use published packages from the registry If you want to use a finished package, you can use a package from the registry. There or two registries. The remote registry operated by Fetch.ai and a local registry stub. The local registry stub is a directory called packages which contains packages in a nested structure with authors on the top level, followed by the package type, then package name. An example of such a directory is the packages directory located in the AEA repository. The local registry is useful for development. You can use the CLI to interact with the registry. By default the CLI points to the remote registry. You can point it to the local registry via the flag --local . Package versioning By default, the AEA can only handle one version per package. That is, a project should never use both some_author/some_package_name:0.1.0 and some_author/some_package_name:0.2.0 . If two AEA packages with the same author and name but different versions are used in the same Python process, then only the code from one of the packages (generally not deterministic) will be available in sys.modules . This can lead to inconsistencies and exceptions at runtime.","title":"File structure"},{"location":"aea/package-imports/#file-structure","text":"The file structure of an AEA is fixed. The top level directory has the AEA's name. Below is a aea-config.yaml configuration file, then directories containing the connections, contracts, protocols, and skills developed by the developer as part of the given project. The connections, contracts, protocols and skills used from the registry (local or remote - added via aea fetch or aea add ) are located in vendor and sorted by author. Build artefacts are placed in the .build/ directory and certificates are placed in the .certs/ directory. Finally, there are files containing the private keys of the AEA. When we create a new agent with the command aea create my_aea we create the file structure that looks like the following: aea_name/ aea-config.yaml YAML configuration of the AEA fetchai_private_key.txt The private key file connections/ Directory containing all the connections developed as part of the given project. connection_1/ First connection ... ... connection_n/ nth connection contracts/ Directory containing all the contracts developed as part of the given project. connection_1/ First connection ... ... connection_n/ nth connection protocols/ Directory containing all the protocols developed as part of the given project. protocol_1/ First protocol ... ... protocol_m/ mth protocol skills/ Directory containing all the skills developed as part of the given project. skill_1/ First skill ... ... skill_k/ kth skill vendor/ Directory containing all the added resources from the registry, sorted by author. author_1/ Directory containing all the resources added from author_1 connections/ Directory containing all the added connections from author_1 ... ... protocols/ Directory containing all the added protocols from author_1 ... ... skills/ Directory containing all the added skills from author_1 ... ... The developer can create new directories where necessary but the core structure must remain the same.","title":"File structure"},{"location":"aea/package-imports/#aea-configuration-yaml","text":"The aea-config.yaml is the top level configuration file of an AEA. It defines the global configurations as well as the component/package dependencies of the AEA. In some sense, the AEA can therefore be understood as an orchestrator of components. For the AEA to use a package, the public_id for the package must be listed in the aea-config.yaml file, e.g. connections : - fetchai/stub:0.21.0 The above shows a part of the aea-config.yaml . If you see the connections, you will see that we follow a pattern of author/name_package:version to identify each package, also referred to as public_id . Here the author is the author of the package.","title":"AEA Configuration YAML"},{"location":"aea/package-imports/#vendor-and-package-directories","text":"The vendor folder contains the packages from the registry (local or remote) which have been developed by ourselves, other authors or Fetch.ai and are namespaced by author name. The packages we develop as part of the given AEA project are in the respective connections/ , contracts/ , protocols/ , and skills/ folders. In the above configuration example, the package is authored by Fetch.ai and is located inside the vendor/fetchai/connections folder.","title":"Vendor and package directories"},{"location":"aea/package-imports/#importing-modules-from-packages","text":"The way we import modules from packages inside the agent is in the form of packages.{author}.{package_type}.{package_name}.{module_name} . So for the above example, the import path is packages.fetchai.connections.stub.{module_name} . The framework loads the modules from the local agent project and adds them to Python's sys.modules under the respective path. We use a custom package management approach for the AEAs rather than the default Python one as it provides us with more flexibility, especially when it comes to extension beyond the Python ecosystem.","title":"Importing modules from packages"},{"location":"aea/package-imports/#python-dependencies-of-packages","text":"Python dependencies of packages are specified in their respective configuration files under dependencies . They will be installed when aea install is run on an agent project.","title":"Python dependencies of packages"},{"location":"aea/package-imports/#create-a-package","text":"If you want to create a package, you can use the CLI command aea scaffold connection/contract/protocol/skill [name] and this will create the package and put it inside the respective folder based on the command for example if we scaffold skill with the name my_skill it will be located inside the folder skills in the root directory of the agent ( my_aea/skills/my_skill ).","title":"Create a package"},{"location":"aea/package-imports/#use-published-packages-from-the-registry","text":"If you want to use a finished package, you can use a package from the registry. There or two registries. The remote registry operated by Fetch.ai and a local registry stub. The local registry stub is a directory called packages which contains packages in a nested structure with authors on the top level, followed by the package type, then package name. An example of such a directory is the packages directory located in the AEA repository. The local registry is useful for development. You can use the CLI to interact with the registry. By default the CLI points to the remote registry. You can point it to the local registry via the flag --local .","title":"Use published packages from the registry"},{"location":"aea/package-imports/#package-versioning","text":"By default, the AEA can only handle one version per package. That is, a project should never use both some_author/some_package_name:0.1.0 and some_author/some_package_name:0.2.0 . If two AEA packages with the same author and name but different versions are used in the same Python process, then only the code from one of the packages (generally not deterministic) will be available in sys.modules . This can lead to inconsistencies and exceptions at runtime.","title":"Package versioning"},{"location":"aea/performance-benchmark/","text":"Test AEA framework performance. What is it? The benchmark module is a set of tools to measure execution time, CPU load and memory usage of the AEA Python code. It produces text reports and draws charts to present the results. How does it work? The framework: spawns a dedicated process for each test run to execute the function to test. measures CPU and RAM usage periodically. waits for function exits or terminates them by timeout. repeats test execution multiple times to get more accurate results. How to use Steps to run a test: Write a function you would like to test with all arguments you would like to parametrise, add some doc strings. Split the function into two parts: prepare part and performance part. The prepare part will not be included in the measurement. Add BenchmarkControl support, to notify framework to start measurement. Import TestCli class, TestCli().run(function_to_be_tested) Call it from console to get text results. Simple example cpuburn - simple test of CPU load depends on idle sleep time. Shows how much CPU consumed during the execution. import time from benchmark.framework.benchmark import BenchmarkControl from benchmark.framework.cli import TestCli def cpu_burn ( benchmark : BenchmarkControl , run_time = 10 , sleep = 0.0001 ) -> None : \"\"\" Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None \"\"\" benchmark . start () start_time = time . time () while True : time . sleep ( sleep ) if time . time () - start_time >= run_time : break if __name__ == \"__main__\" : TestCli ( cpu_burn ) . run () Run it with python ./benchmark/cases/cpu_burn.py --help to get help about usage. Usage: cpu_burn.py [ OPTIONS ] [ ARGS ] ... Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None ARGS is function arguments in format: ` run_time,sleep ` default ARGS is ` 10 ,0.0001 ` Options: --timeout FLOAT Executor timeout in seconds [ default: 10 .0 ] --period FLOAT Period for measurement [ default: 0 .1 ] -N, --num-executions INTEGER Number of runs for each case [ default: 1 ] -P, --plot INTEGER X axis parameter idx --help Show this message and exit. Run it with python ./benchmark/cases/cpu_burn.py to start with default parameters. Test execution timeout: 10 .0 Test execution measure period: 0 .1 Tested function name: cpu_burn Tested function description: Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None Tested function argument names: [ 'run_time' , 'sleep' ] Tested function argument default values: [ 10 , 0 .0001 ] == Report created 2020 -04-27 15 :14:56.076549 == Arguments are ` [ 10 , 0 .0001 ] ` Number of runs: 1 Number of time terminated: 0 Time passed ( seconds ) : 10 .031443119049072 \u00b1 0 cpu min ( % ) : 0 .0 \u00b1 0 cpu max ( % ) : 10 .0 \u00b1 0 cpu mean ( % ) : 3 .4 \u00b1 0 mem min ( kb ) : 53 .98828125 \u00b1 0 mem max ( kb ) : 53 .98828125 \u00b1 0 mem mean ( kb ) : 53 .98828125 \u00b1 0 Here you can see test report for default arguments set. Run with multiple arguments set, multiple repeats and draw a chart on resources python ./benchmark/cases/cpu_burn.py -N 5 -P 1 3,0.00001 3,0.001 3,0.01 Report is: Test execution timeout: 10 .0 Test execution measure period: 0 .1 Tested function name: cpu_burn Tested function description: Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None Tested function argument names: [ 'run_time' , 'sleep' ] Tested function argument default values: [ 10 , 0 .0001 ] == Report created 2020 -04-27 15 :38:17.849535 == Arguments are ` ( 3 , 1e-05 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .0087939262390138 \u00b1 0 .0001147521277690166 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 11 .0 \u00b1 2 .23606797749979 cpu mean ( % ) : 6 .2 \u00b1 0 .18257418583505522 mem min ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 mem max ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 mem mean ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 == Report created 2020 -04-27 15 :38:32.947308 == Arguments are ` ( 3 , 0 .001 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .014109659194946 \u00b1 0 .0004416575764579524 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 8 .0 \u00b1 2 .7386127875258306 cpu mean ( % ) : 1 .9986666666666666 \u00b1 0 .002981423969999689 mem min ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 mem max ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 mem mean ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 == Report created 2020 -04-27 15 :38:48.067511 == Arguments are ` ( 3 , 0 .01 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .0181806087493896 \u00b1 0 .0022409499756841883 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 1 .0 \u00b1 2 .23606797749979 cpu mean ( % ) : 0 .06666666666666667 \u00b1 0 .14907119849998599 mem min ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 mem max ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 mem mean ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 Chart is drawn for argument 1: sleep: The most interesting part is CPU usage, as you can see CPU usage decreases with increasing value of idle sleep. Memory usage and execution time can slightly differ per case execution. Requirements for tested function The first function's argument has to be benchmark: BenchmarkControl which is passed by default by the framework. All arguments except the fist one have to set default values. Function doc string is required, it used for help information. benchmark.start() has to be called once in the function body to start measurement. The timeout is counted from this point! All the \"prepare part\" in the function that should not be measured has to be placed before benchmark.start() Code to be measured has to go after benchmark.start() Try to avoid infinitive loops and assume the test should exit after a while. Execution options To pass an arguments set just provide it as a comma separated string like 10,0.1 To pass several argument sets just separate them by white space 10,0.1 20,0.2 --timeout FLOAT is test execution timeout in seconds. If the test takes more time, it will be terminated. --period FLOAT is measurement interval in seconds, how often to make CPU and RAM usage measurements. -N, --num-executions INTEGER - how many time to run the same argument set to make result more accurate. -P, --plot INTEGER - Draw a chart using, using values of argument specified as values for axis X. argument positions started with 0, argument benchmark does not counted. for example -P 0 will use run_time values, -P 1 will use sleep values. Limitations Currently, the benchmark framework does not measure resources consumed by subprocess spawned in python code. So try to keep one process solutions during tests. Asynchronous functions or coroutines are not supported directly. So you have to set up an event loop inside test function and start loop manually. Testing AEA: handlers example Test react speed on specific messages amount. def react_speed_in_loop ( benchmark : BenchmarkControl , inbox_amount = 1000 ) -> None : \"\"\" Test inbox message processing in a loop. :param benchmark: benchmark special parameter to communicate with executor :param inbox_amount: num of inbox messages for every agent :return: None \"\"\" skill_definition = { \"handlers\" : { \"dummy_handler\" : DummyHandler } } aea_test_wrapper = AEATestWrapper ( name = \"dummy agent\" , skills = [ skill_definition ], ) for _ in range ( inbox_amount ): aea_test_wrapper . put_inbox ( aea_test_wrapper . dummy_envelope ()) aea_test_wrapper . set_loop_timeout ( 0.0 ) benchmark . start () aea_test_wrapper . start_loop () while not aea_test_wrapper . is_inbox_empty (): time . sleep ( 0.1 ) aea_test_wrapper . stop_loop () Create AEA wrapper with specified handler: skill_definition = { \"handlers\" : { \"dummy_handler\" : DummyHandler } } aea_test_wrapper = AEATestWrapper ( name = \"dummy agent\" , skills = [ skill_definition ], ) Populate inbox with dummy messages: for _ in range ( inbox_amount ): aea_test_wrapper . put_inbox ( aea_test_wrapper . dummy_envelope ()) Set timeout 0 , for maximum messages processing speed: aea_test_wrapper.set_loop_timeout(0.0) Start benchmark: benchmark.start() Start/stop AEA: aea_test_wrapper . start () ... aea_test_wrapper . stop () Wait till messages present in inbox: while not aea_test_wrapper . is_inbox_empty (): time . sleep ( 0.1 )","title":"Performance benchmark"},{"location":"aea/performance-benchmark/#what-is-it","text":"The benchmark module is a set of tools to measure execution time, CPU load and memory usage of the AEA Python code. It produces text reports and draws charts to present the results.","title":"What is it?"},{"location":"aea/performance-benchmark/#how-does-it-work","text":"The framework: spawns a dedicated process for each test run to execute the function to test. measures CPU and RAM usage periodically. waits for function exits or terminates them by timeout. repeats test execution multiple times to get more accurate results.","title":"How does it work?"},{"location":"aea/performance-benchmark/#how-to-use","text":"Steps to run a test: Write a function you would like to test with all arguments you would like to parametrise, add some doc strings. Split the function into two parts: prepare part and performance part. The prepare part will not be included in the measurement. Add BenchmarkControl support, to notify framework to start measurement. Import TestCli class, TestCli().run(function_to_be_tested) Call it from console to get text results.","title":"How to use"},{"location":"aea/performance-benchmark/#simple-example","text":"cpuburn - simple test of CPU load depends on idle sleep time. Shows how much CPU consumed during the execution. import time from benchmark.framework.benchmark import BenchmarkControl from benchmark.framework.cli import TestCli def cpu_burn ( benchmark : BenchmarkControl , run_time = 10 , sleep = 0.0001 ) -> None : \"\"\" Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None \"\"\" benchmark . start () start_time = time . time () while True : time . sleep ( sleep ) if time . time () - start_time >= run_time : break if __name__ == \"__main__\" : TestCli ( cpu_burn ) . run () Run it with python ./benchmark/cases/cpu_burn.py --help to get help about usage. Usage: cpu_burn.py [ OPTIONS ] [ ARGS ] ... Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None ARGS is function arguments in format: ` run_time,sleep ` default ARGS is ` 10 ,0.0001 ` Options: --timeout FLOAT Executor timeout in seconds [ default: 10 .0 ] --period FLOAT Period for measurement [ default: 0 .1 ] -N, --num-executions INTEGER Number of runs for each case [ default: 1 ] -P, --plot INTEGER X axis parameter idx --help Show this message and exit. Run it with python ./benchmark/cases/cpu_burn.py to start with default parameters. Test execution timeout: 10 .0 Test execution measure period: 0 .1 Tested function name: cpu_burn Tested function description: Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None Tested function argument names: [ 'run_time' , 'sleep' ] Tested function argument default values: [ 10 , 0 .0001 ] == Report created 2020 -04-27 15 :14:56.076549 == Arguments are ` [ 10 , 0 .0001 ] ` Number of runs: 1 Number of time terminated: 0 Time passed ( seconds ) : 10 .031443119049072 \u00b1 0 cpu min ( % ) : 0 .0 \u00b1 0 cpu max ( % ) : 10 .0 \u00b1 0 cpu mean ( % ) : 3 .4 \u00b1 0 mem min ( kb ) : 53 .98828125 \u00b1 0 mem max ( kb ) : 53 .98828125 \u00b1 0 mem mean ( kb ) : 53 .98828125 \u00b1 0 Here you can see test report for default arguments set. Run with multiple arguments set, multiple repeats and draw a chart on resources python ./benchmark/cases/cpu_burn.py -N 5 -P 1 3,0.00001 3,0.001 3,0.01 Report is: Test execution timeout: 10 .0 Test execution measure period: 0 .1 Tested function name: cpu_burn Tested function description: Do nothing, just burn cpu to check cpu load changed on sleep. :param benchmark: benchmark special parameter to communicate with executor :param run_time: time limit to run this function :param sleep: time to sleep in loop :return: None Tested function argument names: [ 'run_time' , 'sleep' ] Tested function argument default values: [ 10 , 0 .0001 ] == Report created 2020 -04-27 15 :38:17.849535 == Arguments are ` ( 3 , 1e-05 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .0087939262390138 \u00b1 0 .0001147521277690166 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 11 .0 \u00b1 2 .23606797749979 cpu mean ( % ) : 6 .2 \u00b1 0 .18257418583505522 mem min ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 mem max ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 mem mean ( kb ) : 54 .0265625 \u00b1 0 .11180339887498948 == Report created 2020 -04-27 15 :38:32.947308 == Arguments are ` ( 3 , 0 .001 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .014109659194946 \u00b1 0 .0004416575764579524 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 8 .0 \u00b1 2 .7386127875258306 cpu mean ( % ) : 1 .9986666666666666 \u00b1 0 .002981423969999689 mem min ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 mem max ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 mem mean ( kb ) : 53 .9890625 \u00b1 0 .10431954926750306 == Report created 2020 -04-27 15 :38:48.067511 == Arguments are ` ( 3 , 0 .01 ) ` Number of runs: 5 Number of time terminated: 0 Time passed ( seconds ) : 3 .0181806087493896 \u00b1 0 .0022409499756841883 cpu min ( % ) : 0 .0 \u00b1 0 .0 cpu max ( % ) : 1 .0 \u00b1 2 .23606797749979 cpu mean ( % ) : 0 .06666666666666667 \u00b1 0 .14907119849998599 mem min ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 mem max ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 mem mean ( kb ) : 53 .9078125 \u00b1 0 .11487297672320501 Chart is drawn for argument 1: sleep: The most interesting part is CPU usage, as you can see CPU usage decreases with increasing value of idle sleep. Memory usage and execution time can slightly differ per case execution.","title":"Simple example"},{"location":"aea/performance-benchmark/#requirements-for-tested-function","text":"The first function's argument has to be benchmark: BenchmarkControl which is passed by default by the framework. All arguments except the fist one have to set default values. Function doc string is required, it used for help information. benchmark.start() has to be called once in the function body to start measurement. The timeout is counted from this point! All the \"prepare part\" in the function that should not be measured has to be placed before benchmark.start() Code to be measured has to go after benchmark.start() Try to avoid infinitive loops and assume the test should exit after a while.","title":"Requirements for tested function"},{"location":"aea/performance-benchmark/#execution-options","text":"To pass an arguments set just provide it as a comma separated string like 10,0.1 To pass several argument sets just separate them by white space 10,0.1 20,0.2 --timeout FLOAT is test execution timeout in seconds. If the test takes more time, it will be terminated. --period FLOAT is measurement interval in seconds, how often to make CPU and RAM usage measurements. -N, --num-executions INTEGER - how many time to run the same argument set to make result more accurate. -P, --plot INTEGER - Draw a chart using, using values of argument specified as values for axis X. argument positions started with 0, argument benchmark does not counted. for example -P 0 will use run_time values, -P 1 will use sleep values.","title":"Execution options"},{"location":"aea/performance-benchmark/#limitations","text":"Currently, the benchmark framework does not measure resources consumed by subprocess spawned in python code. So try to keep one process solutions during tests. Asynchronous functions or coroutines are not supported directly. So you have to set up an event loop inside test function and start loop manually.","title":"Limitations"},{"location":"aea/performance-benchmark/#testing-aea-handlers-example","text":"Test react speed on specific messages amount. def react_speed_in_loop ( benchmark : BenchmarkControl , inbox_amount = 1000 ) -> None : \"\"\" Test inbox message processing in a loop. :param benchmark: benchmark special parameter to communicate with executor :param inbox_amount: num of inbox messages for every agent :return: None \"\"\" skill_definition = { \"handlers\" : { \"dummy_handler\" : DummyHandler } } aea_test_wrapper = AEATestWrapper ( name = \"dummy agent\" , skills = [ skill_definition ], ) for _ in range ( inbox_amount ): aea_test_wrapper . put_inbox ( aea_test_wrapper . dummy_envelope ()) aea_test_wrapper . set_loop_timeout ( 0.0 ) benchmark . start () aea_test_wrapper . start_loop () while not aea_test_wrapper . is_inbox_empty (): time . sleep ( 0.1 ) aea_test_wrapper . stop_loop () Create AEA wrapper with specified handler: skill_definition = { \"handlers\" : { \"dummy_handler\" : DummyHandler } } aea_test_wrapper = AEATestWrapper ( name = \"dummy agent\" , skills = [ skill_definition ], ) Populate inbox with dummy messages: for _ in range ( inbox_amount ): aea_test_wrapper . put_inbox ( aea_test_wrapper . dummy_envelope ()) Set timeout 0 , for maximum messages processing speed: aea_test_wrapper.set_loop_timeout(0.0) Start benchmark: benchmark.start() Start/stop AEA: aea_test_wrapper . start () ... aea_test_wrapper . stop () Wait till messages present in inbox: while not aea_test_wrapper . is_inbox_empty (): time . sleep ( 0.1 )","title":"Testing AEA: handlers example"},{"location":"aea/por/","text":"An AEA can use several key pairs. In particular, it can use different keys for securing its communication and for engaging in exchange. In the ACN we make use of this fact. To be able to signal to other agents that the address derived from one key pair is allowed to represent the agent controlling the other key pair, the key pair which is being represented must sign a message to prove that the other key pair is allowed to represent it. The aea issue-certificates command allows to create this association. The proof of representation feature is used in the context of the fetchai/p2p_libp2p and fetchai/p2p_libp2p_client connection. In the former connection, the configuration YAML specifies a cert_requests field: cert_requests : - identifier : acn ledger_id : fetchai not_after : '2022-01-01' not_before : '2021-01-01' public_key : fetchai message_format : '{public_key}' save_path : .certs/conn_cert.txt The identifier refers to the environment for which the signature is generated, here acn . The ledger_id refers to the key pair to be used from the private_key_paths specified in aea-config.yaml for signing. The not_after and not_before fields specify constraints on the validity of the signature. The public_key can specify either the identifier of the key pair in connection_private_key_paths of which the public key is signed or it can contain the to be signed public key in plain text. The save_path specifies the path where the certificate is to be saved at. In the above example, the connection requests a certificate which is a signature of the fetchai public key in connection_private_key_paths with the fetchai key pair in private_key_paths . The validity of the signature will be constrained to the year 2021 for the environment acn .","title":"Proof of Representation"},{"location":"aea/prometheus/","text":"AEAs can create and update prometheus metrics for remote monitoring by sending messages to the prometheus connection fetchai/prometheus:0.8.0 . To see this working in an agent, fetch and run the coin_price_feed agent and check localhost:9090/metrics to see the latest values of the metrics num_retrievals and num_requests : aea fetch fetchai/coin_price_feed:0.14.0 cd coin_price_feed aea install aea build aea run You can then instruct a prometheus server running on the same computing cluster as a deployed agent to scrape these metrics for remote monitoring and visualisation with the Prometheus/Grafana toolset. To use this connection, add a model prometheus_dialogues to your skill to handle the metrics configuration and messages to the prometheus connection. Click here for example class PrometheusDialogues ( Model , BasePrometheusDialogues ): \"\"\"The dialogues class keeps track of all prometheus dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" self . enabled = kwargs . pop ( \"enabled\" , False ) self . metrics = kwargs . pop ( \"metrics\" , []) Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return PrometheusDialogue . Role . AGENT BasePrometheusDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , ) Then configure your metrics in the skill.yaml file. For example (from the advanced_data_request skill): models : prometheus_dialogues : args : enabled : true metrics : - name : num_retrievals type : Gauge description : Number of price quotes retrieved labels : {} - name : num_requests type : Gauge description : Number of price quote requests served labels : {} class_name : PrometheusDialogues Add a metric metric_name of type metric_type { Gauge , Counter , ...} and description description by sending a message with performative ADD_METRIC to the prometheus connection: def add_prometheus_metric ( self , metric_name : str , metric_type : str , description : str , labels : Dict [ str , str ], ) -> None : \"\"\" Add a prometheus metric. :param metric_name: the name of the metric to add. :param type: the type of the metric. :param description: a description of the metric. :param labels: the metric labels. :return: None \"\"\" # context prom_dialogues = cast ( PrometheusDialogues , self . context . prometheus_dialogues ) # prometheus update message message , _ = prom_dialogues . create ( counterparty = str ( PROM_CONNECTION_ID ), performative = PrometheusMessage . Performative . ADD_METRIC , type = metric_type , title = metric_name , description = description , labels = labels , ) # send message self . context . outbox . put_message ( message = message ) where PROM_CONNECTION_ID should be imported to your skill as follows: from packages.fetchai.connections.prometheus.connection import ( PUBLIC_ID as PROM_CONNECTION_ID , ) Update metric metric_name with update function update_func { inc , set , observe , ...} and value value by sending a message with performative UPDATE_METRIC to the prometheus connection: def update_prometheus_metric ( self , metric_name : str , update_func : str , value : float , labels : Dict [ str , str ], ) -> None : \"\"\" Update a prometheus metric. :param metric_name: the name of the metric. :param update_func: the name of the update function (e.g. inc, dec, set, ...). :param value: the value to provide to the update function. :param labels: the metric labels. :return: None \"\"\" # context prom_dialogues = cast ( PrometheusDialogues , self . context . prometheus_dialogues ) # prometheus update message message , _ = prom_dialogues . create ( counterparty = str ( PROM_CONNECTION_ID ), performative = PrometheusMessage . Performative . UPDATE_METRIC , title = metric_name , callable = update_func , value = value , labels = labels , ) # send message self . context . outbox . put_message ( message = message ) Initialize the metrics from the configuration file in the behaviour setup: def setup ( self ) -> None : \"\"\"Implement the setup of the behaviour\"\"\" prom_dialogues = cast ( PrometheusDialogues , self . context . prometheus_dialogues ) if prom_dialogues . enabled : for metric in prom_dialogues . metrics : self . context . logger . info ( \"Adding Prometheus metric: \" + metric [ \"name\" ]) self . add_prometheus_metric ( metric [ \"name\" ], metric [ \"type\" ], metric [ \"description\" ], dict ( metric [ \"labels\" ]), Then call the update_prometheus_metric function from the appropriate places. For example, the following code in handlers.py for the advanced_data_request skill updates the number of http requests served: if self . context . prometheus_dialogues . enabled : self . context . behaviours . advanced_data_request_behaviour . update_prometheus_metric ( \"num_requests\" , \"inc\" , 1.0 , {} ) Finally, you can add a PrometheusHandler to your skill to process response messages from the prometheus connection. Click here for example class PrometheusHandler ( Handler ): \"\"\"This class handles responses from the prometheus server.\"\"\" SUPPORTED_PROTOCOL = PrometheusMessage . protocol_id def __init__ ( self , ** kwargs ): \"\"\"Initialize the handler.\"\"\" super () . __init__ ( ** kwargs ) self . handled_message = None def setup ( self ) -> None : \"\"\"Set up the handler.\"\"\" if self . context . prometheus_dialogues . enabled : self . context . logger . info ( \"setting up PrometheusHandler\" ) def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" message = cast ( PrometheusMessage , message ) # recover dialogue prometheus_dialogues = cast ( PrometheusDialogues , self . context . prometheus_dialogues ) prometheus_dialogue = cast ( PrometheusDialogue , prometheus_dialogues . update ( message ) ) if prometheus_dialogue is None : self . _handle_unidentified_dialogue ( message ) return self . handled_message = message if message . performative == PrometheusMessage . Performative . RESPONSE : self . context . logger . debug ( f \"Prometheus response ( { message . code } ): { message . message } \" ) else : self . context . logger . debug ( f \"got unexpected prometheus message: Performative = { PrometheusMessage . Performative } \" ) def _handle_unidentified_dialogue ( self , msg : Message ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the unidentified message to be handled :return: None \"\"\" self . context . logger . info ( \"received invalid message= {} , unidentified dialogue.\" . format ( msg ) ) def teardown ( self ) -> None : \"\"\" Teardown the handler. :return: None \"\"\"","title":"Prometheus monitoring"},{"location":"aea/protocol-generator/","text":"Note This is currently an experimental feature. To try it follow this guide. How to run First make sure you are inside your AEA's folder (see here on how to create a new agent). Then run aea generate protocol <path-to-protocol-specification> where <path-to-protocol-specification> is the path to a protocol specification file. If there are no errors, this command will generate the protocol and place it in your AEA project. The name of the protocol's directory will match the protocol name given in the specification. The author will match the registered author in the CLI. The generator currently produces the following files (assuming the name of the protocol in the specification is sample ): message.py : defines messages valid under the sample protocol serialisation.py : defines how messages are serialised/deserialised __init__.py : makes the directory a package protocol.yaml : contains package information about the sample protocol sample.proto protocol buffer schema file sample_pb2.py : the generated protocol buffer implementation custom_types.py : stub implementations for custom types (created only if the specification contains custom types) Full mode vs Protobuf Only mode Currently, the generator can operate in full mode for Python, creating a complete protocol package (files 1 to 7 above) from a protocol specification. The generator also has a protobuf only mode which only creates the protocol buffer schema and implementation files (files 5 and 6 above). The languages supported in the protobuf only mode and their respective ids are below: go: go c++: cpp java: java c#: csharp ruby: ruby objective-c: objc javascript: js To use the generator in protobuf only mode for any of the above languages: aea generate protocol --l <language> <path-to-protocol-specification> where <language> is a language id. The protocol buffer compiler requires a plugin to generate Go code. Install it with: Note Note the protocol buffer compiler protoc that the generator uses requires a plugin to produce go code. Follow this instruction . Protocol Specification A protocol can be described in a YAML file. This is called a protocol specification . The following is an example protocol specification: --- name : two_party_negotiation author : fetchai version : 0.1.0 description : An example of a protocol specification that describes a protocol for bilateral negotiation. license : Apache-2.0 aea_version : '>=1.0.0, <2.0.0' speech_acts : cfp : query : ct:Query propose : price : pt:float proposal : pt:dict[pt:str, pt:str] conditions : pt:optional[pt:union[pt:str, pt:dict[pt:str,pt:str], pt:set[pt:str]]] resources : pt:list[pt:bytes] accept : {} decline : {} ... --- ct:Query : | bytes query_bytes = 1; ... --- initiation : [ cfp ] reply : cfp : [ propose , decline ] propose : [ propose , accept , decline ] accept : [] decline : [] termination : [ accept , decline ] roles : { buyer , seller } end_states : [ agreement_reached , agreement_unreached ] keep_terminal_state_dialogues : true ... Each protocol specification must follow the YAML format , and have a minimum of one and a maximum of three YAML documents (each YAML document is enclosed within --- and ...). Basic Protocol Detail and Messages Syntax The first YAML document is mandatory in any protocol specification. It contains some basic information about the protocol and describes the syntax of communicative messages allowed under this protocol. The allowed fields and what they represent are: name : The name of the protocol (written in snake_case ) author : The creator of the protocol version : The current version of the protocol license : Licensing information aea_version : The version(s) of the framework that support this protocol. The format is described here . description : A short description of the protocol protocol_specification_id : The id which identifies the protocol for over-the-wire transport. This id is decoupled from the protocol_id ( {author}/{name}:{version} ) which is tied to the Python implementation. All of the above fields are mandatory and each is a key/value pair, where both key and value are YAML strings. Additionally, the first YAML document of a protocol specification must describe the syntax of valid messages according to this protocol. Therefore, it must contain another mandatory speech-acts field which defines the set of performatives valid under this protocol, and a set of contents for each performative. A performative defines the type of a message (e.g. propose, accept) and has a set of contents (or parameters) of varying types. The format of the speech-act is as follows: speech-act is a dictionary, where each key is a unique performative (YAML string), and the value is a content dictionary. If a performative does not have any content, then its content dictionary is empty, for instance accept and decline in the specification above. A content dictionary in turn has key/value pairs, where each key is the name of a content (YAML string) and the value is its type (YAML string). For example, the cfp (short for 'call for proposal') performative has one content whose name is query and whose type is ct:Query . Types The specific types which could be assigned to contents in a protocol specification are described in the table below. Types are either user defined (i.e. custom types) or primitive: Custom types are prepended with ct: and their format is described using regular expression in the table below. Primitive types are prepended with pt: . There are different categories of primitive types. For example, <PT> such as integers and booleans, <PCT> such as sets and lists, and so on. Primitive types are compositional: For example, consider pt:set[...] under <PCT> , i.e. an unordered collection of elements without duplicates. A pt:set[...] describes the type of its elements (called \"sub-type\") in square brackets. The sub-type of a pt:set[...] must be a <PT> (e.g. pt:int , pt:bool ). In describing the format of types, / between two sub-types should be treated as \"or\". For example, the sub-type of a pt:optional[...] is either a <PT> , <CT> , <PCT> , <PMT> or <MT> . A multi type denotes an \"or\" separated set of sub-types. For example, a content whose type is specified as pt:union[pt:str, pt:int] should either be pt:int or pt:float . An optional type pt:optional[...] assigned to a content means the content's existence is optional, but if it is present, its type must match pt:optional[...] 's sub-type. Type Code Format Example In Python Custom types 1 <CT> ct:RegExp(^[A-Z][a-zA-Z0-9]*$) ct:DataModel Custom Class Primitive types <PT> pt:bytes pt:bytes bytes pt:int pt:int int pt:float pt:float float pt:bool pt:bool bool pt:str pt:str str Primitive collection types <PCT> pt:set[<PT>] pt:set[pt:str] FrozenSet[str] pt:list[<PT>] pt:list[pt:int] Tuple[int, ...] * Primitive mapping types 2 <PMT> pt:dict[<PT>, <PT>] pt:dict[pt:str, pt:bool] Dict[str, bool] Multi types <MT> pt:union[<PT>/<CT>/<PCT>/<PMT>, ..., <PT>/<CT>/<PCT>/<PMT>] pt:union[ct:DataModel, pt:set[pt:str]] Union[DataModel, FrozenSet[str]] Optional types <O> pt:optional[<MT>/<PMT>/<PCT>/<PT>/<CT>] pt:optional[pt:bool] Optional[bool] * This is how variable length tuples containing elements of the same type are declared in Python; see here . Protocol Buffer Schema Currently, the AEA framework does not officially support describing custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required serialisation logic must be provided manually. Therefore, if any of the contents declared in speech-acts is of a custom type, the specification must then have a second YAML document, containing the protocol buffer schema code for each custom type. You can see an example of the second YAML document in the above protocol specification. Dialogues You can optionally specify the structure of dialogues conforming to your protocol in a third YAML document in the specification. The allowed fields and what they represent are: initiation : The list of initial performatives reply : The reply structure of speech-acts termination : The list of terminal performatives roles : The roles of players participating in a dialogue end_states : The possible outcomes a terminated dialogue. keep_terminal_state_dialogues : whether to keep or drop a terminated dialogue. When a storage backend is configured, the dialogues will be persisted in storage when kept. All of the above fields are mandatory. initiation is a YAML list, containing the performatives which can be used to start a dialogue. reply specifies for every performative, what its valid replies are. If a performative per_1 is a valid reply to another per_2 , this means a message with performative per_1 can target a message whose performative is per_2 . reply is a YAML dictionary, where the keys are the performatives (YAML string) defined in speech-acts . For each performative key, its value is a list of performatives which are defined to be a valid reply. For example, valid replies to cfp are propose and decline . termination is a YAML list, containing the performatives which terminate a dialogue. Once any of these performatives are used in a dialogue, the dialogue is terminated and no other messages may be added to it. roles is a YAML set, containing the roles players participating in dialogues can take. roles may contain one or two roles, each role being a YAML string. If there are two roles, each participant has a distinguished role in the dialogue (e.g. buyer and seller in the above specification). If there is only one role, then both participants in a dialogue have this same role. end_states lists the final states a terminated dialogue may have. end_states is a YAML list of strings. keep_terminal_state_dialogues has a boolean value and specifies whether the terminated dialogues of this protocol are to be kept or discarded. Design Guidelines initiation and termination cannot be empty. Make sure that when defining reply , you include every speech-act you specified under speech_acts . If any of the speech-acts does not have a reply, indicate that with an empty list [] similar to accept and decline in the specification above. If a speech-act is listed in termination , it must not have any replies in reply . The reason is simple: a terminal speech-act terminates a dialogue and so its reply can never be used. If a speech-act replies to no other speech-acts, it should be listed in initiation otherwise it could never be used in a dialogue (neither to a start a dialogue with, nor as a reply to another speech-act). Notes Currently, there is no way to describe custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required implementations must be provided manually. Before generating the protocol, the protocol buffer schema code for every custom type must be provided in the protocol specification. Once the generator is called, it produces a custom_types module containing stub implementations for every custom type in the specification. The user must then modify this module and add implementations for every custom type in the specification. This includes implementations of how an object of a custom type can be encoded and decoded using protocol buffer. Note, currently the way custom types are dealt with in the generator is admittedly inconvenient. The reason is, the generator does not know the structure of custom types and how they may be serialised/deserialised. Although this approach works, it is only a temporary solution until further work on a programming language-independent type description language is finished (similar to how the generator is designed to be a programming language-independent protocol description language). Currently, the first element in pt:dict cannot be a <CT> , pt:float or pt:bytes . This is because of a constraint in protocol buffer version 3 which is the framework's underlying serialisation mechanism. In a future version, we may address this limitation, in which case we will relax this constraint. In protocol buffer version 3, which is the version used by the generator, there is no way to check whether an optional field (i.e. contents of type pt:optional[...] ) has been set or not (see discussion here ). In proto3, all optional fields are assigned a default value (e.g. 0 for integers types, false for boolean types, etc). Therefore, given an optional field whose value is the default value, there is no way to know from the optional field itself, whether it is not set, or in fact is set but its value happens to be the default value. Because of this, in the generated protocol schema file (the .proto file), for every optional content there is a second field that declares whether this field is set or not. We will maintain this temporary solution until a cleaner alternative is found. Be aware that currently, using the generated protocols in python, there might be some rounding errors when serialising and then deserialising values of pt:float contents. Demo instructions First, create a new AEA project: aea create my_aea cd my_aea Second, run the generator on the sample specification: aea generate protocol ../examples/protocol_specification_ex/sample.yaml This will generate the protocol and place it in your AEA project. Third, try generating other protocols by first defining a specification, then running the generator.","title":"Generating protocols"},{"location":"aea/protocol-generator/#how-to-run","text":"First make sure you are inside your AEA's folder (see here on how to create a new agent). Then run aea generate protocol <path-to-protocol-specification> where <path-to-protocol-specification> is the path to a protocol specification file. If there are no errors, this command will generate the protocol and place it in your AEA project. The name of the protocol's directory will match the protocol name given in the specification. The author will match the registered author in the CLI. The generator currently produces the following files (assuming the name of the protocol in the specification is sample ): message.py : defines messages valid under the sample protocol serialisation.py : defines how messages are serialised/deserialised __init__.py : makes the directory a package protocol.yaml : contains package information about the sample protocol sample.proto protocol buffer schema file sample_pb2.py : the generated protocol buffer implementation custom_types.py : stub implementations for custom types (created only if the specification contains custom types)","title":"How to run"},{"location":"aea/protocol-generator/#full-mode-vs-protobuf-only-mode","text":"Currently, the generator can operate in full mode for Python, creating a complete protocol package (files 1 to 7 above) from a protocol specification. The generator also has a protobuf only mode which only creates the protocol buffer schema and implementation files (files 5 and 6 above). The languages supported in the protobuf only mode and their respective ids are below: go: go c++: cpp java: java c#: csharp ruby: ruby objective-c: objc javascript: js To use the generator in protobuf only mode for any of the above languages: aea generate protocol --l <language> <path-to-protocol-specification> where <language> is a language id. The protocol buffer compiler requires a plugin to generate Go code. Install it with: Note Note the protocol buffer compiler protoc that the generator uses requires a plugin to produce go code. Follow this instruction .","title":"Full mode vs Protobuf Only mode"},{"location":"aea/protocol-generator/#protocol-specification","text":"A protocol can be described in a YAML file. This is called a protocol specification . The following is an example protocol specification: --- name : two_party_negotiation author : fetchai version : 0.1.0 description : An example of a protocol specification that describes a protocol for bilateral negotiation. license : Apache-2.0 aea_version : '>=1.0.0, <2.0.0' speech_acts : cfp : query : ct:Query propose : price : pt:float proposal : pt:dict[pt:str, pt:str] conditions : pt:optional[pt:union[pt:str, pt:dict[pt:str,pt:str], pt:set[pt:str]]] resources : pt:list[pt:bytes] accept : {} decline : {} ... --- ct:Query : | bytes query_bytes = 1; ... --- initiation : [ cfp ] reply : cfp : [ propose , decline ] propose : [ propose , accept , decline ] accept : [] decline : [] termination : [ accept , decline ] roles : { buyer , seller } end_states : [ agreement_reached , agreement_unreached ] keep_terminal_state_dialogues : true ... Each protocol specification must follow the YAML format , and have a minimum of one and a maximum of three YAML documents (each YAML document is enclosed within --- and ...).","title":"Protocol Specification"},{"location":"aea/protocol-generator/#basic-protocol-detail-and-messages-syntax","text":"The first YAML document is mandatory in any protocol specification. It contains some basic information about the protocol and describes the syntax of communicative messages allowed under this protocol. The allowed fields and what they represent are: name : The name of the protocol (written in snake_case ) author : The creator of the protocol version : The current version of the protocol license : Licensing information aea_version : The version(s) of the framework that support this protocol. The format is described here . description : A short description of the protocol protocol_specification_id : The id which identifies the protocol for over-the-wire transport. This id is decoupled from the protocol_id ( {author}/{name}:{version} ) which is tied to the Python implementation. All of the above fields are mandatory and each is a key/value pair, where both key and value are YAML strings. Additionally, the first YAML document of a protocol specification must describe the syntax of valid messages according to this protocol. Therefore, it must contain another mandatory speech-acts field which defines the set of performatives valid under this protocol, and a set of contents for each performative. A performative defines the type of a message (e.g. propose, accept) and has a set of contents (or parameters) of varying types. The format of the speech-act is as follows: speech-act is a dictionary, where each key is a unique performative (YAML string), and the value is a content dictionary. If a performative does not have any content, then its content dictionary is empty, for instance accept and decline in the specification above. A content dictionary in turn has key/value pairs, where each key is the name of a content (YAML string) and the value is its type (YAML string). For example, the cfp (short for 'call for proposal') performative has one content whose name is query and whose type is ct:Query .","title":"Basic Protocol Detail and Messages Syntax"},{"location":"aea/protocol-generator/#types","text":"The specific types which could be assigned to contents in a protocol specification are described in the table below. Types are either user defined (i.e. custom types) or primitive: Custom types are prepended with ct: and their format is described using regular expression in the table below. Primitive types are prepended with pt: . There are different categories of primitive types. For example, <PT> such as integers and booleans, <PCT> such as sets and lists, and so on. Primitive types are compositional: For example, consider pt:set[...] under <PCT> , i.e. an unordered collection of elements without duplicates. A pt:set[...] describes the type of its elements (called \"sub-type\") in square brackets. The sub-type of a pt:set[...] must be a <PT> (e.g. pt:int , pt:bool ). In describing the format of types, / between two sub-types should be treated as \"or\". For example, the sub-type of a pt:optional[...] is either a <PT> , <CT> , <PCT> , <PMT> or <MT> . A multi type denotes an \"or\" separated set of sub-types. For example, a content whose type is specified as pt:union[pt:str, pt:int] should either be pt:int or pt:float . An optional type pt:optional[...] assigned to a content means the content's existence is optional, but if it is present, its type must match pt:optional[...] 's sub-type. Type Code Format Example In Python Custom types 1 <CT> ct:RegExp(^[A-Z][a-zA-Z0-9]*$) ct:DataModel Custom Class Primitive types <PT> pt:bytes pt:bytes bytes pt:int pt:int int pt:float pt:float float pt:bool pt:bool bool pt:str pt:str str Primitive collection types <PCT> pt:set[<PT>] pt:set[pt:str] FrozenSet[str] pt:list[<PT>] pt:list[pt:int] Tuple[int, ...] * Primitive mapping types 2 <PMT> pt:dict[<PT>, <PT>] pt:dict[pt:str, pt:bool] Dict[str, bool] Multi types <MT> pt:union[<PT>/<CT>/<PCT>/<PMT>, ..., <PT>/<CT>/<PCT>/<PMT>] pt:union[ct:DataModel, pt:set[pt:str]] Union[DataModel, FrozenSet[str]] Optional types <O> pt:optional[<MT>/<PMT>/<PCT>/<PT>/<CT>] pt:optional[pt:bool] Optional[bool] * This is how variable length tuples containing elements of the same type are declared in Python; see here .","title":"Types"},{"location":"aea/protocol-generator/#protocol-buffer-schema","text":"Currently, the AEA framework does not officially support describing custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required serialisation logic must be provided manually. Therefore, if any of the contents declared in speech-acts is of a custom type, the specification must then have a second YAML document, containing the protocol buffer schema code for each custom type. You can see an example of the second YAML document in the above protocol specification.","title":"Protocol Buffer Schema"},{"location":"aea/protocol-generator/#dialogues","text":"You can optionally specify the structure of dialogues conforming to your protocol in a third YAML document in the specification. The allowed fields and what they represent are: initiation : The list of initial performatives reply : The reply structure of speech-acts termination : The list of terminal performatives roles : The roles of players participating in a dialogue end_states : The possible outcomes a terminated dialogue. keep_terminal_state_dialogues : whether to keep or drop a terminated dialogue. When a storage backend is configured, the dialogues will be persisted in storage when kept. All of the above fields are mandatory. initiation is a YAML list, containing the performatives which can be used to start a dialogue. reply specifies for every performative, what its valid replies are. If a performative per_1 is a valid reply to another per_2 , this means a message with performative per_1 can target a message whose performative is per_2 . reply is a YAML dictionary, where the keys are the performatives (YAML string) defined in speech-acts . For each performative key, its value is a list of performatives which are defined to be a valid reply. For example, valid replies to cfp are propose and decline . termination is a YAML list, containing the performatives which terminate a dialogue. Once any of these performatives are used in a dialogue, the dialogue is terminated and no other messages may be added to it. roles is a YAML set, containing the roles players participating in dialogues can take. roles may contain one or two roles, each role being a YAML string. If there are two roles, each participant has a distinguished role in the dialogue (e.g. buyer and seller in the above specification). If there is only one role, then both participants in a dialogue have this same role. end_states lists the final states a terminated dialogue may have. end_states is a YAML list of strings. keep_terminal_state_dialogues has a boolean value and specifies whether the terminated dialogues of this protocol are to be kept or discarded.","title":"Dialogues"},{"location":"aea/protocol-generator/#design-guidelines","text":"initiation and termination cannot be empty. Make sure that when defining reply , you include every speech-act you specified under speech_acts . If any of the speech-acts does not have a reply, indicate that with an empty list [] similar to accept and decline in the specification above. If a speech-act is listed in termination , it must not have any replies in reply . The reason is simple: a terminal speech-act terminates a dialogue and so its reply can never be used. If a speech-act replies to no other speech-acts, it should be listed in initiation otherwise it could never be used in a dialogue (neither to a start a dialogue with, nor as a reply to another speech-act).","title":"Design Guidelines"},{"location":"aea/protocol-generator/#notes","text":"Currently, there is no way to describe custom types in a programming language independent format. This means that if a protocol specification includes custom types, the required implementations must be provided manually. Before generating the protocol, the protocol buffer schema code for every custom type must be provided in the protocol specification. Once the generator is called, it produces a custom_types module containing stub implementations for every custom type in the specification. The user must then modify this module and add implementations for every custom type in the specification. This includes implementations of how an object of a custom type can be encoded and decoded using protocol buffer. Note, currently the way custom types are dealt with in the generator is admittedly inconvenient. The reason is, the generator does not know the structure of custom types and how they may be serialised/deserialised. Although this approach works, it is only a temporary solution until further work on a programming language-independent type description language is finished (similar to how the generator is designed to be a programming language-independent protocol description language). Currently, the first element in pt:dict cannot be a <CT> , pt:float or pt:bytes . This is because of a constraint in protocol buffer version 3 which is the framework's underlying serialisation mechanism. In a future version, we may address this limitation, in which case we will relax this constraint. In protocol buffer version 3, which is the version used by the generator, there is no way to check whether an optional field (i.e. contents of type pt:optional[...] ) has been set or not (see discussion here ). In proto3, all optional fields are assigned a default value (e.g. 0 for integers types, false for boolean types, etc). Therefore, given an optional field whose value is the default value, there is no way to know from the optional field itself, whether it is not set, or in fact is set but its value happens to be the default value. Because of this, in the generated protocol schema file (the .proto file), for every optional content there is a second field that declares whether this field is set or not. We will maintain this temporary solution until a cleaner alternative is found. Be aware that currently, using the generated protocols in python, there might be some rounding errors when serialising and then deserialising values of pt:float contents.","title":"Notes"},{"location":"aea/protocol-generator/#demo-instructions","text":"First, create a new AEA project: aea create my_aea cd my_aea Second, run the generator on the sample specification: aea generate protocol ../examples/protocol_specification_ex/sample.yaml This will generate the protocol and place it in your AEA project. Third, try generating other protocols by first defining a specification, then running the generator.","title":"Demo instructions"},{"location":"aea/protocol/","text":"Protocols define the structure of agent-to-agent and component-to-component interactions, which in the AEA world, are in the form of communication. To learn more about interactions and interaction protocols, see here . Protocols in the AEA world provide definitions for: messages defining the structure and syntax of messages; serialization defining how a message is encoded/decoded for transport; and optionally dialogues defining the structure of dialogues formed from exchanging series of messages. The framework provides a default protocol. This protocol provides a bare-bones implementation for an AEA protocol which includes a DefaultMessage class and associated DefaultSerializer and DefaultDialogue classes. Additional protocols - i.e. a new type of interaction - can be added as packages or generated with the protocol generator . We highly recommend you to not attempt writing your protocol manually as they tend to have involved logic; always use existing packages or the protocol generator! Components of a protocol A protocol package contains the following files: __init__.py message.py , which defines message representation serialization.py , which defines the encoding and decoding logic two protobuf related files It optionally also contains dialogues.py , which defines the structure of dialogues formed from the exchange of a series of messages custom_types.py , which defines custom types All protocols are for point to point interactions between two agents or agent-like services. Metadata Each Message in an interaction protocol has a set of default fields: dialogue_reference: Tuple[str, str] , a reference of the dialogue the message is part of. The first part of the tuple is the reference assigned to by the agent who first initiates the dialogue (i.e. sends the first message). The second part of the tuple is the reference assigned to by the other agent. The default value is (\"\", \"\") . message_id: int , the identifier of the message in a dialogue. The default value is 1 . target: int , the id of the message this message is replying to. The default value is 0 . performative: Enum , the purpose/intention of the message. sender: Address , the address of the sender of this message. to: Address , the address of the receiver of this message. The default values for message_id and target assume the message is the first message in a dialogue. Therefore, the message_id is set to 1 indicating the first message in the dialogue and target is 0 since the first message is the only message that does not reply to any other. By default, the values of dialogue_reference , message_id , target are set. However, most interactions involve more than one message being sent as part of the interaction and potentially multiple simultaneous interactions utilising the same protocol. In those cases, the dialogue_reference allows different interactions to be identified as such. The message_id and target are used to keep track of messages and their replies. For instance, on receiving of a message with message_id=1 and target=0 , the responding agent could respond with another with message_id=2 and target=1 replying to the first message. In particular, target holds the id of the message being replied to. This can be the preceding message, or an older one. Contents Each message may optionally have any number of contents of varying types. Dialogue rules Protocols can optionally have a dialogue module. A dialogue , respectively dialogues object, maintains the state of a single, respectively, all dialogues associated with a protocol. The framework provides a number of helpful classes which implement most of the logic to maintain dialogues, namely the Dialogue and Dialogues base classes. Custom protocol The developer can generate custom protocols with the protocol generator . This lets the developer specify the speech-acts as well as optionally the dialogue structure (e.g. roles of agents participating in a dialogue, the states a dialogue may end in, and the reply structure of the speech-acts in a dialogue). We highly recommend you do not attempt to write your own protocol code; always use existing packages or the protocol generator! fetchai/default:1.0.0 protocol The fetchai/default:1.0.0 protocol is meant to be implemented by every AEA. It serves AEA to AEA interaction and includes three message performatives: from enum import Enum class Performative ( Enum ): \"\"\"Performatives for the default protocol.\"\"\" BYTES = \"bytes\" END = \"end\" ERROR = \"error\" def __str__ ( self ): \"\"\"Get the string representation.\"\"\" return self . value The DefaultMessage of performative DefaultMessage.Performative.BYTES is used to send payloads of byte strings to other AEAs. An example is: from packages.fetchai.protocols.default.message import DefaultMessage msg = DefaultMessage ( performative = DefaultMessage . Performative . BYTES , content = b \"This is a bytes payload\" , ) The DefaultMessage of performative DefaultMessage.Performative.ERROR is used to notify other AEAs of errors in an interaction, including errors with other protocols, by including an error_code in the payload: class ErrorCode ( Enum ): \"\"\"This class represents an instance of ErrorCode.\"\"\" UNSUPPORTED_PROTOCOL = 0 DECODING_ERROR = 1 INVALID_MESSAGE = 2 UNSUPPORTED_SKILL = 3 INVALID_DIALOGUE = 4 An example is: msg = DefaultMessage ( performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . UNSUPPORTED_PROTOCOL , error_msg = \"This protocol is not supported by this AEA.\" , error_data = { \"unsupported_msg\" : b \"serialized unsupported protocol message\" }, ) The DefaultMessage of performative DefaultMessage.Performative.END is used to terminate a default protocol dialogue. An example is: from packages.fetchai.protocols.default.message import DefaultMessage msg = DefaultMessage ( performative = DefaultMessage . Performative . END , ) Each AEA's fetchai/error:0.17.0 skill utilises the fetchai/default:1.0.0 protocol for error handling. fetchai/oef_search:1.0.0 protocol The fetchai/oef_search:1.0.0 protocol is used by AEAs to interact with an SOEF search node to register and unregister their own services and search for services registered by other agents. The fetchai/oef_search:1.0.0 protocol definition includes an OefSearchMessage with the following message types: class Performative ( Enum ): \"\"\"Performatives for the oef_search protocol.\"\"\" REGISTER_SERVICE = \"register_service\" UNREGISTER_SERVICE = \"unregister_service\" SEARCH_SERVICES = \"search_services\" OEF_ERROR = \"oef_error\" SEARCH_RESULT = \"search_result\" SUCCESS = \"success\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value We show some example messages below: To register a service, we require a reference to the dialogue in string form (used to keep different dialogues apart), for instance my_dialogue_reference = \"a_unique_register_service_dialogue_reference\" and a description of the service we would like to register, for instance from aea.helpers.search.models import Description my_service_data = { \"country\" : \"UK\" , \"city\" : \"Cambridge\" } my_service_description = Description ( my_service_data , data_model = my_data_model , ) where we use, for instance from aea.helpers.search.generic import GenericDataModel data_model_name = \"location\" data_model = { \"attribute_one\" : { \"name\" : \"country\" , \"type\" : \"str\" , \"is_required\" : True , }, \"attribute_two\" : { \"name\" : \"city\" , \"type\" : \"str\" , \"is_required\" : True , }, } my_data_model = GenericDataModel ( data_model_name , data_model ) We can then create the message to register this service: msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = ( my_dialogue_reference , \"\" ), service_description = my_service_description , ) To unregister a service, we require a reference to the dialogue in string form, for instance my_dialogue_reference = \"a_unique_unregister_service_dialogue_reference\" the description of the service we would like to unregister, say my_service_description from above and construct the message: msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = ( my_dialogue_reference , \"\" ), service_description = my_service_description , ) To search a service, we similarly require a reference to the dialogue in string form, and then the query we would like the search node to evaluate, for instance from aea.helpers.search.models import Constraint , ConstraintType , Query query_data = { \"search_term\" : \"country\" , \"search_value\" : \"UK\" , \"constraint_type\" : \"==\" , } query = Query ( [ Constraint ( query_data [ \"search_term\" ], ConstraintType ( query_data [ \"constraint_type\" ], query_data [ \"search_value\" ], ), ) ], model = None , ) We can then create the message to search these services: oef_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , dialogue_reference = ( my_dialogue_reference , \"\" ), query = query , ) The SOEF search node will respond with a message msg of type OefSearchMessage with performative OefSearchMessage.Performative.SEARCH_RESULT . To access the tuple of agents which match the query, simply use msg.agents . In particular, this will return the agent addresses matching the query. The agent address can then be used to send a message to the agent utilising the P2P agent communication network and any protocol other than fetchai/oef_search:1.0.0 . If the SOEF search node encounters any errors with the messages you send, it will return an OefSearchMessage of performative OefSearchMessage.Performative.OEF_ERROR and indicate the error operation encountered: class OefErrorOperation ( Enum ): \"\"\"This class represents an instance of OefErrorOperation.\"\"\" REGISTER_SERVICE = 0 UNREGISTER_SERVICE = 1 SEARCH_SERVICES = 2 SEND_MESSAGE = 3 OTHER = 10000 fetchai/fipa:1.0.0 protocol This protocol provides classes and functions necessary for communication between AEAs via a variant of the FIPA Agent Communication Language. The fetchai/fipa:1.0.0 protocol definition includes a FipaMessage with the following performatives: class Performative ( Enum ): \"\"\"Performatives for the fipa protocol.\"\"\" ACCEPT = \"accept\" ACCEPT_W_INFORM = \"accept_w_inform\" CFP = \"cfp\" DECLINE = \"decline\" END = \"end\" INFORM = \"inform\" MATCH_ACCEPT = \"match_accept\" MATCH_ACCEPT_W_INFORM = \"match_accept_w_inform\" PROPOSE = \"propose\" def __str__ ( self ): \"\"\"Get the string representation.\"\"\" return self . value FipaMessages are constructed with a performative , dialogue_reference , message_id , and target as well as the kwargs specific to each message performative. def __init__ ( self , performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs , ) The fetchai/fipa:1.0.0 protocol also defines a FipaDialogue class which specifies the valid reply structure and provides other helper methods to maintain dialogues. For examples of the usage of the fetchai/fipa:1.0.0 protocol check out the generic skills step by step guide . Fipa dialogue Below, we give an example of a dialogue between two agents. In practice; both dialogues would be maintained in the respective agent. We first create concrete implementations of FipaDialogue and FipaDialogues for the buyer and seller: from aea.common import Address from aea.helpers.search.models import Constraint , ConstraintType , Description , Query from aea.mail.base import Envelope from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.protocols.dialogue.base import DialogueLabel from packages.fetchai.protocols.fipa.dialogues import FipaDialogue , FipaDialogues from packages.fetchai.protocols.fipa.message import FipaMessage class BuyerDialogue ( FipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : DialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ FipaMessage ] = FipaMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" FipaDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . proposal = None # type: Optional[Description] class BuyerDialogues ( FipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , self_address : Address ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" def role_from_first_message ( message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseFipaDialogue . Role . BUYER FipaDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , dialogue_class = FipaDialogue , ) class SellerDialogue ( FipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : DialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ FipaMessage ] = FipaMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" FipaDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . proposal = None # type: Optional[Description] class SellerDialogues ( FipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , self_address : Address ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" def role_from_first_message ( message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return FipaDialogue . Role . SELLER FipaDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , dialogue_class = FipaDialogue , ) Next, we can imitate a dialogue between the buyer and the seller. We first instantiate the dialogues models: buyer_address = \"buyer_address_stub\" seller_address = \"seller_address_stub\" buyer_dialogues = BuyerDialogues ( buyer_address ) seller_dialogues = SellerDialogues ( seller_address ) First, the buyer creates a message destined for the seller and updates the dialogues: cfp_msg = FipaMessage ( message_id = 1 , dialogue_reference = buyer_dialogues . new_self_initiated_dialogue_reference (), target = 0 , performative = FipaMessage . Performative . CFP , query = Query ([ Constraint ( \"something\" , ConstraintType ( \">\" , 1 ))]), ) cfp_msg . counterparty = seller_addr # Extends the outgoing list of messages. buyer_dialogue = buyer_dialogues . update ( cfp_msg ) If the message has been correctly constructed, the buyer_dialogue will be returned, otherwise it will be None . In a skill, the message could now be sent: # In a skill we would do: # self.context.outbox.put_message(message=cfp_msg) However, here we simply continue with the seller: # change the incoming message field & counterparty cfp_msg . is_incoming = True cfp_msg . counterparty = buyer_address In the skill, the above two lines will be done by the framework; you can simply receive the message in the handler. We update the seller's dialogues model next to generate a new dialogue: # Creates a new dialogue for the seller side based on the income message. seller_dialogue = seller_dialogues . update ( cfp_msg ) Next, the seller can generate a proposal: # Generate a proposal message to send to the buyer. proposal = Description ({ \"foo1\" : 1 , \"bar1\" : 2 }) message_id = cfp_msg . message_id + 1 target = cfp_msg . message_id proposal_msg = FipaMessage ( message_id = message_id , dialogue_reference = seller_dialogue . dialogue_label . dialogue_reference , target = target , performative = FipaMessage . Performative . PROPOSE , proposal = proposal , ) proposal_msg . counterparty = cfp_msg . counterparty # Then we update the dialogue seller_dialogue . update ( proposal_msg ) In a skill, the message could now be sent: # In a skill we would do: # self.context.outbox.put_message(message=proposal_msg) The dialogue can continue like this. To retrieve a dialogue for a given message, we can do the following: retrieved_dialogue = seller_dialogues . get_dialogue ( cfp_msg )","title":"Protocols"},{"location":"aea/protocol/#components-of-a-protocol","text":"A protocol package contains the following files: __init__.py message.py , which defines message representation serialization.py , which defines the encoding and decoding logic two protobuf related files It optionally also contains dialogues.py , which defines the structure of dialogues formed from the exchange of a series of messages custom_types.py , which defines custom types All protocols are for point to point interactions between two agents or agent-like services.","title":"Components of a protocol"},{"location":"aea/protocol/#metadata","text":"Each Message in an interaction protocol has a set of default fields: dialogue_reference: Tuple[str, str] , a reference of the dialogue the message is part of. The first part of the tuple is the reference assigned to by the agent who first initiates the dialogue (i.e. sends the first message). The second part of the tuple is the reference assigned to by the other agent. The default value is (\"\", \"\") . message_id: int , the identifier of the message in a dialogue. The default value is 1 . target: int , the id of the message this message is replying to. The default value is 0 . performative: Enum , the purpose/intention of the message. sender: Address , the address of the sender of this message. to: Address , the address of the receiver of this message. The default values for message_id and target assume the message is the first message in a dialogue. Therefore, the message_id is set to 1 indicating the first message in the dialogue and target is 0 since the first message is the only message that does not reply to any other. By default, the values of dialogue_reference , message_id , target are set. However, most interactions involve more than one message being sent as part of the interaction and potentially multiple simultaneous interactions utilising the same protocol. In those cases, the dialogue_reference allows different interactions to be identified as such. The message_id and target are used to keep track of messages and their replies. For instance, on receiving of a message with message_id=1 and target=0 , the responding agent could respond with another with message_id=2 and target=1 replying to the first message. In particular, target holds the id of the message being replied to. This can be the preceding message, or an older one.","title":"Metadata"},{"location":"aea/protocol/#contents","text":"Each message may optionally have any number of contents of varying types.","title":"Contents"},{"location":"aea/protocol/#dialogue-rules","text":"Protocols can optionally have a dialogue module. A dialogue , respectively dialogues object, maintains the state of a single, respectively, all dialogues associated with a protocol. The framework provides a number of helpful classes which implement most of the logic to maintain dialogues, namely the Dialogue and Dialogues base classes.","title":"Dialogue rules"},{"location":"aea/protocol/#custom-protocol","text":"The developer can generate custom protocols with the protocol generator . This lets the developer specify the speech-acts as well as optionally the dialogue structure (e.g. roles of agents participating in a dialogue, the states a dialogue may end in, and the reply structure of the speech-acts in a dialogue). We highly recommend you do not attempt to write your own protocol code; always use existing packages or the protocol generator!","title":"Custom protocol"},{"location":"aea/protocol/#fetchaidefault100-protocol","text":"The fetchai/default:1.0.0 protocol is meant to be implemented by every AEA. It serves AEA to AEA interaction and includes three message performatives: from enum import Enum class Performative ( Enum ): \"\"\"Performatives for the default protocol.\"\"\" BYTES = \"bytes\" END = \"end\" ERROR = \"error\" def __str__ ( self ): \"\"\"Get the string representation.\"\"\" return self . value The DefaultMessage of performative DefaultMessage.Performative.BYTES is used to send payloads of byte strings to other AEAs. An example is: from packages.fetchai.protocols.default.message import DefaultMessage msg = DefaultMessage ( performative = DefaultMessage . Performative . BYTES , content = b \"This is a bytes payload\" , ) The DefaultMessage of performative DefaultMessage.Performative.ERROR is used to notify other AEAs of errors in an interaction, including errors with other protocols, by including an error_code in the payload: class ErrorCode ( Enum ): \"\"\"This class represents an instance of ErrorCode.\"\"\" UNSUPPORTED_PROTOCOL = 0 DECODING_ERROR = 1 INVALID_MESSAGE = 2 UNSUPPORTED_SKILL = 3 INVALID_DIALOGUE = 4 An example is: msg = DefaultMessage ( performative = DefaultMessage . Performative . ERROR , error_code = DefaultMessage . ErrorCode . UNSUPPORTED_PROTOCOL , error_msg = \"This protocol is not supported by this AEA.\" , error_data = { \"unsupported_msg\" : b \"serialized unsupported protocol message\" }, ) The DefaultMessage of performative DefaultMessage.Performative.END is used to terminate a default protocol dialogue. An example is: from packages.fetchai.protocols.default.message import DefaultMessage msg = DefaultMessage ( performative = DefaultMessage . Performative . END , ) Each AEA's fetchai/error:0.17.0 skill utilises the fetchai/default:1.0.0 protocol for error handling.","title":"fetchai/default:1.0.0 protocol"},{"location":"aea/protocol/#fetchaioef_search100-protocol","text":"The fetchai/oef_search:1.0.0 protocol is used by AEAs to interact with an SOEF search node to register and unregister their own services and search for services registered by other agents. The fetchai/oef_search:1.0.0 protocol definition includes an OefSearchMessage with the following message types: class Performative ( Enum ): \"\"\"Performatives for the oef_search protocol.\"\"\" REGISTER_SERVICE = \"register_service\" UNREGISTER_SERVICE = \"unregister_service\" SEARCH_SERVICES = \"search_services\" OEF_ERROR = \"oef_error\" SEARCH_RESULT = \"search_result\" SUCCESS = \"success\" def __str__ ( self ): \"\"\"Get string representation.\"\"\" return self . value We show some example messages below: To register a service, we require a reference to the dialogue in string form (used to keep different dialogues apart), for instance my_dialogue_reference = \"a_unique_register_service_dialogue_reference\" and a description of the service we would like to register, for instance from aea.helpers.search.models import Description my_service_data = { \"country\" : \"UK\" , \"city\" : \"Cambridge\" } my_service_description = Description ( my_service_data , data_model = my_data_model , ) where we use, for instance from aea.helpers.search.generic import GenericDataModel data_model_name = \"location\" data_model = { \"attribute_one\" : { \"name\" : \"country\" , \"type\" : \"str\" , \"is_required\" : True , }, \"attribute_two\" : { \"name\" : \"city\" , \"type\" : \"str\" , \"is_required\" : True , }, } my_data_model = GenericDataModel ( data_model_name , data_model ) We can then create the message to register this service: msg = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , dialogue_reference = ( my_dialogue_reference , \"\" ), service_description = my_service_description , ) To unregister a service, we require a reference to the dialogue in string form, for instance my_dialogue_reference = \"a_unique_unregister_service_dialogue_reference\" the description of the service we would like to unregister, say my_service_description from above and construct the message: msg = OefSearchMessage ( performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , dialogue_reference = ( my_dialogue_reference , \"\" ), service_description = my_service_description , ) To search a service, we similarly require a reference to the dialogue in string form, and then the query we would like the search node to evaluate, for instance from aea.helpers.search.models import Constraint , ConstraintType , Query query_data = { \"search_term\" : \"country\" , \"search_value\" : \"UK\" , \"constraint_type\" : \"==\" , } query = Query ( [ Constraint ( query_data [ \"search_term\" ], ConstraintType ( query_data [ \"constraint_type\" ], query_data [ \"search_value\" ], ), ) ], model = None , ) We can then create the message to search these services: oef_msg = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , dialogue_reference = ( my_dialogue_reference , \"\" ), query = query , ) The SOEF search node will respond with a message msg of type OefSearchMessage with performative OefSearchMessage.Performative.SEARCH_RESULT . To access the tuple of agents which match the query, simply use msg.agents . In particular, this will return the agent addresses matching the query. The agent address can then be used to send a message to the agent utilising the P2P agent communication network and any protocol other than fetchai/oef_search:1.0.0 . If the SOEF search node encounters any errors with the messages you send, it will return an OefSearchMessage of performative OefSearchMessage.Performative.OEF_ERROR and indicate the error operation encountered: class OefErrorOperation ( Enum ): \"\"\"This class represents an instance of OefErrorOperation.\"\"\" REGISTER_SERVICE = 0 UNREGISTER_SERVICE = 1 SEARCH_SERVICES = 2 SEND_MESSAGE = 3 OTHER = 10000","title":"fetchai/oef_search:1.0.0 protocol"},{"location":"aea/protocol/#fetchaifipa100-protocol","text":"This protocol provides classes and functions necessary for communication between AEAs via a variant of the FIPA Agent Communication Language. The fetchai/fipa:1.0.0 protocol definition includes a FipaMessage with the following performatives: class Performative ( Enum ): \"\"\"Performatives for the fipa protocol.\"\"\" ACCEPT = \"accept\" ACCEPT_W_INFORM = \"accept_w_inform\" CFP = \"cfp\" DECLINE = \"decline\" END = \"end\" INFORM = \"inform\" MATCH_ACCEPT = \"match_accept\" MATCH_ACCEPT_W_INFORM = \"match_accept_w_inform\" PROPOSE = \"propose\" def __str__ ( self ): \"\"\"Get the string representation.\"\"\" return self . value FipaMessages are constructed with a performative , dialogue_reference , message_id , and target as well as the kwargs specific to each message performative. def __init__ ( self , performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs , ) The fetchai/fipa:1.0.0 protocol also defines a FipaDialogue class which specifies the valid reply structure and provides other helper methods to maintain dialogues. For examples of the usage of the fetchai/fipa:1.0.0 protocol check out the generic skills step by step guide .","title":"fetchai/fipa:1.0.0 protocol"},{"location":"aea/protocol/#fipa-dialogue","text":"Below, we give an example of a dialogue between two agents. In practice; both dialogues would be maintained in the respective agent. We first create concrete implementations of FipaDialogue and FipaDialogues for the buyer and seller: from aea.common import Address from aea.helpers.search.models import Constraint , ConstraintType , Description , Query from aea.mail.base import Envelope from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.protocols.dialogue.base import DialogueLabel from packages.fetchai.protocols.fipa.dialogues import FipaDialogue , FipaDialogues from packages.fetchai.protocols.fipa.message import FipaMessage class BuyerDialogue ( FipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : DialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ FipaMessage ] = FipaMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" FipaDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . proposal = None # type: Optional[Description] class BuyerDialogues ( FipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , self_address : Address ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" def role_from_first_message ( message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseFipaDialogue . Role . BUYER FipaDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , dialogue_class = FipaDialogue , ) class SellerDialogue ( FipaDialogue ): \"\"\"The dialogue class maintains state of a dialogue and manages it.\"\"\" def __init__ ( self , dialogue_label : DialogueLabel , self_address : Address , role : BaseDialogue . Role , message_class : Type [ FipaMessage ] = FipaMessage , ) -> None : \"\"\" Initialize a dialogue. :param dialogue_label: the identifier of the dialogue :param self_address: the address of the entity for whom this dialogue is maintained :param role: the role of the agent this dialogue is maintained for :return: None \"\"\" FipaDialogue . __init__ ( self , dialogue_label = dialogue_label , self_address = self_address , role = role , message_class = message_class , ) self . proposal = None # type: Optional[Description] class SellerDialogues ( FipaDialogues ): \"\"\"The dialogues class keeps track of all dialogues.\"\"\" def __init__ ( self , self_address : Address ) -> None : \"\"\" Initialize dialogues. :return: None \"\"\" def role_from_first_message ( message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return FipaDialogue . Role . SELLER FipaDialogues . __init__ ( self , self_address = self_address , role_from_first_message = role_from_first_message , dialogue_class = FipaDialogue , ) Next, we can imitate a dialogue between the buyer and the seller. We first instantiate the dialogues models: buyer_address = \"buyer_address_stub\" seller_address = \"seller_address_stub\" buyer_dialogues = BuyerDialogues ( buyer_address ) seller_dialogues = SellerDialogues ( seller_address ) First, the buyer creates a message destined for the seller and updates the dialogues: cfp_msg = FipaMessage ( message_id = 1 , dialogue_reference = buyer_dialogues . new_self_initiated_dialogue_reference (), target = 0 , performative = FipaMessage . Performative . CFP , query = Query ([ Constraint ( \"something\" , ConstraintType ( \">\" , 1 ))]), ) cfp_msg . counterparty = seller_addr # Extends the outgoing list of messages. buyer_dialogue = buyer_dialogues . update ( cfp_msg ) If the message has been correctly constructed, the buyer_dialogue will be returned, otherwise it will be None . In a skill, the message could now be sent: # In a skill we would do: # self.context.outbox.put_message(message=cfp_msg) However, here we simply continue with the seller: # change the incoming message field & counterparty cfp_msg . is_incoming = True cfp_msg . counterparty = buyer_address In the skill, the above two lines will be done by the framework; you can simply receive the message in the handler. We update the seller's dialogues model next to generate a new dialogue: # Creates a new dialogue for the seller side based on the income message. seller_dialogue = seller_dialogues . update ( cfp_msg ) Next, the seller can generate a proposal: # Generate a proposal message to send to the buyer. proposal = Description ({ \"foo1\" : 1 , \"bar1\" : 2 }) message_id = cfp_msg . message_id + 1 target = cfp_msg . message_id proposal_msg = FipaMessage ( message_id = message_id , dialogue_reference = seller_dialogue . dialogue_label . dialogue_reference , target = target , performative = FipaMessage . Performative . PROPOSE , proposal = proposal , ) proposal_msg . counterparty = cfp_msg . counterparty # Then we update the dialogue seller_dialogue . update ( proposal_msg ) In a skill, the message could now be sent: # In a skill we would do: # self.context.outbox.put_message(message=proposal_msg) The dialogue can continue like this. To retrieve a dialogue for a given message, we can do the following: retrieved_dialogue = seller_dialogues . get_dialogue ( cfp_msg )","title":"Fipa dialogue"},{"location":"aea/query-language/","text":"We recommend reading Defining a Data Model before reading this section. Along with the Data Model language, the AEA framework offers the possibility to specify queries defined over data models. The aea.helpers.search module implements the API that allows you to build queries. In one sentence, a Query is a set of constraints , defined over a data model . The outcome is a set of description (that is, instances of Description ) matching with the query. That is, all the description whose attributes satisfy the constraints in the query. In the next sections, we describe how to build queries. Constraints A Constraint is associated with an attribute name and imposes restrictions on the domain of that attribute. That is, it imposes some limitations on the values the attribute can assume. We have different types of constraints: relation constraints: the author of the book must be Stephen King the publication year must be greater than 1990 set constraints: the genre must fall into the following set of genres: Horror , Science fiction , Non-fiction . range constraints: the average rating must be between 3.5 and 4.5 distance constraints: the nearest bookshop must be within a distance from a given location. The class that implements the constraint concept is Constraint In the following, we show how to define them. Relation There are several ConstraintTypes that allows you to impose specific values for the attributes. The types of relation constraints are: Equal: == Not Equal: != Less than: < Less than or Equal: <= Greater than: > Greater than or Equal: >= Examples : using the attributes we used before: from aea.helpers.search.models import Constraint , ConstraintType # all the books whose author is Stephen King Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )) # all the books that are not of the genre Horror Constraint ( \"genre\" , ConstraintType ( \"!=\" , \"Horror\" )) # all the books published before 1990 Constraint ( \"year\" , ConstraintType ( \"<\" , 1990 )) # the same of before, but including 1990 Constraint ( \"year\" , ConstraintType ( \"<=\" , 1990 )) # all the books with rating greater than 4.0 Constraint ( \"average_rating\" , ConstraintType ( \">\" , 4.0 )) # all the books published after 2000, included Constraint ( \"year\" , ConstraintType ( \">=\" , 2000 )) Set The set is a constraint type that allows you to restrict the values of the attribute in a specific set. There are two kind of set constraints: In (a set of values): in Not in (a set of values): not_in Examples : from aea.helpers.search.models import Constraint , ConstraintType # all the books whose genre is one of `Horror`, `Science fiction`, `Non-fiction` Constraint ( \"genre\" , ConstraintType ( \"in\" , ( \"horror\" , \"science fiction\" , \"non-fiction\" ))) # all the books that have not been published neither in 1990, nor in 1995, nor in 2000 Constraint ( \"year\" , ConstraintType ( \"not_in\" , ( 1990 , 1995 , 2000 ))) Range The range is a constraint type that allows you to restrict the values of the attribute in a given range. Examples : from aea.helpers.search.models import Constraint , ConstraintType # all the books whose title is between 'A' and 'B' (alphanumeric order) Constraint ( \"title\" , ConstraintType ( \"within\" , ( \"A\" , \"B\" ))) # all the books that have been published between 1960 and 1970 Constraint ( \"genre\" , ConstraintType ( \"within\" , ( 1960 , 1970 ))) Distance The distance is a constraint type that allows you to put a limit on a Location attribute type. More specifically, you can set a maximum distance from a given location (the centre ), such that will be considered only the instances whose location attribute value is within a distance from the centre. Examples : from aea.helpers.search.models import Constraint , ConstraintType , Description , Location # define a location of interest, e.g. the Tour Eiffel tour_eiffel = Location ( 48.8581064 , 2.29447 ) # find all the locations close to the Tour Eiffel within 1 km close_to_tour_eiffel = Constraint ( \"position\" , ConstraintType ( \"distance\" , ( tour_eiffel , 1.0 ))) # Le Jules Verne, a famous restaurant close to the Tour Eiffel, satisfies the constraint. le_jules_verne_restaurant = Location ( 48.8579675 , 2.2951849 ) close_to_tour_eiffel . check ( Description ({ \"position\" : le_jules_verne_restaurant })) # gives `True` # The Colosseum does not satisfy the constraint (farther than 1 km from the Tour Eiffel). colosseum = Location ( 41.8902102 , 12.4922309 ) close_to_tour_eiffel . check ( Description ({ \"position\" : colosseum })) # gives `False` Constraint Expressions The constraints above mentioned can be combined with the common logical operators (i.e. and, or and not), yielding more complex expression. In particular we can specify any conjunction/disjunction/negations of the previous constraints or composite ConstraintExpressions , e.g.: books that belong to Horror and has been published after 2000, but not published by Stephen King . books whose author is either J. K. Rowling or J. R. R. Tolkien The classes that implement these operators are Not , And and Or . Not The Not is a constraint expression that allows you to specify a negation of a constraint expression. The Not constraint is satisfied whenever its subexpression is not satisfied. Example : from aea.helpers.search.models import Constraint , ConstraintType , Not # all the books whose year of publication is not between 1990 and 2000 Not ( Constraint ( \"year\" , ConstraintType ( \"within\" , ( 1990 , 2000 )))) And The And is a constraint type that allows you to specify a conjunction of constraints over an attribute. That is, the And constraint is satisfied whenever all the subexpressions that constitute the and are satisfied. Notice: the number of subexpressions must be at least 2. Example : from aea.helpers.search.models import Constraint , ConstraintType , And # all the books whose title is between 'I' and 'J' (alphanumeric order) but not equal to 'It' And ([ Constraint ( \"title\" , ConstraintType ( \"within\" , ( \"I\" , \"J\" ))), Constraint ( \"title\" , ConstraintType ( \"!=\" , \"It\" ))]) Or The class Or is a constraint type that allows you to specify a disjunction of constraints. That is, the Or constraint is satisfied whenever at least one of the constraints that constitute the or is satisfied. Notice: the number of subexpressions must be at least 2. Example : from aea.helpers.search.models import Constraint , ConstraintType , Or # all the books that have been published either before the year 1960 or after the year 1970 Or ([ Constraint ( \"year\" , ConstraintType ( \"<\" , 1960 )), Constraint ( \"year\" , ConstraintType ( \">\" , 1970 ))]) Queries A query is simply a list of constraint expressions , interpreted as a conjunction (that is, a matching description with the query must satisfy every constraint expression.) Examples : from aea.helpers.search.models import Query , Constraint , ConstraintType # query all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )), Constraint ( \"year\" , ConstraintType ( \">=\" , 1990 )), Constraint ( \"ebook_available\" , ConstraintType ( \"==\" , True )) ], book_model ) Where book_model is the DataModel object. However, the data model is an optional parameter, but to avoid ambiguity is recommended to include it. The check method The Query class supports a way to check whether a Description matches with the query. This method is called Query.check . Examples: from aea.helpers.search.models import Query , Constraint , ConstraintType from aea.helpers.search.models import Description q = Query ([ Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )), Constraint ( \"year\" , ConstraintType ( \">=\" , 1990 )), Constraint ( \"ebook_available\" , ConstraintType ( \"==\" , True )) ]) # With a query, you can check that a `Description` object satisfies the constraints. q . check ( Description ({ \"author\" : \"Stephen King\" , \"year\" : 1991 , \"ebook_available\" : True })) # True q . check ( Description ({ \"author\" : \"George Orwell\" , \"year\" : 1948 , \"ebook_available\" : False })) # False Validity A Query object must satisfy some conditions in order to be instantiated. The list of constraints expressions can't be empty; must have at least one constraint expression. If the data model is specified: For every constraint expression that constitute the query, check if they are valid with respect to the data model . A ConstraintExpr c (that is, one of And , Or , Not , Constraint ) is valid with respect to a DataModel if: If c is an instance of And , Or or Not , then every subexpression of c must be valid (with respect to to the data model); If c is an instance of Constraint , then: if the constraint type is one of < , <= , > , >= , the value in the constructor must be one of str , int or float . if the constraint type is a within , then the types in the range must be one of int , str , float or Location . if the constraint type is a distance , then the only valid type is Location . if the constraint type is a in , then the types supported are str , int , float , bool , Location . Notice though that a set of bool is trivial, so you may find yourself more comfortable by using other alternatives. for the other constraint types, i.e. == and != , the value can be one of the allowed types for Attribute , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with respect to the data model. E.g. consider a Constraint like: Constraint ( \"foo\" , ConstraintType ( \"==\" , True )) Consider a DataModel where there is an Attribute \"foo\" of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expect an equality comparison with a boolean True , instead of a str .","title":"The Query Language"},{"location":"aea/query-language/#constraints","text":"A Constraint is associated with an attribute name and imposes restrictions on the domain of that attribute. That is, it imposes some limitations on the values the attribute can assume. We have different types of constraints: relation constraints: the author of the book must be Stephen King the publication year must be greater than 1990 set constraints: the genre must fall into the following set of genres: Horror , Science fiction , Non-fiction . range constraints: the average rating must be between 3.5 and 4.5 distance constraints: the nearest bookshop must be within a distance from a given location. The class that implements the constraint concept is Constraint In the following, we show how to define them.","title":"Constraints"},{"location":"aea/query-language/#relation","text":"There are several ConstraintTypes that allows you to impose specific values for the attributes. The types of relation constraints are: Equal: == Not Equal: != Less than: < Less than or Equal: <= Greater than: > Greater than or Equal: >= Examples : using the attributes we used before: from aea.helpers.search.models import Constraint , ConstraintType # all the books whose author is Stephen King Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )) # all the books that are not of the genre Horror Constraint ( \"genre\" , ConstraintType ( \"!=\" , \"Horror\" )) # all the books published before 1990 Constraint ( \"year\" , ConstraintType ( \"<\" , 1990 )) # the same of before, but including 1990 Constraint ( \"year\" , ConstraintType ( \"<=\" , 1990 )) # all the books with rating greater than 4.0 Constraint ( \"average_rating\" , ConstraintType ( \">\" , 4.0 )) # all the books published after 2000, included Constraint ( \"year\" , ConstraintType ( \">=\" , 2000 ))","title":"Relation"},{"location":"aea/query-language/#set","text":"The set is a constraint type that allows you to restrict the values of the attribute in a specific set. There are two kind of set constraints: In (a set of values): in Not in (a set of values): not_in Examples : from aea.helpers.search.models import Constraint , ConstraintType # all the books whose genre is one of `Horror`, `Science fiction`, `Non-fiction` Constraint ( \"genre\" , ConstraintType ( \"in\" , ( \"horror\" , \"science fiction\" , \"non-fiction\" ))) # all the books that have not been published neither in 1990, nor in 1995, nor in 2000 Constraint ( \"year\" , ConstraintType ( \"not_in\" , ( 1990 , 1995 , 2000 )))","title":"Set"},{"location":"aea/query-language/#range","text":"The range is a constraint type that allows you to restrict the values of the attribute in a given range. Examples : from aea.helpers.search.models import Constraint , ConstraintType # all the books whose title is between 'A' and 'B' (alphanumeric order) Constraint ( \"title\" , ConstraintType ( \"within\" , ( \"A\" , \"B\" ))) # all the books that have been published between 1960 and 1970 Constraint ( \"genre\" , ConstraintType ( \"within\" , ( 1960 , 1970 )))","title":"Range"},{"location":"aea/query-language/#distance","text":"The distance is a constraint type that allows you to put a limit on a Location attribute type. More specifically, you can set a maximum distance from a given location (the centre ), such that will be considered only the instances whose location attribute value is within a distance from the centre. Examples : from aea.helpers.search.models import Constraint , ConstraintType , Description , Location # define a location of interest, e.g. the Tour Eiffel tour_eiffel = Location ( 48.8581064 , 2.29447 ) # find all the locations close to the Tour Eiffel within 1 km close_to_tour_eiffel = Constraint ( \"position\" , ConstraintType ( \"distance\" , ( tour_eiffel , 1.0 ))) # Le Jules Verne, a famous restaurant close to the Tour Eiffel, satisfies the constraint. le_jules_verne_restaurant = Location ( 48.8579675 , 2.2951849 ) close_to_tour_eiffel . check ( Description ({ \"position\" : le_jules_verne_restaurant })) # gives `True` # The Colosseum does not satisfy the constraint (farther than 1 km from the Tour Eiffel). colosseum = Location ( 41.8902102 , 12.4922309 ) close_to_tour_eiffel . check ( Description ({ \"position\" : colosseum })) # gives `False`","title":"Distance"},{"location":"aea/query-language/#constraint-expressions","text":"The constraints above mentioned can be combined with the common logical operators (i.e. and, or and not), yielding more complex expression. In particular we can specify any conjunction/disjunction/negations of the previous constraints or composite ConstraintExpressions , e.g.: books that belong to Horror and has been published after 2000, but not published by Stephen King . books whose author is either J. K. Rowling or J. R. R. Tolkien The classes that implement these operators are Not , And and Or .","title":"Constraint Expressions"},{"location":"aea/query-language/#not","text":"The Not is a constraint expression that allows you to specify a negation of a constraint expression. The Not constraint is satisfied whenever its subexpression is not satisfied. Example : from aea.helpers.search.models import Constraint , ConstraintType , Not # all the books whose year of publication is not between 1990 and 2000 Not ( Constraint ( \"year\" , ConstraintType ( \"within\" , ( 1990 , 2000 ))))","title":"Not"},{"location":"aea/query-language/#and","text":"The And is a constraint type that allows you to specify a conjunction of constraints over an attribute. That is, the And constraint is satisfied whenever all the subexpressions that constitute the and are satisfied. Notice: the number of subexpressions must be at least 2. Example : from aea.helpers.search.models import Constraint , ConstraintType , And # all the books whose title is between 'I' and 'J' (alphanumeric order) but not equal to 'It' And ([ Constraint ( \"title\" , ConstraintType ( \"within\" , ( \"I\" , \"J\" ))), Constraint ( \"title\" , ConstraintType ( \"!=\" , \"It\" ))])","title":"And"},{"location":"aea/query-language/#or","text":"The class Or is a constraint type that allows you to specify a disjunction of constraints. That is, the Or constraint is satisfied whenever at least one of the constraints that constitute the or is satisfied. Notice: the number of subexpressions must be at least 2. Example : from aea.helpers.search.models import Constraint , ConstraintType , Or # all the books that have been published either before the year 1960 or after the year 1970 Or ([ Constraint ( \"year\" , ConstraintType ( \"<\" , 1960 )), Constraint ( \"year\" , ConstraintType ( \">\" , 1970 ))])","title":"Or"},{"location":"aea/query-language/#queries","text":"A query is simply a list of constraint expressions , interpreted as a conjunction (that is, a matching description with the query must satisfy every constraint expression.) Examples : from aea.helpers.search.models import Query , Constraint , ConstraintType # query all the books written by Stephen King published after 1990, and available as an e-book: Query ([ Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )), Constraint ( \"year\" , ConstraintType ( \">=\" , 1990 )), Constraint ( \"ebook_available\" , ConstraintType ( \"==\" , True )) ], book_model ) Where book_model is the DataModel object. However, the data model is an optional parameter, but to avoid ambiguity is recommended to include it.","title":"Queries"},{"location":"aea/query-language/#the-check-method","text":"The Query class supports a way to check whether a Description matches with the query. This method is called Query.check . Examples: from aea.helpers.search.models import Query , Constraint , ConstraintType from aea.helpers.search.models import Description q = Query ([ Constraint ( \"author\" , ConstraintType ( \"==\" , \"Stephen King\" )), Constraint ( \"year\" , ConstraintType ( \">=\" , 1990 )), Constraint ( \"ebook_available\" , ConstraintType ( \"==\" , True )) ]) # With a query, you can check that a `Description` object satisfies the constraints. q . check ( Description ({ \"author\" : \"Stephen King\" , \"year\" : 1991 , \"ebook_available\" : True })) # True q . check ( Description ({ \"author\" : \"George Orwell\" , \"year\" : 1948 , \"ebook_available\" : False })) # False","title":"The check method"},{"location":"aea/query-language/#validity","text":"A Query object must satisfy some conditions in order to be instantiated. The list of constraints expressions can't be empty; must have at least one constraint expression. If the data model is specified: For every constraint expression that constitute the query, check if they are valid with respect to the data model . A ConstraintExpr c (that is, one of And , Or , Not , Constraint ) is valid with respect to a DataModel if: If c is an instance of And , Or or Not , then every subexpression of c must be valid (with respect to to the data model); If c is an instance of Constraint , then: if the constraint type is one of < , <= , > , >= , the value in the constructor must be one of str , int or float . if the constraint type is a within , then the types in the range must be one of int , str , float or Location . if the constraint type is a distance , then the only valid type is Location . if the constraint type is a in , then the types supported are str , int , float , bool , Location . Notice though that a set of bool is trivial, so you may find yourself more comfortable by using other alternatives. for the other constraint types, i.e. == and != , the value can be one of the allowed types for Attribute , that is str , int , float , bool , Location . Moreover, when c is a Constraint , the attribute must have a consistent type with respect to the data model. E.g. consider a Constraint like: Constraint ( \"foo\" , ConstraintType ( \"==\" , True )) Consider a DataModel where there is an Attribute \"foo\" of type str . Then the constraint is not compatible with the mentioned data model, because the constraint expect an equality comparison with a boolean True , instead of a str .","title":"Validity"},{"location":"aea/questions-and-answers/","text":"What is an AEA? AEA stands for \"Autonomous Economic Agent\". An AEA can represent an individual, organisation or object and looks after its owner's interests. AEAs act independently of constant user input and autonomously execute actions to achieve their prescribed goals. Their purpose is to create economic value for their owners. How do AEAs talk to each other when they do not know each other? For an Autonomous Economic Agent (AEA) to talk to other AEAs, it first needs to find them. Once it does, it should ensure that they both use the same protocol for communication, and if so, they then have to send messages to each other. The AEA framework, together with some of the services it provides, address all three problems. You can read more about search and discovery here , protocols here , and the Agent Communication Network (ACN) here . How does an AEA use blockchain? The AEA framework enables agents to interact with blockchains to settle transactions. Currently, the framework has native support for three different networks: Fetch.ai , Ethereum and Cosmos . You can read more about the framework's integration with the different blockchains here and gain a high level overview here . How does one install third party libraries? The framework supports the use of third-party libraries hosted on PyPI . You can directly reference the external dependencies of an AEA package (e.g. skill) in its configuration file. From inside an AEA's project directory, the install command can be used to install all the dependencies of the AEA listed in the configuration files of any of it's packages. How does one connect to a database? You have two options to connect to a database: using the built-in storage solution or using a custom ORM (object-relational mapping) library and backend. The use of the built-in storage is explained here . For a detailed example of how to use an ORM, follow the ORM guide . How does one connect a frontend? There are multiple options. The most obvious is using an HTTP server connection and creating a client that communicates with this connection. You can find a more detailed discussion here . Is the AEA framework ideal for agent-based modelling? The goal of agent-based modelling (ABM) is to study the unknown (often complex) behaviour of systems comprised of agents with known (much simpler) behaviour. ABM is a popular technique for studying biological and social systems. Despite some similarities between ABM and the AEA framework, the two have fundamentally different goals. ABM's goal is not the design of agents or solving specific practical or engineering problems. Although it would be potentially possible, it would likely be inefficient to use the AEA framework for that kind of problem. You can find more details on the application areas of the AEA framework here . When a new AEA is created, is the vendor folder populated with some default packages? All AEA projects by default hold the fetchai/default:1.0.0 , fetchai/state_update:1.0.0 and fetchai/signing:1.0.0 protocols. These (as all other packages installed from the registry) are placed in the vendor folder. You can find more details about the file structure here . Is there a standardization for private key files? Currently, the private keys are stored in .txt files. This is temporary and will be improved soon. How to use the same protocol in different skills? The details of envelope/message routing by the AEA framework are discussed in this guide . Why does the AEA framework use its own package registry? AEA packages could be described as personalized plugins for the AEA runtime. They are not like a library - they have no direct use outside the context of the framework - and therefore are not suitable for distribution via PyPI .","title":"Q&A"},{"location":"aea/quickstart/","text":"If you want to create Autonomous Economic Agents (AEAs) that can act independently of constant user input and autonomously execute actions to achieve their objective, you can use the AEA framework. This example will take you through a simple AEA to familiarise you with the basics of the framework. System Requirements The AEA framework can be used on Windows , Ubuntu/Debian and MacOS . You need Python 3.6 or higher as well as Go 1.14.2 or higher installed. \u200bGCC installation is required: * Ubuntu: apt-get install gcc * Windows (with choco installed): choco install mingw * MacOS X (with home brew): brew install gcc Option 1: Manual system preparation Install a compatible Python and Go version on your system (see this external resource for a comprehensive guide). Manual approach The following hints can help: To install Go, follow the official guide, depending on your platform here Python is already included by default on many Linux distributions (e.g. Ubuntu), as well as MacOS. To check you have the right version, open a terminal and run: python3 --version To install Python on Windows machines, you can download a specific release here . Ubuntu/Debian systems only: install Python headers, depending on the Python version you have installed on your machine. E.g. for Python 3.7: sudo apt-get install python3.7-dev Windows users: install tools for Visual Studio . Option 2: Using an automated install script We provide a script to automatically install all framework dependencies and the framework itself. This means that if you follow this option, you can skip the installation step that comes later on this page. Automated install script approach On MacOS or Ubuntu run the following commands to download and install: curl https://raw.githubusercontent.com/fetchai/agents-aea/main/scripts/install.sh --output install.sh chmod +x install.sh ./install.sh On Windows: download https://raw.githubusercontent.com/fetchai/agents-aea/main/scripts/install.ps1 , then run install.ps1 with the PowerShell terminal. Option 3: Using Docker \u200b We also provide a Docker image with all the needed dependencies. Docker approach To use the image you will first have to pull it and than run it with your current local directory mounted as a docker volume. This allows you to keep your agents local while working on them from within the docker container. To pull: docker pull fetchai/aea-user:latest To run the image on Linux and MacOs: docker run -it -v $( pwd ) :/agents --workdir = /agents fetchai/aea-user:latest And on Windows: docker run -it -v %cd%:/agents --workdir = /agents fetchai/aea-user:latest Once successfully logged into the docker container, you can follow the rest of the guide the same way as if not using docker. \u200b Preliminaries Ensure, you are in a clean working directory: either you create it manually mkdir my_aea_projects/ && cd my_aea_projects/ , then add an empty directory called packages with the following command mkdir packages/ , or you clone the template repo as described in Approach 1 in the development setup guide. At this point, when typing ls you should see a single folder called packages in your working environment. This will act as your local registry for AEA components. Unless you are using the docker image, we highly recommend using a virtual environment to ensure consistency across dependencies. Check that you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it (here we use Python 3.7 but the AEA framework supports any Python >= 3.6). touch Pipfile && pipenv --python 3 .7 && pipenv shell Installation The following installs the entire AEA package which also includes a command-line interface (CLI) . (You can skip this step if you used the install script above: Option 2 .) pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[all]' If the installation steps fail, it might be a dependency issue. Make sure you have followed all the relevant system specific steps above under System Requirements . Setup author name AEAs are composed from components. AEAs and AEA components can be developed by anyone and pushed to the AEA registry for others to use. To use the registry, we need to register an author name. You can set up your author name using the init command: aea init This is your unique author (or developer) name in the AEA ecosystem. You should see a similar output (with your input instead of the sample username and email): Do you have a Registry account? [ y/N ] : n Create a new account on the Registry now: Username: fetchai Email: hello@fetch.ai Password: Please make sure that passwords are equal. Confirm password: _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v1.1.0 AEA configurations successfully initialized: { 'author' : 'fetchai' } Note If you would rather not create an account on the registry at this point, then run aea init --local instead. Echo skill demo This is a simple demo that introduces you to the main components of an AEA. The fastest way to have your first AEA is to fetch one that already exists! aea fetch fetchai/my_first_aea:0.27.0 cd my_first_aea To learn more about the folder structure of an AEA project read on here . Alternatively: step by step install Create a new AEA First, create a new AEA project and enter it. aea create my_first_aea cd my_first_aea Add the stub connection Second, add the stub connection to the project. aea add connection fetchai/stub:0.21.0 Add the echo skill Third, add the echo skill to the project. aea add skill fetchai/echo:0.19.0 This copies the fetchai/echo:0.19.0 skill code containing the \"behaviours\", and \"handlers\" into the project, ready to run. The identifier of the skill fetchai/echo:0.19.0 consists of the name of the author of the skill, followed by the skill name and its version. Echo skill Just like humans, AEAs can have skills to achieve their tasks. As an agent developer, you can create skills to add to your own AEAs. You can also choose to publish your skills so others add them to their AEAs. More details on skills can be found on this page . The above agent has an echo skill , fetched from the registry , which simply echoes any messages it receives back to its sender. Communication via envelopes and messages AEAs use envelopes containing messages for communication. To learn more, check out the next section . Stub connection Besides skills, AEAs may have one or more connections enabling them to interface with entities in the outside world. For example, an HTTP client connection allows an AEA to communicate with HTTP servers. To read more about connections see this page . In this demo, we use the stub connection ( fetchai/stub0.15.0 ) to send envelopes to and receive envelopes from the AEA. A stub connection provides an I/O reader and writer. It uses two files for communication: one for incoming envelopes and the other for outgoing envelopes. The AEA waits for a new envelope posted to the file my_first_aea/input_file , and adds a response to the file my_first_aea/output_file . The format of each envelope is the following: TO,SENDER,PROTOCOL_ID,ENCODED_MESSAGE, For example: recipient_aea,sender_aea,fetchai/default:1.0.0, \\x 08 \\x 01 \\x 12 \\x 011 * \\x 07 \\n\\x 05hello, Install AEA dependencies aea install Add and create a private key All AEAs need a private key to run. Add one now: aea generate-key fetchai aea add-key fetchai Run the AEA Run the AEA. aea run You will see the echo skill running in the terminal window (an output similar to the one below). _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v1.1.0 Starting AEA 'my_first_aea' in 'async' mode ... info: Echo Handler: setup method called. info: Echo Behaviour: setup method called. info: [ my_first_aea ] : Start processing messages... info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ... The framework first calls the setup methods in the skill's Handler and Behaviour classes in that order; after which it repeatedly calls the act method of Behaviour class. This is the main agent loop in action. Add a message to the input file You can send the AEA a message wrapped in an envelope using the CLI's interact command. From a different terminal and same directory (ensure you are in the same virtual environment: pipenv shell ): cd my_first_aea aea interact You can now send messages to this AEA via an interactive tool by typing anything into the prompt and hitting enter twice (once to send the message and once more to check for a response). Let us send hello to this AEA (type hello and press enter twice). In the original terminal, you will see the Echo Handler dealing with this envelope and its contained message. You should see an output similar to the one below but with a different dialogue_reference . info: Echo Behaviour: act method called. info: Echo Handler: message = Message ( dialogue_reference =( '1' , '' ) message_id = 1 target = 0 performative = bytes content = b 'hello' ) , sender = my_first_aea_interact info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. Manual approach Optionally, from a different terminal and same directory (i.e. the my_first_aea project), you can send the AEA a message wrapped in an envelope via the input file. echo 'my_first_aea,sender_aea,fetchai/default:1.0.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello,' >> input_file You will see the Echo Handler dealing with the envelope and responding with the same message to the output_file , and also decoding the Base64 encrypted message in this case. info: Echo Behaviour: act method called. Echo Handler: message = Message ( sender = sender_aea,to = my_first_aea,content = b 'hello' ,dialogue_reference =( '1' , '' ) ,message_id = 1 ,performative = bytes,target = 0 ) , sender = sender_aea info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. Note, due to the dialogue reference having to be incremented, you can only send the above envelope once! This approach does not work in conjunction with the aea interact command. Stop the AEA You can stop an AEA by pressing CTRL C . Once you do, you should see the AEA being interrupted and then calling the teardown() methods: info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ^C my_first_aea interrupted! my_first_aea stopping ... info: Echo Handler: teardown method called. info: Echo Behaviour: teardown method called. Write a test for the AEA We can write an end-to-end test for the AEA utilising helper classes provided by the framework. Writing tests The following test class replicates the preceding demo and tests it's correct behaviour. The AEATestCase classes are a tool for AEA developers to write useful end-to-end tests of their AEAs. First, get the packages directory from the AEA repository (execute from the working directory which contains the my_first_aea folder): svn export https://github.com/fetchai/agents-aea.git/trunk/packages Then write the test: import signal import time from aea.common import Address from aea.mail.base import Envelope from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue from packages.fetchai.protocols.default.dialogues import DefaultDialogue , DefaultDialogues from packages.fetchai.protocols.default.message import DefaultMessage from packages.fetchai.protocols.default.serialization import DefaultSerializer from aea.test_tools.test_cases import AEATestCase class TestEchoSkill ( AEATestCase ): \"\"\"Test that echo skill works.\"\"\" def test_echo ( self ): \"\"\"Run the echo skill sequence.\"\"\" process = self . run_agent () is_running = self . is_running ( process ) assert is_running , \"AEA not running within timeout!\" # add sending and receiving envelope from input/output files sender_aea = \"sender_aea\" def role_from_first_message ( message : Message , receiver_address : Address ) -> Dialogue . Role : return DefaultDialogue . Role . AGENT dialogues = DefaultDialogues ( sender_aea , role_from_first_message ) message_content = b \"hello\" message = DefaultMessage ( performative = DefaultMessage . Performative . BYTES , dialogue_reference = dialogues . new_self_initiated_dialogue_reference (), content = message_content , ) sent_envelope = Envelope ( to = self . agent_name , sender = sender_aea , protocol_id = message . protocol_id , message = DefaultSerializer () . encode ( message ), ) self . send_envelope_to_agent ( sent_envelope , self . agent_name ) time . sleep ( 2.0 ) received_envelope = self . read_envelope_from_agent ( self . agent_name ) assert sent_envelope . to == received_envelope . sender assert sent_envelope . sender == received_envelope . to assert sent_envelope . protocol_id == received_envelope . protocol_id received_message = DefaultMessage . serializer . decode ( received_envelope . message ) assert message . content == received_message . content check_strings = ( \"Echo Handler: setup method called.\" , \"Echo Behaviour: setup method called.\" , \"Echo Behaviour: act method called.\" , \"content= {} \" . format ( message_content ), ) missing_strings = self . missing_from_output ( process , check_strings ) assert ( missing_strings == [] ), \"Strings {} didn't appear in agent output.\" . format ( missing_strings ) assert ( self . is_successfully_terminated () ), \"Echo agent wasn't successfully terminated.\" Place the above code into a file test.py in your AEA project directory (the same level as the aea-config.yaml file). To run, execute the following: pytest test.py Delete the AEA Delete the AEA from the parent directory ( cd .. to go to the parent directory). aea delete my_first_aea Next steps To gain an understanding of the core components of the framework, please continue to the next page: Core components - Part 1 For more demos, use cases or step by step guides, please check the following: Generic skill use case Weather skill demo Generic step by step guide","title":"AEA quick start"},{"location":"aea/quickstart/#system-requirements","text":"The AEA framework can be used on Windows , Ubuntu/Debian and MacOS . You need Python 3.6 or higher as well as Go 1.14.2 or higher installed. \u200bGCC installation is required: * Ubuntu: apt-get install gcc * Windows (with choco installed): choco install mingw * MacOS X (with home brew): brew install gcc","title":"System Requirements"},{"location":"aea/quickstart/#option-1-manual-system-preparation","text":"Install a compatible Python and Go version on your system (see this external resource for a comprehensive guide). Manual approach The following hints can help: To install Go, follow the official guide, depending on your platform here Python is already included by default on many Linux distributions (e.g. Ubuntu), as well as MacOS. To check you have the right version, open a terminal and run: python3 --version To install Python on Windows machines, you can download a specific release here . Ubuntu/Debian systems only: install Python headers, depending on the Python version you have installed on your machine. E.g. for Python 3.7: sudo apt-get install python3.7-dev Windows users: install tools for Visual Studio .","title":"Option 1: Manual system preparation"},{"location":"aea/quickstart/#option-2-using-an-automated-install-script","text":"We provide a script to automatically install all framework dependencies and the framework itself. This means that if you follow this option, you can skip the installation step that comes later on this page. Automated install script approach On MacOS or Ubuntu run the following commands to download and install: curl https://raw.githubusercontent.com/fetchai/agents-aea/main/scripts/install.sh --output install.sh chmod +x install.sh ./install.sh On Windows: download https://raw.githubusercontent.com/fetchai/agents-aea/main/scripts/install.ps1 , then run install.ps1 with the PowerShell terminal.","title":"Option 2: Using an automated install script"},{"location":"aea/quickstart/#option-3-using-docker","text":"\u200b We also provide a Docker image with all the needed dependencies. Docker approach To use the image you will first have to pull it and than run it with your current local directory mounted as a docker volume. This allows you to keep your agents local while working on them from within the docker container. To pull: docker pull fetchai/aea-user:latest To run the image on Linux and MacOs: docker run -it -v $( pwd ) :/agents --workdir = /agents fetchai/aea-user:latest And on Windows: docker run -it -v %cd%:/agents --workdir = /agents fetchai/aea-user:latest Once successfully logged into the docker container, you can follow the rest of the guide the same way as if not using docker. \u200b","title":"Option 3: Using Docker"},{"location":"aea/quickstart/#preliminaries","text":"Ensure, you are in a clean working directory: either you create it manually mkdir my_aea_projects/ && cd my_aea_projects/ , then add an empty directory called packages with the following command mkdir packages/ , or you clone the template repo as described in Approach 1 in the development setup guide. At this point, when typing ls you should see a single folder called packages in your working environment. This will act as your local registry for AEA components. Unless you are using the docker image, we highly recommend using a virtual environment to ensure consistency across dependencies. Check that you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Once installed, create a new environment and open it (here we use Python 3.7 but the AEA framework supports any Python >= 3.6). touch Pipfile && pipenv --python 3 .7 && pipenv shell","title":"Preliminaries"},{"location":"aea/quickstart/#installation","text":"The following installs the entire AEA package which also includes a command-line interface (CLI) . (You can skip this step if you used the install script above: Option 2 .) pip install aea [ all ] If you are using zsh rather than bash type pip install 'aea[all]' If the installation steps fail, it might be a dependency issue. Make sure you have followed all the relevant system specific steps above under System Requirements .","title":"Installation"},{"location":"aea/quickstart/#setup-author-name","text":"AEAs are composed from components. AEAs and AEA components can be developed by anyone and pushed to the AEA registry for others to use. To use the registry, we need to register an author name. You can set up your author name using the init command: aea init This is your unique author (or developer) name in the AEA ecosystem. You should see a similar output (with your input instead of the sample username and email): Do you have a Registry account? [ y/N ] : n Create a new account on the Registry now: Username: fetchai Email: hello@fetch.ai Password: Please make sure that passwords are equal. Confirm password: _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v1.1.0 AEA configurations successfully initialized: { 'author' : 'fetchai' } Note If you would rather not create an account on the registry at this point, then run aea init --local instead.","title":"Setup author name"},{"location":"aea/quickstart/#echo-skill-demo","text":"This is a simple demo that introduces you to the main components of an AEA. The fastest way to have your first AEA is to fetch one that already exists! aea fetch fetchai/my_first_aea:0.27.0 cd my_first_aea To learn more about the folder structure of an AEA project read on here . Alternatively: step by step install Create a new AEA First, create a new AEA project and enter it. aea create my_first_aea cd my_first_aea Add the stub connection Second, add the stub connection to the project. aea add connection fetchai/stub:0.21.0 Add the echo skill Third, add the echo skill to the project. aea add skill fetchai/echo:0.19.0 This copies the fetchai/echo:0.19.0 skill code containing the \"behaviours\", and \"handlers\" into the project, ready to run. The identifier of the skill fetchai/echo:0.19.0 consists of the name of the author of the skill, followed by the skill name and its version.","title":"Echo skill demo"},{"location":"aea/quickstart/#echo-skill","text":"Just like humans, AEAs can have skills to achieve their tasks. As an agent developer, you can create skills to add to your own AEAs. You can also choose to publish your skills so others add them to their AEAs. More details on skills can be found on this page . The above agent has an echo skill , fetched from the registry , which simply echoes any messages it receives back to its sender.","title":"Echo skill"},{"location":"aea/quickstart/#communication-via-envelopes-and-messages","text":"AEAs use envelopes containing messages for communication. To learn more, check out the next section .","title":"Communication via envelopes and messages"},{"location":"aea/quickstart/#stub-connection","text":"Besides skills, AEAs may have one or more connections enabling them to interface with entities in the outside world. For example, an HTTP client connection allows an AEA to communicate with HTTP servers. To read more about connections see this page . In this demo, we use the stub connection ( fetchai/stub0.15.0 ) to send envelopes to and receive envelopes from the AEA. A stub connection provides an I/O reader and writer. It uses two files for communication: one for incoming envelopes and the other for outgoing envelopes. The AEA waits for a new envelope posted to the file my_first_aea/input_file , and adds a response to the file my_first_aea/output_file . The format of each envelope is the following: TO,SENDER,PROTOCOL_ID,ENCODED_MESSAGE, For example: recipient_aea,sender_aea,fetchai/default:1.0.0, \\x 08 \\x 01 \\x 12 \\x 011 * \\x 07 \\n\\x 05hello,","title":"Stub connection"},{"location":"aea/quickstart/#install-aea-dependencies","text":"aea install","title":"Install AEA dependencies"},{"location":"aea/quickstart/#add-and-create-a-private-key","text":"All AEAs need a private key to run. Add one now: aea generate-key fetchai aea add-key fetchai","title":"Add and create a private key"},{"location":"aea/quickstart/#run-the-aea","text":"Run the AEA. aea run You will see the echo skill running in the terminal window (an output similar to the one below). _ _____ _ / \\ | ____ | / \\ / _ \\ | _ | / _ \\ / ___ \\ | | ___ / ___ \\ /_/ \\_\\| _____ | /_/ \\_\\ v1.1.0 Starting AEA 'my_first_aea' in 'async' mode ... info: Echo Handler: setup method called. info: Echo Behaviour: setup method called. info: [ my_first_aea ] : Start processing messages... info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ... The framework first calls the setup methods in the skill's Handler and Behaviour classes in that order; after which it repeatedly calls the act method of Behaviour class. This is the main agent loop in action.","title":"Run the AEA"},{"location":"aea/quickstart/#add-a-message-to-the-input-file","text":"You can send the AEA a message wrapped in an envelope using the CLI's interact command. From a different terminal and same directory (ensure you are in the same virtual environment: pipenv shell ): cd my_first_aea aea interact You can now send messages to this AEA via an interactive tool by typing anything into the prompt and hitting enter twice (once to send the message and once more to check for a response). Let us send hello to this AEA (type hello and press enter twice). In the original terminal, you will see the Echo Handler dealing with this envelope and its contained message. You should see an output similar to the one below but with a different dialogue_reference . info: Echo Behaviour: act method called. info: Echo Handler: message = Message ( dialogue_reference =( '1' , '' ) message_id = 1 target = 0 performative = bytes content = b 'hello' ) , sender = my_first_aea_interact info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. Manual approach Optionally, from a different terminal and same directory (i.e. the my_first_aea project), you can send the AEA a message wrapped in an envelope via the input file. echo 'my_first_aea,sender_aea,fetchai/default:1.0.0,\\x12\\x10\\x08\\x01\\x12\\x011*\\t*\\x07\\n\\x05hello,' >> input_file You will see the Echo Handler dealing with the envelope and responding with the same message to the output_file , and also decoding the Base64 encrypted message in this case. info: Echo Behaviour: act method called. Echo Handler: message = Message ( sender = sender_aea,to = my_first_aea,content = b 'hello' ,dialogue_reference =( '1' , '' ) ,message_id = 1 ,performative = bytes,target = 0 ) , sender = sender_aea info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. Note, due to the dialogue reference having to be incremented, you can only send the above envelope once! This approach does not work in conjunction with the aea interact command.","title":"Add a message to the input file"},{"location":"aea/quickstart/#stop-the-aea","text":"You can stop an AEA by pressing CTRL C . Once you do, you should see the AEA being interrupted and then calling the teardown() methods: info: Echo Behaviour: act method called. info: Echo Behaviour: act method called. ^C my_first_aea interrupted! my_first_aea stopping ... info: Echo Handler: teardown method called. info: Echo Behaviour: teardown method called.","title":"Stop the AEA"},{"location":"aea/quickstart/#write-a-test-for-the-aea","text":"We can write an end-to-end test for the AEA utilising helper classes provided by the framework. Writing tests The following test class replicates the preceding demo and tests it's correct behaviour. The AEATestCase classes are a tool for AEA developers to write useful end-to-end tests of their AEAs. First, get the packages directory from the AEA repository (execute from the working directory which contains the my_first_aea folder): svn export https://github.com/fetchai/agents-aea.git/trunk/packages Then write the test: import signal import time from aea.common import Address from aea.mail.base import Envelope from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue from packages.fetchai.protocols.default.dialogues import DefaultDialogue , DefaultDialogues from packages.fetchai.protocols.default.message import DefaultMessage from packages.fetchai.protocols.default.serialization import DefaultSerializer from aea.test_tools.test_cases import AEATestCase class TestEchoSkill ( AEATestCase ): \"\"\"Test that echo skill works.\"\"\" def test_echo ( self ): \"\"\"Run the echo skill sequence.\"\"\" process = self . run_agent () is_running = self . is_running ( process ) assert is_running , \"AEA not running within timeout!\" # add sending and receiving envelope from input/output files sender_aea = \"sender_aea\" def role_from_first_message ( message : Message , receiver_address : Address ) -> Dialogue . Role : return DefaultDialogue . Role . AGENT dialogues = DefaultDialogues ( sender_aea , role_from_first_message ) message_content = b \"hello\" message = DefaultMessage ( performative = DefaultMessage . Performative . BYTES , dialogue_reference = dialogues . new_self_initiated_dialogue_reference (), content = message_content , ) sent_envelope = Envelope ( to = self . agent_name , sender = sender_aea , protocol_id = message . protocol_id , message = DefaultSerializer () . encode ( message ), ) self . send_envelope_to_agent ( sent_envelope , self . agent_name ) time . sleep ( 2.0 ) received_envelope = self . read_envelope_from_agent ( self . agent_name ) assert sent_envelope . to == received_envelope . sender assert sent_envelope . sender == received_envelope . to assert sent_envelope . protocol_id == received_envelope . protocol_id received_message = DefaultMessage . serializer . decode ( received_envelope . message ) assert message . content == received_message . content check_strings = ( \"Echo Handler: setup method called.\" , \"Echo Behaviour: setup method called.\" , \"Echo Behaviour: act method called.\" , \"content= {} \" . format ( message_content ), ) missing_strings = self . missing_from_output ( process , check_strings ) assert ( missing_strings == [] ), \"Strings {} didn't appear in agent output.\" . format ( missing_strings ) assert ( self . is_successfully_terminated () ), \"Echo agent wasn't successfully terminated.\" Place the above code into a file test.py in your AEA project directory (the same level as the aea-config.yaml file). To run, execute the following: pytest test.py","title":"Write a test for the AEA"},{"location":"aea/quickstart/#delete-the-aea","text":"Delete the AEA from the parent directory ( cd .. to go to the parent directory). aea delete my_first_aea","title":"Delete the AEA"},{"location":"aea/quickstart/#next-steps","text":"To gain an understanding of the core components of the framework, please continue to the next page: Core components - Part 1 For more demos, use cases or step by step guides, please check the following: Generic skill use case Weather skill demo Generic step by step guide","title":"Next steps"},{"location":"aea/raspberry-set-up/","text":"This guide explains how to run an AEA inside a Raspberry Pi. Prerequisites Raspberry Pi 4 (You can also use Raspberry Pi3 b or Raspberry Pi3 b+) Internet connection (preferably wireless to minimise the number of wires connecting into your device) Preparing the Raspberry Pi If you have a brand-new Raspberry Pi, you can simply insert the SD card, connect the power and boot up. If you do not have a new Raspberry Pi SD card, you will need to make one. To do this follow the NOOBS instructions below. NOOBS NOOBS is a way to create an SD card for easy operating system installation on a Raspberry Pi. First download noobs from this link . Then follow this guide to set up your SD card. Once you have set up your SD card, plug it into your Raspberry Pi, connect the power and boot up. When prompted, select the Raspbian operating system and click \"Install\". Booting up and updating the OS When you first boot your Raspberry Pi, you will be prompted to enter a password for the Raspberry Pi and your WiFi password so the device can access the internet. You may also be given the option to update the operating system and software. We recommend that you let the system update. Once finished you will be prompted to restart. Even if your Raspberry Pi updated itself, we recommend that you make sure it is completely up to date using the terminal. Open a Terminal window (your Raspberry Pi might restart a few times during this process): sudo apt update -y sudo apt-get update sudo apt-get dist-upgrade Install the AEA Framework First, install pipenv: sudo apt-get install pipenv Once installed, create and launch a clean virtual environment with Python 3.7: pipenv --python 3 .7 && pipenv shell Finally, install the AEA framework from PyPI: pip install aea [ all ]","title":"Build an AEA on a Raspberry Pi"},{"location":"aea/raspberry-set-up/#prerequisites","text":"Raspberry Pi 4 (You can also use Raspberry Pi3 b or Raspberry Pi3 b+) Internet connection (preferably wireless to minimise the number of wires connecting into your device)","title":"Prerequisites"},{"location":"aea/raspberry-set-up/#preparing-the-raspberry-pi","text":"If you have a brand-new Raspberry Pi, you can simply insert the SD card, connect the power and boot up. If you do not have a new Raspberry Pi SD card, you will need to make one. To do this follow the NOOBS instructions below.","title":"Preparing the Raspberry Pi"},{"location":"aea/raspberry-set-up/#noobs","text":"NOOBS is a way to create an SD card for easy operating system installation on a Raspberry Pi. First download noobs from this link . Then follow this guide to set up your SD card. Once you have set up your SD card, plug it into your Raspberry Pi, connect the power and boot up. When prompted, select the Raspbian operating system and click \"Install\".","title":"NOOBS"},{"location":"aea/raspberry-set-up/#booting-up-and-updating-the-os","text":"When you first boot your Raspberry Pi, you will be prompted to enter a password for the Raspberry Pi and your WiFi password so the device can access the internet. You may also be given the option to update the operating system and software. We recommend that you let the system update. Once finished you will be prompted to restart. Even if your Raspberry Pi updated itself, we recommend that you make sure it is completely up to date using the terminal. Open a Terminal window (your Raspberry Pi might restart a few times during this process): sudo apt update -y sudo apt-get update sudo apt-get dist-upgrade","title":"Booting up and updating the OS"},{"location":"aea/raspberry-set-up/#install-the-aea-framework","text":"First, install pipenv: sudo apt-get install pipenv Once installed, create and launch a clean virtual environment with Python 3.7: pipenv --python 3 .7 && pipenv shell Finally, install the AEA framework from PyPI: pip install aea [ all ]","title":"Install the AEA Framework"},{"location":"aea/runtime-cost/","text":"Measuring runtime cost It is important to emphasise the fact that the AEA is a framework, so ultimately its running cost will highly depend on the number and type of components which are being run as part of a given AEA. The other cost factor is determined by the cost of running the core framework itself and how fast and efficient the framework is in interconnecting the components. These observations can provide guidance on what to report as part of the cost of running an AEA. Here is a list of suggestion on how to measure the cost of running an AEA: - the cost of running the framework itself: by running a minimal agent with an idle loop (the default one) with no connections, skills or protocols and measuring memory usage and CPU consumption as a baseline. - the cost of interconnecting components: by running an a agent with a basic skill (e.g. fetchai/echo ) and measuring memory usage and CPU consumption relative to number of messages exchanged as well as bandwidth. - the cost of basic components: dialogues memory relative to number of messages, SOEF connection baseline memory usage, P2P connection baseline memory usage, smart contract baseline memory usage The aea run --profiling SECONDS command can be used to report measures in all of the above scenarios.","title":"Profiling"},{"location":"aea/runtime-cost/#measuring-runtime-cost","text":"It is important to emphasise the fact that the AEA is a framework, so ultimately its running cost will highly depend on the number and type of components which are being run as part of a given AEA. The other cost factor is determined by the cost of running the core framework itself and how fast and efficient the framework is in interconnecting the components. These observations can provide guidance on what to report as part of the cost of running an AEA. Here is a list of suggestion on how to measure the cost of running an AEA: - the cost of running the framework itself: by running a minimal agent with an idle loop (the default one) with no connections, skills or protocols and measuring memory usage and CPU consumption as a baseline. - the cost of interconnecting components: by running an a agent with a basic skill (e.g. fetchai/echo ) and measuring memory usage and CPU consumption relative to number of messages exchanged as well as bandwidth. - the cost of basic components: dialogues memory relative to number of messages, SOEF connection baseline memory usage, P2P connection baseline memory usage, smart contract baseline memory usage The aea run --profiling SECONDS command can be used to report measures in all of the above scenarios.","title":"Measuring runtime cost"},{"location":"aea/scaffolding/","text":"Scaffold generator The scaffold generator builds out the directory structure required when adding new skills, protocols, contracts and connections to the AEA. For example, create a new AEA project (add the author flag using your own author handle if this is your first project using the aea package). aea create my_aea --author \"fetchai\" cd my_aea Then, enter into your project directory and scaffold your project skill, protocol, or connection. Scaffold a skill aea scaffold skill my_skill Scaffold a protocol aea scaffold protocol my_protocol Scaffold a contract aea scaffold contract my_contract Scaffold a connection aea scaffold connection my_connection After running the above commands, you are able to develop your own skill, protocol, contract and connection. Once you have made changes to your scaffolded packages, make sure you update the fingerprint of the package: aea fingerprint [ package_name ] [ public_id ] Then you are ready to run the AEA.","title":"Scaffolding packages"},{"location":"aea/scaffolding/#scaffold-generator","text":"The scaffold generator builds out the directory structure required when adding new skills, protocols, contracts and connections to the AEA. For example, create a new AEA project (add the author flag using your own author handle if this is your first project using the aea package). aea create my_aea --author \"fetchai\" cd my_aea Then, enter into your project directory and scaffold your project skill, protocol, or connection.","title":"Scaffold generator"},{"location":"aea/scaffolding/#scaffold-a-skill","text":"aea scaffold skill my_skill","title":"Scaffold a skill"},{"location":"aea/scaffolding/#scaffold-a-protocol","text":"aea scaffold protocol my_protocol","title":"Scaffold a protocol"},{"location":"aea/scaffolding/#scaffold-a-contract","text":"aea scaffold contract my_contract","title":"Scaffold a contract"},{"location":"aea/scaffolding/#scaffold-a-connection","text":"aea scaffold connection my_connection After running the above commands, you are able to develop your own skill, protocol, contract and connection. Once you have made changes to your scaffolded packages, make sure you update the fingerprint of the package: aea fingerprint [ package_name ] [ public_id ] Then you are ready to run the AEA.","title":"Scaffold a connection"},{"location":"aea/security/","text":"The AEA framework takes every care to follow best practice around security. The following advice will help you when writing your own code: Many potential common security vulnerabilities can be caught by static code analysis. We recommend you use safety , pylint and bandit to analyse your code. Don't use relative import paths, these can lead to malicious code being executed. Try to avoid using the subprocess module. If needed, make sure you sanitise commands passed to subprocess . Try to avoid using the pickle module. Pickle should never be used for agent-to-agent communication protocols. By design, the framework prevents skill code from accessing private keys directly, as they are not reachable from the skill execution context through attribute getters. However, if the flag -p or the option --password are not used when generating private keys for an AEA project via the aea CLI tool, the private keys will be stored in plaintext. This allows the skills to access them via interaction with the OS file system. We recommend to always specify a password to encrypt private keys by using the flag argument.","title":"Security"},{"location":"aea/simple-oef-usage/","text":"You can use the SOEF in the agent framework by using the SOEF connection as a package in your agent project. Add the SOEF package Check out the CLI guide on details how to add a connection. You will want to add the fetchai/soef:0.26.0 connection package. Register your agent and its services Register agent location To register your agent's location, you have to send a message in the fetchai/oef_search:1.0.0 protocol to the SOEF connection. First, define a data model for location data: from aea.helpers.search.models import Attribute , DataModel , Location AGENT_LOCATION_MODEL = DataModel ( \"location_agent\" , [ Attribute ( \"location\" , Location , True , \"The location where the agent is.\" )], \"A data model to describe location of an agent.\" , ) It is important to use this exact data model, as the SOEF connection can only process specific data models. Second, create a location object: from aea.helpers.search.models import Location agent_location = Location ( 52.2057092 , 2.1183431 ) Third, construct a service description instance with location and data model: from aea.helpers.search.models import Description service_instance = { \"location\" : agent_location } service_description = Description ( service_instance , data_model = AGENT_LOCATION_MODEL ) Finally, construct a message and send it: from packages.fetchai.protocols.oef_search.message import OefSearchMessage message = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , service_description = service_description , ) In case everything is registered OK, you will not receive any message back. If something goes wrong you will receive an error message with performative OefSearchMessage.Performative.OEF_ERROR . Register personality pieces To register personality pieces, you have to use a specific data model: from aea.helpers.search.models import Attribute , DataModel , Location AGENT_PERSONALITY_MODEL = DataModel ( \"personality_agent\" , [ Attribute ( \"piece\" , str , True , \"The personality piece key.\" ), Attribute ( \"value\" , str , True , \"The personality piece value.\" ), ], \"A data model to describe the personality of an agent.\" , ) An example follows: service_instance = { \"piece\" : \"genus\" , \"value\" : \"service\" } service_description = Description ( service_instance , data_model = AGENT_PERSONALITY_MODEL ) Register services To set some service key and value you have to use a specific data model: SET_SERVICE_KEY_MODEL = DataModel ( \"set_service_key\" , [ Attribute ( \"key\" , str , True , \"Service key name.\" ), Attribute ( \"value\" , str , True , \"Service key value.\" ), ], \"A data model to set service key.\" , ) An example follows: service_instance = { \"key\" : \"test\" , \"value\" : \"test\" } service_description = Description ( service_instance , data_model = SET_SERVICE_KEY_MODEL ) Remove service key To remove service key have to use a specific data model: REMOVE_SERVICE_KEY_MODEL = DataModel ( \"remove_service_key\" , [ Attribute ( \"key\" , str , True , \"Service key name.\" )], \"A data model to remove service key.\" , ) An example follows: service_instance = { \"key\" : \"test\" } service_description = Description ( service_instance , data_model = REMOVE_SERVICE_KEY_MODEL ) Note Currently, the soef does not allow for multiple registrations to be combined into a single command. Perform a search To perform a search for services registered you have to define a search query consisting of constraints. The location constraints is required, personality pieces or services keys constraints are optional. An example follows: from aea.helpers.search.models import ( Constraint , ConstraintType , Location , Query , ) radius = 0.1 close_to_my_service = Constraint ( \"location\" , ConstraintType ( \"distance\" , ( agent_location , radius )) ) personality_filters = [ Constraint ( \"genus\" , ConstraintType ( \"==\" , \"vehicle\" )), Constraint ( \"classification\" , ConstraintType ( \"==\" , \"mobility.railway.train\" ) ), ] service_key_filters = [ Constraint ( \"test\" , ConstraintType ( \"==\" , \"test\" )), ] closeness_query = Query ( [ close_to_my_service ] + personality_filters + service_key_filters ) message = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , query = closeness_query , ) In case of error you will received a message with OefSearchMessage.Performative.OEF_ERROR . In case of successful search you will receive a message with performative OefSearchMessage.Performative.SEARCH_RESULT and the list of matched agents addresses. Generic command To send a generic command request to the SOEF use the following (here on the example of setting a declared name): import urllib AGENT_GENERIC_COMMAND_MODEL = DataModel ( \"generic_command\" , [ Attribute ( \"command\" , str , True , \"Command name to execute.\" ), Attribute ( \"parameters\" , str , False , \"Url encoded parameters string.\" ), ], \"A data model to describe the generic soef command.\" , ) declared_name = \"new_declared_name\" service_description = Description ( { \"command\" : \"set_declared_name\" , \"parameters\" : urllib . parse . urlencode ({ \"name\" : declared_name }), }, data_model = AGENT_GENERIC_COMMAND_MODEL , ) message = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , service_description = service_description , )","title":"SOEF Connection"},{"location":"aea/simple-oef-usage/#add-the-soef-package","text":"Check out the CLI guide on details how to add a connection. You will want to add the fetchai/soef:0.26.0 connection package.","title":"Add the SOEF package"},{"location":"aea/simple-oef-usage/#register-your-agent-and-its-services","text":"","title":"Register your agent and its services"},{"location":"aea/simple-oef-usage/#register-agent-location","text":"To register your agent's location, you have to send a message in the fetchai/oef_search:1.0.0 protocol to the SOEF connection. First, define a data model for location data: from aea.helpers.search.models import Attribute , DataModel , Location AGENT_LOCATION_MODEL = DataModel ( \"location_agent\" , [ Attribute ( \"location\" , Location , True , \"The location where the agent is.\" )], \"A data model to describe location of an agent.\" , ) It is important to use this exact data model, as the SOEF connection can only process specific data models. Second, create a location object: from aea.helpers.search.models import Location agent_location = Location ( 52.2057092 , 2.1183431 ) Third, construct a service description instance with location and data model: from aea.helpers.search.models import Description service_instance = { \"location\" : agent_location } service_description = Description ( service_instance , data_model = AGENT_LOCATION_MODEL ) Finally, construct a message and send it: from packages.fetchai.protocols.oef_search.message import OefSearchMessage message = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , service_description = service_description , ) In case everything is registered OK, you will not receive any message back. If something goes wrong you will receive an error message with performative OefSearchMessage.Performative.OEF_ERROR .","title":"Register agent location"},{"location":"aea/simple-oef-usage/#register-personality-pieces","text":"To register personality pieces, you have to use a specific data model: from aea.helpers.search.models import Attribute , DataModel , Location AGENT_PERSONALITY_MODEL = DataModel ( \"personality_agent\" , [ Attribute ( \"piece\" , str , True , \"The personality piece key.\" ), Attribute ( \"value\" , str , True , \"The personality piece value.\" ), ], \"A data model to describe the personality of an agent.\" , ) An example follows: service_instance = { \"piece\" : \"genus\" , \"value\" : \"service\" } service_description = Description ( service_instance , data_model = AGENT_PERSONALITY_MODEL )","title":"Register personality pieces"},{"location":"aea/simple-oef-usage/#register-services","text":"To set some service key and value you have to use a specific data model: SET_SERVICE_KEY_MODEL = DataModel ( \"set_service_key\" , [ Attribute ( \"key\" , str , True , \"Service key name.\" ), Attribute ( \"value\" , str , True , \"Service key value.\" ), ], \"A data model to set service key.\" , ) An example follows: service_instance = { \"key\" : \"test\" , \"value\" : \"test\" } service_description = Description ( service_instance , data_model = SET_SERVICE_KEY_MODEL )","title":"Register services"},{"location":"aea/simple-oef-usage/#remove-service-key","text":"To remove service key have to use a specific data model: REMOVE_SERVICE_KEY_MODEL = DataModel ( \"remove_service_key\" , [ Attribute ( \"key\" , str , True , \"Service key name.\" )], \"A data model to remove service key.\" , ) An example follows: service_instance = { \"key\" : \"test\" } service_description = Description ( service_instance , data_model = REMOVE_SERVICE_KEY_MODEL ) Note Currently, the soef does not allow for multiple registrations to be combined into a single command.","title":"Remove service key"},{"location":"aea/simple-oef-usage/#perform-a-search","text":"To perform a search for services registered you have to define a search query consisting of constraints. The location constraints is required, personality pieces or services keys constraints are optional. An example follows: from aea.helpers.search.models import ( Constraint , ConstraintType , Location , Query , ) radius = 0.1 close_to_my_service = Constraint ( \"location\" , ConstraintType ( \"distance\" , ( agent_location , radius )) ) personality_filters = [ Constraint ( \"genus\" , ConstraintType ( \"==\" , \"vehicle\" )), Constraint ( \"classification\" , ConstraintType ( \"==\" , \"mobility.railway.train\" ) ), ] service_key_filters = [ Constraint ( \"test\" , ConstraintType ( \"==\" , \"test\" )), ] closeness_query = Query ( [ close_to_my_service ] + personality_filters + service_key_filters ) message = OefSearchMessage ( performative = OefSearchMessage . Performative . SEARCH_SERVICES , query = closeness_query , ) In case of error you will received a message with OefSearchMessage.Performative.OEF_ERROR . In case of successful search you will receive a message with performative OefSearchMessage.Performative.SEARCH_RESULT and the list of matched agents addresses.","title":"Perform a search"},{"location":"aea/simple-oef-usage/#generic-command","text":"To send a generic command request to the SOEF use the following (here on the example of setting a declared name): import urllib AGENT_GENERIC_COMMAND_MODEL = DataModel ( \"generic_command\" , [ Attribute ( \"command\" , str , True , \"Command name to execute.\" ), Attribute ( \"parameters\" , str , False , \"Url encoded parameters string.\" ), ], \"A data model to describe the generic soef command.\" , ) declared_name = \"new_declared_name\" service_description = Description ( { \"command\" : \"set_declared_name\" , \"parameters\" : urllib . parse . urlencode ({ \"name\" : declared_name }), }, data_model = AGENT_GENERIC_COMMAND_MODEL , ) message = OefSearchMessage ( performative = OefSearchMessage . Performative . REGISTER_SERVICE , service_description = service_description , )","title":"Generic command"},{"location":"aea/simple-oef/","text":"Simple-OEF: Agent Search and Discovery The full documentation is available here .","title":"Simple OEF"},{"location":"aea/simple-oef/#simple-oef-agent-search-and-discovery","text":"The full documentation is available here .","title":"Simple-OEF: Agent Search and Discovery"},{"location":"aea/skill-guide/","text":"This guide will take you through the development of your first skill. It will teach you, how to connect the AEA to the digital world, register the AEA and search for other AEAs. Although one can imagine scenarios where a single AEA pursues its goals in isolation without interacting with other AEAs, there is no doubt that by working together, AEAs can achieve much more. To do so, an AEA must be seen and found by other AEAs so that they can trade and do other useful things. Fetch.ai\u2019s search-and-discovery mechanism, the simple OEF (or SOEF, for short) lets your agents register, be discovered, and find other agents. You can then negotiate using the AEA framework\u2019s peer-to-peer network (ACN) and trade. This guide covers getting your AEA connected to the SOEF, and describing your AEA to make itself visible. Registering your AEA with the SOEF involves setting a name, a genus (a high-level description of what the agent represents, e.g. vehicle , building or service ), a classification (for example infrastructure.railway.train ) and other descriptors to further fine-tune the kind of service your AEA offers (for example, the agent's position, whether it buys or sells, and other descriptive items). The more you describe your AEA, the easier it is for others to find it using specific filters. Dependencies (Required) Follow the Preliminaries and Installation sections from the AEA quick start. Step 1: Setup We will first create an AEA and add a scaffold skill, which we call my_search . aea create my_aea && cd my_aea aea scaffold skill my_search In the following steps, we replace the scaffolded Behaviour and Handler in my_aea/skills/my_search with our implementation. We will build a simple skill which lets the AEA send a search query to the SOEF search node and process the resulting response. Step 2: Develop a Behaviour A Behaviour class contains the business logic specific to actions initiated by the AEA rather than reactions to other events. In this example, we implement a simple search behaviour. Each time, act() gets called by the main agent loop, we will send a search request to the SOEF search node via the P2P communication network . from typing import cast from aea.helpers.search.models import Constraint , ConstraintType , Location , Query from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.my_search.dialogues import OefSearchDialogues DEFAULT_LOCATION = { \"longitude\" : 0.1270 , \"latitude\" : 51.5194 } DEFAULT_SEARCH_QUERY = { \"search_key\" : \"seller_service\" , \"search_value\" : \"generic_service\" , \"constraint_type\" : \"==\" , } DEFAULT_SEARCH_RADIUS = 5.0 class MySearchBehaviour ( TickerBehaviour ): \"\"\"This class provides a simple search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" search_query = kwargs . pop ( \"search_query\" , DEFAULT_SEARCH_QUERY ) location = kwargs . pop ( \"location\" , DEFAULT_LOCATION ) agent_location = Location ( latitude = location [ \"latitude\" ], longitude = location [ \"longitude\" ]) radius = kwargs . pop ( \"search_radius\" , DEFAULT_SEARCH_RADIUS ) close_to_my_service = Constraint ( \"location\" , ConstraintType ( \"distance\" , ( agent_location , radius )) ) service_key_filter = Constraint ( search_query [ \"search_key\" ], ConstraintType ( search_query [ \"constraint_type\" ], search_query [ \"search_value\" ], ), ) self . query = Query ([ close_to_my_service , service_key_filter ]) super () . __init__ ( ** kwargs ) self . sent_search_count = 0 def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" self . context . logger . info ( \"setting up MySearchBehaviour\" ) def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . sent_search_count += 1 oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) self . context . logger . info ( \"sending search request to OEF search node, search_count= {} \" . format ( self . sent_search_count ) ) search_request , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . SEARCH_SERVICES , query = self . query , ) self . context . outbox . put_message ( message = search_request ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . context . logger . info ( \"tearing down MySearchBehaviour\" ) Searches are proactive and, as such, well placed in a Behaviour . Specifically, we subclass the TickerBehaviour as it allows us to repeatedly search at a defined tick interval. We place this code in my_aea/skills/my_search/behaviours.py . Ensure you replace the fetchai author in this line from packages.fetchai.skills.my_search.dialogues import OefSearchDialogues with your author handle (run aea init to set or check the author name). Note Note that the import paths to agent packages, for example packages.fetchai.skills.my_search.dialogues above, are not actual paths. Package files always reside in your AEA's folder, either under a specific package directory (e.g. connection, protocol, skill) if the package is custom built, or under vendor if it is pulled from the registry. These paths are virtual and created automatically when an AEA is run. See this page for more details. Step 3: Develop a Handler So far, we have tasked the AEA with sending search requests to the SOEF search node . However, we have no way of handling the responses sent to the AEA by the SOEF search node at the moment. The AEA would simply respond to the SOEF search node via the default error skill which sends all unrecognised envelopes back to the sender. Let us now implement a Handler to deal with the incoming search responses. from typing import Optional , cast from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.my_search.dialogues import ( OefSearchDialogue , OefSearchDialogues , ) class MySearchHandler ( Handler ): \"\"\"This class provides a simple search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id def __init__ ( self , ** kwargs ): \"\"\"Initialize the handler.\"\"\" super () . __init__ ( ** kwargs ) self . received_search_count = 0 def setup ( self ) -> None : \"\"\"Set up the handler.\"\"\" self . context . logger . info ( \"setting up MySearchHandler\" ) def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" oef_search_msg = cast ( OefSearchMessage , message ) # recover dialogue oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_dialogue = cast ( Optional [ OefSearchDialogue ], oef_search_dialogues . update ( oef_search_msg ) ) if oef_search_dialogue is None : self . _handle_unidentified_dialogue ( oef_search_msg ) return # handle message if oef_search_msg . performative is OefSearchMessage . Performative . OEF_ERROR : self . _handle_error ( oef_search_msg , oef_search_dialogue ) elif oef_search_msg . performative is OefSearchMessage . Performative . SEARCH_RESULT : self . _handle_search ( oef_search_msg , oef_search_dialogue ) else : self . _handle_invalid ( oef_search_msg , oef_search_dialogue ) def _handle_unidentified_dialogue ( self , oef_search_msg : OefSearchMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid oef_search message= {} , unidentified dialogue.\" . format ( oef_search_msg ) ) def _handle_error ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"received oef_search error message= {} in dialogue= {} .\" . format ( oef_search_msg , oef_search_dialogue ) ) def _handle_search ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle the search response. :param agents: the agents returned by the search :return: None \"\"\" self . received_search_count += 1 nb_agents_found = len ( oef_search_msg . agents ) self . context . logger . info ( \"found number of agents= {} , received search count= {} \" . format ( nb_agents_found , self . received_search_count ) ) self . context . logger . info ( \"number of search requests sent= {} vs. number of search responses received= {} \" . format ( self . context . behaviours . my_search_behaviour . sent_search_count , self . received_search_count , ) ) def _handle_invalid ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle oef_search message of performative= {} in dialogue= {} .\" . format ( oef_search_msg . performative , oef_search_dialogue , ) ) def teardown ( self ) -> None : \"\"\" Teardown the handler. :return: None \"\"\" self . context . logger . info ( \"tearing down MySearchHandler\" ) We create a handler which is registered for the oef_search protocol. Whenever it receives a search result, we log the number of agents returned in the search - the agents matching the search query - and update the counter of received searches. We also implement a trivial check on the difference between the amount of search requests sent and responses received. Note, how the handler simply reacts to incoming events (i.e. messages). It could initiate further actions, however, they are still reactions to the upstream search event. Also note, how we have access to other objects in the skill via self.context , the SkillContext . We place this code in my_aea/skills/my_search/handlers.py . Ensure you replace the fetchai author in this line from packages.fetchai.skills.my_search.dialogues import ( with your author handle (run aea init to set or check the author name). Step 4: Add dialogues model We have implemented a behaviour and a handler. We now implement a Model , in particular we implement the Dialogue and Dialogues classes. These ensure that the message flow satisfies the fetchai/oef_search:1.0.0 protocol and keep track of the individual messages being sent and received. from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.skills.base import Address , Model from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogue as BaseOefSearchDialogue , ) from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogues as BaseOefSearchDialogues , ) OefSearchDialogue = BaseOefSearchDialogue class OefSearchDialogues ( Model , BaseOefSearchDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :param agent_address: the address of the agent for whom dialogues are maintained :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseOefSearchDialogue . Role . AGENT BaseOefSearchDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , ) We add this code in the file my_aea/skills/my_search/my_model.py , replacing its original content. We then rename my_aea/skills/my_search/my_model.py to my_aea/skills/my_search/dialogues.py . Step 5: Create the configuration file Based on our skill components above, we create the following configuration file. name : my_search author : fetchai version : 0.1.0 type : skill description : A simple search skill utilising the SOEF search node. license : Apache-2.0 aea_version : '>=1.0.0, <2.0.0' fingerprint : {} fingerprint_ignore_patterns : [] connections : [] contracts : [] protocols : - fetchai/oef_search:1.0.0 skills : [] behaviours : my_search_behaviour : args : location : latitude : 51.5194 longitude : 0.127 search_query : constraint_type : == search_key : seller_service search_value : generic_service search_radius : 5.0 tick_interval : 5 class_name : MySearchBehaviour handlers : my_search_handler : args : {} class_name : MySearchHandler models : oef_search_dialogues : args : {} class_name : OefSearchDialogues dependencies : aea-ledger-fetchai : version : <2.0.0,>=1.0.0 is_abstract : false Ensure, you replace the author field with your author name! (Run aea init to set or check the author name.) Importantly, the keys my_search_behaviour and my_search_handler are used in the above handler to access these skill components at runtime via the context. We also set the tick_interval of the TickerBehaviour to 5 seconds. We place this code in my_aea/skills/my_search/skill.yaml . Similarly, we replace my_aea/skills/my_search/__init__.py as follows: # -*- coding: utf-8 -*- # ------------------------------------------------------------------------------ # # Copyright 2018-2019 Fetch.AI Limited # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ \"\"\"This module contains the implementation of the error skill.\"\"\" from aea.configurations.base import PublicId PUBLIC_ID = PublicId . from_str ( \"fetchai/my_search:0.1.0\" ) Again, ensure the author field matches your own. Step 6: Update fingerprint To run an AEA with new or modified code, you need to update the fingerprint of the new/modified components. In this case, we need to fingerprint our skill: aea fingerprint skill fetchai/my_search:0.1.0 Ensure, you use the correct author name to reference your skill (here we use fetchai as the author.) Step 7: Add the OEF protocol and connection Our AEA does not have the OEF protocol yet so let's add it. aea add protocol fetchai/oef_search:1.0.0 This adds the protocol to our AEA and makes it available on the path packages.fetchai.protocols... . At this point we need to add the SOEF and P2P connections to allow the AEA to communicate with the SOEF node and other AEAs, install the AEA's dependencies, and configure the AEA: aea add connection fetchai/soef:0.26.0 aea add connection fetchai/p2p_libp2p:0.25.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' The last command will ensure that search requests are processed by the correct connection. Step 8: Run a service provider AEA In order for this AEA to find another AEA when searching, the second AEA (let's call it the service provider AEA) must exist and have been registered with the SOEF. From a different terminal window, we fetch a finished service provider AEA and install its Python dependencies: aea fetch fetchai/simple_service_registration:0.31.0 && cd simple_service_registration && aea install && aea build This AEA will simply register a location service on the SOEF search node so we can search for it. We first create the private key for the service provider AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Then we run the AEA: aea run Once you see a message of the form To join its network use multiaddr: ['SOME_ADDRESS'] take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the simple_service_registration (service provider) AEA. Click here to see full code and guide for this AEA We use a TickerBehaviour to update the service registration at regular intervals. The following code is placed in behaviours.py . from typing import Any , Optional , cast from aea.helpers.search.models import Description from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.simple_service_registration.dialogues import ( OefSearchDialogues , ) from packages.fetchai.skills.simple_service_registration.strategy import Strategy DEFAULT_MAX_SOEF_REGISTRATION_RETRIES = 5 DEFAULT_SERVICES_INTERVAL = 30.0 class ServiceRegistrationBehaviour ( TickerBehaviour ): \"\"\"This class implements a behaviour.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\"Initialise the behaviour.\"\"\" services_interval = kwargs . pop ( \"services_interval\" , DEFAULT_SERVICES_INTERVAL ) # type: int self . _max_soef_registration_retries = kwargs . pop ( \"max_soef_registration_retries\" , DEFAULT_MAX_SOEF_REGISTRATION_RETRIES ) # type: int super () . __init__ ( tick_interval = services_interval , ** kwargs ) self . failed_registration_msg = None # type: Optional[OefSearchMessage] self . _nb_retries = 0 def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" self . _register_agent () def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . _retry_failed_registration () def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . _unregister_service () self . _unregister_agent () def _retry_failed_registration ( self ) -> None : \"\"\" Retry a failed registration. :return: None \"\"\" if self . failed_registration_msg is not None : self . _nb_retries += 1 if self . _nb_retries > self . _max_soef_registration_retries : self . context . is_active = False return oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . failed_registration_msg . to , performative = self . failed_registration_msg . performative , service_description = self . failed_registration_msg . service_description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( f \"Retrying registration on SOEF. Retry { self . _nb_retries } out of { self . _max_soef_registration_retries } .\" ) self . failed_registration_msg = None def _register ( self , description : Description , logger_msg : str ) -> None : \"\"\" Register something on the SOEF. :param description: the description of what is being registered :param logger_msg: the logger message to print after the registration :return: None \"\"\" oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . REGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( logger_msg ) def _register_agent ( self ) -> None : \"\"\" Register the agent's location. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_location_description () self . _register ( description , \"registering agent on SOEF.\" ) def register_service ( self ) -> None : \"\"\" Register the agent's service. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_register_service_description () self . _register ( description , \"registering agent's service on the SOEF.\" ) def register_genus ( self ) -> None : \"\"\" Register the agent's personality genus. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_register_personality_description () self . _register ( description , \"registering agent's personality genus on the SOEF.\" ) def register_classification ( self ) -> None : \"\"\" Register the agent's personality classification. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_register_classification_description () self . _register ( description , \"registering agent's personality classification on the SOEF.\" ) def _unregister_service ( self ) -> None : \"\"\" Unregister service from the SOEF. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_unregister_service_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"unregistering service from SOEF.\" ) def _unregister_agent ( self ) -> None : \"\"\" Unregister agent from the SOEF. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_location_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"unregistering agent from SOEF.\" ) We create a Model type strategy class and place it in strategy.py . We use a generic data model to register the service. As part of the registration we register a location and a key pair describing our service. from typing import Any from aea.exceptions import enforce from aea.helpers.search.generic import ( AGENT_LOCATION_MODEL , AGENT_PERSONALITY_MODEL , AGENT_REMOVE_SERVICE_MODEL , AGENT_SET_SERVICE_MODEL , ) from aea.helpers.search.models import Description , Location from aea.skills.base import Model DEFAULT_LOCATION = { \"longitude\" : 0.1270 , \"latitude\" : 51.5194 } DEFAULT_SERVICE_DATA = { \"key\" : \"seller_service\" , \"value\" : \"generic_service\" } DEFAULT_PERSONALITY_DATA = { \"piece\" : \"genus\" , \"value\" : \"data\" } DEFAULT_CLASSIFICATION = { \"piece\" : \"classification\" , \"value\" : \"seller\" } class Strategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize the strategy of the agent. :return: None \"\"\" location = kwargs . pop ( \"location\" , DEFAULT_LOCATION ) self . _agent_location = { \"location\" : Location ( latitude = location [ \"latitude\" ], longitude = location [ \"longitude\" ] ) } self . _set_personality_data = kwargs . pop ( \"personality_data\" , DEFAULT_PERSONALITY_DATA ) enforce ( len ( self . _set_personality_data ) == 2 and \"piece\" in self . _set_personality_data and \"value\" in self . _set_personality_data , \"personality_data must contain keys `key` and `value`\" , ) self . _set_classification = kwargs . pop ( \"classification\" , DEFAULT_CLASSIFICATION ) enforce ( len ( self . _set_classification ) == 2 and \"piece\" in self . _set_classification and \"value\" in self . _set_classification , \"classification must contain keys `key` and `value`\" , ) self . _set_service_data = kwargs . pop ( \"service_data\" , DEFAULT_SERVICE_DATA ) enforce ( len ( self . _set_service_data ) == 2 and \"key\" in self . _set_service_data and \"value\" in self . _set_service_data , \"service_data must contain keys `key` and `value`\" , ) self . _remove_service_data = { \"key\" : self . _set_service_data [ \"key\" ]} super () . __init__ ( ** kwargs ) def get_location_description ( self ) -> Description : \"\"\" Get the location description. :return: a description of the agent's location \"\"\" description = Description ( self . _agent_location , data_model = AGENT_LOCATION_MODEL , ) return description def get_register_service_description ( self ) -> Description : \"\"\" Get the register service description. :return: a description of the offered services \"\"\" description = Description ( self . _set_service_data , data_model = AGENT_SET_SERVICE_MODEL , ) return description def get_register_personality_description ( self ) -> Description : \"\"\" Get the register personality description. :return: a description of the personality \"\"\" description = Description ( self . _set_personality_data , data_model = AGENT_PERSONALITY_MODEL , ) return description def get_register_classification_description ( self ) -> Description : \"\"\" Get the register classification description. :return: a description of the classification \"\"\" description = Description ( self . _set_classification , data_model = AGENT_PERSONALITY_MODEL , ) return description def get_unregister_service_description ( self ) -> Description : \"\"\" Get the unregister service description. :return: a description of the to be removed service \"\"\" description = Description ( self . _remove_service_data , data_model = AGENT_REMOVE_SERVICE_MODEL , ) return description We create a Model type dialogue class and place it in dialogues.py . These classes ensure that the message flow satisfies the fetchai/oef_search:1.0.0 protocol and keep track of the individual messages being sent and received. from typing import Any from aea.protocols.base import Address , Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.skills.base import Model from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogue as BaseOefSearchDialogue , ) from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogues as BaseOefSearchDialogues , ) OefSearchDialogue = BaseOefSearchDialogue class OefSearchDialogues ( Model , BaseOefSearchDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param agent_address: the address of the agent for whom dialogues are maintained :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseOefSearchDialogue . Role . AGENT BaseOefSearchDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , ) Finally, we have a handler, placed in handlers.py . The handler deals with handling any error messages which might occur during service registration: from typing import Optional , cast from aea.configurations.base import PublicId from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.simple_service_registration.behaviours import ( ServiceRegistrationBehaviour , ) from packages.fetchai.skills.simple_service_registration.dialogues import ( OefSearchDialogue , OefSearchDialogues , ) class OefSearchHandler ( Handler ): \"\"\"This class implements an OEF search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Call to setup the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" oef_search_msg = cast ( OefSearchMessage , message ) # recover dialogue oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_dialogue = cast ( Optional [ OefSearchDialogue ], oef_search_dialogues . update ( oef_search_msg ) ) if oef_search_dialogue is None : self . _handle_unidentified_dialogue ( oef_search_msg ) return # handle message if oef_search_msg . performative == OefSearchMessage . Performative . SUCCESS : self . _handle_success ( oef_search_msg , oef_search_dialogue ) elif oef_search_msg . performative == OefSearchMessage . Performative . OEF_ERROR : self . _handle_error ( oef_search_msg , oef_search_dialogue ) else : self . _handle_invalid ( oef_search_msg , oef_search_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" def _handle_unidentified_dialogue ( self , oef_search_msg : OefSearchMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid oef_search message= {} , unidentified dialogue.\" . format ( oef_search_msg ) ) def _handle_success ( self , oef_search_success_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue , ) -> None : \"\"\" Handle an oef search message. :param oef_search_success_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"received oef_search success message= {} in dialogue= {} .\" . format ( oef_search_success_msg , oef_search_dialogue ) ) target_message = cast ( OefSearchMessage , oef_search_dialogue . get_message_by_id ( oef_search_success_msg . target ), ) if ( target_message . performative == OefSearchMessage . Performative . REGISTER_SERVICE ): description = target_message . service_description data_model_name = description . data_model . name registration_behaviour = cast ( ServiceRegistrationBehaviour , self . context . behaviours . service , ) if \"location_agent\" in data_model_name : registration_behaviour . register_service () elif \"set_service_key\" in data_model_name : registration_behaviour . register_genus () elif ( \"personality_agent\" in data_model_name and description . values [ \"piece\" ] == \"genus\" ): registration_behaviour . register_classification () elif ( \"personality_agent\" in data_model_name and description . values [ \"piece\" ] == \"classification\" ): self . context . logger . info ( \"the agent, with its genus and classification, and its service are successfully registered on the SOEF.\" ) else : self . context . logger . warning ( f \"received soef SUCCESS message as a reply to the following unexpected message: { target_message } \" ) def _handle_error ( self , oef_search_error_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue , ) -> None : \"\"\" Handle an oef search message. :param oef_search_error_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"received oef_search error message= {} in dialogue= {} .\" . format ( oef_search_error_msg , oef_search_dialogue ) ) target_message = cast ( OefSearchMessage , oef_search_dialogue . get_message_by_id ( oef_search_error_msg . target ), ) if ( target_message . performative == OefSearchMessage . Performative . REGISTER_SERVICE ): registration_behaviour = cast ( ServiceRegistrationBehaviour , self . context . behaviours . service , ) registration_behaviour . failed_registration_msg = target_message def _handle_invalid ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle oef_search message of performative= {} in dialogue= {} .\" . format ( oef_search_msg . performative , oef_search_dialogue , ) ) The associated skill.yaml is: name : simple_service_registration author : fetchai version : 0.20.0 type : skill description : The simple service registration skills is a skill to register a service. license : Apache-2.0 aea_version : '>=1.0.0, <2.0.0' fingerprint : README.md : QmUgCcR7sDBQeeCBRKwDT7tPBTi3t4zSibyEqR3xdQUKmh __init__.py : QmZd48HmYDr7FMxNaVeGfWRvVtieEdEV78hd7h7roTceP2 behaviours.py : QmQHf6QL5aBtLJ34D2tdcbjJLbzom9gaA3HWgRn3rWyigM dialogues.py : QmTT9dvFhWt6qvxjwBfMFDTrgEtgWbvgANYafyRg2BXwcR handlers.py : QmZqPt8toGbJgTT6NZBLxjkusrQCZ8GmUEwcmqZ1sd7DpG strategy.py : QmVXfQpk4cjDw576H2ELE12tEiN5brPkwvffvcTeMbsugA fingerprint_ignore_patterns : [] connections : [] contracts : [] protocols : - fetchai/oef_search:1.0.0 skills : [] behaviours : service : args : max_soef_registration_retries : 5 services_interval : 30 class_name : ServiceRegistrationBehaviour handlers : oef_search : args : {} class_name : OefSearchHandler models : oef_search_dialogues : args : {} class_name : OefSearchDialogues strategy : args : classification : piece : classification value : seller location : latitude : 51.5194 longitude : 0.127 personality_data : piece : genus value : data service_data : key : seller_service value : generic_service class_name : Strategy dependencies : {} is_abstract : false Step 9: Run the Search AEA First, create the private key for the search AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Then, in the search AEA, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAm1uJpFsqSgHStJdtTBPpDme1fo8uFEvvY182D2y89jQuj\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the search AEA to connect to the same local agent communication network as the service registration AEA. We can then launch our AEA. aea run We can see that the AEA sends search requests to the SOEF search node and receives search responses from the SOEF search node . The search response returns one or more agents (the service provider and potentially other agents which match the query). We stop the AEA with CTRL + C . Next steps Recommended We recommend you continue with the next step in the 'Getting Started' series: Core components (Part 2) Relevant deep-dives This guide goes through a more elaborate scenario than the one on this page, where after finding each other, the two AEAs negotiate and trade via a ledger.","title":"Build your first skill - search & discovery"},{"location":"aea/skill-guide/#dependencies-required","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies (Required)"},{"location":"aea/skill-guide/#step-1-setup","text":"We will first create an AEA and add a scaffold skill, which we call my_search . aea create my_aea && cd my_aea aea scaffold skill my_search In the following steps, we replace the scaffolded Behaviour and Handler in my_aea/skills/my_search with our implementation. We will build a simple skill which lets the AEA send a search query to the SOEF search node and process the resulting response.","title":"Step 1: Setup"},{"location":"aea/skill-guide/#step-2-develop-a-behaviour","text":"A Behaviour class contains the business logic specific to actions initiated by the AEA rather than reactions to other events. In this example, we implement a simple search behaviour. Each time, act() gets called by the main agent loop, we will send a search request to the SOEF search node via the P2P communication network . from typing import cast from aea.helpers.search.models import Constraint , ConstraintType , Location , Query from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.my_search.dialogues import OefSearchDialogues DEFAULT_LOCATION = { \"longitude\" : 0.1270 , \"latitude\" : 51.5194 } DEFAULT_SEARCH_QUERY = { \"search_key\" : \"seller_service\" , \"search_value\" : \"generic_service\" , \"constraint_type\" : \"==\" , } DEFAULT_SEARCH_RADIUS = 5.0 class MySearchBehaviour ( TickerBehaviour ): \"\"\"This class provides a simple search behaviour.\"\"\" def __init__ ( self , ** kwargs ): \"\"\"Initialize the search behaviour.\"\"\" search_query = kwargs . pop ( \"search_query\" , DEFAULT_SEARCH_QUERY ) location = kwargs . pop ( \"location\" , DEFAULT_LOCATION ) agent_location = Location ( latitude = location [ \"latitude\" ], longitude = location [ \"longitude\" ]) radius = kwargs . pop ( \"search_radius\" , DEFAULT_SEARCH_RADIUS ) close_to_my_service = Constraint ( \"location\" , ConstraintType ( \"distance\" , ( agent_location , radius )) ) service_key_filter = Constraint ( search_query [ \"search_key\" ], ConstraintType ( search_query [ \"constraint_type\" ], search_query [ \"search_value\" ], ), ) self . query = Query ([ close_to_my_service , service_key_filter ]) super () . __init__ ( ** kwargs ) self . sent_search_count = 0 def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" self . context . logger . info ( \"setting up MySearchBehaviour\" ) def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . sent_search_count += 1 oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) self . context . logger . info ( \"sending search request to OEF search node, search_count= {} \" . format ( self . sent_search_count ) ) search_request , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . SEARCH_SERVICES , query = self . query , ) self . context . outbox . put_message ( message = search_request ) def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . context . logger . info ( \"tearing down MySearchBehaviour\" ) Searches are proactive and, as such, well placed in a Behaviour . Specifically, we subclass the TickerBehaviour as it allows us to repeatedly search at a defined tick interval. We place this code in my_aea/skills/my_search/behaviours.py . Ensure you replace the fetchai author in this line from packages.fetchai.skills.my_search.dialogues import OefSearchDialogues with your author handle (run aea init to set or check the author name). Note Note that the import paths to agent packages, for example packages.fetchai.skills.my_search.dialogues above, are not actual paths. Package files always reside in your AEA's folder, either under a specific package directory (e.g. connection, protocol, skill) if the package is custom built, or under vendor if it is pulled from the registry. These paths are virtual and created automatically when an AEA is run. See this page for more details.","title":"Step 2: Develop a Behaviour"},{"location":"aea/skill-guide/#step-3-develop-a-handler","text":"So far, we have tasked the AEA with sending search requests to the SOEF search node . However, we have no way of handling the responses sent to the AEA by the SOEF search node at the moment. The AEA would simply respond to the SOEF search node via the default error skill which sends all unrecognised envelopes back to the sender. Let us now implement a Handler to deal with the incoming search responses. from typing import Optional , cast from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.my_search.dialogues import ( OefSearchDialogue , OefSearchDialogues , ) class MySearchHandler ( Handler ): \"\"\"This class provides a simple search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id def __init__ ( self , ** kwargs ): \"\"\"Initialize the handler.\"\"\" super () . __init__ ( ** kwargs ) self . received_search_count = 0 def setup ( self ) -> None : \"\"\"Set up the handler.\"\"\" self . context . logger . info ( \"setting up MySearchHandler\" ) def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" oef_search_msg = cast ( OefSearchMessage , message ) # recover dialogue oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_dialogue = cast ( Optional [ OefSearchDialogue ], oef_search_dialogues . update ( oef_search_msg ) ) if oef_search_dialogue is None : self . _handle_unidentified_dialogue ( oef_search_msg ) return # handle message if oef_search_msg . performative is OefSearchMessage . Performative . OEF_ERROR : self . _handle_error ( oef_search_msg , oef_search_dialogue ) elif oef_search_msg . performative is OefSearchMessage . Performative . SEARCH_RESULT : self . _handle_search ( oef_search_msg , oef_search_dialogue ) else : self . _handle_invalid ( oef_search_msg , oef_search_dialogue ) def _handle_unidentified_dialogue ( self , oef_search_msg : OefSearchMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid oef_search message= {} , unidentified dialogue.\" . format ( oef_search_msg ) ) def _handle_error ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"received oef_search error message= {} in dialogue= {} .\" . format ( oef_search_msg , oef_search_dialogue ) ) def _handle_search ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle the search response. :param agents: the agents returned by the search :return: None \"\"\" self . received_search_count += 1 nb_agents_found = len ( oef_search_msg . agents ) self . context . logger . info ( \"found number of agents= {} , received search count= {} \" . format ( nb_agents_found , self . received_search_count ) ) self . context . logger . info ( \"number of search requests sent= {} vs. number of search responses received= {} \" . format ( self . context . behaviours . my_search_behaviour . sent_search_count , self . received_search_count , ) ) def _handle_invalid ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle oef_search message of performative= {} in dialogue= {} .\" . format ( oef_search_msg . performative , oef_search_dialogue , ) ) def teardown ( self ) -> None : \"\"\" Teardown the handler. :return: None \"\"\" self . context . logger . info ( \"tearing down MySearchHandler\" ) We create a handler which is registered for the oef_search protocol. Whenever it receives a search result, we log the number of agents returned in the search - the agents matching the search query - and update the counter of received searches. We also implement a trivial check on the difference between the amount of search requests sent and responses received. Note, how the handler simply reacts to incoming events (i.e. messages). It could initiate further actions, however, they are still reactions to the upstream search event. Also note, how we have access to other objects in the skill via self.context , the SkillContext . We place this code in my_aea/skills/my_search/handlers.py . Ensure you replace the fetchai author in this line from packages.fetchai.skills.my_search.dialogues import ( with your author handle (run aea init to set or check the author name).","title":"Step 3: Develop a Handler"},{"location":"aea/skill-guide/#step-4-add-dialogues-model","text":"We have implemented a behaviour and a handler. We now implement a Model , in particular we implement the Dialogue and Dialogues classes. These ensure that the message flow satisfies the fetchai/oef_search:1.0.0 protocol and keep track of the individual messages being sent and received. from aea.protocols.base import Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.skills.base import Address , Model from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogue as BaseOefSearchDialogue , ) from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogues as BaseOefSearchDialogues , ) OefSearchDialogue = BaseOefSearchDialogue class OefSearchDialogues ( Model , BaseOefSearchDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs ) -> None : \"\"\" Initialize dialogues. :param agent_address: the address of the agent for whom dialogues are maintained :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseOefSearchDialogue . Role . AGENT BaseOefSearchDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , ) We add this code in the file my_aea/skills/my_search/my_model.py , replacing its original content. We then rename my_aea/skills/my_search/my_model.py to my_aea/skills/my_search/dialogues.py .","title":"Step 4: Add dialogues model"},{"location":"aea/skill-guide/#step-5-create-the-configuration-file","text":"Based on our skill components above, we create the following configuration file. name : my_search author : fetchai version : 0.1.0 type : skill description : A simple search skill utilising the SOEF search node. license : Apache-2.0 aea_version : '>=1.0.0, <2.0.0' fingerprint : {} fingerprint_ignore_patterns : [] connections : [] contracts : [] protocols : - fetchai/oef_search:1.0.0 skills : [] behaviours : my_search_behaviour : args : location : latitude : 51.5194 longitude : 0.127 search_query : constraint_type : == search_key : seller_service search_value : generic_service search_radius : 5.0 tick_interval : 5 class_name : MySearchBehaviour handlers : my_search_handler : args : {} class_name : MySearchHandler models : oef_search_dialogues : args : {} class_name : OefSearchDialogues dependencies : aea-ledger-fetchai : version : <2.0.0,>=1.0.0 is_abstract : false Ensure, you replace the author field with your author name! (Run aea init to set or check the author name.) Importantly, the keys my_search_behaviour and my_search_handler are used in the above handler to access these skill components at runtime via the context. We also set the tick_interval of the TickerBehaviour to 5 seconds. We place this code in my_aea/skills/my_search/skill.yaml . Similarly, we replace my_aea/skills/my_search/__init__.py as follows: # -*- coding: utf-8 -*- # ------------------------------------------------------------------------------ # # Copyright 2018-2019 Fetch.AI Limited # # Licensed under the Apache License, Version 2.0 (the \"License\"); # you may not use this file except in compliance with the License. # You may obtain a copy of the License at # # http://www.apache.org/licenses/LICENSE-2.0 # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ \"\"\"This module contains the implementation of the error skill.\"\"\" from aea.configurations.base import PublicId PUBLIC_ID = PublicId . from_str ( \"fetchai/my_search:0.1.0\" ) Again, ensure the author field matches your own.","title":"Step 5: Create the configuration file"},{"location":"aea/skill-guide/#step-6-update-fingerprint","text":"To run an AEA with new or modified code, you need to update the fingerprint of the new/modified components. In this case, we need to fingerprint our skill: aea fingerprint skill fetchai/my_search:0.1.0 Ensure, you use the correct author name to reference your skill (here we use fetchai as the author.)","title":"Step 6: Update fingerprint"},{"location":"aea/skill-guide/#step-7-add-the-oef-protocol-and-connection","text":"Our AEA does not have the OEF protocol yet so let's add it. aea add protocol fetchai/oef_search:1.0.0 This adds the protocol to our AEA and makes it available on the path packages.fetchai.protocols... . At this point we need to add the SOEF and P2P connections to allow the AEA to communicate with the SOEF node and other AEAs, install the AEA's dependencies, and configure the AEA: aea add connection fetchai/soef:0.26.0 aea add connection fetchai/p2p_libp2p:0.25.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' The last command will ensure that search requests are processed by the correct connection.","title":"Step 7: Add the OEF protocol and connection"},{"location":"aea/skill-guide/#step-8-run-a-service-provider-aea","text":"In order for this AEA to find another AEA when searching, the second AEA (let's call it the service provider AEA) must exist and have been registered with the SOEF. From a different terminal window, we fetch a finished service provider AEA and install its Python dependencies: aea fetch fetchai/simple_service_registration:0.31.0 && cd simple_service_registration && aea install && aea build This AEA will simply register a location service on the SOEF search node so we can search for it. We first create the private key for the service provider AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Then we run the AEA: aea run Once you see a message of the form To join its network use multiaddr: ['SOME_ADDRESS'] take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the simple_service_registration (service provider) AEA. Click here to see full code and guide for this AEA We use a TickerBehaviour to update the service registration at regular intervals. The following code is placed in behaviours.py . from typing import Any , Optional , cast from aea.helpers.search.models import Description from aea.skills.behaviours import TickerBehaviour from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.simple_service_registration.dialogues import ( OefSearchDialogues , ) from packages.fetchai.skills.simple_service_registration.strategy import Strategy DEFAULT_MAX_SOEF_REGISTRATION_RETRIES = 5 DEFAULT_SERVICES_INTERVAL = 30.0 class ServiceRegistrationBehaviour ( TickerBehaviour ): \"\"\"This class implements a behaviour.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\"Initialise the behaviour.\"\"\" services_interval = kwargs . pop ( \"services_interval\" , DEFAULT_SERVICES_INTERVAL ) # type: int self . _max_soef_registration_retries = kwargs . pop ( \"max_soef_registration_retries\" , DEFAULT_MAX_SOEF_REGISTRATION_RETRIES ) # type: int super () . __init__ ( tick_interval = services_interval , ** kwargs ) self . failed_registration_msg = None # type: Optional[OefSearchMessage] self . _nb_retries = 0 def setup ( self ) -> None : \"\"\" Implement the setup. :return: None \"\"\" self . _register_agent () def act ( self ) -> None : \"\"\" Implement the act. :return: None \"\"\" self . _retry_failed_registration () def teardown ( self ) -> None : \"\"\" Implement the task teardown. :return: None \"\"\" self . _unregister_service () self . _unregister_agent () def _retry_failed_registration ( self ) -> None : \"\"\" Retry a failed registration. :return: None \"\"\" if self . failed_registration_msg is not None : self . _nb_retries += 1 if self . _nb_retries > self . _max_soef_registration_retries : self . context . is_active = False return oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . failed_registration_msg . to , performative = self . failed_registration_msg . performative , service_description = self . failed_registration_msg . service_description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( f \"Retrying registration on SOEF. Retry { self . _nb_retries } out of { self . _max_soef_registration_retries } .\" ) self . failed_registration_msg = None def _register ( self , description : Description , logger_msg : str ) -> None : \"\"\" Register something on the SOEF. :param description: the description of what is being registered :param logger_msg: the logger message to print after the registration :return: None \"\"\" oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . REGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( logger_msg ) def _register_agent ( self ) -> None : \"\"\" Register the agent's location. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_location_description () self . _register ( description , \"registering agent on SOEF.\" ) def register_service ( self ) -> None : \"\"\" Register the agent's service. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_register_service_description () self . _register ( description , \"registering agent's service on the SOEF.\" ) def register_genus ( self ) -> None : \"\"\" Register the agent's personality genus. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_register_personality_description () self . _register ( description , \"registering agent's personality genus on the SOEF.\" ) def register_classification ( self ) -> None : \"\"\" Register the agent's personality classification. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_register_classification_description () self . _register ( description , \"registering agent's personality classification on the SOEF.\" ) def _unregister_service ( self ) -> None : \"\"\" Unregister service from the SOEF. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_unregister_service_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"unregistering service from SOEF.\" ) def _unregister_agent ( self ) -> None : \"\"\" Unregister agent from the SOEF. :return: None \"\"\" strategy = cast ( Strategy , self . context . strategy ) description = strategy . get_location_description () oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_msg , _ = oef_search_dialogues . create ( counterparty = self . context . search_service_address , performative = OefSearchMessage . Performative . UNREGISTER_SERVICE , service_description = description , ) self . context . outbox . put_message ( message = oef_search_msg ) self . context . logger . info ( \"unregistering agent from SOEF.\" ) We create a Model type strategy class and place it in strategy.py . We use a generic data model to register the service. As part of the registration we register a location and a key pair describing our service. from typing import Any from aea.exceptions import enforce from aea.helpers.search.generic import ( AGENT_LOCATION_MODEL , AGENT_PERSONALITY_MODEL , AGENT_REMOVE_SERVICE_MODEL , AGENT_SET_SERVICE_MODEL , ) from aea.helpers.search.models import Description , Location from aea.skills.base import Model DEFAULT_LOCATION = { \"longitude\" : 0.1270 , \"latitude\" : 51.5194 } DEFAULT_SERVICE_DATA = { \"key\" : \"seller_service\" , \"value\" : \"generic_service\" } DEFAULT_PERSONALITY_DATA = { \"piece\" : \"genus\" , \"value\" : \"data\" } DEFAULT_CLASSIFICATION = { \"piece\" : \"classification\" , \"value\" : \"seller\" } class Strategy ( Model ): \"\"\"This class defines a strategy for the agent.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize the strategy of the agent. :return: None \"\"\" location = kwargs . pop ( \"location\" , DEFAULT_LOCATION ) self . _agent_location = { \"location\" : Location ( latitude = location [ \"latitude\" ], longitude = location [ \"longitude\" ] ) } self . _set_personality_data = kwargs . pop ( \"personality_data\" , DEFAULT_PERSONALITY_DATA ) enforce ( len ( self . _set_personality_data ) == 2 and \"piece\" in self . _set_personality_data and \"value\" in self . _set_personality_data , \"personality_data must contain keys `key` and `value`\" , ) self . _set_classification = kwargs . pop ( \"classification\" , DEFAULT_CLASSIFICATION ) enforce ( len ( self . _set_classification ) == 2 and \"piece\" in self . _set_classification and \"value\" in self . _set_classification , \"classification must contain keys `key` and `value`\" , ) self . _set_service_data = kwargs . pop ( \"service_data\" , DEFAULT_SERVICE_DATA ) enforce ( len ( self . _set_service_data ) == 2 and \"key\" in self . _set_service_data and \"value\" in self . _set_service_data , \"service_data must contain keys `key` and `value`\" , ) self . _remove_service_data = { \"key\" : self . _set_service_data [ \"key\" ]} super () . __init__ ( ** kwargs ) def get_location_description ( self ) -> Description : \"\"\" Get the location description. :return: a description of the agent's location \"\"\" description = Description ( self . _agent_location , data_model = AGENT_LOCATION_MODEL , ) return description def get_register_service_description ( self ) -> Description : \"\"\" Get the register service description. :return: a description of the offered services \"\"\" description = Description ( self . _set_service_data , data_model = AGENT_SET_SERVICE_MODEL , ) return description def get_register_personality_description ( self ) -> Description : \"\"\" Get the register personality description. :return: a description of the personality \"\"\" description = Description ( self . _set_personality_data , data_model = AGENT_PERSONALITY_MODEL , ) return description def get_register_classification_description ( self ) -> Description : \"\"\" Get the register classification description. :return: a description of the classification \"\"\" description = Description ( self . _set_classification , data_model = AGENT_PERSONALITY_MODEL , ) return description def get_unregister_service_description ( self ) -> Description : \"\"\" Get the unregister service description. :return: a description of the to be removed service \"\"\" description = Description ( self . _remove_service_data , data_model = AGENT_REMOVE_SERVICE_MODEL , ) return description We create a Model type dialogue class and place it in dialogues.py . These classes ensure that the message flow satisfies the fetchai/oef_search:1.0.0 protocol and keep track of the individual messages being sent and received. from typing import Any from aea.protocols.base import Address , Message from aea.protocols.dialogue.base import Dialogue as BaseDialogue from aea.skills.base import Model from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogue as BaseOefSearchDialogue , ) from packages.fetchai.protocols.oef_search.dialogues import ( OefSearchDialogues as BaseOefSearchDialogues , ) OefSearchDialogue = BaseOefSearchDialogue class OefSearchDialogues ( Model , BaseOefSearchDialogues ): \"\"\"This class keeps track of all oef_search dialogues.\"\"\" def __init__ ( self , ** kwargs : Any ) -> None : \"\"\" Initialize dialogues. :param agent_address: the address of the agent for whom dialogues are maintained :return: None \"\"\" Model . __init__ ( self , ** kwargs ) def role_from_first_message ( # pylint: disable=unused-argument message : Message , receiver_address : Address ) -> BaseDialogue . Role : \"\"\"Infer the role of the agent from an incoming/outgoing first message :param message: an incoming/outgoing first message :param receiver_address: the address of the receiving agent :return: The role of the agent \"\"\" return BaseOefSearchDialogue . Role . AGENT BaseOefSearchDialogues . __init__ ( self , self_address = str ( self . skill_id ), role_from_first_message = role_from_first_message , ) Finally, we have a handler, placed in handlers.py . The handler deals with handling any error messages which might occur during service registration: from typing import Optional , cast from aea.configurations.base import PublicId from aea.protocols.base import Message from aea.skills.base import Handler from packages.fetchai.protocols.oef_search.message import OefSearchMessage from packages.fetchai.skills.simple_service_registration.behaviours import ( ServiceRegistrationBehaviour , ) from packages.fetchai.skills.simple_service_registration.dialogues import ( OefSearchDialogue , OefSearchDialogues , ) class OefSearchHandler ( Handler ): \"\"\"This class implements an OEF search handler.\"\"\" SUPPORTED_PROTOCOL = OefSearchMessage . protocol_id # type: Optional[PublicId] def setup ( self ) -> None : \"\"\"Call to setup the handler.\"\"\" def handle ( self , message : Message ) -> None : \"\"\" Implement the reaction to a message. :param message: the message :return: None \"\"\" oef_search_msg = cast ( OefSearchMessage , message ) # recover dialogue oef_search_dialogues = cast ( OefSearchDialogues , self . context . oef_search_dialogues ) oef_search_dialogue = cast ( Optional [ OefSearchDialogue ], oef_search_dialogues . update ( oef_search_msg ) ) if oef_search_dialogue is None : self . _handle_unidentified_dialogue ( oef_search_msg ) return # handle message if oef_search_msg . performative == OefSearchMessage . Performative . SUCCESS : self . _handle_success ( oef_search_msg , oef_search_dialogue ) elif oef_search_msg . performative == OefSearchMessage . Performative . OEF_ERROR : self . _handle_error ( oef_search_msg , oef_search_dialogue ) else : self . _handle_invalid ( oef_search_msg , oef_search_dialogue ) def teardown ( self ) -> None : \"\"\" Implement the handler teardown. :return: None \"\"\" def _handle_unidentified_dialogue ( self , oef_search_msg : OefSearchMessage ) -> None : \"\"\" Handle an unidentified dialogue. :param msg: the message \"\"\" self . context . logger . info ( \"received invalid oef_search message= {} , unidentified dialogue.\" . format ( oef_search_msg ) ) def _handle_success ( self , oef_search_success_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue , ) -> None : \"\"\" Handle an oef search message. :param oef_search_success_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"received oef_search success message= {} in dialogue= {} .\" . format ( oef_search_success_msg , oef_search_dialogue ) ) target_message = cast ( OefSearchMessage , oef_search_dialogue . get_message_by_id ( oef_search_success_msg . target ), ) if ( target_message . performative == OefSearchMessage . Performative . REGISTER_SERVICE ): description = target_message . service_description data_model_name = description . data_model . name registration_behaviour = cast ( ServiceRegistrationBehaviour , self . context . behaviours . service , ) if \"location_agent\" in data_model_name : registration_behaviour . register_service () elif \"set_service_key\" in data_model_name : registration_behaviour . register_genus () elif ( \"personality_agent\" in data_model_name and description . values [ \"piece\" ] == \"genus\" ): registration_behaviour . register_classification () elif ( \"personality_agent\" in data_model_name and description . values [ \"piece\" ] == \"classification\" ): self . context . logger . info ( \"the agent, with its genus and classification, and its service are successfully registered on the SOEF.\" ) else : self . context . logger . warning ( f \"received soef SUCCESS message as a reply to the following unexpected message: { target_message } \" ) def _handle_error ( self , oef_search_error_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue , ) -> None : \"\"\" Handle an oef search message. :param oef_search_error_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . info ( \"received oef_search error message= {} in dialogue= {} .\" . format ( oef_search_error_msg , oef_search_dialogue ) ) target_message = cast ( OefSearchMessage , oef_search_dialogue . get_message_by_id ( oef_search_error_msg . target ), ) if ( target_message . performative == OefSearchMessage . Performative . REGISTER_SERVICE ): registration_behaviour = cast ( ServiceRegistrationBehaviour , self . context . behaviours . service , ) registration_behaviour . failed_registration_msg = target_message def _handle_invalid ( self , oef_search_msg : OefSearchMessage , oef_search_dialogue : OefSearchDialogue ) -> None : \"\"\" Handle an oef search message. :param oef_search_msg: the oef search message :param oef_search_dialogue: the dialogue :return: None \"\"\" self . context . logger . warning ( \"cannot handle oef_search message of performative= {} in dialogue= {} .\" . format ( oef_search_msg . performative , oef_search_dialogue , ) ) The associated skill.yaml is: name : simple_service_registration author : fetchai version : 0.20.0 type : skill description : The simple service registration skills is a skill to register a service. license : Apache-2.0 aea_version : '>=1.0.0, <2.0.0' fingerprint : README.md : QmUgCcR7sDBQeeCBRKwDT7tPBTi3t4zSibyEqR3xdQUKmh __init__.py : QmZd48HmYDr7FMxNaVeGfWRvVtieEdEV78hd7h7roTceP2 behaviours.py : QmQHf6QL5aBtLJ34D2tdcbjJLbzom9gaA3HWgRn3rWyigM dialogues.py : QmTT9dvFhWt6qvxjwBfMFDTrgEtgWbvgANYafyRg2BXwcR handlers.py : QmZqPt8toGbJgTT6NZBLxjkusrQCZ8GmUEwcmqZ1sd7DpG strategy.py : QmVXfQpk4cjDw576H2ELE12tEiN5brPkwvffvcTeMbsugA fingerprint_ignore_patterns : [] connections : [] contracts : [] protocols : - fetchai/oef_search:1.0.0 skills : [] behaviours : service : args : max_soef_registration_retries : 5 services_interval : 30 class_name : ServiceRegistrationBehaviour handlers : oef_search : args : {} class_name : OefSearchHandler models : oef_search_dialogues : args : {} class_name : OefSearchDialogues strategy : args : classification : piece : classification value : seller location : latitude : 51.5194 longitude : 0.127 personality_data : piece : genus value : data service_data : key : seller_service value : generic_service class_name : Strategy dependencies : {} is_abstract : false","title":"Step 8: Run a service provider AEA"},{"location":"aea/skill-guide/#step-9-run-the-search-aea","text":"First, create the private key for the search AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Then, in the search AEA, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"/dns4/127.0.0.1/tcp/9000/p2p/16Uiu2HAm1uJpFsqSgHStJdtTBPpDme1fo8uFEvvY182D2y89jQuj\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the search AEA to connect to the same local agent communication network as the service registration AEA. We can then launch our AEA. aea run We can see that the AEA sends search requests to the SOEF search node and receives search responses from the SOEF search node . The search response returns one or more agents (the service provider and potentially other agents which match the query). We stop the AEA with CTRL + C .","title":"Step 9: Run the Search AEA"},{"location":"aea/skill-guide/#next-steps","text":"","title":"Next steps"},{"location":"aea/skill-guide/#recommended","text":"We recommend you continue with the next step in the 'Getting Started' series: Core components (Part 2)","title":"Recommended"},{"location":"aea/skill-guide/#relevant-deep-dives","text":"This guide goes through a more elaborate scenario than the one on this page, where after finding each other, the two AEAs negotiate and trade via a ledger.","title":"Relevant deep-dives"},{"location":"aea/skill-testing/","text":"In this guide we describe some of the tools the framework offers for testing skills. The BaseSkillTestCase class The framework offers a BaseSkillTestCase class which you can subclass and write your test cases with. Let us assume you want to test the my_behaviour behaviour of a CustomSkill skill you have developed. You can create a TestMyBehaviour class which inherits BaseSkillTestCase as below: import asyncio from asyncio import Queue from pathlib import Path from types import SimpleNamespace from typing import cast from aea.configurations.constants import DEFAULT_LEDGER from aea.context.base import AgentContext from aea.crypto.ledger_apis import DEFAULT_CURRENCY_DENOMINATIONS from aea.identity.base import Identity from aea.multiplexer import AsyncMultiplexer , OutBox , Multiplexer from aea.skills.tasks import TaskManager from aea.test_tools.test_skill import BaseSkillTestCase class TestMyBehaviour ( BaseSkillTestCase ): \"\"\"Test my_behaviours of the custom skill.\"\"\" path_to_skill = Path ( \"path_to_this_skill\" ) Specifying Skill Path You must then specify the path to your skill directory via path_to_skill to allow the skill to be loaded and tested. This must be the directory in which skill.yaml of your skill resides. Setting up Each Test You can add a setup() class method to set the environment up for each of your tests. This code will be executed before every test method. If you do include this method, you must call the setup() method of the BaseSkillTestCase class via super().setup() . @classmethod def setup ( cls ): \"\"\"Setup the test class.\"\"\" super () . setup () cls . my_behaviour = cast ( MyBehaviour , cls . _skill . skill_context . behaviours . my_behaviour ) In the above, we make the my_behaviour behaviour object accessible for every test. Skill and Skill Context The skill object itself is exposed via a property. So you can access the skill object by self.skill and by extension all of its attributes. This crucially includes the complete skill_context . This means that for example, all of the components of the skill (e.g. behaviours, handlers, models) can be accessed via the skill context. In the above code snippet, my_behavior is accessed and exposed as a class attribute. Note accessing the skill context is slightly different in the above because it is a class method. If this was a test method, you could access the behaviour via self.skill.skill_context.behaviours.my_behaviour . Dummy Agent Context The loaded skill is also fed a dummy agent_context complete with an identity , outbox , decision_maker_queue and so on, to allow the skill to be properly loaded and have access to everything it requires to function. The agent_context object fed to the skill is shown below: _multiplexer = AsyncMultiplexer () _multiplexer . _out_queue = ( asyncio . Queue ()) agent_context = AgentContext ( identity = Identity ( \"test_agent_name\" , \"test_agent_address\" , \"test_agent_public_key\" ), connection_status = _multiplexer . connection_status , outbox = OutBox ( cast ( Multiplexer , cls . _multiplexer )), decision_maker_message_queue = Queue (), decision_maker_handler_context = SimpleNamespace (), task_manager = TaskManager (), default_ledger_id = DEFAULT_LEDGER , currency_denominations = {}, default_connection = None , default_routing = {}, search_service_address = \"dummy_search_service_address\" , decision_maker_address = \"dummy_decision_maker_address\" , data_dir = \".\" ) Some Useful Skill Attributes Some of the useful objects you can access in your test class for the loaded skill are below: self.skill.skill_context.agent_address : this is the agent identity the skill uses and is set to \"test_agent_address\" . self.skill.skill_context.search_service_address : this is the address of the search service and is set to \"dummy_search_service_address\" . self.skill.skill_context.skill_id : this is the id of the skill. self.skill.skill_context.decision_maker_address : this is the address of the decision maker and is set to \"dummy_decision_maker_address\" . Some Useful BaseSkillTestCase Methods There are a number of methods that BaseSkillTestCase offers to make testing skills easier. Some of these are mentioned below. For the rest, consult the API for BaseSkillTestCase : self.get_quantity_in_outbox() : gives you the number of messages which are in the outbox. After running a part of the skill which is expected to send messages, you can use this method to assert the correct number of messages are indeed sent. self.get_message_from_outbox() : gives you the last message in the outbox. Together with the above, you can use this method to grab the last message sent by the skill code you tested and check this is indeed the expected message. self.message_has_attributes(actual_message: Message, message_type: Type[Message], **kwargs,) : you can use this method in tandem with the above method to check that a message has the attributes you expect it to have. You have to supply it with the actual message (e.g. using self.get_message_from_outbox() ), specify its expected type (e.g. FipaMessage ), and any other attribute you expect the message to have (e.g. message_id is 1) may be provided via keyword arguments. self.build_incoming_message : this is an especially useful method to test handlers. Since handlers handle incoming messages, you can create an incoming message using this method to feed it to the handler and test its execution. Checking Logger Output You can check the output of your skill's logger by mocking it using unittest.mock before executing a part of your skill as such: import logging from unittest import mock with mock . patch . object ( self . my_behaviour . context . logger , \"log\" ) as mock_logger : self . my_behaviour . act () mock_logger . assert_any_call ( logging . INFO , \"some_logger_message\" ) In the above, we mock the logger before running my_behaviour 's act() method and check that the string \"some_logger_message\" is indeed passed to the logger. Next steps You can consult the fetchai/generic_buyer and fetchai/generic_seller skills and their associated tests here to study how BaseSkillTestCase can help you in testing your skills. You can also refer to the API to study the different methods BaseSkillTestCase makes available to make testing your skills easier.","title":"Testing Skills"},{"location":"aea/skill-testing/#the-baseskilltestcase-class","text":"The framework offers a BaseSkillTestCase class which you can subclass and write your test cases with. Let us assume you want to test the my_behaviour behaviour of a CustomSkill skill you have developed. You can create a TestMyBehaviour class which inherits BaseSkillTestCase as below: import asyncio from asyncio import Queue from pathlib import Path from types import SimpleNamespace from typing import cast from aea.configurations.constants import DEFAULT_LEDGER from aea.context.base import AgentContext from aea.crypto.ledger_apis import DEFAULT_CURRENCY_DENOMINATIONS from aea.identity.base import Identity from aea.multiplexer import AsyncMultiplexer , OutBox , Multiplexer from aea.skills.tasks import TaskManager from aea.test_tools.test_skill import BaseSkillTestCase class TestMyBehaviour ( BaseSkillTestCase ): \"\"\"Test my_behaviours of the custom skill.\"\"\" path_to_skill = Path ( \"path_to_this_skill\" )","title":"The BaseSkillTestCase class"},{"location":"aea/skill-testing/#specifying-skill-path","text":"You must then specify the path to your skill directory via path_to_skill to allow the skill to be loaded and tested. This must be the directory in which skill.yaml of your skill resides.","title":"Specifying Skill Path"},{"location":"aea/skill-testing/#setting-up-each-test","text":"You can add a setup() class method to set the environment up for each of your tests. This code will be executed before every test method. If you do include this method, you must call the setup() method of the BaseSkillTestCase class via super().setup() . @classmethod def setup ( cls ): \"\"\"Setup the test class.\"\"\" super () . setup () cls . my_behaviour = cast ( MyBehaviour , cls . _skill . skill_context . behaviours . my_behaviour ) In the above, we make the my_behaviour behaviour object accessible for every test.","title":"Setting up Each Test"},{"location":"aea/skill-testing/#skill-and-skill-context","text":"The skill object itself is exposed via a property. So you can access the skill object by self.skill and by extension all of its attributes. This crucially includes the complete skill_context . This means that for example, all of the components of the skill (e.g. behaviours, handlers, models) can be accessed via the skill context. In the above code snippet, my_behavior is accessed and exposed as a class attribute. Note accessing the skill context is slightly different in the above because it is a class method. If this was a test method, you could access the behaviour via self.skill.skill_context.behaviours.my_behaviour .","title":"Skill and Skill Context"},{"location":"aea/skill-testing/#dummy-agent-context","text":"The loaded skill is also fed a dummy agent_context complete with an identity , outbox , decision_maker_queue and so on, to allow the skill to be properly loaded and have access to everything it requires to function. The agent_context object fed to the skill is shown below: _multiplexer = AsyncMultiplexer () _multiplexer . _out_queue = ( asyncio . Queue ()) agent_context = AgentContext ( identity = Identity ( \"test_agent_name\" , \"test_agent_address\" , \"test_agent_public_key\" ), connection_status = _multiplexer . connection_status , outbox = OutBox ( cast ( Multiplexer , cls . _multiplexer )), decision_maker_message_queue = Queue (), decision_maker_handler_context = SimpleNamespace (), task_manager = TaskManager (), default_ledger_id = DEFAULT_LEDGER , currency_denominations = {}, default_connection = None , default_routing = {}, search_service_address = \"dummy_search_service_address\" , decision_maker_address = \"dummy_decision_maker_address\" , data_dir = \".\" )","title":"Dummy Agent Context"},{"location":"aea/skill-testing/#some-useful-skill-attributes","text":"Some of the useful objects you can access in your test class for the loaded skill are below: self.skill.skill_context.agent_address : this is the agent identity the skill uses and is set to \"test_agent_address\" . self.skill.skill_context.search_service_address : this is the address of the search service and is set to \"dummy_search_service_address\" . self.skill.skill_context.skill_id : this is the id of the skill. self.skill.skill_context.decision_maker_address : this is the address of the decision maker and is set to \"dummy_decision_maker_address\" .","title":"Some Useful Skill Attributes"},{"location":"aea/skill-testing/#some-useful-baseskilltestcase-methods","text":"There are a number of methods that BaseSkillTestCase offers to make testing skills easier. Some of these are mentioned below. For the rest, consult the API for BaseSkillTestCase : self.get_quantity_in_outbox() : gives you the number of messages which are in the outbox. After running a part of the skill which is expected to send messages, you can use this method to assert the correct number of messages are indeed sent. self.get_message_from_outbox() : gives you the last message in the outbox. Together with the above, you can use this method to grab the last message sent by the skill code you tested and check this is indeed the expected message. self.message_has_attributes(actual_message: Message, message_type: Type[Message], **kwargs,) : you can use this method in tandem with the above method to check that a message has the attributes you expect it to have. You have to supply it with the actual message (e.g. using self.get_message_from_outbox() ), specify its expected type (e.g. FipaMessage ), and any other attribute you expect the message to have (e.g. message_id is 1) may be provided via keyword arguments. self.build_incoming_message : this is an especially useful method to test handlers. Since handlers handle incoming messages, you can create an incoming message using this method to feed it to the handler and test its execution.","title":"Some Useful BaseSkillTestCase Methods"},{"location":"aea/skill-testing/#checking-logger-output","text":"You can check the output of your skill's logger by mocking it using unittest.mock before executing a part of your skill as such: import logging from unittest import mock with mock . patch . object ( self . my_behaviour . context . logger , \"log\" ) as mock_logger : self . my_behaviour . act () mock_logger . assert_any_call ( logging . INFO , \"some_logger_message\" ) In the above, we mock the logger before running my_behaviour 's act() method and check that the string \"some_logger_message\" is indeed passed to the logger.","title":"Checking Logger Output"},{"location":"aea/skill-testing/#next-steps","text":"You can consult the fetchai/generic_buyer and fetchai/generic_seller skills and their associated tests here to study how BaseSkillTestCase can help you in testing your skills. You can also refer to the API to study the different methods BaseSkillTestCase makes available to make testing your skills easier.","title":"Next steps"},{"location":"aea/skill/","text":"Skills are the core focus of the framework's extensibility as they implement business logic to deliver economic value for the AEA. They are self-contained capabilities that AEAs can dynamically take on board, in order to expand their effectiveness in different situations. A skill encapsulates implementations of the three abstract base classes Handler , Behaviour , Model , and is closely related with the abstract base class Task : Handler : each skill has zero, one or more Handler objects, each responsible for the registered messaging protocol. Handlers implement AEAs' reactive behaviour. If the AEA understands the protocol referenced in a received Envelope , the Handler reacts appropriately to the corresponding message. Each Handler is responsible for only one protocol. A Handler is also capable of dealing with internal messages (see next section). Behaviour : zero, one or more Behaviours encapsulate actions which further the AEAs goal and are initiated by internals of the AEA, rather than external events. Behaviours implement AEAs' pro-activeness . The framework provides a number of abstract base classes implementing different types of behaviours (e.g. cyclic/one-shot/finite-state-machine/etc.). Model : zero, one or more Models that inherit from the Model class. Models encapsulate custom objects which are made accessible to any part of a skill via the SkillContext . Task : zero, one or more Tasks encapsulate background work internal to the AEA. Task differs from the other three in that it is not a part of skills, but Task s are declared in or from skills if a packaging approach for AEA creation is used. A skill can read (parts of) the state of the the AEA (as summarised in the AgentContext ), and suggest actions to the AEA according to its specific logic. As such, more than one skill could exist per protocol, competing with each other in suggesting to the AEA the best course of actions to take. In technical terms this means skills are horizontally arranged. For instance, an AEA who is trading goods, could subscribe to more than one skill, where each skill corresponds to a different trading strategy. The skills could then read the preference and ownership state of the AEA, and independently suggest profitable transactions. The framework places no limits on the complexity of skills. They can implement simple (e.g. if-this-then-that ) or complex (e.g. a deep learning model or reinforcement learning agent). The framework provides one default skill, called error . Additional skills can be added as packages. Independence of skills Skills are horizontally layered , that is they run independently of each other. They also cannot access each other's state. Two skills can communicate with each other in two ways. The skill context provides access via self.context.shared_state to a key-value store which allows skills to share state. A skill can also define as a callback another skill in a message to the decision maker . Context The skill has a SkillContext object which is shared by all Handler , Behaviour , and Model objects. The skill context also has a link to the AgentContext . The AgentContext provides read access to AEA specific information like the public key and address of the AEA, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the AEA. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. self . context . outbox . put_message ( message = reply ) Moreover, you can read/write to the agent context namespace by accessing the attribute SkillContext.namespace . Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker . What to code Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class. handlers.py There can be none, one or more Handler class per skill. Handler classes can receive Message objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle(self, message: Message) : is where the skill receives a Message of the specified protocol and decides what to do with it. A handler can be registered in one way: By declaring it in the skill configuration file skill.yaml (see below ). It is possible to register new handlers dynamically by enqueuing new Handler instances in the queue context.new_handlers , e.g. in a skill component we can write: self . context . new_handlers . put ( MyHandler ( name = \"my_handler\" , skill_context = self . context )) behaviours.py Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer must create a subclass from the abstract class Behaviour to create a new Behaviour . act(self) : is how the framework calls the Behaviour code. A behaviour can be registered in two ways: By declaring it in the skill configuration file skill.yaml (see below ) In any part of the code of the skill, by enqueuing new Behaviour instances in the queue context.new_behaviours . In that case, setup is not called by the framework, as the behaviour will be added after the AEA setup is complete. The framework supports different types of behaviours: OneShotBehaviour : this behaviour is executed only once. TickerBehaviour : the act() method is called every tick_interval . E.g. if the TickerBehaviour subclass is instantiated There is another category of behaviours, called CompositeBehaviour : SequenceBehaviour : a sequence of Behaviour classes, executed one after the other. FSMBehaviour : a state machine of State behaviours. A state is in charge of scheduling the next state. If your behaviour fits one of the above, we suggest subclassing your behaviour class with that behaviour class. Otherwise, you can always subclass the general-purpose Behaviour class. Follows an example of a custom behaviour: from aea.skills.behaviours import OneShotBehaviour class HelloWorldBehaviour ( OneShotBehaviour ): def setup ( self ): \"\"\"This method is called once, when the behaviour gets loaded.\"\"\" def act ( self ): \"\"\"This methods is called in every iteration of the agent main loop.\"\"\" print ( \"Hello, World!\" ) def teardown ( self ): \"\"\"This method is called once, when the behaviour is teared down.\"\"\" If we want to register this behaviour dynamically, in any part of the skill code (i.e. wherever the skill context is available), we can write: self . context . new_behaviours . put ( HelloWorldBehaviour ( name = \"hello_world\" , skill_context = self . context )) Or, equivalently to the previous two code blocks: def hello (): print ( \"Hello, World!\" ) self . context . new_behaviours . put ( OneShotBehaviour ( act = hello , name = \"hello_world\" , skill_context = self . context )) The callable passed to the act parameter is equivalent to the implementation of the act method described above. The framework is then in charge of registering the behaviour and scheduling it for execution. tasks.py Conceptually, a Task is where the developer codes any internal tasks the AEA requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . The Task class implements the functor pattern . An instance of the Task class can be invoked as if it were an ordinary function. Once completed, it will store the result in the property result . Raises error if the task has not been executed yet, or an error occurred during computation. We suggest using the task_manager , accessible through the skill context, to manage long-running tasks. The task manager uses multiprocessing to schedule tasks, so be aware that the changes on the task object will not be updated. Here's an example: In tasks.py : from aea.skills.tasks import Task def nth_prime_number ( n : int ) -> int : \"\"\"A naive algorithm to find the n_th prime number.\"\"\" assert n > 0 primes = [ 2 ] num = 3 while len ( primes ) < n : for p in primes : if num % p == 0 : break else : primes . append ( num ) num += 2 return primes [ - 1 ] class LongTask ( Task ): def setup ( self ): \"\"\"Set the task up before execution.\"\"\" def execute ( self , n : int ): return nth_prime_number ( n ) def teardown ( self ): \"\"\"Clean the task up after execution.\"\"\" In behaviours.py : from aea.skills.behaviours import TickerBehaviour from packages.my_author_name.skills.my_skill.tasks import LongTask class MyBehaviour ( TickerBehaviour ): def setup ( self ): \"\"\"Setup behaviour.\"\"\" my_task = LongTask () task_id = self . context . task_manager . enqueue_task ( my_task , args = ( 10000 , )) self . async_result = self . context . task_manager . get_task_result ( task_id ) # type: multiprocessing.pool.AsyncResult def act ( self ): \"\"\"Act implementation.\"\"\" if self . async_result . ready () is False : print ( \"The task is not finished yet.\" ) else : completed_task = self . async_result . get () # type: LongTask print ( \"The result is:\" , completed_task . result ) # Stop the skill self . context . is_active = False def teardown ( self ): \"\"\"Teardown behaviour.\"\"\" Models The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end, the developer can subclass an abstract Model . These models are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeModel class SomeModel ( Model ): ... Then, an instance of this class is available on the context level like so: some_model = self . context . some_model Skill configuration Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, i.e. modules of type Model , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : fetchai version : 0.1.0 license : Apache-2.0 behaviours : echo : class_name : EchoBehaviour args : tick_interval : 1.0 handlers : echo : class_name : EchoHandler args : foo : bar models : {} dependencies : {} protocols : - fetchai/default:1.0.0 Error skill All AEAs have a default error skill that contains error handling code for a number of scenarios: Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered) Envelopes with decoding errors Invalid messages with respect to the registered protocol The error skill relies on the fetchai/default:1.0.0 protocol which provides error codes for the above. Custom Error handler The framework implements a default ErrorHandler . You can implement your own and mount it. The easiest way to do this is to run the following command to scaffold a custom ErrorHandler : aea scaffold error-handler Now you will see a file called error_handler.py in the AEA project root. You can then implement your own custom logic to process messages.","title":"Skills"},{"location":"aea/skill/#independence-of-skills","text":"Skills are horizontally layered , that is they run independently of each other. They also cannot access each other's state. Two skills can communicate with each other in two ways. The skill context provides access via self.context.shared_state to a key-value store which allows skills to share state. A skill can also define as a callback another skill in a message to the decision maker .","title":"Independence of skills"},{"location":"aea/skill/#context","text":"The skill has a SkillContext object which is shared by all Handler , Behaviour , and Model objects. The skill context also has a link to the AgentContext . The AgentContext provides read access to AEA specific information like the public key and address of the AEA, its preferences and ownership state. It also provides access to the OutBox . This means it is possible to, at any point, grab the context and have access to the code in other parts of the skill and the AEA. For example, in the ErrorHandler(Handler) class, the code often grabs a reference to its context and by doing so can access initialised and running framework objects such as an OutBox for putting messages into. self . context . outbox . put_message ( message = reply ) Moreover, you can read/write to the agent context namespace by accessing the attribute SkillContext.namespace . Importantly, however, a skill does not have access to the context of another skill or protected AEA components like the DecisionMaker .","title":"Context"},{"location":"aea/skill/#what-to-code","text":"Each of the skill classes has three methods that must be implemented. All of them include a setup() and teardown() method which the developer must implement. Then there is a specific method that the framework requires for each class.","title":"What to code"},{"location":"aea/skill/#handlerspy","text":"There can be none, one or more Handler class per skill. Handler classes can receive Message objects of one protocol type only. However, Handler classes can send Envelope objects of any type of protocol they require. handle(self, message: Message) : is where the skill receives a Message of the specified protocol and decides what to do with it. A handler can be registered in one way: By declaring it in the skill configuration file skill.yaml (see below ). It is possible to register new handlers dynamically by enqueuing new Handler instances in the queue context.new_handlers , e.g. in a skill component we can write: self . context . new_handlers . put ( MyHandler ( name = \"my_handler\" , skill_context = self . context ))","title":"handlers.py"},{"location":"aea/skill/#behaviourspy","text":"Conceptually, a Behaviour class contains the business logic specific to initial actions initiated by the AEA rather than reactions to other events. There can be one or more Behaviour classes per skill. The developer must create a subclass from the abstract class Behaviour to create a new Behaviour . act(self) : is how the framework calls the Behaviour code. A behaviour can be registered in two ways: By declaring it in the skill configuration file skill.yaml (see below ) In any part of the code of the skill, by enqueuing new Behaviour instances in the queue context.new_behaviours . In that case, setup is not called by the framework, as the behaviour will be added after the AEA setup is complete. The framework supports different types of behaviours: OneShotBehaviour : this behaviour is executed only once. TickerBehaviour : the act() method is called every tick_interval . E.g. if the TickerBehaviour subclass is instantiated There is another category of behaviours, called CompositeBehaviour : SequenceBehaviour : a sequence of Behaviour classes, executed one after the other. FSMBehaviour : a state machine of State behaviours. A state is in charge of scheduling the next state. If your behaviour fits one of the above, we suggest subclassing your behaviour class with that behaviour class. Otherwise, you can always subclass the general-purpose Behaviour class. Follows an example of a custom behaviour: from aea.skills.behaviours import OneShotBehaviour class HelloWorldBehaviour ( OneShotBehaviour ): def setup ( self ): \"\"\"This method is called once, when the behaviour gets loaded.\"\"\" def act ( self ): \"\"\"This methods is called in every iteration of the agent main loop.\"\"\" print ( \"Hello, World!\" ) def teardown ( self ): \"\"\"This method is called once, when the behaviour is teared down.\"\"\" If we want to register this behaviour dynamically, in any part of the skill code (i.e. wherever the skill context is available), we can write: self . context . new_behaviours . put ( HelloWorldBehaviour ( name = \"hello_world\" , skill_context = self . context )) Or, equivalently to the previous two code blocks: def hello (): print ( \"Hello, World!\" ) self . context . new_behaviours . put ( OneShotBehaviour ( act = hello , name = \"hello_world\" , skill_context = self . context )) The callable passed to the act parameter is equivalent to the implementation of the act method described above. The framework is then in charge of registering the behaviour and scheduling it for execution.","title":"behaviours.py"},{"location":"aea/skill/#taskspy","text":"Conceptually, a Task is where the developer codes any internal tasks the AEA requires. There can be one or more Task classes per skill. The developer subclasses abstract class Task to create a new Task . execute(self) : is how the framework calls a Task . The Task class implements the functor pattern . An instance of the Task class can be invoked as if it were an ordinary function. Once completed, it will store the result in the property result . Raises error if the task has not been executed yet, or an error occurred during computation. We suggest using the task_manager , accessible through the skill context, to manage long-running tasks. The task manager uses multiprocessing to schedule tasks, so be aware that the changes on the task object will not be updated. Here's an example: In tasks.py : from aea.skills.tasks import Task def nth_prime_number ( n : int ) -> int : \"\"\"A naive algorithm to find the n_th prime number.\"\"\" assert n > 0 primes = [ 2 ] num = 3 while len ( primes ) < n : for p in primes : if num % p == 0 : break else : primes . append ( num ) num += 2 return primes [ - 1 ] class LongTask ( Task ): def setup ( self ): \"\"\"Set the task up before execution.\"\"\" def execute ( self , n : int ): return nth_prime_number ( n ) def teardown ( self ): \"\"\"Clean the task up after execution.\"\"\" In behaviours.py : from aea.skills.behaviours import TickerBehaviour from packages.my_author_name.skills.my_skill.tasks import LongTask class MyBehaviour ( TickerBehaviour ): def setup ( self ): \"\"\"Setup behaviour.\"\"\" my_task = LongTask () task_id = self . context . task_manager . enqueue_task ( my_task , args = ( 10000 , )) self . async_result = self . context . task_manager . get_task_result ( task_id ) # type: multiprocessing.pool.AsyncResult def act ( self ): \"\"\"Act implementation.\"\"\" if self . async_result . ready () is False : print ( \"The task is not finished yet.\" ) else : completed_task = self . async_result . get () # type: LongTask print ( \"The result is:\" , completed_task . result ) # Stop the skill self . context . is_active = False def teardown ( self ): \"\"\"Teardown behaviour.\"\"\"","title":"tasks.py"},{"location":"aea/skill/#models","text":"The developer might want to add other classes on the context level which are shared equally across the Handler , Behaviour and Task classes. To this end, the developer can subclass an abstract Model . These models are made available on the context level upon initialization of the AEA. Say, the developer has a class called SomeModel class SomeModel ( Model ): ... Then, an instance of this class is available on the context level like so: some_model = self . context . some_model","title":"Models"},{"location":"aea/skill/#skill-configuration","text":"Each skill has a skill.yaml configuration file which lists all Behaviour , Handler , and Task objects pertaining to the skill. It also details the protocol types used in the skill and points to shared modules, i.e. modules of type Model , which allow custom classes within the skill to be accessible in the skill context. name : echo authors : fetchai version : 0.1.0 license : Apache-2.0 behaviours : echo : class_name : EchoBehaviour args : tick_interval : 1.0 handlers : echo : class_name : EchoHandler args : foo : bar models : {} dependencies : {} protocols : - fetchai/default:1.0.0","title":"Skill configuration"},{"location":"aea/skill/#error-skill","text":"All AEAs have a default error skill that contains error handling code for a number of scenarios: Received envelopes with unsupported protocols Received envelopes with unsupported skills (i.e. protocols for which no handler is registered) Envelopes with decoding errors Invalid messages with respect to the registered protocol The error skill relies on the fetchai/default:1.0.0 protocol which provides error codes for the above.","title":"Error skill"},{"location":"aea/skill/#custom-error-handler","text":"The framework implements a default ErrorHandler . You can implement your own and mount it. The easiest way to do this is to run the following command to scaffold a custom ErrorHandler : aea scaffold error-handler Now you will see a file called error_handler.py in the AEA project root. You can then implement your own custom logic to process messages.","title":"Custom Error handler"},{"location":"aea/standalone-transaction/","text":"In this guide, we will generate some wealth for the Fetch.ai testnet and create a standalone transaction. After the completion of the transaction, we get the transaction digest. With this we can search for the transaction on the block explorer This guide requires the aea-ledger-fetchai plug-in installed in your Python environment: pip install aea-ledger-fetchai First, import the python and application specific libraries and set the static variables. import logging from aea_ledger_fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key , try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" Create the private keys # Create a private keys create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) Create the wallets Once we created the private keys we need to generate the wallets. # Set up the wallets wallet_1 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) Generate wealth Since we want to send funds from wallet_1 to wallet_2 , we need to generate some wealth for the wallet_1 . We can do this with the following code # Generate some wealth try_generate_testnet_wealth ( FetchAICrypto . identifier , wallet_1 . addresses [ FetchAICrypto . identifier ] ) Send transaction Finally, we create a transaction that sends the funds to the wallet_2 # Create the transaction and send it to the ledger. tx_nonce = LedgerApis . generate_tx_nonce ( FetchAICrypto . identifier , wallet_2 . addresses . get ( FetchAICrypto . identifier ), wallet_1 . addresses . get ( FetchAICrypto . identifier ), ) transaction = LedgerApis . get_transfer_transaction ( identifier = FetchAICrypto . identifier , sender_address = wallet_1 . addresses . get ( FetchAICrypto . identifier ), destination_address = wallet_2 . addresses . get ( FetchAICrypto . identifier ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) signed_transaction = wallet_1 . sign_transaction ( FetchAICrypto . identifier , transaction ) transaction_digest = LedgerApis . send_signed_transaction ( FetchAICrypto . identifier , signed_transaction ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( transaction_digest )) Stand-alone transaction full code import logging from aea_ledger_fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key , try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" def run (): \"\"\"Run demo.\"\"\" # Create a private keys create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) # Set up the wallets wallet_1 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) # Generate some wealth try_generate_testnet_wealth ( FetchAICrypto . identifier , wallet_1 . addresses [ FetchAICrypto . identifier ] ) logger . info ( \"Sending amount to {} \" . format ( wallet_2 . addresses . get ( FetchAICrypto . identifier )) ) # Create the transaction and send it to the ledger. tx_nonce = LedgerApis . generate_tx_nonce ( FetchAICrypto . identifier , wallet_2 . addresses . get ( FetchAICrypto . identifier ), wallet_1 . addresses . get ( FetchAICrypto . identifier ), ) transaction = LedgerApis . get_transfer_transaction ( identifier = FetchAICrypto . identifier , sender_address = wallet_1 . addresses . get ( FetchAICrypto . identifier ), destination_address = wallet_2 . addresses . get ( FetchAICrypto . identifier ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) signed_transaction = wallet_1 . sign_transaction ( FetchAICrypto . identifier , transaction ) transaction_digest = LedgerApis . send_signed_transaction ( FetchAICrypto . identifier , signed_transaction ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( transaction_digest )) if __name__ == \"__main__\" : run ()","title":"Create stand-alone transaction"},{"location":"aea/standalone-transaction/#create-the-private-keys","text":"# Create a private keys create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 )","title":"Create the private keys"},{"location":"aea/standalone-transaction/#create-the-wallets","text":"Once we created the private keys we need to generate the wallets. # Set up the wallets wallet_1 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 })","title":"Create the wallets"},{"location":"aea/standalone-transaction/#generate-wealth","text":"Since we want to send funds from wallet_1 to wallet_2 , we need to generate some wealth for the wallet_1 . We can do this with the following code # Generate some wealth try_generate_testnet_wealth ( FetchAICrypto . identifier , wallet_1 . addresses [ FetchAICrypto . identifier ] )","title":"Generate wealth"},{"location":"aea/standalone-transaction/#send-transaction","text":"Finally, we create a transaction that sends the funds to the wallet_2 # Create the transaction and send it to the ledger. tx_nonce = LedgerApis . generate_tx_nonce ( FetchAICrypto . identifier , wallet_2 . addresses . get ( FetchAICrypto . identifier ), wallet_1 . addresses . get ( FetchAICrypto . identifier ), ) transaction = LedgerApis . get_transfer_transaction ( identifier = FetchAICrypto . identifier , sender_address = wallet_1 . addresses . get ( FetchAICrypto . identifier ), destination_address = wallet_2 . addresses . get ( FetchAICrypto . identifier ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) signed_transaction = wallet_1 . sign_transaction ( FetchAICrypto . identifier , transaction ) transaction_digest = LedgerApis . send_signed_transaction ( FetchAICrypto . identifier , signed_transaction ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( transaction_digest )) Stand-alone transaction full code import logging from aea_ledger_fetchai import FetchAICrypto from aea.crypto.helpers import create_private_key , try_generate_testnet_wealth from aea.crypto.ledger_apis import LedgerApis from aea.crypto.wallet import Wallet logger = logging . getLogger ( \"aea\" ) logging . basicConfig ( level = logging . INFO ) FETCHAI_PRIVATE_KEY_FILE_1 = \"fetchai_private_key_1.txt\" FETCHAI_PRIVATE_KEY_FILE_2 = \"fetchai_private_key_2.txt\" def run (): \"\"\"Run demo.\"\"\" # Create a private keys create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_1 ) create_private_key ( FetchAICrypto . identifier , private_key_file = FETCHAI_PRIVATE_KEY_FILE_2 ) # Set up the wallets wallet_1 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_1 }) wallet_2 = Wallet ({ FetchAICrypto . identifier : FETCHAI_PRIVATE_KEY_FILE_2 }) # Generate some wealth try_generate_testnet_wealth ( FetchAICrypto . identifier , wallet_1 . addresses [ FetchAICrypto . identifier ] ) logger . info ( \"Sending amount to {} \" . format ( wallet_2 . addresses . get ( FetchAICrypto . identifier )) ) # Create the transaction and send it to the ledger. tx_nonce = LedgerApis . generate_tx_nonce ( FetchAICrypto . identifier , wallet_2 . addresses . get ( FetchAICrypto . identifier ), wallet_1 . addresses . get ( FetchAICrypto . identifier ), ) transaction = LedgerApis . get_transfer_transaction ( identifier = FetchAICrypto . identifier , sender_address = wallet_1 . addresses . get ( FetchAICrypto . identifier ), destination_address = wallet_2 . addresses . get ( FetchAICrypto . identifier ), amount = 1 , tx_fee = 1 , tx_nonce = tx_nonce , ) signed_transaction = wallet_1 . sign_transaction ( FetchAICrypto . identifier , transaction ) transaction_digest = LedgerApis . send_signed_transaction ( FetchAICrypto . identifier , signed_transaction ) logger . info ( \"Transaction complete.\" ) logger . info ( \"The transaction digest is {} \" . format ( transaction_digest )) if __name__ == \"__main__\" : run ()","title":"Send transaction"},{"location":"aea/step-one/","text":"There are a number of ways to build an AEA: To start with, we recommended you build an AEA project step-by-step with the CLI tool as demonstrated in the quick start guide and described here . Using the CLI aea fetch command, pull in an already built project and run as is or extend it to your needs. The last option is to build an AEA programmatically as described here . Sometimes, an AEA is more than is required for the task at hand. In particular, an AEA is much more than just an agent. In those cases, we suggest you have a look at the following two guides: the AEA vs Agents guide shows the difference between an agent and an AEA in code, the Use multiplexer standalone guide shows how to use the multiplexer on its own to receive and send envelopes.","title":"Ways to build an AEA"},{"location":"aea/tac-skills-contract/","text":"The AEA TAC - trading agent competition - skills demonstrate an interaction between multiple AEAs in a game. There are two types of AEAs: The tac_controller which coordinates the game. The tac_participant AEAs which compete in the game. The tac_participant AEAs trade tokens with each other to maximize their utility. Discussion This demo shows how agents negotiate autonomously with each other while they pursue their goals by participating in the Trading Agents Competition (TAC). The demo can be run against Fetchai or Ethereum ledger. Transactions are validated on an ERC1155 smart contract on the Fetchai StargateWorld or a local Ganache Ethereum testnet. In the following video we discuss the framework and TAC in more detail: Communication There are two types of interactions: - between the controller and participants (game management communication) - between the participants (negotiations) Registration communication This diagram shows the communication between the various entities during the registration phase. sequenceDiagram participant Agent_2 participant Agent_1 participant Search participant Controller activate Search activate Controller Controller->>Search: register_service activate Agent_1 Agent_1->>Search: search Search-->>Agent_1: controller Agent_1->>Controller: register activate Agent_2 Agent_2->>Search: search Search-->>Agent_2: controller Agent_2->>Controller: register Controller->>Agent_1: game_data Controller->>Agent_2: game_data deactivate Agent_1 deactivate Agent_2 deactivate Search deactivate Controller Transaction communication This diagram shows the communication between two AEAs and a controller. In this case, we have a Seller_Agent which is set up as a seller (and registers itself as such with the controller during the registration phase). We also have the Searching_Agent which is set up to search for sellers. sequenceDiagram participant Buyer_Agent participant Seller_Agent participant Search participant Controller activate Buyer_Agent activate Seller_Agent activate Search activate Controller Seller_Agent->>Search: register_service Buyer_Agent->>Search: search Search-->>Buyer_Agent: list_of_agents Buyer_Agent->>Seller_Agent: call_for_proposal Seller_Agent->>Buyer_Agent: proposal Buyer_Agent->>Seller_Agent: accept Seller_Agent->>Buyer_Agent: match_accept Seller_Agent->>Controller: transaction Controller->>Controller: transaction_execution Controller->>Seller_Agent: confirm_transaction Controller->>Buyer_Agent: confirm_transaction deactivate Buyer_Agent deactivate Seller_Agent deactivate Search deactivate Controller In the above case, the proposal received contains a set of goods to sell and an associated price. The buyer AEA needs to determine if this is a good deal for them, and if so, it accepts. There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead be a list of goods that the buyer wishes to buy and the price it is willing to pay for them. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions (Fetchai): Follow this instruction to run TAC against the fetch.ai StargateWorld test-net. Fetch TAC controller AEA In the root directory, fetch the controller AEA: aea fetch fetchai/tac_controller_contract:0.31.0 cd tac_controller_contract aea install aea build Alternatively, create from scratch. The following steps create the controller from scratch: aea create tac_controller_contract cd tac_controller_contract aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_control_contract:0.26.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger fetchai aea config set vendor.fetchai.connections.soef.config.chain_identifier fetchai_v2_misc aea config set --type bool vendor.fetchai.skills.tac_control.is_abstract true aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"fetchai\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' aea install aea build Fetch the TAC participant AEAs In separate terminals, in the root directory, fetch at least two participants: aea fetch fetchai/tac_participant_contract:0.21.0 --alias tac_participant_one cd tac_participant_one aea install aea build cd .. aea fetch fetchai/tac_participant_contract:0.21.0 --alias tac_participant_two cd tac_participant_two aea install aea build Alternatively, create from scratch. In a separate terminal, in the root directory, create at least two tac participant AEAs: aea create tac_participant_one aea create tac_participant_two Build participant one: cd tac_participant_one aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_participation:0.24.0 aea add skill fetchai/tac_negotiation:0.28.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger fetchai aea config set vendor.fetchai.connections.soef.config.chain_identifier fetchai_v2_misc aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool aea config set vendor.fetchai.skills.tac_negotiation.models.strategy.args.is_contract_tx 'True' --type bool aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type dict agent.decision_maker_handler \\ '{ \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\", \"file_path\": null }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '''[{\"identifier\": \"acn\", \"ledger_id\": \"fetchai\", \"message_format\": \"' { public_key } '\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]''' aea install aea build Then, build participant two: cd tac_participant_two aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_participation:0.24.0 aea add skill fetchai/tac_negotiation:0.28.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger fetchai aea config set vendor.fetchai.connections.soef.config.chain_identifier fetchai_v2_misc aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool aea config set vendor.fetchai.skills.tac_negotiation.models.strategy.args.is_contract_tx 'True' --type bool aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type dict agent.decision_maker_handler \\ '{ \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\", \"file_path\": null }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '''[{\"identifier\": \"acn\", \"ledger_id\": \"fetchai\", \"message_format\": \"' { public_key } '\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]''' aea install aea build Add keys for all AEAs For every AEA in the competition (controller and participants): First generate and add a private key: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then create and add a separate private key for secure communication: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Update the game parameters in the controller In the tac controller project, get and set the registration start time (set it to at least 5 minutes in the future): aea config get vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time aea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time '01 01 2020 00:01' To set the registration time, you may find handy the following command: aea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time \" $( date -d \"5 minutes\" + '%d %m %Y %H:%M' ) \" Update the connection parameters Update the connection parameters of the TAC participants to allow them to connect to the same local agent communication network as the TAC controller. First, retrieve controller's local ACN address by running the following in the controller agent's project terminal: aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri Then, in participant one, run this command (replace SOME_ADDRESS with the value you retrieved above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Do the same in participant two (beware of the different port numbers): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11002\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9002\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9002\" }' Fund agents' accounts Retrieve the address of each agent (in each terminal): aea get-address fetchai Go to the StargateWorld block explorer and request some test tokens via Get Funds . To check the wealth of an AEA, use: aea get-wealth fetchai Run the AEAs First, launch the tac_contract_controller then the participants by executing the following from their respective terminals: aea run The CLI tool supports launching several agents at once. For example, assuming you followed the tutorial, you can launch both TAC participant agents as follows from the root directory (ensure you run the controller agent first as above): aea launch tac_participant_one tac_participant_two You may want to try --multithreaded option in order to run the agents in the same process. Cleaning up When you're finished, delete your AEAs: aea delete tac_controller_contract aea delete tac_participant_one aea delete tac_participant_two Demo instructions (Ethereum): Follow this instruction to run TAC against a local Ganache Ethereum test-net. Create TAC controller AEA In the root directory, fetch the controller AEA: aea fetch fetchai/tac_controller_contract:0.31.0 cd tac_controller_contract aea install aea build Alternatively, create from scratch. The following steps create the controller from scratch: aea create tac_controller_contract cd tac_controller_contract aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_control_contract:0.26.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger ethereum aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum aea config set --type bool vendor.fetchai.skills.tac_control.is_abstract true aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' aea install aea build Fetch the TAC participant AEAs In separate terminals, in the root directory, fetch at least two participants: aea fetch fetchai/tac_participant_contract:0.21.0 --alias tac_participant_one cd tac_participant_one aea install aea build cd .. aea fetch fetchai/tac_participant_contract:0.21.0 --alias tac_participant_two cd tac_participant_two aea install aea build Alternatively, create from scratch. In a separate terminal, in the root directory, create at least two tac participant AEAs: aea create tac_participant_one aea create tac_participant_two Build participant one: cd tac_participant_one aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_participation:0.24.0 aea add skill fetchai/tac_negotiation:0.28.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger ethereum aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool aea config set vendor.fetchai.skills.tac_negotiation.models.strategy.args.is_contract_tx 'True' --type bool aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type dict agent.decision_maker_handler \\ '{ \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\", \"file_path\": null }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '''[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"message_format\": \"' { public_key } '\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]''' aea install aea build Then, build participant two: cd tac_participant_two aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_participation:0.24.0 aea add skill fetchai/tac_negotiation:0.28.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger ethereum aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool aea config set vendor.fetchai.skills.tac_negotiation.models.strategy.args.is_contract_tx 'True' --type bool aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type dict agent.decision_maker_handler \\ '{ \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\", \"file_path\": null }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '''[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"message_format\": \"' { public_key } '\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]''' aea install aea build Configure the agents to use Ethereum Run the following in every AEA's terminal: aea config set agent.default_ledger ethereum json = $( printf '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"message_format\": \"{public_key}\", \"save_path\": \".certs/conn_cert.txt\"}]' ) aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \" $json \" aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum Add keys for all AEAs For every AEA in the competition (controller and participants): First generate and add a private key: aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt Then create and add a separate private key for secure communication: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Update the game parameters in the controller In the tac controller project, get and set the registration start time (set it to at least 5 minutes in the future): aea config get vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time aea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time '01 01 2020 00:01' To set the registration time, you may find handy the following command: aea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time \" $( date -d \"5 minutes\" + '%d %m %Y %H:%M' ) \" Update the connection parameters Update the connection parameters of the TAC participants to allow them to connect to the same local agent communication network as the TAC controller. First, retrieve controller's local ACN address by running the following in the controller agent's project terminal: aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri Then, in participant one, run this command (replace SOME_ADDRESS with the value you retrieved above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Do the same in participant two (beware of the different port numbers): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11002\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9002\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9002\" }' Fund agents' accounts Run a local Ganache Ethereum test-net with funds for the addresses of the three AEAs in this demo: docker run -p 8545 :8545 trufflesuite/ganache-cli:latest --verbose --gasPrice = 0 --gasLimit = 0x1fffffffffffff --account = \" $( cat tac_controller_contract/ethereum_private_key.txt ) ,1000000000000000000000\" --account = \" $( cat tac_participant_one/ethereum_private_key.txt ) ,1000000000000000000000\" --account = \" $( cat tac_participant_two/ethereum_private_key.txt ) ,1000000000000000000000\" To check the wealth of an AEA, use: aea get-wealth ethereum You should get 1000000000000000000000 . Run the AEAs First, launch the tac_contract_controller then the participants by executing the following from their respective terminals: aea run The CLI tool supports launching several agents at once. For example, assuming you followed the tutorial, you can launch both TAC participant agents as follows from the root directory (ensure you run the controller agent first as above): aea launch tac_participant_one tac_participant_two You may want to try --multithreaded option in order to run the agents in the same process. Cleaning up When you're finished, delete your AEAs: aea delete tac_controller_contract aea delete tac_participant_one aea delete tac_participant_two","title":"TAC skills ledger-based"},{"location":"aea/tac-skills-contract/#discussion","text":"This demo shows how agents negotiate autonomously with each other while they pursue their goals by participating in the Trading Agents Competition (TAC). The demo can be run against Fetchai or Ethereum ledger. Transactions are validated on an ERC1155 smart contract on the Fetchai StargateWorld or a local Ganache Ethereum testnet. In the following video we discuss the framework and TAC in more detail:","title":"Discussion"},{"location":"aea/tac-skills-contract/#communication","text":"There are two types of interactions: - between the controller and participants (game management communication) - between the participants (negotiations)","title":"Communication"},{"location":"aea/tac-skills-contract/#registration-communication","text":"This diagram shows the communication between the various entities during the registration phase. sequenceDiagram participant Agent_2 participant Agent_1 participant Search participant Controller activate Search activate Controller Controller->>Search: register_service activate Agent_1 Agent_1->>Search: search Search-->>Agent_1: controller Agent_1->>Controller: register activate Agent_2 Agent_2->>Search: search Search-->>Agent_2: controller Agent_2->>Controller: register Controller->>Agent_1: game_data Controller->>Agent_2: game_data deactivate Agent_1 deactivate Agent_2 deactivate Search deactivate Controller","title":"Registration communication"},{"location":"aea/tac-skills-contract/#transaction-communication","text":"This diagram shows the communication between two AEAs and a controller. In this case, we have a Seller_Agent which is set up as a seller (and registers itself as such with the controller during the registration phase). We also have the Searching_Agent which is set up to search for sellers. sequenceDiagram participant Buyer_Agent participant Seller_Agent participant Search participant Controller activate Buyer_Agent activate Seller_Agent activate Search activate Controller Seller_Agent->>Search: register_service Buyer_Agent->>Search: search Search-->>Buyer_Agent: list_of_agents Buyer_Agent->>Seller_Agent: call_for_proposal Seller_Agent->>Buyer_Agent: proposal Buyer_Agent->>Seller_Agent: accept Seller_Agent->>Buyer_Agent: match_accept Seller_Agent->>Controller: transaction Controller->>Controller: transaction_execution Controller->>Seller_Agent: confirm_transaction Controller->>Buyer_Agent: confirm_transaction deactivate Buyer_Agent deactivate Seller_Agent deactivate Search deactivate Controller In the above case, the proposal received contains a set of goods to sell and an associated price. The buyer AEA needs to determine if this is a good deal for them, and if so, it accepts. There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead be a list of goods that the buyer wishes to buy and the price it is willing to pay for them.","title":"Transaction communication"},{"location":"aea/tac-skills-contract/#preparation-instructions","text":"","title":"Preparation instructions"},{"location":"aea/tac-skills-contract/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/tac-skills-contract/#demo-instructions-fetchai","text":"Follow this instruction to run TAC against the fetch.ai StargateWorld test-net.","title":"Demo instructions (Fetchai):"},{"location":"aea/tac-skills-contract/#fetch-tac-controller-aea","text":"In the root directory, fetch the controller AEA: aea fetch fetchai/tac_controller_contract:0.31.0 cd tac_controller_contract aea install aea build Alternatively, create from scratch. The following steps create the controller from scratch: aea create tac_controller_contract cd tac_controller_contract aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_control_contract:0.26.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger fetchai aea config set vendor.fetchai.connections.soef.config.chain_identifier fetchai_v2_misc aea config set --type bool vendor.fetchai.skills.tac_control.is_abstract true aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"fetchai\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' aea install aea build","title":"Fetch TAC controller AEA"},{"location":"aea/tac-skills-contract/#fetch-the-tac-participant-aeas","text":"In separate terminals, in the root directory, fetch at least two participants: aea fetch fetchai/tac_participant_contract:0.21.0 --alias tac_participant_one cd tac_participant_one aea install aea build cd .. aea fetch fetchai/tac_participant_contract:0.21.0 --alias tac_participant_two cd tac_participant_two aea install aea build Alternatively, create from scratch. In a separate terminal, in the root directory, create at least two tac participant AEAs: aea create tac_participant_one aea create tac_participant_two Build participant one: cd tac_participant_one aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_participation:0.24.0 aea add skill fetchai/tac_negotiation:0.28.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger fetchai aea config set vendor.fetchai.connections.soef.config.chain_identifier fetchai_v2_misc aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool aea config set vendor.fetchai.skills.tac_negotiation.models.strategy.args.is_contract_tx 'True' --type bool aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type dict agent.decision_maker_handler \\ '{ \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\", \"file_path\": null }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '''[{\"identifier\": \"acn\", \"ledger_id\": \"fetchai\", \"message_format\": \"' { public_key } '\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]''' aea install aea build Then, build participant two: cd tac_participant_two aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_participation:0.24.0 aea add skill fetchai/tac_negotiation:0.28.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger fetchai aea config set vendor.fetchai.connections.soef.config.chain_identifier fetchai_v2_misc aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool aea config set vendor.fetchai.skills.tac_negotiation.models.strategy.args.is_contract_tx 'True' --type bool aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type dict agent.decision_maker_handler \\ '{ \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\", \"file_path\": null }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '''[{\"identifier\": \"acn\", \"ledger_id\": \"fetchai\", \"message_format\": \"' { public_key } '\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]''' aea install aea build","title":"Fetch the TAC participant AEAs"},{"location":"aea/tac-skills-contract/#add-keys-for-all-aeas","text":"For every AEA in the competition (controller and participants): First generate and add a private key: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then create and add a separate private key for secure communication: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for all AEAs"},{"location":"aea/tac-skills-contract/#update-the-game-parameters-in-the-controller","text":"In the tac controller project, get and set the registration start time (set it to at least 5 minutes in the future): aea config get vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time aea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time '01 01 2020 00:01' To set the registration time, you may find handy the following command: aea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time \" $( date -d \"5 minutes\" + '%d %m %Y %H:%M' ) \"","title":"Update the game parameters in the controller"},{"location":"aea/tac-skills-contract/#update-the-connection-parameters","text":"Update the connection parameters of the TAC participants to allow them to connect to the same local agent communication network as the TAC controller. First, retrieve controller's local ACN address by running the following in the controller agent's project terminal: aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri Then, in participant one, run this command (replace SOME_ADDRESS with the value you retrieved above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Do the same in participant two (beware of the different port numbers): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11002\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9002\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9002\" }'","title":"Update the connection parameters"},{"location":"aea/tac-skills-contract/#fund-agents-accounts","text":"Retrieve the address of each agent (in each terminal): aea get-address fetchai Go to the StargateWorld block explorer and request some test tokens via Get Funds . To check the wealth of an AEA, use: aea get-wealth fetchai","title":"Fund agents' accounts"},{"location":"aea/tac-skills-contract/#run-the-aeas","text":"First, launch the tac_contract_controller then the participants by executing the following from their respective terminals: aea run The CLI tool supports launching several agents at once. For example, assuming you followed the tutorial, you can launch both TAC participant agents as follows from the root directory (ensure you run the controller agent first as above): aea launch tac_participant_one tac_participant_two You may want to try --multithreaded option in order to run the agents in the same process.","title":"Run the AEAs"},{"location":"aea/tac-skills-contract/#cleaning-up","text":"When you're finished, delete your AEAs: aea delete tac_controller_contract aea delete tac_participant_one aea delete tac_participant_two","title":"Cleaning up"},{"location":"aea/tac-skills-contract/#demo-instructions-ethereum","text":"Follow this instruction to run TAC against a local Ganache Ethereum test-net.","title":"Demo instructions (Ethereum):"},{"location":"aea/tac-skills-contract/#create-tac-controller-aea","text":"In the root directory, fetch the controller AEA: aea fetch fetchai/tac_controller_contract:0.31.0 cd tac_controller_contract aea install aea build Alternatively, create from scratch. The following steps create the controller from scratch: aea create tac_controller_contract cd tac_controller_contract aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_control_contract:0.26.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger ethereum aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum aea config set --type bool vendor.fetchai.skills.tac_control.is_abstract true aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]' aea install aea build","title":"Create TAC controller AEA"},{"location":"aea/tac-skills-contract/#fetch-the-tac-participant-aeas_1","text":"In separate terminals, in the root directory, fetch at least two participants: aea fetch fetchai/tac_participant_contract:0.21.0 --alias tac_participant_one cd tac_participant_one aea install aea build cd .. aea fetch fetchai/tac_participant_contract:0.21.0 --alias tac_participant_two cd tac_participant_two aea install aea build Alternatively, create from scratch. In a separate terminal, in the root directory, create at least two tac participant AEAs: aea create tac_participant_one aea create tac_participant_two Build participant one: cd tac_participant_one aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_participation:0.24.0 aea add skill fetchai/tac_negotiation:0.28.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger ethereum aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool aea config set vendor.fetchai.skills.tac_negotiation.models.strategy.args.is_contract_tx 'True' --type bool aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type dict agent.decision_maker_handler \\ '{ \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\", \"file_path\": null }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '''[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"message_format\": \"' { public_key } '\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]''' aea install aea build Then, build participant two: cd tac_participant_two aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_participation:0.24.0 aea add skill fetchai/tac_negotiation:0.28.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"}, \"aea-ledger-ethereum\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger ethereum aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum aea config set vendor.fetchai.skills.tac_participation.models.game.args.is_using_contract 'True' --type bool aea config set vendor.fetchai.skills.tac_negotiation.models.strategy.args.is_contract_tx 'True' --type bool aea config set --type dict agent.default_routing \\ '{ \"fetchai/contract_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type dict agent.decision_maker_handler \\ '{ \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\", \"file_path\": null }' aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \\ '''[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"message_format\": \"' { public_key } '\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"save_path\": \".certs/conn_cert.txt\"}]''' aea install aea build","title":"Fetch the TAC participant AEAs"},{"location":"aea/tac-skills-contract/#configure-the-agents-to-use-ethereum","text":"Run the following in every AEA's terminal: aea config set agent.default_ledger ethereum json = $( printf '[{\"identifier\": \"acn\", \"ledger_id\": \"ethereum\", \"not_after\": \"2022-01-01\", \"not_before\": \"2021-01-01\", \"public_key\": \"fetchai\", \"message_format\": \"{public_key}\", \"save_path\": \".certs/conn_cert.txt\"}]' ) aea config set --type list vendor.fetchai.connections.p2p_libp2p.cert_requests \" $json \" aea config set vendor.fetchai.connections.soef.config.chain_identifier ethereum","title":"Configure the agents to use Ethereum"},{"location":"aea/tac-skills-contract/#add-keys-for-all-aeas_1","text":"For every AEA in the competition (controller and participants): First generate and add a private key: aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt Then create and add a separate private key for secure communication: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for all AEAs"},{"location":"aea/tac-skills-contract/#update-the-game-parameters-in-the-controller_1","text":"In the tac controller project, get and set the registration start time (set it to at least 5 minutes in the future): aea config get vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time aea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time '01 01 2020 00:01' To set the registration time, you may find handy the following command: aea config set vendor.fetchai.skills.tac_control_contract.models.parameters.args.registration_start_time \" $( date -d \"5 minutes\" + '%d %m %Y %H:%M' ) \"","title":"Update the game parameters in the controller"},{"location":"aea/tac-skills-contract/#update-the-connection-parameters_1","text":"Update the connection parameters of the TAC participants to allow them to connect to the same local agent communication network as the TAC controller. First, retrieve controller's local ACN address by running the following in the controller agent's project terminal: aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri Then, in participant one, run this command (replace SOME_ADDRESS with the value you retrieved above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Do the same in participant two (beware of the different port numbers): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11002\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9002\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9002\" }'","title":"Update the connection parameters"},{"location":"aea/tac-skills-contract/#fund-agents-accounts_1","text":"Run a local Ganache Ethereum test-net with funds for the addresses of the three AEAs in this demo: docker run -p 8545 :8545 trufflesuite/ganache-cli:latest --verbose --gasPrice = 0 --gasLimit = 0x1fffffffffffff --account = \" $( cat tac_controller_contract/ethereum_private_key.txt ) ,1000000000000000000000\" --account = \" $( cat tac_participant_one/ethereum_private_key.txt ) ,1000000000000000000000\" --account = \" $( cat tac_participant_two/ethereum_private_key.txt ) ,1000000000000000000000\" To check the wealth of an AEA, use: aea get-wealth ethereum You should get 1000000000000000000000 .","title":"Fund agents' accounts"},{"location":"aea/tac-skills-contract/#run-the-aeas_1","text":"First, launch the tac_contract_controller then the participants by executing the following from their respective terminals: aea run The CLI tool supports launching several agents at once. For example, assuming you followed the tutorial, you can launch both TAC participant agents as follows from the root directory (ensure you run the controller agent first as above): aea launch tac_participant_one tac_participant_two You may want to try --multithreaded option in order to run the agents in the same process.","title":"Run the AEAs"},{"location":"aea/tac-skills-contract/#cleaning-up_1","text":"When you're finished, delete your AEAs: aea delete tac_controller_contract aea delete tac_participant_one aea delete tac_participant_two","title":"Cleaning up"},{"location":"aea/tac-skills/","text":"The AEA TAC - trading agent competition - skills demonstrate an interaction between multiple AEAs in a game. There are two types of AEAs: The tac_controller which coordinates the game. The tac_participant AEAs which compete in the game. The tac_participant AEAs trade tokens with each other to maximize their utility. Discussion The scope of this specific demo is to demonstrate how the agents negotiate autonomously with each other while they pursue their goals by playing a game of TAC. Another AEA has the role of the controller and it's responsible for calculating the revenue for each participant and if the transaction messages are valid. Transactions are settled with the controller agent rather than against a public ledger. Communication There are two types of interactions: - between the participants and the controller, the game communication - between the participants, the negotiation Registration communication This diagram shows the communication between the various entities during the registration phase. sequenceDiagram participant Agent_2 participant Agent_1 participant Search participant Controller activate Search activate Controller Controller->>Search: register_service activate Agent_1 Agent_1->>Search: search Search-->>Agent_1: controller Agent_1->>Controller: register activate Agent_2 Agent_2->>Search: search Search-->>Agent_2: controller Agent_2->>Controller: register Controller->>Controller: start_game Controller->>Agent_1: game_data Controller->>Agent_2: game_data deactivate Agent_1 deactivate Agent_2 deactivate Search deactivate Controller Transaction communication This diagram shows the communication between two AEAs and the controller. In this case, we have an AEA in the role of the seller, referred to as Seller_Agent . We also have an AEA in the role of the buyer, referred to as Buyer_Agent . During a given TAC, an AEA can be in both roles simultaneously in different bilateral interactions. sequenceDiagram participant Buyer_Agent participant Seller_Agent participant Search participant Controller activate Buyer_Agent activate Seller_Agent activate Search activate Controller Seller_Agent->>Search: register_service Buyer_Agent->>Search: search Search-->>Buyer_Agent: list_of_agents Buyer_Agent->>Seller_Agent: call_for_proposal Seller_Agent->>Buyer_Agent: proposal Buyer_Agent->>Seller_Agent: accept Seller_Agent->>Buyer_Agent: match_accept Seller_Agent->>Controller: transaction Controller->>Controller: transaction_execution Controller->>Seller_Agent: confirm_transaction Controller->>Buyer_Agent: confirm_transaction deactivate Buyer_Agent deactivate Seller_Agent deactivate Search deactivate Controller In the above case, the proposal received contains a set of good which the seller wishes to sell and a cost of them. The buyer AEA needs to determine if this is a good deal for them and if so, it accepts. There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead, be a list of goods that the buyer wishes to buy and the price it is willing to pay for them. Option 1: AEA Manager approach Follow this approach when using the AEA Manager Desktop app. Otherwise, skip and follow the CLI approach below. Preparation instructions Install the AEA Manager . Demo instructions The following steps assume you have launched the AEA Manager Desktop app. Add a new AEA called controller with public id fetchai/tac_controller:0.26.0 . Add another new AEA called participant_1 with public id fetchai/tac_participant:0.28.0 . Add another new AEA called participant_2 with public id fetchai/tac_participant:0.28.0 . Navigate to the settings of controller and under components > skill > fetchai/fetchai/tac_controller:0.22.0 > models > parameters > args update registration_start_time to the time you want TAC to begin (e.g. 2 minutes in the future) Run the controller AEA. Navigate to its logs and copy the multiaddress displayed. Stop the controller . Navigate to the settings of participant_1 and under components > connection > fetchai/p2p_libp2p:0.22.0 update as follows (make sure to replace the placeholder with the multiaddress): { \"delegate_uri\" : \"127.0.0.1:11001\" , \"entry_peers\" : [ \"REPLACE_WITH_MULTI_ADDRESS_HERE\" ] , \"local_uri\" : \"127.0.0.1:9001\" , \"log_file\" : \"libp2p_node.log\" , \"public_uri\" : \"127.0.0.1:9001\" } Navigate to the settings of participant_2 and under components > connection > fetchai/p2p_libp2p:0.22.0 update as follows (make sure to replace the placeholder with the multiaddress): { \"delegate_uri\" : \"127.0.0.1:11002\" , \"entry_peers\" : [ \"REPLACE_WITH_MULTI_ADDRESS_HERE\" ] , \"local_uri\" : \"127.0.0.1:9002\" , \"log_file\" : \"libp2p_node.log\" , \"public_uri\" : \"127.0.0.1:9002\" } You may add more participants by repeating steps 3 (with an updated name) and 6 (bumping the port numbers. See the difference between steps 5 and 6). Run the controller , then participant_1 and participant_2 (and any other participants you added). In the controller 's log, you should see the details of the transactions participants submit as well as changes in their scores and holdings. In participants' logs, you should see the agents trading. Option 2: CLI approach Follow this approach when using the aea CLI. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions: Create TAC controller AEA In the root directory, fetch the controller AEA: aea fetch fetchai/tac_controller:0.29.0 cd tac_controller aea install aea build Alternatively, create from scratch. The following steps create the controller from scratch: aea create tac_controller cd tac_controller aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_control:0.24.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger fetchai aea config set --type dict agent.default_routing \\ '{ \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build Create the TAC participant AEAs In a separate terminal, in the root directory, fetch at least two participants: aea fetch fetchai/tac_participant:0.31.0 --alias tac_participant_one cd tac_participant_one aea install aea build cd .. aea fetch fetchai/tac_participant:0.31.0 --alias tac_participant_two cd tac_participant_two aea build Alternatively, create from scratch. In a separate terminal, in the root directory, create at least two tac participant AEAs: aea create tac_participant_one aea create tac_participant_two Build participant one: cd tac_participant_one aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_participation:0.24.0 aea add skill fetchai/tac_negotiation:0.28.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger fetchai aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type dict agent.decision_maker_handler \\ '{ \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\", \"file_path\": null }' aea install aea build Then, build participant two: cd tac_participant_two aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_participation:0.24.0 aea add skill fetchai/tac_negotiation:0.28.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger fetchai aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type dict agent.decision_maker_handler \\ '{ \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\", \"file_path\": null }' aea install aea build Add keys for all AEAs Create the private key for the AEA for Fetch.ai StargateWorld : aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Update the game parameters in the controller Navigate to the tac controller project, then use the command line to get and set the start time (set it to at least two minutes in the future): aea config get vendor.fetchai.skills.tac_control.models.parameters.args.registration_start_time aea config set vendor.fetchai.skills.tac_control.models.parameters.args.registration_start_time '01 01 2020 00:01' To set the registration time, you may find handy the following command: aea config set vendor.fetchai.skills.tac_control.models.parameters.args.registration_start_time \" $( date -d \"2 minutes\" + '%d %m %Y %H:%M' ) \" Update the connection parameters Briefly run the controller AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) Then, in the participant one, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Do the same in participant two (beware of the different port numbers): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11002\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9002\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9002\" }' This allows the TAC participants to connect to the same local agent communication network as the TAC controller. Run the AEAs First, launch the tac_controller : aea run The CLI tool supports the launch of several agents at once. For example, assuming you followed the tutorial, you can launch both the TAC agents as follows from the root directory: aea launch tac_participant_one tac_participant_two You may want to try --multithreaded option in order to run the agents in the same process. Cleaning up When you're finished, delete your AEAs: aea delete tac_controller aea delete tac_participant_one aea delete tac_participant_two","title":"TAC skills"},{"location":"aea/tac-skills/#discussion","text":"The scope of this specific demo is to demonstrate how the agents negotiate autonomously with each other while they pursue their goals by playing a game of TAC. Another AEA has the role of the controller and it's responsible for calculating the revenue for each participant and if the transaction messages are valid. Transactions are settled with the controller agent rather than against a public ledger.","title":"Discussion"},{"location":"aea/tac-skills/#communication","text":"There are two types of interactions: - between the participants and the controller, the game communication - between the participants, the negotiation","title":"Communication"},{"location":"aea/tac-skills/#registration-communication","text":"This diagram shows the communication between the various entities during the registration phase. sequenceDiagram participant Agent_2 participant Agent_1 participant Search participant Controller activate Search activate Controller Controller->>Search: register_service activate Agent_1 Agent_1->>Search: search Search-->>Agent_1: controller Agent_1->>Controller: register activate Agent_2 Agent_2->>Search: search Search-->>Agent_2: controller Agent_2->>Controller: register Controller->>Controller: start_game Controller->>Agent_1: game_data Controller->>Agent_2: game_data deactivate Agent_1 deactivate Agent_2 deactivate Search deactivate Controller","title":"Registration communication"},{"location":"aea/tac-skills/#transaction-communication","text":"This diagram shows the communication between two AEAs and the controller. In this case, we have an AEA in the role of the seller, referred to as Seller_Agent . We also have an AEA in the role of the buyer, referred to as Buyer_Agent . During a given TAC, an AEA can be in both roles simultaneously in different bilateral interactions. sequenceDiagram participant Buyer_Agent participant Seller_Agent participant Search participant Controller activate Buyer_Agent activate Seller_Agent activate Search activate Controller Seller_Agent->>Search: register_service Buyer_Agent->>Search: search Search-->>Buyer_Agent: list_of_agents Buyer_Agent->>Seller_Agent: call_for_proposal Seller_Agent->>Buyer_Agent: proposal Buyer_Agent->>Seller_Agent: accept Seller_Agent->>Buyer_Agent: match_accept Seller_Agent->>Controller: transaction Controller->>Controller: transaction_execution Controller->>Seller_Agent: confirm_transaction Controller->>Buyer_Agent: confirm_transaction deactivate Buyer_Agent deactivate Seller_Agent deactivate Search deactivate Controller In the above case, the proposal received contains a set of good which the seller wishes to sell and a cost of them. The buyer AEA needs to determine if this is a good deal for them and if so, it accepts. There is an equivalent diagram for seller AEAs set up to search for buyers and their interaction with AEAs which are registered as buyers. In that scenario, the proposal will instead, be a list of goods that the buyer wishes to buy and the price it is willing to pay for them.","title":"Transaction communication"},{"location":"aea/tac-skills/#option-1-aea-manager-approach","text":"Follow this approach when using the AEA Manager Desktop app. Otherwise, skip and follow the CLI approach below.","title":"Option 1: AEA Manager approach"},{"location":"aea/tac-skills/#preparation-instructions","text":"Install the AEA Manager .","title":"Preparation instructions"},{"location":"aea/tac-skills/#demo-instructions","text":"The following steps assume you have launched the AEA Manager Desktop app. Add a new AEA called controller with public id fetchai/tac_controller:0.26.0 . Add another new AEA called participant_1 with public id fetchai/tac_participant:0.28.0 . Add another new AEA called participant_2 with public id fetchai/tac_participant:0.28.0 . Navigate to the settings of controller and under components > skill > fetchai/fetchai/tac_controller:0.22.0 > models > parameters > args update registration_start_time to the time you want TAC to begin (e.g. 2 minutes in the future) Run the controller AEA. Navigate to its logs and copy the multiaddress displayed. Stop the controller . Navigate to the settings of participant_1 and under components > connection > fetchai/p2p_libp2p:0.22.0 update as follows (make sure to replace the placeholder with the multiaddress): { \"delegate_uri\" : \"127.0.0.1:11001\" , \"entry_peers\" : [ \"REPLACE_WITH_MULTI_ADDRESS_HERE\" ] , \"local_uri\" : \"127.0.0.1:9001\" , \"log_file\" : \"libp2p_node.log\" , \"public_uri\" : \"127.0.0.1:9001\" } Navigate to the settings of participant_2 and under components > connection > fetchai/p2p_libp2p:0.22.0 update as follows (make sure to replace the placeholder with the multiaddress): { \"delegate_uri\" : \"127.0.0.1:11002\" , \"entry_peers\" : [ \"REPLACE_WITH_MULTI_ADDRESS_HERE\" ] , \"local_uri\" : \"127.0.0.1:9002\" , \"log_file\" : \"libp2p_node.log\" , \"public_uri\" : \"127.0.0.1:9002\" } You may add more participants by repeating steps 3 (with an updated name) and 6 (bumping the port numbers. See the difference between steps 5 and 6). Run the controller , then participant_1 and participant_2 (and any other participants you added). In the controller 's log, you should see the details of the transactions participants submit as well as changes in their scores and holdings. In participants' logs, you should see the agents trading.","title":"Demo instructions"},{"location":"aea/tac-skills/#option-2-cli-approach","text":"Follow this approach when using the aea CLI.","title":"Option 2: CLI approach"},{"location":"aea/tac-skills/#preparation-instructions_1","text":"","title":"Preparation instructions"},{"location":"aea/tac-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/tac-skills/#demo-instructions_1","text":"","title":"Demo instructions:"},{"location":"aea/tac-skills/#create-tac-controller-aea","text":"In the root directory, fetch the controller AEA: aea fetch fetchai/tac_controller:0.29.0 cd tac_controller aea install aea build Alternatively, create from scratch. The following steps create the controller from scratch: aea create tac_controller cd tac_controller aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_control:0.24.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger fetchai aea config set --type dict agent.default_routing \\ '{ \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build","title":"Create TAC controller AEA"},{"location":"aea/tac-skills/#create-the-tac-participant-aeas","text":"In a separate terminal, in the root directory, fetch at least two participants: aea fetch fetchai/tac_participant:0.31.0 --alias tac_participant_one cd tac_participant_one aea install aea build cd .. aea fetch fetchai/tac_participant:0.31.0 --alias tac_participant_two cd tac_participant_two aea build Alternatively, create from scratch. In a separate terminal, in the root directory, create at least two tac participant AEAs: aea create tac_participant_one aea create tac_participant_two Build participant one: cd tac_participant_one aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_participation:0.24.0 aea add skill fetchai/tac_negotiation:0.28.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger fetchai aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type dict agent.decision_maker_handler \\ '{ \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\", \"file_path\": null }' aea install aea build Then, build participant two: cd tac_participant_two aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/tac_participation:0.24.0 aea add skill fetchai/tac_negotiation:0.28.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set agent.default_ledger fetchai aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea config set --type dict agent.decision_maker_handler \\ '{ \"dotted_path\": \"aea.decision_maker.gop:DecisionMakerHandler\", \"file_path\": null }' aea install aea build","title":"Create the TAC participant AEAs"},{"location":"aea/tac-skills/#add-keys-for-all-aeas","text":"Create the private key for the AEA for Fetch.ai StargateWorld : aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for all AEAs"},{"location":"aea/tac-skills/#update-the-game-parameters-in-the-controller","text":"Navigate to the tac controller project, then use the command line to get and set the start time (set it to at least two minutes in the future): aea config get vendor.fetchai.skills.tac_control.models.parameters.args.registration_start_time aea config set vendor.fetchai.skills.tac_control.models.parameters.args.registration_start_time '01 01 2020 00:01' To set the registration time, you may find handy the following command: aea config set vendor.fetchai.skills.tac_control.models.parameters.args.registration_start_time \" $( date -d \"2 minutes\" + '%d %m %Y %H:%M' ) \"","title":"Update the game parameters in the controller"},{"location":"aea/tac-skills/#update-the-connection-parameters","text":"Briefly run the controller AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) Then, in the participant one, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' Do the same in participant two (beware of the different port numbers): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11002\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9002\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9002\" }' This allows the TAC participants to connect to the same local agent communication network as the TAC controller.","title":"Update the connection parameters"},{"location":"aea/tac-skills/#run-the-aeas","text":"First, launch the tac_controller : aea run The CLI tool supports the launch of several agents at once. For example, assuming you followed the tutorial, you can launch both the TAC agents as follows from the root directory: aea launch tac_participant_one tac_participant_two You may want to try --multithreaded option in order to run the agents in the same process.","title":"Run the AEAs"},{"location":"aea/tac-skills/#cleaning-up","text":"When you're finished, delete your AEAs: aea delete tac_controller aea delete tac_participant_one aea delete tac_participant_two","title":"Cleaning up"},{"location":"aea/tac/","text":"The original TAC has its own repo . Follow the instructions below to build and run the TAC demo. Requirements Make sure you are running Docker and Docker Compose . Quick start Clone the repo to include sub-modules. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Create and launch a virtual environment. pipenv --python 3 .7 && pipenv shell Install the dependencies. pipenv install Install the package. python setup.py install Run the launch script. This may take a while. python scripts/launch.py The Visdom server is now running. The controller GUI at http://localhost:8097 provides real time insights. In the Environment tab, make sure you have the tac_controller environment selected. Alternative build and run In a new terminal window, clone the repo, build the sandbox, and launch it. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac pipenv --python 3 .7 && pipenv shell python setup.py install cd sandbox && docker-compose build docker-compose up In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. pipenv shell python templates/v1/basic.py --name my_agent --dashboard Click through to the controller GUI . Possible gotchas Stop all running containers before restart. docker stop $( docker ps -q ) To remove all images, run the following command. # mac docker ps -q | xargs docker stop ; docker system prune -a","title":"TAC external app"},{"location":"aea/tac/#requirements","text":"Make sure you are running Docker and Docker Compose .","title":"Requirements"},{"location":"aea/tac/#quick-start","text":"Clone the repo to include sub-modules. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac Check you have pipenv . which pipenv If you don't have it, install it. Instructions are here . Create and launch a virtual environment. pipenv --python 3 .7 && pipenv shell Install the dependencies. pipenv install Install the package. python setup.py install Run the launch script. This may take a while. python scripts/launch.py The Visdom server is now running. The controller GUI at http://localhost:8097 provides real time insights. In the Environment tab, make sure you have the tac_controller environment selected.","title":"Quick start"},{"location":"aea/tac/#alternative-build-and-run","text":"In a new terminal window, clone the repo, build the sandbox, and launch it. git clone git@github.com:fetchai/agents-tac.git --recursive && cd agents-tac pipenv --python 3 .7 && pipenv shell python setup.py install cd sandbox && docker-compose build docker-compose up In a new terminal window, enter the virtual environment, and connect a template agent to the sandbox. pipenv shell python templates/v1/basic.py --name my_agent --dashboard Click through to the controller GUI .","title":"Alternative build and run"},{"location":"aea/tac/#possible-gotchas","text":"Stop all running containers before restart. docker stop $( docker ps -q ) To remove all images, run the following command. # mac docker ps -q | xargs docker stop ; docker system prune -a","title":"Possible gotchas"},{"location":"aea/thermometer-skills/","text":"The AEA thermometer skills demonstrate an interaction between two AEAs, one purchasing temperature data from the other. The provider of thermometer data (the thermometer ). The buyer of thermometer data (the thermometer_client ). Discussion This demo aims to demonstrate how to create a very simple AEA with the usage of the AEA framework and a thermometer sensor. The thermometer AEA will read data from the sensor each time a client requests the data and will deliver it to the client upon payment. To keep the demo simple, we avoided the usage of a database since this would increase the complexity. As a result, the AEA can provide only one reading from the sensor. This demo does not utilise a smart contract. As a result, the ledger interaction is only for completing a transaction. Communication This diagram shows the communication between the various entities as data is successfully sold by the thermometer AEA to the client AEA. sequenceDiagram participant Search participant Client_AEA participant Thermometer_AEA participant Blockchain activate Client_AEA activate Search activate Thermometer_AEA activate Blockchain Thermometer_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Thermometer_AEA: call_for_proposal Thermometer_AEA->>Client_AEA: propose Client_AEA->>Thermometer_AEA: accept Thermometer_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Thermometer_AEA: send_transaction_hash Thermometer_AEA->>Blockchain: check_transaction_status Thermometer_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Thermometer_AEA deactivate Blockchain Option 1: AEA Manager approach Follow this approach when using the AEA Manager Desktop app. Otherwise, skip and follow the CLI approach below. Preparation instructions Install the AEA Manager . Demo instructions The following steps assume you have launched the AEA Manager Desktop app. Add a new AEA called my_thermometer_aea with public id fetchai/thermometer_aea:0.29.0 . Add another new AEA called my_thermometer_client with public id fetchai/thermometer_client:0.30.0 . Copy the address from the my_thermometer_client into your clip board. Then go to the StargateWorld block explorer and request some test tokens via Get Funds . Run the my_thermometer_aea AEA. Navigate to its logs and copy the multiaddress displayed. Navigate to the settings of the my_thermometer_client and under components > connection > fetchai/p2p_libp2p:0.22.0 update as follows (make sure to replace the placeholder with the multiaddress): { \"delegate_uri\" : \"127.0.0.1:11001\" , \"entry_peers\" : [ \"REPLACE_WITH_MULTI_ADDRESS_HERE\" ] , \"local_uri\" : \"127.0.0.1:9001\" , \"log_file\" : \"libp2p_node.log\" , \"public_uri\" : \"127.0.0.1:9001\" } Run the my_thermometer_client . In the AEA's logs, you should see the agent trading successfully. Option 2: CLI approach Follow this approach when using the aea CLI. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions A demo to run the thermometer scenario with a true ledger transaction This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Create thermometer AEA First, fetch the thermometer AEA: aea fetch fetchai/thermometer_aea:0.29.0 --alias my_thermometer_aea cd my_thermometer_aea aea install aea build Alternatively, create from scratch. The following steps create the thermometer AEA from scratch: aea create my_thermometer_aea cd my_thermometer_aea aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/thermometer:0.26.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' Create thermometer client Then, fetch the thermometer client AEA: aea fetch fetchai/thermometer_client:0.30.0 --alias my_thermometer_client cd my_thermometer_client aea install aea build Alternatively, create from scratch. The following steps create the thermometer client from scratch: aea create my_thermometer_client cd my_thermometer_client aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/thermometer_client:0.25.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' Add keys for the thermometer AEA First, create the private key for the thermometer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Add keys and generate wealth for the thermometer client AEA The thermometer client needs to have some wealth to purchase the thermometer information. First, create the private key for the thermometer client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your thermometer client based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Run both AEAs Run both AEAs from their respective terminals. First, run the thermometer AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the thermometer AEA. Then, in the thermometer client, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the thermometer client to connect to the same local agent communication network as the thermometer AEA. Then run the thermometer client AEA: aea run You can see that the AEAs find each other, negotiate and eventually trade. Cleaning up When you're done, go up a level and delete the AEAs. cd .. aea delete my_thermometer_aea aea delete my_thermometer_client","title":"Thermometer skills"},{"location":"aea/thermometer-skills/#discussion","text":"This demo aims to demonstrate how to create a very simple AEA with the usage of the AEA framework and a thermometer sensor. The thermometer AEA will read data from the sensor each time a client requests the data and will deliver it to the client upon payment. To keep the demo simple, we avoided the usage of a database since this would increase the complexity. As a result, the AEA can provide only one reading from the sensor. This demo does not utilise a smart contract. As a result, the ledger interaction is only for completing a transaction.","title":"Discussion"},{"location":"aea/thermometer-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the thermometer AEA to the client AEA. sequenceDiagram participant Search participant Client_AEA participant Thermometer_AEA participant Blockchain activate Client_AEA activate Search activate Thermometer_AEA activate Blockchain Thermometer_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Thermometer_AEA: call_for_proposal Thermometer_AEA->>Client_AEA: propose Client_AEA->>Thermometer_AEA: accept Thermometer_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Thermometer_AEA: send_transaction_hash Thermometer_AEA->>Blockchain: check_transaction_status Thermometer_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Thermometer_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/thermometer-skills/#option-1-aea-manager-approach","text":"Follow this approach when using the AEA Manager Desktop app. Otherwise, skip and follow the CLI approach below.","title":"Option 1: AEA Manager approach"},{"location":"aea/thermometer-skills/#preparation-instructions","text":"Install the AEA Manager .","title":"Preparation instructions"},{"location":"aea/thermometer-skills/#demo-instructions","text":"The following steps assume you have launched the AEA Manager Desktop app. Add a new AEA called my_thermometer_aea with public id fetchai/thermometer_aea:0.29.0 . Add another new AEA called my_thermometer_client with public id fetchai/thermometer_client:0.30.0 . Copy the address from the my_thermometer_client into your clip board. Then go to the StargateWorld block explorer and request some test tokens via Get Funds . Run the my_thermometer_aea AEA. Navigate to its logs and copy the multiaddress displayed. Navigate to the settings of the my_thermometer_client and under components > connection > fetchai/p2p_libp2p:0.22.0 update as follows (make sure to replace the placeholder with the multiaddress): { \"delegate_uri\" : \"127.0.0.1:11001\" , \"entry_peers\" : [ \"REPLACE_WITH_MULTI_ADDRESS_HERE\" ] , \"local_uri\" : \"127.0.0.1:9001\" , \"log_file\" : \"libp2p_node.log\" , \"public_uri\" : \"127.0.0.1:9001\" } Run the my_thermometer_client . In the AEA's logs, you should see the agent trading successfully.","title":"Demo instructions"},{"location":"aea/thermometer-skills/#option-2-cli-approach","text":"Follow this approach when using the aea CLI.","title":"Option 2: CLI approach"},{"location":"aea/thermometer-skills/#preparation-instructions_1","text":"","title":"Preparation instructions"},{"location":"aea/thermometer-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/thermometer-skills/#demo-instructions_1","text":"A demo to run the thermometer scenario with a true ledger transaction This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.","title":"Demo instructions"},{"location":"aea/thermometer-skills/#create-thermometer-aea","text":"First, fetch the thermometer AEA: aea fetch fetchai/thermometer_aea:0.29.0 --alias my_thermometer_aea cd my_thermometer_aea aea install aea build Alternatively, create from scratch. The following steps create the thermometer AEA from scratch: aea create my_thermometer_aea cd my_thermometer_aea aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/thermometer:0.26.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }'","title":"Create thermometer AEA"},{"location":"aea/thermometer-skills/#create-thermometer-client","text":"Then, fetch the thermometer client AEA: aea fetch fetchai/thermometer_client:0.30.0 --alias my_thermometer_client cd my_thermometer_client aea install aea build Alternatively, create from scratch. The following steps create the thermometer client from scratch: aea create my_thermometer_client cd my_thermometer_client aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/thermometer_client:0.25.0 aea install aea build aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }'","title":"Create thermometer client"},{"location":"aea/thermometer-skills/#add-keys-for-the-thermometer-aea","text":"First, create the private key for the thermometer AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for the thermometer AEA"},{"location":"aea/thermometer-skills/#add-keys-and-generate-wealth-for-the-thermometer-client-aea","text":"The thermometer client needs to have some wealth to purchase the thermometer information. First, create the private key for the thermometer client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your thermometer client based on the network you want to transact with. On the Fetch.ai testnet network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys and generate wealth for the thermometer client AEA"},{"location":"aea/thermometer-skills/#run-both-aeas","text":"Run both AEAs from their respective terminals. First, run the thermometer AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the thermometer AEA. Then, in the thermometer client, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the thermometer client to connect to the same local agent communication network as the thermometer AEA. Then run the thermometer client AEA: aea run You can see that the AEAs find each other, negotiate and eventually trade.","title":"Run both AEAs"},{"location":"aea/thermometer-skills/#cleaning-up","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_thermometer_aea aea delete my_thermometer_client","title":"Cleaning up"},{"location":"aea/trust/","text":"AEA applications have different requirements for trustlessness or trust minimisation . For example, using the AEA weather skills demo without ledger payments means that the client has to trust the weather station to send the weather data it purchased and that this data is in fact valid. Similarly, the weather station must trust that the client somehow sends the payment amount to which they agreed. A step up, if you run the weather skills demo with a ledger (e.g. Fetch.ai or Ethereum) then the client must still trust that the weather station sends valid data. However, all payment transactions are executed via the public ledger. This means the weather station no longer needs to trust the client for payment and can verify whether the transactions take place on the public ledger. We can further minimise trust requirements by incorporating a third party as an arbitrator or escrow implemented in a smart contract to further reduce trust requirements. However, in the current weather skills demo, there are limits to trustlessness as the station ultimately offers unverifiable data. Another example of minimising trust, is applications with (non-fungible) token transactions involving atomic swaps where trustlessness is clearly satisfied (e.g. in the TAC demo ).","title":"Trust minimisation"},{"location":"aea/upgrading/","text":"This page provides some tips on how to upgrade AEA projects between different versions of the AEA framework. For full release notes check the AEA repo . The primary tool for upgrading AEA projects is the aea upgrade command in the CLI . Below we describe the additional manual steps required to upgrade between different versions: v1.0.2 to v1.1.0 No backwards incompatible changes. We advise everyone to upgrade their fetchai packages and plugins to get the latest fixes. v1.0.1 to v1.0.2 No backwards incompatible changes. We advise everyone to upgrade their fetchai packages and plugins to get the latest fixes. v1.0.0 to v1.0.1 No backwards incompatible changes. We advise everyone to upgrade their fetchai packages to get the latest fixes. v1.0.0rc2 to v1.0.0 No backwards incompatible changes to component development. We advise everyone to upgrade to v1 as soon as possible. When upgrading from versions below v1.0.0rc1 first upgrade to the first release candidate, then to v1 . v1.0.0rc1 to v1.0.0rc2 No backwards incompatible changes to component development. Various configuration changes introduced in v1.0.0rc1 are now enforced strictly. v0.11.1 to v1.0.0rc1 No backwards incompatible changes to component development. The aea-config.yaml now requires the field required_ledgers which must specify all ledgers for which private keys are required to run the agent. Please add it to your project. The registry_path field has been removed from the aea-config.yaml . Please remove it from your project. All packages provided by author fetchai must be upgraded. v0.11.0 to v0.11.1 No backwards incompatible changes. v0.10.1 to v0.11.0 Take special care when upgrading to v0.11.0 . We introduced several breaking changes in preparation for v1 ! CLI GUI We removed the CLI GUI. It was not used by anyone as far as we know and needs to be significantly improved. Soon we will release the AEA Manager App to make up for this. Message routing Routing has been completely revised and simplified. The new message routing logic is described here . When upgrading take the following steps: For agent-to-agent communication: ensure the default routing and default connection are correctly defined and that the dialogues used specify the agent's address as the self_address . This is most likely already the case. Only in some edge cases will you need to use an EnvelopeContext to target a connection different from the one specified in the default_routing map. For component-to-component communication: there is now only one single way to route component to component (skill to skill, skill to connection, connection to skill) messages, this is by specifying the component id in string form in the sender / to field. The EnvelopeContext can no longer be used, messages are routed based on their target ( to field). Ensure that dialogues in skills set the skill_id as the self_address (in connections they need to set the connection_id ). Agent configuration and ledger plugins Agent configuration files have a new optional field, dependencies , analogous to dependencies field in other AEA packages. The default value is the empty object {} . The field will be made mandatory in the next release. Crypto modules have been extracted and released as independent plug-ins, released on PyPI. In particular: Fetch.ai crypto classes have been released in the aea-ledger-fetchai package; Ethereum crypto classes have been released in the aea-ledger-ethereum package; Cosmos crypto classes have been released in the aea-ledger-cosmos package. If an AEA project, or an AEA package, makes use of crypto functionalities, it will be needed to add the above packages as PyPI dependencies with version specifiers ranging from the latest minor and the latest minor + 1 (excluded). E.g. if the latest version if 0.1.0 , the version specifier should be <0.2.0,>=0.1.0 : dependencies : aea-ledger-cosmos : version : <2.0.0,>=1.0.0 aea-ledger-ethereum : version : <2.0.0,>=1.0.0 aea-ledger-fetchai : version : <2.0.0,>=1.0.0 The version specifier sets are important, as these plug-ins, at version 0.1.0 , depend on a specific range of the aea package. Then, running aea install inside the AEA project should install them in the current Python environment. For more, read the guide on ledger plugins . v0.10.0 to v0.10.1 No backwards incompatible changes for skill and connection development. v0.9.2 to v0.10.0 Skill development sees no backward incompatible changes. Connection development requires updating the keyword arguments of the constructor: the new data_dir argument must be defined. Protocol specifications now need to contain a protocol_specification_id in addition to the public id. The protocol_specification_id is used for identifying Envelopes during transport. By being able to set the id independently of the protocol id, backwards compatibility in the specification (and therefore wire format) can be maintained even when the Python implementation changes. Please update to the latest packages by running aea upgrade and then re-generating your own protocols. v0.9.1 to v0.9.2 No backwards incompatible changes for skill and connection development. v0.9.0 to v0.9.1 No backwards incompatible changes for skill and connection development. v0.8.0 to v0.9.0 This release introduces proof of representation in the ACN. You will need to upgrade to the latest fetchai/p2p_libp2p or fetchai/p2p_libp2p_client connection and then use two key pairs, one for your AEA's decision maker and one for the connection. Please update to the latest packages by running aea upgrade . v0.7.5 to v0.8.0 Minimal backwards incompatible changes for skill and connection development: The semantics of the < , <= , > and >= relations in ConstraintTypes are simplified. Protocols now need to correctly define terminal states. Regenerate your protocol to identify if your protocol's dialogue rules are valid. Please update to the latest packages by running aea upgrade . v0.7.4 to v0.7.5 No backwards incompatible changes for skill and connection development. v0.7.3 to v0.7.4 No backwards incompatible changes for skill and connection development. v0.7.2 to v0.7.3 No backwards incompatible changes for skill and connection development. v0.7.1 to v0.7.2 No backwards incompatible changes for skill and connection development. v0.7.0 to v0.7.1 To improve performance, in particular optimize memory usage, we refactored the Message and Dialogue classes. This means all protocols need to be bumped to the latest version or regenerated using the aea generate protocol command in the CLI . v0.6.3 to v0.7.0 Multiple breaking changes require action in this order: Custom configuration overrides in aea-config.yaml are now identified via public_id rather than author , name and version individually. Please replace the three fields with the equivalent public_id . Run aea upgrade command to upgrade your project's dependencies. Note, you still do have to manually update the public ids under default_routing and default_connection in aea-config.yaml as well as the public ids in the non-vendor packages. Previously, connection fetchai/stub , skill fetchai/error and protocols fetchai/default , fetchai/signing and fetchai/state_update where part of the AEA distribution. Now they need to be fetched from registry. If you create a new project with aea create then this happens automatically. For existing projects, add the dependencies explicitly if not already present. You also must update the import paths as follows: aea.connections.stub > packages.fetchai.connections.stub aea.protocols.default > packages.fetchai.protocols.default aea.protocols.signing > packages.fetchai.protocols.signing aea.protocols.state_update > packages.fetchai.protocols.state_update aea.skills.error > packages.fetchai.skills.error If you use custom protocols, regenerate them. In your own skills' __init__.py files add the public id (updating the string as appropriate): from aea.configurations.base import PublicId PUBLIC_ID = PublicId . from_str ( \"author/name:0.1.0\" ) - The fetchai/http protocol's bodyy field has been renamed to body . Skills can now specify connections as dependencies in the configuration YAML. v0.6.2 to v0.6.3 A new upgrade command is introduced to upgrade agent projects and components to their latest versions on the registry. To use the command first upgrade the AEA PyPI package to the latest version, then enter your project and run aea upgrade . The project's vendor dependencies will be updated where possible. v0.6.1 to v0.6.2 No public APIs have been changed. v0.6.0 to v0.6.1 The soef connection and oef_search protocol have backward incompatible changes. v0.5.4 to v0.6.0 Dialogue and Dialogues API updates The dialogue and dialogues APIs have changed significantly. The constructor is different for both classes and there are now four primary methods for the developer: Dialogues.create : this method is used to create a new dialogue and message: cfp_msg , fipa_dialogue = fipa_dialogues . create ( counterparty = opponent_address , performative = FipaMessage . Performative . CFP , query = query , ) The method will raise if the provided arguments are inconsistent. Dialogues.create_with_message : this method is used to create a new dialogue from a message: fipa_dialogue = fipa_dialogues . create_with_message ( counterparty = opponent_address , initial_message = cfp_msg ) The method will raise if the provided arguments are inconsistent. Dialogues.update : this method is used to handle messages passed by the framework: fipa_dialogue = fipa_dialogues . update ( message = cfp_msg ) The method will return a valid dialogue if it is a valid message, otherwise it will return None . Dialogue.reply : this method is used to reply within a dialogue: proposal_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . PROPOSE , target_message = cfp_msg , proposal = proposal , ) The method will raise if the provided arguments are inconsistent. The new methods significantly reduce the lines of code needed to maintain a dialogue. They also make it easier for the developer to construct valid dialogues and messages. FetchAICrypto - default crypto The FetchAICrypto has been upgraded to the default crypto. Update your default_ledger to fetchai . Private key file naming The private key files are now consistently named with the ledger_id followed by _private_key.txt (e.g. fetchai_private_key.txt ). Rename your existing files to match this pattern. Type in package YAML The package YAML files now contain a type field. This must be added for the loading mechanism to work properly. Moved address type The address type has moved to aea.common . The import paths must be updated. v0.5.3 to v0.5.4 The contract base class was slightly modified. If you have implemented your own contract package you need to update it accordingly. The dialogue reference nonce is now randomly generated. This can result in previously working but buggy implementations (which relied on the order of dialogue reference nonces) to now fail. v0.5.2 to v0.5.3 Connection states and logger usage in connections where updated. If you have implemented your own connection package you need to update it accordingly. Additional dialogue consistency checks where enabled. This can result in previously working but buggy implementations to now fail. v0.5.1 to 0.5.2 No public APIs have been changed. v0.5.0 to 0.5.1 No public APIs have been changed. v0.4.1 to 0.5.0 A number of breaking changes where introduced which make backwards compatibility of skills rare. Ledger APIs LedgerApis have been removed from the AEA constructor and skill context. LedgerApis are now exposed in the LedgerConnection ( fetchai/ledger ). To communicate with the LedgerApis use the fetchai/ledger_api protocol. This allows for more flexibility (anyone can add another LedgerAPI to the registry and execute it with the connection) and removes dependencies from the core framework. Skills can now depend on other skills. As a result, skills have a new required configuration field in skill.yaml files, by default empty: skills: [] . v0.4.0 to v0.4.1 There are no upgrade requirements if you use the CLI based approach to AEA development. Connections are now added via Resources to the AEA, not the AEA constructor directly. For programmatic usage remove the list of connections from the AEA constructor and instead add the connections to resources. v0.3.3 to v0.4.0 Message sending in the skills has been updated. In the past you had to construct messages, then serialize them and place them in an envelope: cfp_msg = FipaMessage ( ... ) self . context . outbox . put_message ( to = opponent_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( cfp_msg ), ) # or cfp_msg = FipaMessage ( ... ) envelope = Envelope ( to = opponent_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( cfp_msg ), ) self . context . outbox . put ( envelope ) Now this has been simplified to: cfp_msg = FipaMessage ( ... ) cfp_msg . counterparty = opponent_addr self . context . outbox . put_message ( message = cfp_msg ) You must update your skills as the old implementation is no longer supported. Connection constructors have been simplified. In the past you had to implement both the `__init__` as well as the `from_config` methods of a Connection. Now you only have to implement the `__init__` method which by default at load time now receives the following keyword arguments: `configuration: ConnectionConfig, identity: Identity, crypto_store: CryptoStore`. See for example in the scaffold connection: class MyScaffoldConnection ( Connection ): \"\"\"Proxy to the functionality of the SDK or API.\"\"\" connection_id = PublicId . from_str ( \"fetchai/scaffold:0.1.0\" ) def __init__ ( self , configuration : ConnectionConfig , identity : Identity , crypto_store : CryptoStore , ): \"\"\" Initialize a connection to an SDK or API. :param configuration: the connection configuration. :param crypto_store: object to access the connection crypto objects. :param identity: the identity object. \"\"\" super () . __init__ ( configuration = configuration , crypto_store = crypto_store , identity = identity ) As a result of this feature, you are now able to pass key-pairs to your connections via the `CryptoStore`. You must update your connections as the old implementation is no longer supported.","title":"Upgrading"},{"location":"aea/upgrading/#v102-to-v110","text":"No backwards incompatible changes. We advise everyone to upgrade their fetchai packages and plugins to get the latest fixes.","title":"v1.0.2 to v1.1.0"},{"location":"aea/upgrading/#v101-to-v102","text":"No backwards incompatible changes. We advise everyone to upgrade their fetchai packages and plugins to get the latest fixes.","title":"v1.0.1 to v1.0.2"},{"location":"aea/upgrading/#v100-to-v101","text":"No backwards incompatible changes. We advise everyone to upgrade their fetchai packages to get the latest fixes.","title":"v1.0.0 to v1.0.1"},{"location":"aea/upgrading/#v100rc2-to-v100","text":"No backwards incompatible changes to component development. We advise everyone to upgrade to v1 as soon as possible. When upgrading from versions below v1.0.0rc1 first upgrade to the first release candidate, then to v1 .","title":"v1.0.0rc2 to v1.0.0"},{"location":"aea/upgrading/#v100rc1-to-v100rc2","text":"No backwards incompatible changes to component development. Various configuration changes introduced in v1.0.0rc1 are now enforced strictly.","title":"v1.0.0rc1 to v1.0.0rc2"},{"location":"aea/upgrading/#v0111-to-v100rc1","text":"No backwards incompatible changes to component development. The aea-config.yaml now requires the field required_ledgers which must specify all ledgers for which private keys are required to run the agent. Please add it to your project. The registry_path field has been removed from the aea-config.yaml . Please remove it from your project. All packages provided by author fetchai must be upgraded.","title":"v0.11.1 to v1.0.0rc1"},{"location":"aea/upgrading/#v0110-to-v0111","text":"No backwards incompatible changes.","title":"v0.11.0 to v0.11.1"},{"location":"aea/upgrading/#v0101-to-v0110","text":"Take special care when upgrading to v0.11.0 . We introduced several breaking changes in preparation for v1 !","title":"v0.10.1 to v0.11.0"},{"location":"aea/upgrading/#cli-gui","text":"We removed the CLI GUI. It was not used by anyone as far as we know and needs to be significantly improved. Soon we will release the AEA Manager App to make up for this.","title":"CLI GUI"},{"location":"aea/upgrading/#message-routing","text":"Routing has been completely revised and simplified. The new message routing logic is described here . When upgrading take the following steps: For agent-to-agent communication: ensure the default routing and default connection are correctly defined and that the dialogues used specify the agent's address as the self_address . This is most likely already the case. Only in some edge cases will you need to use an EnvelopeContext to target a connection different from the one specified in the default_routing map. For component-to-component communication: there is now only one single way to route component to component (skill to skill, skill to connection, connection to skill) messages, this is by specifying the component id in string form in the sender / to field. The EnvelopeContext can no longer be used, messages are routed based on their target ( to field). Ensure that dialogues in skills set the skill_id as the self_address (in connections they need to set the connection_id ).","title":"Message routing"},{"location":"aea/upgrading/#agent-configuration-and-ledger-plugins","text":"Agent configuration files have a new optional field, dependencies , analogous to dependencies field in other AEA packages. The default value is the empty object {} . The field will be made mandatory in the next release. Crypto modules have been extracted and released as independent plug-ins, released on PyPI. In particular: Fetch.ai crypto classes have been released in the aea-ledger-fetchai package; Ethereum crypto classes have been released in the aea-ledger-ethereum package; Cosmos crypto classes have been released in the aea-ledger-cosmos package. If an AEA project, or an AEA package, makes use of crypto functionalities, it will be needed to add the above packages as PyPI dependencies with version specifiers ranging from the latest minor and the latest minor + 1 (excluded). E.g. if the latest version if 0.1.0 , the version specifier should be <0.2.0,>=0.1.0 : dependencies : aea-ledger-cosmos : version : <2.0.0,>=1.0.0 aea-ledger-ethereum : version : <2.0.0,>=1.0.0 aea-ledger-fetchai : version : <2.0.0,>=1.0.0 The version specifier sets are important, as these plug-ins, at version 0.1.0 , depend on a specific range of the aea package. Then, running aea install inside the AEA project should install them in the current Python environment. For more, read the guide on ledger plugins .","title":"Agent configuration and ledger plugins"},{"location":"aea/upgrading/#v0100-to-v0101","text":"No backwards incompatible changes for skill and connection development.","title":"v0.10.0 to v0.10.1"},{"location":"aea/upgrading/#v092-to-v0100","text":"Skill development sees no backward incompatible changes. Connection development requires updating the keyword arguments of the constructor: the new data_dir argument must be defined. Protocol specifications now need to contain a protocol_specification_id in addition to the public id. The protocol_specification_id is used for identifying Envelopes during transport. By being able to set the id independently of the protocol id, backwards compatibility in the specification (and therefore wire format) can be maintained even when the Python implementation changes. Please update to the latest packages by running aea upgrade and then re-generating your own protocols.","title":"v0.9.2 to v0.10.0"},{"location":"aea/upgrading/#v091-to-v092","text":"No backwards incompatible changes for skill and connection development.","title":"v0.9.1 to v0.9.2"},{"location":"aea/upgrading/#v090-to-v091","text":"No backwards incompatible changes for skill and connection development.","title":"v0.9.0 to v0.9.1"},{"location":"aea/upgrading/#v080-to-v090","text":"This release introduces proof of representation in the ACN. You will need to upgrade to the latest fetchai/p2p_libp2p or fetchai/p2p_libp2p_client connection and then use two key pairs, one for your AEA's decision maker and one for the connection. Please update to the latest packages by running aea upgrade .","title":"v0.8.0 to v0.9.0"},{"location":"aea/upgrading/#v075-to-v080","text":"Minimal backwards incompatible changes for skill and connection development: The semantics of the < , <= , > and >= relations in ConstraintTypes are simplified. Protocols now need to correctly define terminal states. Regenerate your protocol to identify if your protocol's dialogue rules are valid. Please update to the latest packages by running aea upgrade .","title":"v0.7.5 to v0.8.0"},{"location":"aea/upgrading/#v074-to-v075","text":"No backwards incompatible changes for skill and connection development.","title":"v0.7.4 to v0.7.5"},{"location":"aea/upgrading/#v073-to-v074","text":"No backwards incompatible changes for skill and connection development.","title":"v0.7.3 to v0.7.4"},{"location":"aea/upgrading/#v072-to-v073","text":"No backwards incompatible changes for skill and connection development.","title":"v0.7.2 to v0.7.3"},{"location":"aea/upgrading/#v071-to-v072","text":"No backwards incompatible changes for skill and connection development.","title":"v0.7.1 to v0.7.2"},{"location":"aea/upgrading/#v070-to-v071","text":"To improve performance, in particular optimize memory usage, we refactored the Message and Dialogue classes. This means all protocols need to be bumped to the latest version or regenerated using the aea generate protocol command in the CLI .","title":"v0.7.0 to v0.7.1"},{"location":"aea/upgrading/#v063-to-v070","text":"Multiple breaking changes require action in this order: Custom configuration overrides in aea-config.yaml are now identified via public_id rather than author , name and version individually. Please replace the three fields with the equivalent public_id . Run aea upgrade command to upgrade your project's dependencies. Note, you still do have to manually update the public ids under default_routing and default_connection in aea-config.yaml as well as the public ids in the non-vendor packages. Previously, connection fetchai/stub , skill fetchai/error and protocols fetchai/default , fetchai/signing and fetchai/state_update where part of the AEA distribution. Now they need to be fetched from registry. If you create a new project with aea create then this happens automatically. For existing projects, add the dependencies explicitly if not already present. You also must update the import paths as follows: aea.connections.stub > packages.fetchai.connections.stub aea.protocols.default > packages.fetchai.protocols.default aea.protocols.signing > packages.fetchai.protocols.signing aea.protocols.state_update > packages.fetchai.protocols.state_update aea.skills.error > packages.fetchai.skills.error If you use custom protocols, regenerate them. In your own skills' __init__.py files add the public id (updating the string as appropriate): from aea.configurations.base import PublicId PUBLIC_ID = PublicId . from_str ( \"author/name:0.1.0\" ) - The fetchai/http protocol's bodyy field has been renamed to body . Skills can now specify connections as dependencies in the configuration YAML.","title":"v0.6.3 to v0.7.0"},{"location":"aea/upgrading/#v062-to-v063","text":"A new upgrade command is introduced to upgrade agent projects and components to their latest versions on the registry. To use the command first upgrade the AEA PyPI package to the latest version, then enter your project and run aea upgrade . The project's vendor dependencies will be updated where possible.","title":"v0.6.2 to v0.6.3"},{"location":"aea/upgrading/#v061-to-v062","text":"No public APIs have been changed.","title":"v0.6.1 to v0.6.2"},{"location":"aea/upgrading/#v060-to-v061","text":"The soef connection and oef_search protocol have backward incompatible changes.","title":"v0.6.0 to v0.6.1"},{"location":"aea/upgrading/#v054-to-v060","text":"","title":"v0.5.4 to v0.6.0"},{"location":"aea/upgrading/#dialogue-and-dialogues-api-updates","text":"The dialogue and dialogues APIs have changed significantly. The constructor is different for both classes and there are now four primary methods for the developer: Dialogues.create : this method is used to create a new dialogue and message: cfp_msg , fipa_dialogue = fipa_dialogues . create ( counterparty = opponent_address , performative = FipaMessage . Performative . CFP , query = query , ) The method will raise if the provided arguments are inconsistent. Dialogues.create_with_message : this method is used to create a new dialogue from a message: fipa_dialogue = fipa_dialogues . create_with_message ( counterparty = opponent_address , initial_message = cfp_msg ) The method will raise if the provided arguments are inconsistent. Dialogues.update : this method is used to handle messages passed by the framework: fipa_dialogue = fipa_dialogues . update ( message = cfp_msg ) The method will return a valid dialogue if it is a valid message, otherwise it will return None . Dialogue.reply : this method is used to reply within a dialogue: proposal_msg = fipa_dialogue . reply ( performative = FipaMessage . Performative . PROPOSE , target_message = cfp_msg , proposal = proposal , ) The method will raise if the provided arguments are inconsistent. The new methods significantly reduce the lines of code needed to maintain a dialogue. They also make it easier for the developer to construct valid dialogues and messages.","title":"Dialogue and Dialogues API updates"},{"location":"aea/upgrading/#fetchaicrypto-default-crypto","text":"The FetchAICrypto has been upgraded to the default crypto. Update your default_ledger to fetchai .","title":"FetchAICrypto - default crypto"},{"location":"aea/upgrading/#private-key-file-naming","text":"The private key files are now consistently named with the ledger_id followed by _private_key.txt (e.g. fetchai_private_key.txt ). Rename your existing files to match this pattern.","title":"Private key file naming"},{"location":"aea/upgrading/#type-in-package-yaml","text":"The package YAML files now contain a type field. This must be added for the loading mechanism to work properly.","title":"Type in package YAML"},{"location":"aea/upgrading/#moved-address-type","text":"The address type has moved to aea.common . The import paths must be updated.","title":"Moved address type"},{"location":"aea/upgrading/#v053-to-v054","text":"The contract base class was slightly modified. If you have implemented your own contract package you need to update it accordingly. The dialogue reference nonce is now randomly generated. This can result in previously working but buggy implementations (which relied on the order of dialogue reference nonces) to now fail.","title":"v0.5.3 to v0.5.4"},{"location":"aea/upgrading/#v052-to-v053","text":"Connection states and logger usage in connections where updated. If you have implemented your own connection package you need to update it accordingly. Additional dialogue consistency checks where enabled. This can result in previously working but buggy implementations to now fail.","title":"v0.5.2 to v0.5.3"},{"location":"aea/upgrading/#v051-to-052","text":"No public APIs have been changed.","title":"v0.5.1 to 0.5.2"},{"location":"aea/upgrading/#v050-to-051","text":"No public APIs have been changed.","title":"v0.5.0 to 0.5.1"},{"location":"aea/upgrading/#v041-to-050","text":"A number of breaking changes where introduced which make backwards compatibility of skills rare. Ledger APIs LedgerApis have been removed from the AEA constructor and skill context. LedgerApis are now exposed in the LedgerConnection ( fetchai/ledger ). To communicate with the LedgerApis use the fetchai/ledger_api protocol. This allows for more flexibility (anyone can add another LedgerAPI to the registry and execute it with the connection) and removes dependencies from the core framework. Skills can now depend on other skills. As a result, skills have a new required configuration field in skill.yaml files, by default empty: skills: [] .","title":"v0.4.1 to 0.5.0"},{"location":"aea/upgrading/#v040-to-v041","text":"There are no upgrade requirements if you use the CLI based approach to AEA development. Connections are now added via Resources to the AEA, not the AEA constructor directly. For programmatic usage remove the list of connections from the AEA constructor and instead add the connections to resources.","title":"v0.4.0 to v0.4.1"},{"location":"aea/upgrading/#v033-to-v040","text":"Message sending in the skills has been updated. In the past you had to construct messages, then serialize them and place them in an envelope: cfp_msg = FipaMessage ( ... ) self . context . outbox . put_message ( to = opponent_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( cfp_msg ), ) # or cfp_msg = FipaMessage ( ... ) envelope = Envelope ( to = opponent_addr , sender = self . context . agent_address , protocol_id = FipaMessage . protocol_id , message = FipaSerializer () . encode ( cfp_msg ), ) self . context . outbox . put ( envelope ) Now this has been simplified to: cfp_msg = FipaMessage ( ... ) cfp_msg . counterparty = opponent_addr self . context . outbox . put_message ( message = cfp_msg ) You must update your skills as the old implementation is no longer supported. Connection constructors have been simplified. In the past you had to implement both the `__init__` as well as the `from_config` methods of a Connection. Now you only have to implement the `__init__` method which by default at load time now receives the following keyword arguments: `configuration: ConnectionConfig, identity: Identity, crypto_store: CryptoStore`. See for example in the scaffold connection: class MyScaffoldConnection ( Connection ): \"\"\"Proxy to the functionality of the SDK or API.\"\"\" connection_id = PublicId . from_str ( \"fetchai/scaffold:0.1.0\" ) def __init__ ( self , configuration : ConnectionConfig , identity : Identity , crypto_store : CryptoStore , ): \"\"\" Initialize a connection to an SDK or API. :param configuration: the connection configuration. :param crypto_store: object to access the connection crypto objects. :param identity: the identity object. \"\"\" super () . __init__ ( configuration = configuration , crypto_store = crypto_store , identity = identity ) As a result of this feature, you are now able to pass key-pairs to your connections via the `CryptoStore`. You must update your connections as the old implementation is no longer supported.","title":"v0.3.3 to v0.4.0"},{"location":"aea/version/","text":"The latest version of the Python implementation of the AEA Framework: . The framework is under rapid development with frequent breaking changes in the run-up to version 1.0 which is due in Q1 2021. If you are upgrading your AEA project from a previous version of the AEA framework, please check out the upgrading guide . The AEA framework's implementation in Python is in principle compatible with its implementation in any other language. The language agnostic definitions describe the aspects of the framework an implementation must adhere to in order for their AEAs to be able to interact with AEAs built with other implementations of the framework.","title":"Version"},{"location":"aea/vision/","text":"Our vision is that the AEA framework enables businesses of all sizes, from single independent developers to large corporations and consortiums, to create and deploy agent-based solutions in different domains, thus contributing to and advancing a decentralized agent economy as envisaged by Fetch.ai. Open source technology for everyone We are creating infrastructure for developers to build their own agent-based solutions. AEA users include, amongst others: Data scientists Economists Researchers (Artificial Intelligence, Machine Learning, Multi-Agent Systems) Engineers Machine learning experts Independent developers Students and academics Crypto connoisseurs and enthusiasts Web developers","title":"Vision"},{"location":"aea/vision/#open-source-technology-for-everyone","text":"We are creating infrastructure for developers to build their own agent-based solutions. AEA users include, amongst others: Data scientists Economists Researchers (Artificial Intelligence, Machine Learning, Multi-Agent Systems) Engineers Machine learning experts Independent developers Students and academics Crypto connoisseurs and enthusiasts Web developers","title":"Open source technology for everyone"},{"location":"aea/wealth/","text":"To fund an AEA for testing on a test-net you need to request some test tokens from a faucet. First, make sure you have installed the crypto plugin of the target test-net. E.g. for Fetch.AI: pip install aea-ledger-fetchai And for Ethereum: pip install aea-ledger-ethereum Add a private key to the agent aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt or aea generate-key ethereum aea add-key ethereum ethereum_private_key.txt Note If you already have keys in your project, the commands will prompt you for confirmation whether or not to replace the existing keys. Using a faucet website First, print the address: aea get-address fetchai or aea get-address ethereum This will print the address to the console. Copy the address into the clipboard and request test tokens from the faucet here for Fetch.ai or here for Ethereum . It will take a while for the tokens to become available. Second, after some time, check the wealth associated with the address: aea get-wealth fetchai or aea get-wealth ethereum Using the CLI Simply generate wealth via the CLI: aea generate-wealth fetchai or aea generate-wealth ethereum Note This approach can be unreliable for non-fetchai test nets.","title":"Generating wealth"},{"location":"aea/wealth/#using-a-faucet-website","text":"First, print the address: aea get-address fetchai or aea get-address ethereum This will print the address to the console. Copy the address into the clipboard and request test tokens from the faucet here for Fetch.ai or here for Ethereum . It will take a while for the tokens to become available. Second, after some time, check the wealth associated with the address: aea get-wealth fetchai or aea get-wealth ethereum","title":"Using a faucet website"},{"location":"aea/wealth/#using-the-cli","text":"Simply generate wealth via the CLI: aea generate-wealth fetchai or aea generate-wealth ethereum Note This approach can be unreliable for non-fetchai test nets.","title":"Using the CLI"},{"location":"aea/weather-skills/","text":"The AEA weather skills demonstrate an interaction between two AEAs. The provider of weather data (the weather_station ). The buyer of weather data (the weather_client ). Discussion The scope of the specific demo is to demonstrate how to create a simple AEA with the usage of the AEA framework and a database. The weather_station AEA will read data from the database, that is populated with readings from a weather station, based on the requested dates and will deliver the data to the client upon payment. This demo does not utilize a smart contract. As a result, we interact with a ledger only to complete a transaction. You can use this AEA as an example of how to read data from a database and advertise these to possible clients. Communication This diagram shows the communication between the various entities as data is successfully sold by the weather station AEA to the client. sequenceDiagram participant Search participant Client_AEA participant Weather_AEA participant Blockchain activate Client_AEA activate Search activate Weather_AEA activate Blockchain Weather_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Weather_AEA: call_for_proposal Weather_AEA->>Client_AEA: propose Client_AEA->>Weather_AEA: accept Weather_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Weather_AEA: send_transaction_hash Weather_AEA->>Blockchain: check_transaction_status Weather_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Weather_AEA deactivate Blockchain Option 1: AEA Manager approach Follow this approach when using the AEA Manager Desktop app. Otherwise, skip and follow the CLI approach below. Preparation instructions Install the AEA Manager . Demo instructions The following steps assume you have launched the AEA Manager Desktop app. Add a new AEA called my_weather_station with public id fetchai/weather_station:0.31.0 . Add another new AEA called my_weather_client with public id fetchai/weather_client:0.32.0 . Copy the address from the my_weather_client into your clip board. Then go to the StargateWorld block explorer and request some test tokens via Get Funds . Run the my_weather_station AEA. Navigate to its logs and copy the multiaddress displayed. Navigate to the settings of the my_weather_client and under components > connection > fetchai/p2p_libp2p:0.22.0 update as follows (make sure to replace the placeholder with the multiaddress): { \"delegate_uri\" : \"127.0.0.1:11001\" , \"entry_peers\" : [ \"REPLACE_WITH_MULTI_ADDRESS_HERE\" ] , \"local_uri\" : \"127.0.0.1:9001\" , \"log_file\" : \"libp2p_node.log\" , \"public_uri\" : \"127.0.0.1:9001\" } Run the my_weather_client . In the AEA's logs, you should see the agent trading successfully. Option 2: CLI approach Follow this approach when using the aea CLI. Preparation instructions Dependencies Follow the Preliminaries and Installation sections from the AEA quick start. Demo instructions: A demo to run the same scenario but with a true ledger transaction on Fetch.ai testnet or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment. Create the weather station First, fetch the AEA that will provide weather measurements: aea fetch fetchai/weather_station:0.31.0 --alias my_weather_station cd my_weather_station aea install aea build Alternatively, create from scratch. The following steps create the weather station from scratch: aea create my_weather_station cd my_weather_station aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/weather_station:0.26.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build Create the weather client In another terminal, fetch the AEA that will query the weather station: aea fetch fetchai/weather_client:0.32.0 --alias my_weather_client cd my_weather_client aea install aea build Alternatively, create from scratch. The following steps create the weather client from scratch: aea create my_weather_client cd my_weather_client aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/weather_client:0.25.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build Add keys for the weather station AEA First, create the private key for the weather station AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Add keys and generate wealth for the weather client AEA The weather client needs to have some wealth to purchase the service from the weather station. First, create the private key for the weather client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your weather client based on the network you want to transact with. On the Fetch.ai StargateWorld network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates Run the AEAs Run both AEAs from their respective terminals. First, run the weather station AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the weather station. Then, in the weather client, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the weather client to connect to the same local agent communication network as the weather station. Then run the weather client AEA: aea run You will see that the AEAs negotiate and then transact using the selected ledger. Cleaning up When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Weather skills"},{"location":"aea/weather-skills/#discussion","text":"The scope of the specific demo is to demonstrate how to create a simple AEA with the usage of the AEA framework and a database. The weather_station AEA will read data from the database, that is populated with readings from a weather station, based on the requested dates and will deliver the data to the client upon payment. This demo does not utilize a smart contract. As a result, we interact with a ledger only to complete a transaction. You can use this AEA as an example of how to read data from a database and advertise these to possible clients.","title":"Discussion"},{"location":"aea/weather-skills/#communication","text":"This diagram shows the communication between the various entities as data is successfully sold by the weather station AEA to the client. sequenceDiagram participant Search participant Client_AEA participant Weather_AEA participant Blockchain activate Client_AEA activate Search activate Weather_AEA activate Blockchain Weather_AEA->>Search: register_service Client_AEA->>Search: search Search-->>Client_AEA: list_of_agents Client_AEA->>Weather_AEA: call_for_proposal Weather_AEA->>Client_AEA: propose Client_AEA->>Weather_AEA: accept Weather_AEA->>Client_AEA: match_accept Client_AEA->>Blockchain: transfer_funds Client_AEA->>Weather_AEA: send_transaction_hash Weather_AEA->>Blockchain: check_transaction_status Weather_AEA->>Client_AEA: send_data deactivate Client_AEA deactivate Search deactivate Weather_AEA deactivate Blockchain","title":"Communication"},{"location":"aea/weather-skills/#option-1-aea-manager-approach","text":"Follow this approach when using the AEA Manager Desktop app. Otherwise, skip and follow the CLI approach below.","title":"Option 1: AEA Manager approach"},{"location":"aea/weather-skills/#preparation-instructions","text":"Install the AEA Manager .","title":"Preparation instructions"},{"location":"aea/weather-skills/#demo-instructions","text":"The following steps assume you have launched the AEA Manager Desktop app. Add a new AEA called my_weather_station with public id fetchai/weather_station:0.31.0 . Add another new AEA called my_weather_client with public id fetchai/weather_client:0.32.0 . Copy the address from the my_weather_client into your clip board. Then go to the StargateWorld block explorer and request some test tokens via Get Funds . Run the my_weather_station AEA. Navigate to its logs and copy the multiaddress displayed. Navigate to the settings of the my_weather_client and under components > connection > fetchai/p2p_libp2p:0.22.0 update as follows (make sure to replace the placeholder with the multiaddress): { \"delegate_uri\" : \"127.0.0.1:11001\" , \"entry_peers\" : [ \"REPLACE_WITH_MULTI_ADDRESS_HERE\" ] , \"local_uri\" : \"127.0.0.1:9001\" , \"log_file\" : \"libp2p_node.log\" , \"public_uri\" : \"127.0.0.1:9001\" } Run the my_weather_client . In the AEA's logs, you should see the agent trading successfully.","title":"Demo instructions"},{"location":"aea/weather-skills/#option-2-cli-approach","text":"Follow this approach when using the aea CLI.","title":"Option 2: CLI approach"},{"location":"aea/weather-skills/#preparation-instructions_1","text":"","title":"Preparation instructions"},{"location":"aea/weather-skills/#dependencies","text":"Follow the Preliminaries and Installation sections from the AEA quick start.","title":"Dependencies"},{"location":"aea/weather-skills/#demo-instructions_1","text":"A demo to run the same scenario but with a true ledger transaction on Fetch.ai testnet or Ethereum ropsten network. This demo assumes the buyer trusts the seller AEA to send the data upon successful payment.","title":"Demo instructions:"},{"location":"aea/weather-skills/#create-the-weather-station","text":"First, fetch the AEA that will provide weather measurements: aea fetch fetchai/weather_station:0.31.0 --alias my_weather_station cd my_weather_station aea install aea build Alternatively, create from scratch. The following steps create the weather station from scratch: aea create my_weather_station cd my_weather_station aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/weather_station:0.26.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build","title":"Create the weather station"},{"location":"aea/weather-skills/#create-the-weather-client","text":"In another terminal, fetch the AEA that will query the weather station: aea fetch fetchai/weather_client:0.32.0 --alias my_weather_client cd my_weather_client aea install aea build Alternatively, create from scratch. The following steps create the weather client from scratch: aea create my_weather_client cd my_weather_client aea add connection fetchai/p2p_libp2p:0.25.0 aea add connection fetchai/soef:0.26.0 aea add connection fetchai/ledger:0.19.0 aea add skill fetchai/weather_client:0.25.0 aea config set --type dict agent.dependencies \\ '{ \"aea-ledger-fetchai\": {\"version\": \"<2.0.0,>=1.0.0\"} }' aea config set agent.default_connection fetchai/p2p_libp2p:0.25.0 aea config set --type dict agent.default_routing \\ '{ \"fetchai/ledger_api:1.0.0\": \"fetchai/ledger:0.19.0\", \"fetchai/oef_search:1.0.0\": \"fetchai/soef:0.26.0\" }' aea install aea build","title":"Create the weather client"},{"location":"aea/weather-skills/#add-keys-for-the-weather-station-aea","text":"First, create the private key for the weather station AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys for the weather station AEA"},{"location":"aea/weather-skills/#add-keys-and-generate-wealth-for-the-weather-client-aea","text":"The weather client needs to have some wealth to purchase the service from the weather station. First, create the private key for the weather client AEA based on the network you want to transact. To generate and add a private-public key pair for Fetch.ai StargateWorld use: aea generate-key fetchai aea add-key fetchai fetchai_private_key.txt Then, create some wealth for your weather client based on the network you want to transact with. On the Fetch.ai StargateWorld network: aea generate-wealth fetchai Next, create a private key used to secure the AEA's communications: aea generate-key fetchai fetchai_connection_private_key.txt aea add-key fetchai fetchai_connection_private_key.txt --connection Finally, certify the key for use by the connections that request that: aea issue-certificates","title":"Add keys and generate wealth for the weather client AEA"},{"location":"aea/weather-skills/#run-the-aeas","text":"Run both AEAs from their respective terminals. First, run the weather station AEA: aea run Once you see a message of the form To join its network use multiaddr 'SOME_ADDRESS' take note of the address. (Alternatively, use aea get-multiaddress fetchai -c -i fetchai/p2p_libp2p:0.25.0 -u public_uri to retrieve the address.) This is the entry peer address for the local agent communication network created by the weather station. Then, in the weather client, run this command (replace SOME_ADDRESS with the correct value as described above): aea config set --type dict vendor.fetchai.connections.p2p_libp2p.config \\ '{ \"delegate_uri\": \"127.0.0.1:11001\", \"entry_peers\": [\"SOME_ADDRESS\"], \"local_uri\": \"127.0.0.1:9001\", \"log_file\": \"libp2p_node.log\", \"public_uri\": \"127.0.0.1:9001\" }' This allows the weather client to connect to the same local agent communication network as the weather station. Then run the weather client AEA: aea run You will see that the AEAs negotiate and then transact using the selected ledger.","title":"Run the AEAs"},{"location":"aea/weather-skills/#cleaning-up","text":"When you're done, go up a level and delete the AEAs. cd .. aea delete my_weather_station aea delete my_weather_client","title":"Cleaning up"},{"location":"aea/api/abstract_agent/","text":"aea.abstract _ agent This module contains the interface definition of the abstract agent. AbstractAgent Objects class AbstractAgent ( ABC ) This class provides an abstract base interface for an agent. name | @abstractproperty | name () -> str Get agent's name. storage _ uri | @abstractproperty | storage_uri () -> Optional [ str ] Return storage uri. start | @abstractmethod | start () -> None Start the agent. Returns : None stop | @abstractmethod | stop () -> None Stop the agent. Returns : None setup | @abstractmethod | setup () -> None Set up the agent. Returns : None act | @abstractmethod | act () -> None Perform actions on period. Returns : None handle _ envelope | @abstractmethod | handle_envelope ( envelope : Envelope ) -> None Handle an envelope. Arguments : envelope : the envelope to handle. Returns : None get _ periodic _ tasks | @abstractmethod | get_periodic_tasks () -> Dict [ Callable , Tuple [ float , Optional [ datetime . datetime ]]] Get all periodic tasks for agent. Returns : dict of callable with period specified get _ message _ handlers | @abstractmethod | get_message_handlers () -> List [ Tuple [ Callable [[ Any ], None ], Callable ]] Get handlers with message getters. Returns : List of tuples of callables: handler and coroutine to get a message exception _ handler | @abstractmethod | exception_handler ( exception : Exception , function : Callable ) -> Optional [ bool ] Handle exception raised during agent main loop execution. Arguments : exception : exception raised function : a callable exception raised in. Returns : skip exception if True, otherwise re-raise it teardown | @abstractmethod | teardown () -> None Tear down the agent. Returns : None","title":"AbstractAgent"},{"location":"aea/api/abstract_agent/#aeaabstract_agent","text":"This module contains the interface definition of the abstract agent.","title":"aea.abstract_agent"},{"location":"aea/api/abstract_agent/#abstractagent-objects","text":"class AbstractAgent ( ABC ) This class provides an abstract base interface for an agent.","title":"AbstractAgent Objects"},{"location":"aea/api/abstract_agent/#name","text":"| @abstractproperty | name () -> str Get agent's name.","title":"name"},{"location":"aea/api/abstract_agent/#storage_uri","text":"| @abstractproperty | storage_uri () -> Optional [ str ] Return storage uri.","title":"storage_uri"},{"location":"aea/api/abstract_agent/#start","text":"| @abstractmethod | start () -> None Start the agent. Returns : None","title":"start"},{"location":"aea/api/abstract_agent/#stop","text":"| @abstractmethod | stop () -> None Stop the agent. Returns : None","title":"stop"},{"location":"aea/api/abstract_agent/#setup","text":"| @abstractmethod | setup () -> None Set up the agent. Returns : None","title":"setup"},{"location":"aea/api/abstract_agent/#act","text":"| @abstractmethod | act () -> None Perform actions on period. Returns : None","title":"act"},{"location":"aea/api/abstract_agent/#handle_envelope","text":"| @abstractmethod | handle_envelope ( envelope : Envelope ) -> None Handle an envelope. Arguments : envelope : the envelope to handle. Returns : None","title":"handle_envelope"},{"location":"aea/api/abstract_agent/#get_periodic_tasks","text":"| @abstractmethod | get_periodic_tasks () -> Dict [ Callable , Tuple [ float , Optional [ datetime . datetime ]]] Get all periodic tasks for agent. Returns : dict of callable with period specified","title":"get_periodic_tasks"},{"location":"aea/api/abstract_agent/#get_message_handlers","text":"| @abstractmethod | get_message_handlers () -> List [ Tuple [ Callable [[ Any ], None ], Callable ]] Get handlers with message getters. Returns : List of tuples of callables: handler and coroutine to get a message","title":"get_message_handlers"},{"location":"aea/api/abstract_agent/#exception_handler","text":"| @abstractmethod | exception_handler ( exception : Exception , function : Callable ) -> Optional [ bool ] Handle exception raised during agent main loop execution. Arguments : exception : exception raised function : a callable exception raised in. Returns : skip exception if True, otherwise re-raise it","title":"exception_handler"},{"location":"aea/api/abstract_agent/#teardown","text":"| @abstractmethod | teardown () -> None Tear down the agent. Returns : None","title":"teardown"},{"location":"aea/api/aea/","text":"aea.aea This module contains the implementation of an autonomous economic agent (AEA). AEA Objects class AEA ( Agent ) This class implements an autonomous economic agent. __ init __ | __init__ ( identity : Identity , wallet : Wallet , resources : Resources , data_dir : str , loop : Optional [ AbstractEventLoop ] = None , period : float = 0.05 , execution_timeout : float = 0 , max_reactions : int = 20 , error_handler_class : Optional [ Type [ AbstractErrorHandler ]] = None , error_handler_config : Optional [ Dict [ str , Any ]] = None , decision_maker_handler_class : Optional [ Type [ DecisionMakerHandler ]] = None , decision_maker_handler_config : Optional [ Dict [ str , Any ]] = None , skill_exception_policy : ExceptionPolicyEnum = ExceptionPolicyEnum . propagate , connection_exception_policy : ExceptionPolicyEnum = ExceptionPolicyEnum . propagate , loop_mode : Optional [ str ] = None , runtime_mode : Optional [ str ] = None , default_ledger : Optional [ str ] = None , currency_denominations : Optional [ Dict [ str , str ]] = None , default_connection : Optional [ PublicId ] = None , default_routing : Optional [ Dict [ PublicId , PublicId ]] = None , connection_ids : Optional [ Collection [ PublicId ]] = None , search_service_address : str = DEFAULT_SEARCH_SERVICE_ADDRESS , storage_uri : Optional [ str ] = None , task_manager_mode : Optional [ str ] = None , ** kwargs : Any , ,) -> None Instantiate the agent. Arguments : identity : the identity of the agent wallet : the wallet of the agent. resources : the resources (protocols and skills) of the agent. data_dir : directory where to put local files. loop : the event loop to run the connections. period : period to call agent's act execution_timeout : amount of time to limit single act/handle to execute. max_reactions : the processing rate of envelopes per tick (i.e. single loop). error_handler_class : the class implementing the error handler error_handler_config : the configuration of the error handler decision_maker_handler_class : the class implementing the decision maker handler to be used. decision_maker_handler_config : the configuration of the decision maker handler skill_exception_policy : the skill exception policy enum connection_exception_policy : the connection exception policy enum loop_mode : loop_mode to choose agent run loop. runtime_mode : runtime mode (async, threaded) to run AEA in. default_ledger : default ledger id currency_denominations : mapping from ledger id to currency denomination default_connection : public id to the default connection default_routing : dictionary for default routing. connection_ids : active connection ids. Default: consider all the ones in the resources. search_service_address : the address of the search service used. storage_uri : optional uri to set generic storage task_manager_mode : task manager mode (threaded) to run tasks with. kwargs : keyword arguments to be attached in the agent context namespace. get _ build _ dir | @classmethod | get_build_dir ( cls ) -> str Get agent build directory. context | @property | context () -> AgentContext Get (agent) context. resources | @property | resources () -> Resources Get resources. resources | @resources . setter | resources ( resources : \"Resources\" ) -> None Set resources. filter | @property | filter () -> Filter Get the filter. active _ behaviours | @property | active_behaviours () -> List [ Behaviour ] Get all active behaviours to use in act. setup | setup () -> None Set up the agent. Calls setup() on the resources. act | act () -> None Perform actions. Adds new handlers and behaviours for use/execution by the runtime. handle _ envelope | handle_envelope ( envelope : Envelope ) -> None Handle an envelope. Performs the following: fetching the protocol referenced by the envelope, and handling if the protocol is unsupported, using the error handler, or handling if there is a decoding error, using the error handler, or handling if no active handler is available for the specified protocol, using the error handler, or handling the message recovered from the envelope with all active handlers for the specified protocol. Arguments : envelope : the envelope to handle. Returns : None get _ periodic _ tasks | get_periodic_tasks () -> Dict [ Callable , Tuple [ float , Optional [ datetime . datetime ]]] Get all periodic tasks for agent. Returns : dict of callable with period specified get _ message _ handlers | get_message_handlers () -> List [ Tuple [ Callable [[ Any ], None ], Callable ]] Get handlers with message getters. Returns : List of tuples of callables: handler and coroutine to get a message exception _ handler | exception_handler ( exception : Exception , function : Callable ) -> bool Handle exception raised during agent main loop execution. Arguments : exception : exception raised function : a callable exception raised in. Returns : bool, propagate exception if True otherwise skip it. teardown | teardown () -> None Tear down the agent. Performs the following: tears down the resources. get _ task _ result | get_task_result ( task_id : int ) -> AsyncResult Get the result from a task. Arguments : task_id : the id of the task Returns : async result for task_id enqueue _ task | enqueue_task ( func : Callable , args : Sequence = (), kwargs : Optional [ Dict [ str , Any ]] = None ) -> int Enqueue a task with the task manager. Arguments : func : the callable instance to be enqueued args : the positional arguments to be passed to the function. kwargs : the keyword arguments to be passed to the function. Returns : the task id to get the the result.","title":"AEA"},{"location":"aea/api/aea/#aeaaea","text":"This module contains the implementation of an autonomous economic agent (AEA).","title":"aea.aea"},{"location":"aea/api/aea/#aea-objects","text":"class AEA ( Agent ) This class implements an autonomous economic agent.","title":"AEA Objects"},{"location":"aea/api/aea/#__init__","text":"| __init__ ( identity : Identity , wallet : Wallet , resources : Resources , data_dir : str , loop : Optional [ AbstractEventLoop ] = None , period : float = 0.05 , execution_timeout : float = 0 , max_reactions : int = 20 , error_handler_class : Optional [ Type [ AbstractErrorHandler ]] = None , error_handler_config : Optional [ Dict [ str , Any ]] = None , decision_maker_handler_class : Optional [ Type [ DecisionMakerHandler ]] = None , decision_maker_handler_config : Optional [ Dict [ str , Any ]] = None , skill_exception_policy : ExceptionPolicyEnum = ExceptionPolicyEnum . propagate , connection_exception_policy : ExceptionPolicyEnum = ExceptionPolicyEnum . propagate , loop_mode : Optional [ str ] = None , runtime_mode : Optional [ str ] = None , default_ledger : Optional [ str ] = None , currency_denominations : Optional [ Dict [ str , str ]] = None , default_connection : Optional [ PublicId ] = None , default_routing : Optional [ Dict [ PublicId , PublicId ]] = None , connection_ids : Optional [ Collection [ PublicId ]] = None , search_service_address : str = DEFAULT_SEARCH_SERVICE_ADDRESS , storage_uri : Optional [ str ] = None , task_manager_mode : Optional [ str ] = None , ** kwargs : Any , ,) -> None Instantiate the agent. Arguments : identity : the identity of the agent wallet : the wallet of the agent. resources : the resources (protocols and skills) of the agent. data_dir : directory where to put local files. loop : the event loop to run the connections. period : period to call agent's act execution_timeout : amount of time to limit single act/handle to execute. max_reactions : the processing rate of envelopes per tick (i.e. single loop). error_handler_class : the class implementing the error handler error_handler_config : the configuration of the error handler decision_maker_handler_class : the class implementing the decision maker handler to be used. decision_maker_handler_config : the configuration of the decision maker handler skill_exception_policy : the skill exception policy enum connection_exception_policy : the connection exception policy enum loop_mode : loop_mode to choose agent run loop. runtime_mode : runtime mode (async, threaded) to run AEA in. default_ledger : default ledger id currency_denominations : mapping from ledger id to currency denomination default_connection : public id to the default connection default_routing : dictionary for default routing. connection_ids : active connection ids. Default: consider all the ones in the resources. search_service_address : the address of the search service used. storage_uri : optional uri to set generic storage task_manager_mode : task manager mode (threaded) to run tasks with. kwargs : keyword arguments to be attached in the agent context namespace.","title":"__init__"},{"location":"aea/api/aea/#get_build_dir","text":"| @classmethod | get_build_dir ( cls ) -> str Get agent build directory.","title":"get_build_dir"},{"location":"aea/api/aea/#context","text":"| @property | context () -> AgentContext Get (agent) context.","title":"context"},{"location":"aea/api/aea/#resources","text":"| @property | resources () -> Resources Get resources.","title":"resources"},{"location":"aea/api/aea/#resources_1","text":"| @resources . setter | resources ( resources : \"Resources\" ) -> None Set resources.","title":"resources"},{"location":"aea/api/aea/#filter","text":"| @property | filter () -> Filter Get the filter.","title":"filter"},{"location":"aea/api/aea/#active_behaviours","text":"| @property | active_behaviours () -> List [ Behaviour ] Get all active behaviours to use in act.","title":"active_behaviours"},{"location":"aea/api/aea/#setup","text":"| setup () -> None Set up the agent. Calls setup() on the resources.","title":"setup"},{"location":"aea/api/aea/#act","text":"| act () -> None Perform actions. Adds new handlers and behaviours for use/execution by the runtime.","title":"act"},{"location":"aea/api/aea/#handle_envelope","text":"| handle_envelope ( envelope : Envelope ) -> None Handle an envelope. Performs the following: fetching the protocol referenced by the envelope, and handling if the protocol is unsupported, using the error handler, or handling if there is a decoding error, using the error handler, or handling if no active handler is available for the specified protocol, using the error handler, or handling the message recovered from the envelope with all active handlers for the specified protocol. Arguments : envelope : the envelope to handle. Returns : None","title":"handle_envelope"},{"location":"aea/api/aea/#get_periodic_tasks","text":"| get_periodic_tasks () -> Dict [ Callable , Tuple [ float , Optional [ datetime . datetime ]]] Get all periodic tasks for agent. Returns : dict of callable with period specified","title":"get_periodic_tasks"},{"location":"aea/api/aea/#get_message_handlers","text":"| get_message_handlers () -> List [ Tuple [ Callable [[ Any ], None ], Callable ]] Get handlers with message getters. Returns : List of tuples of callables: handler and coroutine to get a message","title":"get_message_handlers"},{"location":"aea/api/aea/#exception_handler","text":"| exception_handler ( exception : Exception , function : Callable ) -> bool Handle exception raised during agent main loop execution. Arguments : exception : exception raised function : a callable exception raised in. Returns : bool, propagate exception if True otherwise skip it.","title":"exception_handler"},{"location":"aea/api/aea/#teardown","text":"| teardown () -> None Tear down the agent. Performs the following: tears down the resources.","title":"teardown"},{"location":"aea/api/aea/#get_task_result","text":"| get_task_result ( task_id : int ) -> AsyncResult Get the result from a task. Arguments : task_id : the id of the task Returns : async result for task_id","title":"get_task_result"},{"location":"aea/api/aea/#enqueue_task","text":"| enqueue_task ( func : Callable , args : Sequence = (), kwargs : Optional [ Dict [ str , Any ]] = None ) -> int Enqueue a task with the task manager. Arguments : func : the callable instance to be enqueued args : the positional arguments to be passed to the function. kwargs : the keyword arguments to be passed to the function. Returns : the task id to get the the result.","title":"enqueue_task"},{"location":"aea/api/aea_builder/","text":"aea.aea _ builder This module contains utilities for building an AEA. _ DependenciesManager Objects class _DependenciesManager () Class to manage dependencies of agent packages. __ init __ | __init__ () -> None Initialize the dependency graph. all _ dependencies | @property | all_dependencies () -> Set [ ComponentId ] Get all dependencies. dependencies _ highest _ version | @property | dependencies_highest_version () -> Set [ ComponentId ] Get the dependencies with highest version. get _ components _ by _ type | get_components_by_type ( component_type : ComponentType ) -> Dict [ ComponentId , ComponentConfiguration ] Get the components by type. protocols | @property | protocols () -> Dict [ ComponentId , ProtocolConfig ] Get the protocols. connections | @property | connections () -> Dict [ ComponentId , ConnectionConfig ] Get the connections. skills | @property | skills () -> Dict [ ComponentId , SkillConfig ] Get the skills. contracts | @property | contracts () -> Dict [ ComponentId , ContractConfig ] Get the contracts. add _ component | add_component ( configuration : ComponentConfiguration ) -> None Add a component to the dependency manager. Arguments : configuration : the component configuration to add. remove _ component | remove_component ( component_id : ComponentId ) -> None Remove a component. Arguments : component_id : the component id Raises : ValueError : if some component depends on this package. pypi _ dependencies | @property | pypi_dependencies () -> Dependencies Get all the PyPI dependencies. We currently consider only dependency that have the default PyPI index url and that specify only the version field. Returns : the merged PyPI dependencies install _ dependencies | install_dependencies () -> None Install extra dependencies for components. AEABuilder Objects class AEABuilder ( WithLogger ) This class helps to build an AEA. It follows the fluent interface. Every method of the builder returns the instance of the builder itself. Note: the method 'build()' is guaranteed of being re-entrant with respect to the 'add_component(path)' method. That is, you can invoke the building method many times against the same builder instance, and the returned agent instance will not share the components with other agents, e.g.: builder = AEABuilder() builder.add_component(...) ... first call my_aea_1 = builder.build() following agents will have different components. my_aea_2 = builder.build() # all good However, if you manually loaded some of the components and added them with the method 'add_component_instance()', then calling build more than one time is prevented: builder = AEABuilder() builder.add_component_instance(...) ... # other initialization code first call my_aea_1 = builder.build() second call to build() would raise a Value Error. call reset builder.reset() re-add the component and private keys builder.add_component_instance(...) ... # add private keys second call my_aea_2 = builder.builder() __ init __ | __init__ ( with_default_packages : bool = True , registry_dir : str = DEFAULT_REGISTRY_NAME , build_dir_root : Optional [ str ] = None ) -> None Initialize the builder. Arguments : with_default_packages : add the default packages. registry_dir : the registry directory. build_dir_root : the root of the build directory. reset | reset ( is_full_reset : bool = False ) -> None Reset the builder. A full reset causes a reset of all data on the builder. A partial reset only resets: - name, - private keys, and - component instances Arguments : is_full_reset : whether it is a full reset or not. set _ period | set_period ( period : Optional [ float ]) -> \"AEABuilder\" Set agent act period. Arguments : period : period in seconds Returns : self set _ execution _ timeout | set_execution_timeout ( execution_timeout : Optional [ float ]) -> \"AEABuilder\" Set agent execution timeout in seconds. Arguments : execution_timeout : execution_timeout in seconds Returns : self set _ max _ reactions | set_max_reactions ( max_reactions : Optional [ int ]) -> \"AEABuilder\" Set agent max reaction in one react. Arguments : max_reactions : int Returns : self set _ decision _ maker _ handler _ details | set_decision_maker_handler_details ( decision_maker_handler_dotted_path : str , file_path : str , config : Dict [ str , Any ]) -> \"AEABuilder\" Set error handler details. Arguments : decision_maker_handler_dotted_path : the dotted path to the decision maker handler file_path : the file path to the file which contains the decision maker handler config : the configuration passed to the decision maker handler on instantiation Returns : self set _ error _ handler _ details | set_error_handler_details ( error_handler_dotted_path : str , file_path : str , config : Dict [ str , Any ]) -> \"AEABuilder\" Set error handler details. Arguments : error_handler_dotted_path : the dotted path to the error handler file_path : the file path to the file which contains the error handler config : the configuration passed to the error handler on instantiation Returns : self set _ skill _ exception _ policy | set_skill_exception_policy ( skill_exception_policy : Optional [ ExceptionPolicyEnum ]) -> \"AEABuilder\" Set skill exception policy. Arguments : skill_exception_policy : the policy Returns : self set _ connection _ exception _ policy | set_connection_exception_policy ( connection_exception_policy : Optional [ ExceptionPolicyEnum ]) -> \"AEABuilder\" Set connection exception policy. Arguments : connection_exception_policy : the policy Returns : self set _ default _ routing | set_default_routing ( default_routing : Dict [ PublicId , PublicId ]) -> \"AEABuilder\" Set default routing. This is a map from public ids (protocols) to public ids (connections). Arguments : default_routing : the default routing mapping Returns : self set _ loop _ mode | set_loop_mode ( loop_mode : Optional [ str ]) -> \"AEABuilder\" Set the loop mode. Arguments : loop_mode : the agent loop mode Returns : self set _ runtime _ mode | set_runtime_mode ( runtime_mode : Optional [ str ]) -> \"AEABuilder\" Set the runtime mode. Arguments : runtime_mode : the agent runtime mode Returns : self set _ task _ manager _ mode | set_task_manager_mode ( task_manager_mode : Optional [ str ]) -> \"AEABuilder\" Set the task_manager_mode. Arguments : task_manager_mode : the agent task_manager_mode Returns : self set _ storage _ uri | set_storage_uri ( storage_uri : Optional [ str ]) -> \"AEABuilder\" Set the storage uri. Arguments : storage_uri : storage uri Returns : self set _ data _ dir | set_data_dir ( data_dir : Optional [ str ]) -> \"AEABuilder\" Set the data directory. Arguments : data_dir : path to directory where to store data. Returns : self set _ logging _ config | set_logging_config ( logging_config : Dict ) -> \"AEABuilder\" Set the logging configurations. The dictionary must satisfy the following schema: https://docs.python.org/3/library/logging.config.html#logging-config-dictschema Arguments : logging_config : the logging configurations. Returns : self set _ search _ service _ address | set_search_service_address ( search_service_address : str ) -> \"AEABuilder\" Set the search service address. Arguments : search_service_address : the search service address Returns : self set _ name | set_name ( name : str ) -> \"AEABuilder\" Set the name of the agent. Arguments : name : the name of the agent. Returns : the AEABuilder set _ default _ connection | set_default_connection ( public_id : Optional [ PublicId ] = None ) -> \"AEABuilder\" Set the default connection. Arguments : public_id : the public id of the default connection package. Returns : the AEABuilder add _ private _ key | add_private_key ( identifier : str , private_key_path : Optional [ PathLike ] = None , is_connection : bool = False ) -> \"AEABuilder\" Add a private key path. Arguments : identifier : the identifier for that private key path. private_key_path : an (optional) path to the private key file. If None, the key will be created at build time. is_connection : if the pair is for the connection cryptos Returns : the AEABuilder remove _ private _ key | remove_private_key ( identifier : str , is_connection : bool = False ) -> \"AEABuilder\" Remove a private key path by identifier, if present. Arguments : identifier : the identifier of the private key. is_connection : if the pair is for the connection cryptos Returns : the AEABuilder private _ key _ paths | @property | private_key_paths () -> Dict [ str , Optional [ str ]] Get the private key paths. connection _ private _ key _ paths | @property | connection_private_key_paths () -> Dict [ str , Optional [ str ]] Get the connection private key paths. set _ default _ ledger | set_default_ledger ( identifier : Optional [ str ]) -> \"AEABuilder\" Set a default ledger API to use. Arguments : identifier : the identifier of the ledger api Returns : the AEABuilder set _ required _ ledgers | set_required_ledgers ( required_ledgers : Optional [ List [ str ]]) -> \"AEABuilder\" Set the required ledger identifiers. These are the ledgers for which the AEA requires a key pair. Arguments : required_ledgers : the required ledgers. Returns : the AEABuilder. set _ build _ entrypoint | set_build_entrypoint ( build_entrypoint : Optional [ str ]) -> \"AEABuilder\" Set build entrypoint. Arguments : build_entrypoint : path to the builder script. Returns : the AEABuilder set _ currency _ denominations | set_currency_denominations ( currency_denominations : Dict [ str , str ]) -> \"AEABuilder\" Set the mapping from ledger ids to currency denominations. Arguments : currency_denominations : the mapping Returns : the AEABuilder add _ component | add_component ( component_type : ComponentType , directory : PathLike , skip_consistency_check : bool = False ) -> \"AEABuilder\" Add a component, given its type and the directory. Arguments : component_type : the component type. directory : the directory path. skip_consistency_check : if True, the consistency check are skipped. Raises : AEAException : if a component is already registered with the same component id. # noqa: DAR402 | or if there's a missing dependency. # noqa: DAR402 Returns : the AEABuilder add _ component _ instance | add_component_instance ( component : Component ) -> \"AEABuilder\" Add already initialized component object to resources or connections. Please, pay attention, all dependencies have to be already loaded. Notice also that this will make the call to 'build()' non re-entrant. You will have to reset() the builder before calling build() again. Arguments : component : Component instance already initialized. Returns : self set _ context _ namespace | set_context_namespace ( context_namespace : Dict [ str , Any ]) -> \"AEABuilder\" Set the context namespace. set _ agent _ pypi _ dependencies | set_agent_pypi_dependencies ( dependencies : Dependencies ) -> \"AEABuilder\" Set agent PyPI dependencies. Arguments : dependencies : PyPI dependencies for the agent. Returns : the AEABuilder. remove _ component | remove_component ( component_id : ComponentId ) -> \"AEABuilder\" Remove a component. Arguments : component_id : the public id of the component. Returns : the AEABuilder add _ protocol | add_protocol ( directory : PathLike ) -> \"AEABuilder\" Add a protocol to the agent. Arguments : directory : the path to the protocol directory Returns : the AEABuilder remove _ protocol | remove_protocol ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the protocol Returns : the AEABuilder add _ connection | add_connection ( directory : PathLike ) -> \"AEABuilder\" Add a connection to the agent. Arguments : directory : the path to the connection directory Returns : the AEABuilder remove _ connection | remove_connection ( public_id : PublicId ) -> \"AEABuilder\" Remove a connection. Arguments : public_id : the public id of the connection Returns : the AEABuilder add _ skill | add_skill ( directory : PathLike ) -> \"AEABuilder\" Add a skill to the agent. Arguments : directory : the path to the skill directory Returns : the AEABuilder remove _ skill | remove_skill ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the skill Returns : the AEABuilder add _ contract | add_contract ( directory : PathLike ) -> \"AEABuilder\" Add a contract to the agent. Arguments : directory : the path to the contract directory Returns : the AEABuilder remove _ contract | remove_contract ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the contract Returns : the AEABuilder call _ all _ build _ entrypoints | call_all_build_entrypoints () -> None Call all the build entrypoints. get _ build _ root _ directory | get_build_root_directory () -> str Get build directory root. run _ build _ for _ component _ configuration | @classmethod | run_build_for_component_configuration ( cls , config : ComponentConfiguration , logger : Optional [ logging . Logger ] = None ) -> None Run a build entrypoint script for component configuration. install _ pypi _ dependencies | install_pypi_dependencies () -> None Install components extra dependencies. build | build ( connection_ids : Optional [ Collection [ PublicId ]] = None , password : Optional [ str ] = None ) -> AEA Build the AEA. This method is re-entrant only if the components have been added through the method 'add_component'. If some of them have been loaded with 'add_component_instance', it can be called only once, and further calls are only possible after a call to 'reset' and re-loading of the components added via 'add_component_instance' and the private keys. Arguments : connection_ids : select only these connections to run the AEA. password : the password to encrypt/decrypt the private key. Returns : the AEA object. get _ default _ ledger | get_default_ledger () -> str Return default ledger. Returns : the default ledger identifier. get _ required _ ledgers | get_required_ledgers () -> List [ str ] Get the required ledger identifiers. These are the ledgers for which the AEA requires a key pair. Returns : the list of required ledgers. try _ to _ load _ agent _ configuration _ file | @classmethod | try_to_load_agent_configuration_file ( cls , aea_project_path : Union [ str , Path ]) -> AgentConfig Try to load the agent configuration file.. set _ from _ configuration | set_from_configuration ( agent_configuration : AgentConfig , aea_project_path : Path , skip_consistency_check : bool = False ) -> None Set builder variables from AgentConfig. Arguments : agent_configuration : AgentConfig to get values from. aea_project_path : PathLike root directory of the agent project. skip_consistency_check : if True, the consistency check are skipped. from _ aea _ project | @classmethod | from_aea_project ( cls , aea_project_path : PathLike , skip_consistency_check : bool = False , password : Optional [ str ] = None ) -> \"AEABuilder\" Construct the builder from an AEA project. load agent configuration file set name and default configurations load private keys load ledger API configurations set default ledger load every component Arguments : aea_project_path : path to the AEA project. skip_consistency_check : if True, the consistency check are skipped. password : the password to encrypt/decrypt private keys. Returns : an AEABuilder. get _ configuration _ file _ path | @staticmethod | get_configuration_file_path ( aea_project_path : Union [ Path , str ]) -> Path Return path to aea-config file for the given aea project path. make _ component _ logger make_component_logger ( configuration : ComponentConfiguration , agent_name : str ) -> Optional [ logging . Logger ] Make the logger for a component. Arguments : configuration : the component configuration agent_name : the agent name Returns : the logger.","title":"AEA Builder"},{"location":"aea/api/aea_builder/#aeaaea_builder","text":"This module contains utilities for building an AEA.","title":"aea.aea_builder"},{"location":"aea/api/aea_builder/#_dependenciesmanager-objects","text":"class _DependenciesManager () Class to manage dependencies of agent packages.","title":"_DependenciesManager Objects"},{"location":"aea/api/aea_builder/#__init__","text":"| __init__ () -> None Initialize the dependency graph.","title":"__init__"},{"location":"aea/api/aea_builder/#all_dependencies","text":"| @property | all_dependencies () -> Set [ ComponentId ] Get all dependencies.","title":"all_dependencies"},{"location":"aea/api/aea_builder/#dependencies_highest_version","text":"| @property | dependencies_highest_version () -> Set [ ComponentId ] Get the dependencies with highest version.","title":"dependencies_highest_version"},{"location":"aea/api/aea_builder/#get_components_by_type","text":"| get_components_by_type ( component_type : ComponentType ) -> Dict [ ComponentId , ComponentConfiguration ] Get the components by type.","title":"get_components_by_type"},{"location":"aea/api/aea_builder/#protocols","text":"| @property | protocols () -> Dict [ ComponentId , ProtocolConfig ] Get the protocols.","title":"protocols"},{"location":"aea/api/aea_builder/#connections","text":"| @property | connections () -> Dict [ ComponentId , ConnectionConfig ] Get the connections.","title":"connections"},{"location":"aea/api/aea_builder/#skills","text":"| @property | skills () -> Dict [ ComponentId , SkillConfig ] Get the skills.","title":"skills"},{"location":"aea/api/aea_builder/#contracts","text":"| @property | contracts () -> Dict [ ComponentId , ContractConfig ] Get the contracts.","title":"contracts"},{"location":"aea/api/aea_builder/#add_component","text":"| add_component ( configuration : ComponentConfiguration ) -> None Add a component to the dependency manager. Arguments : configuration : the component configuration to add.","title":"add_component"},{"location":"aea/api/aea_builder/#remove_component","text":"| remove_component ( component_id : ComponentId ) -> None Remove a component. Arguments : component_id : the component id Raises : ValueError : if some component depends on this package.","title":"remove_component"},{"location":"aea/api/aea_builder/#pypi_dependencies","text":"| @property | pypi_dependencies () -> Dependencies Get all the PyPI dependencies. We currently consider only dependency that have the default PyPI index url and that specify only the version field. Returns : the merged PyPI dependencies","title":"pypi_dependencies"},{"location":"aea/api/aea_builder/#install_dependencies","text":"| install_dependencies () -> None Install extra dependencies for components.","title":"install_dependencies"},{"location":"aea/api/aea_builder/#aeabuilder-objects","text":"class AEABuilder ( WithLogger ) This class helps to build an AEA. It follows the fluent interface. Every method of the builder returns the instance of the builder itself. Note: the method 'build()' is guaranteed of being re-entrant with respect to the 'add_component(path)' method. That is, you can invoke the building method many times against the same builder instance, and the returned agent instance will not share the components with other agents, e.g.: builder = AEABuilder() builder.add_component(...) ...","title":"AEABuilder Objects"},{"location":"aea/api/aea_builder/#first-call","text":"my_aea_1 = builder.build()","title":"first call"},{"location":"aea/api/aea_builder/#following-agents-will-have-different-components","text":"my_aea_2 = builder.build() # all good However, if you manually loaded some of the components and added them with the method 'add_component_instance()', then calling build more than one time is prevented: builder = AEABuilder() builder.add_component_instance(...) ... # other initialization code","title":"following agents will have different components."},{"location":"aea/api/aea_builder/#first-call_1","text":"my_aea_1 = builder.build()","title":"first call"},{"location":"aea/api/aea_builder/#second-call-to-build-would-raise-a-value-error","text":"","title":"second call to build() would raise a Value Error."},{"location":"aea/api/aea_builder/#call-reset","text":"builder.reset()","title":"call reset"},{"location":"aea/api/aea_builder/#re-add-the-component-and-private-keys","text":"builder.add_component_instance(...) ... # add private keys","title":"re-add the component and private keys"},{"location":"aea/api/aea_builder/#second-call","text":"my_aea_2 = builder.builder()","title":"second call"},{"location":"aea/api/aea_builder/#__init___1","text":"| __init__ ( with_default_packages : bool = True , registry_dir : str = DEFAULT_REGISTRY_NAME , build_dir_root : Optional [ str ] = None ) -> None Initialize the builder. Arguments : with_default_packages : add the default packages. registry_dir : the registry directory. build_dir_root : the root of the build directory.","title":"__init__"},{"location":"aea/api/aea_builder/#reset","text":"| reset ( is_full_reset : bool = False ) -> None Reset the builder. A full reset causes a reset of all data on the builder. A partial reset only resets: - name, - private keys, and - component instances Arguments : is_full_reset : whether it is a full reset or not.","title":"reset"},{"location":"aea/api/aea_builder/#set_period","text":"| set_period ( period : Optional [ float ]) -> \"AEABuilder\" Set agent act period. Arguments : period : period in seconds Returns : self","title":"set_period"},{"location":"aea/api/aea_builder/#set_execution_timeout","text":"| set_execution_timeout ( execution_timeout : Optional [ float ]) -> \"AEABuilder\" Set agent execution timeout in seconds. Arguments : execution_timeout : execution_timeout in seconds Returns : self","title":"set_execution_timeout"},{"location":"aea/api/aea_builder/#set_max_reactions","text":"| set_max_reactions ( max_reactions : Optional [ int ]) -> \"AEABuilder\" Set agent max reaction in one react. Arguments : max_reactions : int Returns : self","title":"set_max_reactions"},{"location":"aea/api/aea_builder/#set_decision_maker_handler_details","text":"| set_decision_maker_handler_details ( decision_maker_handler_dotted_path : str , file_path : str , config : Dict [ str , Any ]) -> \"AEABuilder\" Set error handler details. Arguments : decision_maker_handler_dotted_path : the dotted path to the decision maker handler file_path : the file path to the file which contains the decision maker handler config : the configuration passed to the decision maker handler on instantiation Returns : self","title":"set_decision_maker_handler_details"},{"location":"aea/api/aea_builder/#set_error_handler_details","text":"| set_error_handler_details ( error_handler_dotted_path : str , file_path : str , config : Dict [ str , Any ]) -> \"AEABuilder\" Set error handler details. Arguments : error_handler_dotted_path : the dotted path to the error handler file_path : the file path to the file which contains the error handler config : the configuration passed to the error handler on instantiation Returns : self","title":"set_error_handler_details"},{"location":"aea/api/aea_builder/#set_skill_exception_policy","text":"| set_skill_exception_policy ( skill_exception_policy : Optional [ ExceptionPolicyEnum ]) -> \"AEABuilder\" Set skill exception policy. Arguments : skill_exception_policy : the policy Returns : self","title":"set_skill_exception_policy"},{"location":"aea/api/aea_builder/#set_connection_exception_policy","text":"| set_connection_exception_policy ( connection_exception_policy : Optional [ ExceptionPolicyEnum ]) -> \"AEABuilder\" Set connection exception policy. Arguments : connection_exception_policy : the policy Returns : self","title":"set_connection_exception_policy"},{"location":"aea/api/aea_builder/#set_default_routing","text":"| set_default_routing ( default_routing : Dict [ PublicId , PublicId ]) -> \"AEABuilder\" Set default routing. This is a map from public ids (protocols) to public ids (connections). Arguments : default_routing : the default routing mapping Returns : self","title":"set_default_routing"},{"location":"aea/api/aea_builder/#set_loop_mode","text":"| set_loop_mode ( loop_mode : Optional [ str ]) -> \"AEABuilder\" Set the loop mode. Arguments : loop_mode : the agent loop mode Returns : self","title":"set_loop_mode"},{"location":"aea/api/aea_builder/#set_runtime_mode","text":"| set_runtime_mode ( runtime_mode : Optional [ str ]) -> \"AEABuilder\" Set the runtime mode. Arguments : runtime_mode : the agent runtime mode Returns : self","title":"set_runtime_mode"},{"location":"aea/api/aea_builder/#set_task_manager_mode","text":"| set_task_manager_mode ( task_manager_mode : Optional [ str ]) -> \"AEABuilder\" Set the task_manager_mode. Arguments : task_manager_mode : the agent task_manager_mode Returns : self","title":"set_task_manager_mode"},{"location":"aea/api/aea_builder/#set_storage_uri","text":"| set_storage_uri ( storage_uri : Optional [ str ]) -> \"AEABuilder\" Set the storage uri. Arguments : storage_uri : storage uri Returns : self","title":"set_storage_uri"},{"location":"aea/api/aea_builder/#set_data_dir","text":"| set_data_dir ( data_dir : Optional [ str ]) -> \"AEABuilder\" Set the data directory. Arguments : data_dir : path to directory where to store data. Returns : self","title":"set_data_dir"},{"location":"aea/api/aea_builder/#set_logging_config","text":"| set_logging_config ( logging_config : Dict ) -> \"AEABuilder\" Set the logging configurations. The dictionary must satisfy the following schema: https://docs.python.org/3/library/logging.config.html#logging-config-dictschema Arguments : logging_config : the logging configurations. Returns : self","title":"set_logging_config"},{"location":"aea/api/aea_builder/#set_search_service_address","text":"| set_search_service_address ( search_service_address : str ) -> \"AEABuilder\" Set the search service address. Arguments : search_service_address : the search service address Returns : self","title":"set_search_service_address"},{"location":"aea/api/aea_builder/#set_name","text":"| set_name ( name : str ) -> \"AEABuilder\" Set the name of the agent. Arguments : name : the name of the agent. Returns : the AEABuilder","title":"set_name"},{"location":"aea/api/aea_builder/#set_default_connection","text":"| set_default_connection ( public_id : Optional [ PublicId ] = None ) -> \"AEABuilder\" Set the default connection. Arguments : public_id : the public id of the default connection package. Returns : the AEABuilder","title":"set_default_connection"},{"location":"aea/api/aea_builder/#add_private_key","text":"| add_private_key ( identifier : str , private_key_path : Optional [ PathLike ] = None , is_connection : bool = False ) -> \"AEABuilder\" Add a private key path. Arguments : identifier : the identifier for that private key path. private_key_path : an (optional) path to the private key file. If None, the key will be created at build time. is_connection : if the pair is for the connection cryptos Returns : the AEABuilder","title":"add_private_key"},{"location":"aea/api/aea_builder/#remove_private_key","text":"| remove_private_key ( identifier : str , is_connection : bool = False ) -> \"AEABuilder\" Remove a private key path by identifier, if present. Arguments : identifier : the identifier of the private key. is_connection : if the pair is for the connection cryptos Returns : the AEABuilder","title":"remove_private_key"},{"location":"aea/api/aea_builder/#private_key_paths","text":"| @property | private_key_paths () -> Dict [ str , Optional [ str ]] Get the private key paths.","title":"private_key_paths"},{"location":"aea/api/aea_builder/#connection_private_key_paths","text":"| @property | connection_private_key_paths () -> Dict [ str , Optional [ str ]] Get the connection private key paths.","title":"connection_private_key_paths"},{"location":"aea/api/aea_builder/#set_default_ledger","text":"| set_default_ledger ( identifier : Optional [ str ]) -> \"AEABuilder\" Set a default ledger API to use. Arguments : identifier : the identifier of the ledger api Returns : the AEABuilder","title":"set_default_ledger"},{"location":"aea/api/aea_builder/#set_required_ledgers","text":"| set_required_ledgers ( required_ledgers : Optional [ List [ str ]]) -> \"AEABuilder\" Set the required ledger identifiers. These are the ledgers for which the AEA requires a key pair. Arguments : required_ledgers : the required ledgers. Returns : the AEABuilder.","title":"set_required_ledgers"},{"location":"aea/api/aea_builder/#set_build_entrypoint","text":"| set_build_entrypoint ( build_entrypoint : Optional [ str ]) -> \"AEABuilder\" Set build entrypoint. Arguments : build_entrypoint : path to the builder script. Returns : the AEABuilder","title":"set_build_entrypoint"},{"location":"aea/api/aea_builder/#set_currency_denominations","text":"| set_currency_denominations ( currency_denominations : Dict [ str , str ]) -> \"AEABuilder\" Set the mapping from ledger ids to currency denominations. Arguments : currency_denominations : the mapping Returns : the AEABuilder","title":"set_currency_denominations"},{"location":"aea/api/aea_builder/#add_component_1","text":"| add_component ( component_type : ComponentType , directory : PathLike , skip_consistency_check : bool = False ) -> \"AEABuilder\" Add a component, given its type and the directory. Arguments : component_type : the component type. directory : the directory path. skip_consistency_check : if True, the consistency check are skipped. Raises : AEAException : if a component is already registered with the same component id. # noqa: DAR402 | or if there's a missing dependency. # noqa: DAR402 Returns : the AEABuilder","title":"add_component"},{"location":"aea/api/aea_builder/#add_component_instance","text":"| add_component_instance ( component : Component ) -> \"AEABuilder\" Add already initialized component object to resources or connections. Please, pay attention, all dependencies have to be already loaded. Notice also that this will make the call to 'build()' non re-entrant. You will have to reset() the builder before calling build() again. Arguments : component : Component instance already initialized. Returns : self","title":"add_component_instance"},{"location":"aea/api/aea_builder/#set_context_namespace","text":"| set_context_namespace ( context_namespace : Dict [ str , Any ]) -> \"AEABuilder\" Set the context namespace.","title":"set_context_namespace"},{"location":"aea/api/aea_builder/#set_agent_pypi_dependencies","text":"| set_agent_pypi_dependencies ( dependencies : Dependencies ) -> \"AEABuilder\" Set agent PyPI dependencies. Arguments : dependencies : PyPI dependencies for the agent. Returns : the AEABuilder.","title":"set_agent_pypi_dependencies"},{"location":"aea/api/aea_builder/#remove_component_1","text":"| remove_component ( component_id : ComponentId ) -> \"AEABuilder\" Remove a component. Arguments : component_id : the public id of the component. Returns : the AEABuilder","title":"remove_component"},{"location":"aea/api/aea_builder/#add_protocol","text":"| add_protocol ( directory : PathLike ) -> \"AEABuilder\" Add a protocol to the agent. Arguments : directory : the path to the protocol directory Returns : the AEABuilder","title":"add_protocol"},{"location":"aea/api/aea_builder/#remove_protocol","text":"| remove_protocol ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the protocol Returns : the AEABuilder","title":"remove_protocol"},{"location":"aea/api/aea_builder/#add_connection","text":"| add_connection ( directory : PathLike ) -> \"AEABuilder\" Add a connection to the agent. Arguments : directory : the path to the connection directory Returns : the AEABuilder","title":"add_connection"},{"location":"aea/api/aea_builder/#remove_connection","text":"| remove_connection ( public_id : PublicId ) -> \"AEABuilder\" Remove a connection. Arguments : public_id : the public id of the connection Returns : the AEABuilder","title":"remove_connection"},{"location":"aea/api/aea_builder/#add_skill","text":"| add_skill ( directory : PathLike ) -> \"AEABuilder\" Add a skill to the agent. Arguments : directory : the path to the skill directory Returns : the AEABuilder","title":"add_skill"},{"location":"aea/api/aea_builder/#remove_skill","text":"| remove_skill ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the skill Returns : the AEABuilder","title":"remove_skill"},{"location":"aea/api/aea_builder/#add_contract","text":"| add_contract ( directory : PathLike ) -> \"AEABuilder\" Add a contract to the agent. Arguments : directory : the path to the contract directory Returns : the AEABuilder","title":"add_contract"},{"location":"aea/api/aea_builder/#remove_contract","text":"| remove_contract ( public_id : PublicId ) -> \"AEABuilder\" Remove protocol. Arguments : public_id : the public id of the contract Returns : the AEABuilder","title":"remove_contract"},{"location":"aea/api/aea_builder/#call_all_build_entrypoints","text":"| call_all_build_entrypoints () -> None Call all the build entrypoints.","title":"call_all_build_entrypoints"},{"location":"aea/api/aea_builder/#get_build_root_directory","text":"| get_build_root_directory () -> str Get build directory root.","title":"get_build_root_directory"},{"location":"aea/api/aea_builder/#run_build_for_component_configuration","text":"| @classmethod | run_build_for_component_configuration ( cls , config : ComponentConfiguration , logger : Optional [ logging . Logger ] = None ) -> None Run a build entrypoint script for component configuration.","title":"run_build_for_component_configuration"},{"location":"aea/api/aea_builder/#install_pypi_dependencies","text":"| install_pypi_dependencies () -> None Install components extra dependencies.","title":"install_pypi_dependencies"},{"location":"aea/api/aea_builder/#build","text":"| build ( connection_ids : Optional [ Collection [ PublicId ]] = None , password : Optional [ str ] = None ) -> AEA Build the AEA. This method is re-entrant only if the components have been added through the method 'add_component'. If some of them have been loaded with 'add_component_instance', it can be called only once, and further calls are only possible after a call to 'reset' and re-loading of the components added via 'add_component_instance' and the private keys. Arguments : connection_ids : select only these connections to run the AEA. password : the password to encrypt/decrypt the private key. Returns : the AEA object.","title":"build"},{"location":"aea/api/aea_builder/#get_default_ledger","text":"| get_default_ledger () -> str Return default ledger. Returns : the default ledger identifier.","title":"get_default_ledger"},{"location":"aea/api/aea_builder/#get_required_ledgers","text":"| get_required_ledgers () -> List [ str ] Get the required ledger identifiers. These are the ledgers for which the AEA requires a key pair. Returns : the list of required ledgers.","title":"get_required_ledgers"},{"location":"aea/api/aea_builder/#try_to_load_agent_configuration_file","text":"| @classmethod | try_to_load_agent_configuration_file ( cls , aea_project_path : Union [ str , Path ]) -> AgentConfig Try to load the agent configuration file..","title":"try_to_load_agent_configuration_file"},{"location":"aea/api/aea_builder/#set_from_configuration","text":"| set_from_configuration ( agent_configuration : AgentConfig , aea_project_path : Path , skip_consistency_check : bool = False ) -> None Set builder variables from AgentConfig. Arguments : agent_configuration : AgentConfig to get values from. aea_project_path : PathLike root directory of the agent project. skip_consistency_check : if True, the consistency check are skipped.","title":"set_from_configuration"},{"location":"aea/api/aea_builder/#from_aea_project","text":"| @classmethod | from_aea_project ( cls , aea_project_path : PathLike , skip_consistency_check : bool = False , password : Optional [ str ] = None ) -> \"AEABuilder\" Construct the builder from an AEA project. load agent configuration file set name and default configurations load private keys load ledger API configurations set default ledger load every component Arguments : aea_project_path : path to the AEA project. skip_consistency_check : if True, the consistency check are skipped. password : the password to encrypt/decrypt private keys. Returns : an AEABuilder.","title":"from_aea_project"},{"location":"aea/api/aea_builder/#get_configuration_file_path","text":"| @staticmethod | get_configuration_file_path ( aea_project_path : Union [ Path , str ]) -> Path Return path to aea-config file for the given aea project path.","title":"get_configuration_file_path"},{"location":"aea/api/aea_builder/#make_component_logger","text":"make_component_logger ( configuration : ComponentConfiguration , agent_name : str ) -> Optional [ logging . Logger ] Make the logger for a component. Arguments : configuration : the component configuration agent_name : the agent name Returns : the logger.","title":"make_component_logger"},{"location":"aea/api/agent/","text":"aea.agent This module contains the implementation of a generic agent. Agent Objects class Agent ( AbstractAgent , WithLogger ) This class provides an abstract base class for a generic agent. __ init __ | __init__ ( identity : Identity , connections : List [ Connection ], loop : Optional [ AbstractEventLoop ] = None , period : float = 1.0 , loop_mode : Optional [ str ] = None , runtime_mode : Optional [ str ] = None , storage_uri : Optional [ str ] = None , logger : Logger = _default_logger , task_manager_mode : Optional [ str ] = None ) -> None Instantiate the agent. Arguments : identity : the identity of the agent. connections : the list of connections of the agent. loop : the event loop to run the connections. period : period to call agent's act loop_mode : loop_mode to choose agent run loop. runtime_mode : runtime mode to up agent. storage_uri : optional uri to set generic storage task_manager_mode : task manager mode. logger : the logger. task_manager_mode : mode of the task manager. storage _ uri | @property | storage_uri () -> Optional [ str ] Return storage uri. is _ running | @property | is_running () -> bool Get running state of the runtime and agent. is _ stopped | @property | is_stopped () -> bool Get running state of the runtime and agent. identity | @property | identity () -> Identity Get the identity. inbox | @property | inbox () -> InBox Get the inbox. The inbox contains Envelopes from the Multiplexer. The agent can pick these messages for processing. Returns : InBox instance outbox | @property | outbox () -> OutBox Get the outbox. The outbox contains Envelopes for the Multiplexer. Envelopes placed in the Outbox are processed by the Multiplexer. Returns : OutBox instance name | @property | name () -> str Get the agent name. tick | @property | tick () -> int Get the tick or agent loop count. Each agent loop (one call to each one of act(), react(), update()) increments the tick. Returns : tick count state | @property | state () -> RuntimeStates Get state of the agent's runtime. Returns : RuntimeStates period | @property | period () -> float Get a period to call act. runtime | @property | runtime () -> BaseRuntime Get the runtime. setup | setup () -> None Set up the agent. start | start () -> None Start the agent. Performs the following: calls start() on runtime. waits for runtime to complete running (blocking) handle _ envelope | handle_envelope ( envelope : Envelope ) -> None Handle an envelope. Arguments : envelope : the envelope to handle. act | act () -> None Perform actions on period. stop | stop () -> None Stop the agent. Performs the following: calls stop() on runtime waits for runtime to stop (blocking) teardown | teardown () -> None Tear down the agent. get _ periodic _ tasks | get_periodic_tasks () -> Dict [ Callable , Tuple [ float , Optional [ datetime . datetime ]]] Get all periodic tasks for agent. Returns : dict of callable with period specified get _ message _ handlers | get_message_handlers () -> List [ Tuple [ Callable [[ Any ], None ], Callable ]] Get handlers with message getters. Returns : List of tuples of callables: handler and coroutine to get a message exception _ handler | exception_handler ( exception : Exception , function : Callable ) -> bool Handle exception raised during agent main loop execution. Arguments : exception : exception raised function : a callable exception raised in. Returns : bool, propagate exception if True otherwise skip it.","title":"Agent"},{"location":"aea/api/agent/#aeaagent","text":"This module contains the implementation of a generic agent.","title":"aea.agent"},{"location":"aea/api/agent/#agent-objects","text":"class Agent ( AbstractAgent , WithLogger ) This class provides an abstract base class for a generic agent.","title":"Agent Objects"},{"location":"aea/api/agent/#__init__","text":"| __init__ ( identity : Identity , connections : List [ Connection ], loop : Optional [ AbstractEventLoop ] = None , period : float = 1.0 , loop_mode : Optional [ str ] = None , runtime_mode : Optional [ str ] = None , storage_uri : Optional [ str ] = None , logger : Logger = _default_logger , task_manager_mode : Optional [ str ] = None ) -> None Instantiate the agent. Arguments : identity : the identity of the agent. connections : the list of connections of the agent. loop : the event loop to run the connections. period : period to call agent's act loop_mode : loop_mode to choose agent run loop. runtime_mode : runtime mode to up agent. storage_uri : optional uri to set generic storage task_manager_mode : task manager mode. logger : the logger. task_manager_mode : mode of the task manager.","title":"__init__"},{"location":"aea/api/agent/#storage_uri","text":"| @property | storage_uri () -> Optional [ str ] Return storage uri.","title":"storage_uri"},{"location":"aea/api/agent/#is_running","text":"| @property | is_running () -> bool Get running state of the runtime and agent.","title":"is_running"},{"location":"aea/api/agent/#is_stopped","text":"| @property | is_stopped () -> bool Get running state of the runtime and agent.","title":"is_stopped"},{"location":"aea/api/agent/#identity","text":"| @property | identity () -> Identity Get the identity.","title":"identity"},{"location":"aea/api/agent/#inbox","text":"| @property | inbox () -> InBox Get the inbox. The inbox contains Envelopes from the Multiplexer. The agent can pick these messages for processing. Returns : InBox instance","title":"inbox"},{"location":"aea/api/agent/#outbox","text":"| @property | outbox () -> OutBox Get the outbox. The outbox contains Envelopes for the Multiplexer. Envelopes placed in the Outbox are processed by the Multiplexer. Returns : OutBox instance","title":"outbox"},{"location":"aea/api/agent/#name","text":"| @property | name () -> str Get the agent name.","title":"name"},{"location":"aea/api/agent/#tick","text":"| @property | tick () -> int Get the tick or agent loop count. Each agent loop (one call to each one of act(), react(), update()) increments the tick. Returns : tick count","title":"tick"},{"location":"aea/api/agent/#state","text":"| @property | state () -> RuntimeStates Get state of the agent's runtime. Returns : RuntimeStates","title":"state"},{"location":"aea/api/agent/#period","text":"| @property | period () -> float Get a period to call act.","title":"period"},{"location":"aea/api/agent/#runtime","text":"| @property | runtime () -> BaseRuntime Get the runtime.","title":"runtime"},{"location":"aea/api/agent/#setup","text":"| setup () -> None Set up the agent.","title":"setup"},{"location":"aea/api/agent/#start","text":"| start () -> None Start the agent. Performs the following: calls start() on runtime. waits for runtime to complete running (blocking)","title":"start"},{"location":"aea/api/agent/#handle_envelope","text":"| handle_envelope ( envelope : Envelope ) -> None Handle an envelope. Arguments : envelope : the envelope to handle.","title":"handle_envelope"},{"location":"aea/api/agent/#act","text":"| act () -> None Perform actions on period.","title":"act"},{"location":"aea/api/agent/#stop","text":"| stop () -> None Stop the agent. Performs the following: calls stop() on runtime waits for runtime to stop (blocking)","title":"stop"},{"location":"aea/api/agent/#teardown","text":"| teardown () -> None Tear down the agent.","title":"teardown"},{"location":"aea/api/agent/#get_periodic_tasks","text":"| get_periodic_tasks () -> Dict [ Callable , Tuple [ float , Optional [ datetime . datetime ]]] Get all periodic tasks for agent. Returns : dict of callable with period specified","title":"get_periodic_tasks"},{"location":"aea/api/agent/#get_message_handlers","text":"| get_message_handlers () -> List [ Tuple [ Callable [[ Any ], None ], Callable ]] Get handlers with message getters. Returns : List of tuples of callables: handler and coroutine to get a message","title":"get_message_handlers"},{"location":"aea/api/agent/#exception_handler","text":"| exception_handler ( exception : Exception , function : Callable ) -> bool Handle exception raised during agent main loop execution. Arguments : exception : exception raised function : a callable exception raised in. Returns : bool, propagate exception if True otherwise skip it.","title":"exception_handler"},{"location":"aea/api/agent_loop/","text":"aea.agent _ loop This module contains the implementation of an agent loop using asyncio. AgentLoopException Objects class AgentLoopException ( AEAException ) Exception for agent loop runtime errors. AgentLoopStates Objects class AgentLoopStates ( Enum ) Internal agent loop states. BaseAgentLoop Objects class BaseAgentLoop ( Runnable , WithLogger , ABC ) Base abstract agent loop class. __ init __ | __init__ ( agent : AbstractAgent , loop : Optional [ AbstractEventLoop ] = None , threaded : bool = False ) -> None Init loop. Arguments : agent : Agent or AEA to run. loop : optional asyncio event loop. if not specified a new loop will be created. threaded : if True, run in threaded mode, else async agent | @property | agent () -> AbstractAgent Get agent. state | @property | state () -> AgentLoopStates Get current main loop state. wait _ state | async wait_state ( state_or_states : Union [ Any , Sequence [ Any ]]) -> Tuple [ Any , Any ] Wait state to be set. Arguments : state_or_states : state or list of states. Returns : tuple of previous state and new state. is _ running | @property | is_running () -> bool Get running state of the loop. set _ loop | set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loop related objects. run | async run () -> None Run agent loop. send _ to _ skill | @abstractmethod | send_to_skill ( message_or_envelope : Union [ Message , Envelope ], context : Optional [ EnvelopeContext ] = None ) -> None Send message or envelope to another skill. If message passed it will be wrapped into envelope with optional envelope context. Arguments : message_or_envelope : envelope to send to another skill. context : envelope context skill2skill _ queue | @property | @abstractmethod | skill2skill_queue () -> Queue Get skill to skill message queue. AsyncAgentLoop Objects class AsyncAgentLoop ( BaseAgentLoop ) Asyncio based agent loop suitable only for AEA. __ init __ | __init__ ( agent : AbstractAgent , loop : AbstractEventLoop = None , threaded : bool = False ) -> None Init agent loop. Arguments : agent : AEA instance loop : asyncio loop to use. optional threaded : is a new thread to be started for the agent loop skill2skill _ queue | @property | skill2skill_queue () -> Queue Get skill to skill message queue. send _ to _ skill | send_to_skill ( message_or_envelope : Union [ Message , Envelope ], context : Optional [ EnvelopeContext ] = None ) -> None Send message or envelope to another skill. If message passed it will be wrapped into envelope with optional envelope context. Arguments : message_or_envelope : envelope to send to another skill. context : envelope context","title":"Agent Loop"},{"location":"aea/api/agent_loop/#aeaagent_loop","text":"This module contains the implementation of an agent loop using asyncio.","title":"aea.agent_loop"},{"location":"aea/api/agent_loop/#agentloopexception-objects","text":"class AgentLoopException ( AEAException ) Exception for agent loop runtime errors.","title":"AgentLoopException Objects"},{"location":"aea/api/agent_loop/#agentloopstates-objects","text":"class AgentLoopStates ( Enum ) Internal agent loop states.","title":"AgentLoopStates Objects"},{"location":"aea/api/agent_loop/#baseagentloop-objects","text":"class BaseAgentLoop ( Runnable , WithLogger , ABC ) Base abstract agent loop class.","title":"BaseAgentLoop Objects"},{"location":"aea/api/agent_loop/#__init__","text":"| __init__ ( agent : AbstractAgent , loop : Optional [ AbstractEventLoop ] = None , threaded : bool = False ) -> None Init loop. Arguments : agent : Agent or AEA to run. loop : optional asyncio event loop. if not specified a new loop will be created. threaded : if True, run in threaded mode, else async","title":"__init__"},{"location":"aea/api/agent_loop/#agent","text":"| @property | agent () -> AbstractAgent Get agent.","title":"agent"},{"location":"aea/api/agent_loop/#state","text":"| @property | state () -> AgentLoopStates Get current main loop state.","title":"state"},{"location":"aea/api/agent_loop/#wait_state","text":"| async wait_state ( state_or_states : Union [ Any , Sequence [ Any ]]) -> Tuple [ Any , Any ] Wait state to be set. Arguments : state_or_states : state or list of states. Returns : tuple of previous state and new state.","title":"wait_state"},{"location":"aea/api/agent_loop/#is_running","text":"| @property | is_running () -> bool Get running state of the loop.","title":"is_running"},{"location":"aea/api/agent_loop/#set_loop","text":"| set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loop related objects.","title":"set_loop"},{"location":"aea/api/agent_loop/#run","text":"| async run () -> None Run agent loop.","title":"run"},{"location":"aea/api/agent_loop/#send_to_skill","text":"| @abstractmethod | send_to_skill ( message_or_envelope : Union [ Message , Envelope ], context : Optional [ EnvelopeContext ] = None ) -> None Send message or envelope to another skill. If message passed it will be wrapped into envelope with optional envelope context. Arguments : message_or_envelope : envelope to send to another skill. context : envelope context","title":"send_to_skill"},{"location":"aea/api/agent_loop/#skill2skill_queue","text":"| @property | @abstractmethod | skill2skill_queue () -> Queue Get skill to skill message queue.","title":"skill2skill_queue"},{"location":"aea/api/agent_loop/#asyncagentloop-objects","text":"class AsyncAgentLoop ( BaseAgentLoop ) Asyncio based agent loop suitable only for AEA.","title":"AsyncAgentLoop Objects"},{"location":"aea/api/agent_loop/#__init___1","text":"| __init__ ( agent : AbstractAgent , loop : AbstractEventLoop = None , threaded : bool = False ) -> None Init agent loop. Arguments : agent : AEA instance loop : asyncio loop to use. optional threaded : is a new thread to be started for the agent loop","title":"__init__"},{"location":"aea/api/agent_loop/#skill2skill_queue_1","text":"| @property | skill2skill_queue () -> Queue Get skill to skill message queue.","title":"skill2skill_queue"},{"location":"aea/api/agent_loop/#send_to_skill_1","text":"| send_to_skill ( message_or_envelope : Union [ Message , Envelope ], context : Optional [ EnvelopeContext ] = None ) -> None Send message or envelope to another skill. If message passed it will be wrapped into envelope with optional envelope context. Arguments : message_or_envelope : envelope to send to another skill. context : envelope context","title":"send_to_skill"},{"location":"aea/api/common/","text":"aea.common This module contains the common types and interfaces used in the aea framework.","title":"Common"},{"location":"aea/api/common/#aeacommon","text":"This module contains the common types and interfaces used in the aea framework.","title":"aea.common"},{"location":"aea/api/exceptions/","text":"aea.exceptions Exceptions for the AEA package. AEAException Objects class AEAException ( Exception ) User-defined exception for the AEA framework. AEAPackageLoadingError Objects class AEAPackageLoadingError ( AEAException ) Class for exceptions that are raised for loading errors of AEA packages. AEASetupError Objects class AEASetupError ( AEAException ) Class for exceptions that are raised for setup errors of AEA packages. AEATeardownError Objects class AEATeardownError ( AEAException ) Class for exceptions that are raised for teardown errors of AEA packages. AEAActException Objects class AEAActException ( AEAException ) Class for exceptions that are raised for act errors of AEA packages. AEAHandleException Objects class AEAHandleException ( AEAException ) Class for exceptions that are raised for handler errors of AEA packages. AEAInstantiationException Objects class AEAInstantiationException ( AEAException ) Class for exceptions that are raised for instantiation errors of AEA packages. AEAPluginError Objects class AEAPluginError ( AEAException ) Class for exceptions that are raised for wrong plugin setup of the working set. AEAEnforceError Objects class AEAEnforceError ( AEAException ) Class for enforcement errors. AEAValidationError Objects class AEAValidationError ( AEAException ) Class for validation errors of an AEA. AEAComponentLoadException Objects class AEAComponentLoadException ( AEAException ) Class for component loading errors of an AEA. AEAWalletNoAddressException Objects class AEAWalletNoAddressException ( AEAException ) Class for attempts to instantiate a wallet without addresses. _ StopRuntime Objects class _StopRuntime ( Exception ) Exception to stop runtime. For internal usage only! Used to perform asyncio call from sync callbacks. __ init __ | __init__ ( reraise : Optional [ Exception ] = None ) -> None Init _StopRuntime exception. Arguments : reraise : exception to reraise. enforce enforce ( is_valid_condition : bool , exception_text : str , exception_class : Type [ Exception ] = AEAEnforceError ) -> None Evaluate a condition and raise an exception with the provided text if it is not satisfied. Arguments : is_valid_condition : the valid condition exception_text : the exception to be raised exception_class : the class of exception parse _ exception parse_exception ( exception : Exception , limit : int = - 1 ) -> str Parse an exception to get the relevant lines. Arguments : exception : the exception to be parsed limit : the limit Returns : exception as string","title":"Exceptions"},{"location":"aea/api/exceptions/#aeaexceptions","text":"Exceptions for the AEA package.","title":"aea.exceptions"},{"location":"aea/api/exceptions/#aeaexception-objects","text":"class AEAException ( Exception ) User-defined exception for the AEA framework.","title":"AEAException Objects"},{"location":"aea/api/exceptions/#aeapackageloadingerror-objects","text":"class AEAPackageLoadingError ( AEAException ) Class for exceptions that are raised for loading errors of AEA packages.","title":"AEAPackageLoadingError Objects"},{"location":"aea/api/exceptions/#aeasetuperror-objects","text":"class AEASetupError ( AEAException ) Class for exceptions that are raised for setup errors of AEA packages.","title":"AEASetupError Objects"},{"location":"aea/api/exceptions/#aeateardownerror-objects","text":"class AEATeardownError ( AEAException ) Class for exceptions that are raised for teardown errors of AEA packages.","title":"AEATeardownError Objects"},{"location":"aea/api/exceptions/#aeaactexception-objects","text":"class AEAActException ( AEAException ) Class for exceptions that are raised for act errors of AEA packages.","title":"AEAActException Objects"},{"location":"aea/api/exceptions/#aeahandleexception-objects","text":"class AEAHandleException ( AEAException ) Class for exceptions that are raised for handler errors of AEA packages.","title":"AEAHandleException Objects"},{"location":"aea/api/exceptions/#aeainstantiationexception-objects","text":"class AEAInstantiationException ( AEAException ) Class for exceptions that are raised for instantiation errors of AEA packages.","title":"AEAInstantiationException Objects"},{"location":"aea/api/exceptions/#aeapluginerror-objects","text":"class AEAPluginError ( AEAException ) Class for exceptions that are raised for wrong plugin setup of the working set.","title":"AEAPluginError Objects"},{"location":"aea/api/exceptions/#aeaenforceerror-objects","text":"class AEAEnforceError ( AEAException ) Class for enforcement errors.","title":"AEAEnforceError Objects"},{"location":"aea/api/exceptions/#aeavalidationerror-objects","text":"class AEAValidationError ( AEAException ) Class for validation errors of an AEA.","title":"AEAValidationError Objects"},{"location":"aea/api/exceptions/#aeacomponentloadexception-objects","text":"class AEAComponentLoadException ( AEAException ) Class for component loading errors of an AEA.","title":"AEAComponentLoadException Objects"},{"location":"aea/api/exceptions/#aeawalletnoaddressexception-objects","text":"class AEAWalletNoAddressException ( AEAException ) Class for attempts to instantiate a wallet without addresses.","title":"AEAWalletNoAddressException Objects"},{"location":"aea/api/exceptions/#_stopruntime-objects","text":"class _StopRuntime ( Exception ) Exception to stop runtime. For internal usage only! Used to perform asyncio call from sync callbacks.","title":"_StopRuntime Objects"},{"location":"aea/api/exceptions/#__init__","text":"| __init__ ( reraise : Optional [ Exception ] = None ) -> None Init _StopRuntime exception. Arguments : reraise : exception to reraise.","title":"__init__"},{"location":"aea/api/exceptions/#enforce","text":"enforce ( is_valid_condition : bool , exception_text : str , exception_class : Type [ Exception ] = AEAEnforceError ) -> None Evaluate a condition and raise an exception with the provided text if it is not satisfied. Arguments : is_valid_condition : the valid condition exception_text : the exception to be raised exception_class : the class of exception","title":"enforce"},{"location":"aea/api/exceptions/#parse_exception","text":"parse_exception ( exception : Exception , limit : int = - 1 ) -> str Parse an exception to get the relevant lines. Arguments : exception : the exception to be parsed limit : the limit Returns : exception as string","title":"parse_exception"},{"location":"aea/api/launcher/","text":"aea.launcher This module contains the implementation of multiple AEA configs launcher. load _ agent load_agent ( agent_dir : Union [ PathLike , str ], password : Optional [ str ] = None ) -> AEA Load AEA from directory. Arguments : agent_dir : agent configuration directory password : the password to encrypt/decrypt the private key. Returns : AEA instance AEADirTask Objects class AEADirTask ( AbstractExecutorTask ) Task to run agent from agent configuration directory. __ init __ | __init__ ( agent_dir : Union [ PathLike , str ], password : Optional [ str ] = None ) -> None Init aea config dir task. Arguments : agent_dir : directory with aea config. password : the password to encrypt/decrypt the private key. id | @property | id () -> Union [ PathLike , str ] Return agent_dir. start | start () -> None Start task. stop | stop () -> None Stop task. create _ async _ task | create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Return asyncio Task for task run in asyncio loop. AEADirMultiprocessTask Objects class AEADirMultiprocessTask ( AbstractMultiprocessExecutorTask ) Task to run agent from agent configuration directory. Version for multiprocess executor mode. __ init __ | __init__ ( agent_dir : Union [ PathLike , str ], log_level : Optional [ str ] = None , password : Optional [ str ] = None ) -> None Init aea config dir task. Arguments : agent_dir : directory with aea config. log_level : debug level applied for AEA in subprocess password : the password to encrypt/decrypt the private key. id | @property | id () -> Union [ PathLike , str ] Return agent_dir. failed | @property | failed () -> bool Return was exception failed or not. If it's running it's not failed. Returns : bool start | start () -> Tuple [ Callable , Sequence [ Any ]] Return function and arguments to call within subprocess. stop | stop () -> None Stop task. AEALauncher Objects class AEALauncher ( AbstractMultipleRunner ) Run multiple AEA instances. __ init __ | __init__ ( agent_dirs : Sequence [ Union [ PathLike , str ]], mode : str , fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate , log_level : Optional [ str ] = None , password : Optional [ str ] = None ) -> None Init AEALauncher. Arguments : agent_dirs : sequence of AEA config directories. mode : executor name to use. fail_policy : one of ExecutorExceptionPolicies to be used with Executor log_level : debug level applied for AEA in subprocesses password : the password to encrypt/decrypt the private key.","title":"Launcher"},{"location":"aea/api/launcher/#aealauncher","text":"This module contains the implementation of multiple AEA configs launcher.","title":"aea.launcher"},{"location":"aea/api/launcher/#load_agent","text":"load_agent ( agent_dir : Union [ PathLike , str ], password : Optional [ str ] = None ) -> AEA Load AEA from directory. Arguments : agent_dir : agent configuration directory password : the password to encrypt/decrypt the private key. Returns : AEA instance","title":"load_agent"},{"location":"aea/api/launcher/#aeadirtask-objects","text":"class AEADirTask ( AbstractExecutorTask ) Task to run agent from agent configuration directory.","title":"AEADirTask Objects"},{"location":"aea/api/launcher/#__init__","text":"| __init__ ( agent_dir : Union [ PathLike , str ], password : Optional [ str ] = None ) -> None Init aea config dir task. Arguments : agent_dir : directory with aea config. password : the password to encrypt/decrypt the private key.","title":"__init__"},{"location":"aea/api/launcher/#id","text":"| @property | id () -> Union [ PathLike , str ] Return agent_dir.","title":"id"},{"location":"aea/api/launcher/#start","text":"| start () -> None Start task.","title":"start"},{"location":"aea/api/launcher/#stop","text":"| stop () -> None Stop task.","title":"stop"},{"location":"aea/api/launcher/#create_async_task","text":"| create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Return asyncio Task for task run in asyncio loop.","title":"create_async_task"},{"location":"aea/api/launcher/#aeadirmultiprocesstask-objects","text":"class AEADirMultiprocessTask ( AbstractMultiprocessExecutorTask ) Task to run agent from agent configuration directory. Version for multiprocess executor mode.","title":"AEADirMultiprocessTask Objects"},{"location":"aea/api/launcher/#__init___1","text":"| __init__ ( agent_dir : Union [ PathLike , str ], log_level : Optional [ str ] = None , password : Optional [ str ] = None ) -> None Init aea config dir task. Arguments : agent_dir : directory with aea config. log_level : debug level applied for AEA in subprocess password : the password to encrypt/decrypt the private key.","title":"__init__"},{"location":"aea/api/launcher/#id_1","text":"| @property | id () -> Union [ PathLike , str ] Return agent_dir.","title":"id"},{"location":"aea/api/launcher/#failed","text":"| @property | failed () -> bool Return was exception failed or not. If it's running it's not failed. Returns : bool","title":"failed"},{"location":"aea/api/launcher/#start_1","text":"| start () -> Tuple [ Callable , Sequence [ Any ]] Return function and arguments to call within subprocess.","title":"start"},{"location":"aea/api/launcher/#stop_1","text":"| stop () -> None Stop task.","title":"stop"},{"location":"aea/api/launcher/#aealauncher-objects","text":"class AEALauncher ( AbstractMultipleRunner ) Run multiple AEA instances.","title":"AEALauncher Objects"},{"location":"aea/api/launcher/#__init___2","text":"| __init__ ( agent_dirs : Sequence [ Union [ PathLike , str ]], mode : str , fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate , log_level : Optional [ str ] = None , password : Optional [ str ] = None ) -> None Init AEALauncher. Arguments : agent_dirs : sequence of AEA config directories. mode : executor name to use. fail_policy : one of ExecutorExceptionPolicies to be used with Executor log_level : debug level applied for AEA in subprocesses password : the password to encrypt/decrypt the private key.","title":"__init__"},{"location":"aea/api/multiplexer/","text":"aea.multiplexer Module for the multiplexer class and related classes. MultiplexerStatus Objects class MultiplexerStatus ( AsyncState ) The connection status class. __ init __ | __init__ () -> None Initialize the connection status. is _ connected | @property | is_connected () -> bool Return is connected. is _ connecting | @property | is_connecting () -> bool Return is connecting. is _ disconnected | @property | is_disconnected () -> bool Return is disconnected. is _ disconnecting | @property | is_disconnecting () -> bool Return is disconnected. AsyncMultiplexer Objects class AsyncMultiplexer ( Runnable , WithLogger ) This class can handle multiple connections at once. __ init __ | __init__ ( connections : Optional [ Sequence [ Connection ]] = None , default_connection_index : int = 0 , loop : Optional [ AbstractEventLoop ] = None , exception_policy : ExceptionPolicyEnum = ExceptionPolicyEnum . propagate , threaded : bool = False , agent_name : str = \"standalone\" , default_routing : Optional [ Dict [ PublicId , PublicId ]] = None , default_connection : Optional [ PublicId ] = None , protocols : Optional [ List [ Union [ Protocol , Message ]]] = None ) -> None Initialize the connection multiplexer. Arguments : connections : a sequence of connections. default_connection_index : the index of the connection to use as default. This information is used for envelopes which don't specify any routing context. If connections is None, this parameter is ignored. loop : the event loop to run the multiplexer. If None, a new event loop is created. exception_policy : the exception policy used for connections. threaded : if True, run in threaded mode, else async agent_name : the name of the agent that owns the multiplexer, for logging purposes. default_routing : default routing map default_connection : default connection protocols : protocols used default _ connection | @property | default_connection () -> Optional [ Connection ] Get the default connection. in _ queue | @property | in_queue () -> AsyncFriendlyQueue Get the in queue. out _ queue | @property | out_queue () -> asyncio . Queue Get the out queue. connections | @property | connections () -> Tuple [ Connection , ... ] Get the connections. is _ connected | @property | is_connected () -> bool Check whether the multiplexer is processing envelopes. default _ routing | @property | default_routing () -> Dict [ PublicId , PublicId ] Get the default routing. default _ routing | @default_routing . setter | default_routing ( default_routing : Dict [ PublicId , PublicId ]) -> None Set the default routing. connection _ status | @property | connection_status () -> MultiplexerStatus Get the connection status. run | async run () -> None Run multiplexer connect and receive/send tasks. set _ loop | set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loop related objects. Arguments : loop : asyncio event loop. add _ connection | add_connection ( connection : Connection , is_default : bool = False ) -> None Add a connection to the multiplexer. Arguments : connection : the connection to add. is_default : whether the connection added should be the default one. connect | async connect () -> None Connect the multiplexer. disconnect | async disconnect () -> None Disconnect the multiplexer. get | get ( block : bool = False , timeout : Optional [ float ] = None ) -> Optional [ Envelope ] Get an envelope within a timeout. Arguments : block : make the call blocking (ignore the timeout). timeout : the timeout to wait until an envelope is received. Returns : the envelope, or None if no envelope is available within a timeout. async _ get | async async_get () -> Envelope Get an envelope async way. Returns : the envelope async _ wait | async async_wait () -> None Get an envelope async way. Returns : the envelope put | put ( envelope : Envelope ) -> None Schedule an envelope for sending it. Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function. Arguments : envelope : the envelope to be sent. Multiplexer Objects class Multiplexer ( AsyncMultiplexer ) Transit sync multiplexer for compatibility. __ init __ | __init__ ( * args : Any , ** kwargs : Any ) -> None Initialize the connection multiplexer. Arguments : args : arguments kwargs : keyword arguments set _ loop | set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loop related objects. Arguments : loop : asyncio event loop. connect | connect () -> None Connect the multiplexer. Synchronously in thread spawned if new loop created. disconnect | disconnect () -> None Disconnect the multiplexer. Also stops a dedicated thread for event loop if spawned on connect. put | put ( envelope : Envelope ) -> None Schedule an envelope for sending it. Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function. Arguments : envelope : the envelope to be sent. InBox Objects class InBox () A queue from where you can only consume envelopes. __ init __ | __init__ ( multiplexer : AsyncMultiplexer ) -> None Initialize the inbox. Arguments : multiplexer : the multiplexer empty | empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is an envelope or not get | get ( block : bool = False , timeout : Optional [ float ] = None ) -> Envelope Check for a envelope on the in queue. Arguments : block : make the call blocking (ignore the timeout). timeout : times out the block after timeout seconds. Returns : the envelope object. Raises : Empty : if the attempt to get an envelope fails. get _ nowait | get_nowait () -> Optional [ Envelope ] Check for a envelope on the in queue and wait for no time. Returns : the envelope object async _ get | async async_get () -> Envelope Check for a envelope on the in queue. Returns : the envelope object. async _ wait | async async_wait () -> None Check for a envelope on the in queue. OutBox Objects class OutBox () A queue from where you can only enqueue envelopes. __ init __ | __init__ ( multiplexer : AsyncMultiplexer ) -> None Initialize the outbox. Arguments : multiplexer : the multiplexer empty | empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is an envelope or not put | put ( envelope : Envelope ) -> None Put an envelope into the queue. Arguments : envelope : the envelope. put _ message | put_message ( message : Message , context : Optional [ EnvelopeContext ] = None ) -> None Put a message in the outbox. This constructs an envelope with the input arguments. Arguments : message : the message context : the envelope context","title":"Multiplexer"},{"location":"aea/api/multiplexer/#aeamultiplexer","text":"Module for the multiplexer class and related classes.","title":"aea.multiplexer"},{"location":"aea/api/multiplexer/#multiplexerstatus-objects","text":"class MultiplexerStatus ( AsyncState ) The connection status class.","title":"MultiplexerStatus Objects"},{"location":"aea/api/multiplexer/#__init__","text":"| __init__ () -> None Initialize the connection status.","title":"__init__"},{"location":"aea/api/multiplexer/#is_connected","text":"| @property | is_connected () -> bool Return is connected.","title":"is_connected"},{"location":"aea/api/multiplexer/#is_connecting","text":"| @property | is_connecting () -> bool Return is connecting.","title":"is_connecting"},{"location":"aea/api/multiplexer/#is_disconnected","text":"| @property | is_disconnected () -> bool Return is disconnected.","title":"is_disconnected"},{"location":"aea/api/multiplexer/#is_disconnecting","text":"| @property | is_disconnecting () -> bool Return is disconnected.","title":"is_disconnecting"},{"location":"aea/api/multiplexer/#asyncmultiplexer-objects","text":"class AsyncMultiplexer ( Runnable , WithLogger ) This class can handle multiple connections at once.","title":"AsyncMultiplexer Objects"},{"location":"aea/api/multiplexer/#__init___1","text":"| __init__ ( connections : Optional [ Sequence [ Connection ]] = None , default_connection_index : int = 0 , loop : Optional [ AbstractEventLoop ] = None , exception_policy : ExceptionPolicyEnum = ExceptionPolicyEnum . propagate , threaded : bool = False , agent_name : str = \"standalone\" , default_routing : Optional [ Dict [ PublicId , PublicId ]] = None , default_connection : Optional [ PublicId ] = None , protocols : Optional [ List [ Union [ Protocol , Message ]]] = None ) -> None Initialize the connection multiplexer. Arguments : connections : a sequence of connections. default_connection_index : the index of the connection to use as default. This information is used for envelopes which don't specify any routing context. If connections is None, this parameter is ignored. loop : the event loop to run the multiplexer. If None, a new event loop is created. exception_policy : the exception policy used for connections. threaded : if True, run in threaded mode, else async agent_name : the name of the agent that owns the multiplexer, for logging purposes. default_routing : default routing map default_connection : default connection protocols : protocols used","title":"__init__"},{"location":"aea/api/multiplexer/#default_connection","text":"| @property | default_connection () -> Optional [ Connection ] Get the default connection.","title":"default_connection"},{"location":"aea/api/multiplexer/#in_queue","text":"| @property | in_queue () -> AsyncFriendlyQueue Get the in queue.","title":"in_queue"},{"location":"aea/api/multiplexer/#out_queue","text":"| @property | out_queue () -> asyncio . Queue Get the out queue.","title":"out_queue"},{"location":"aea/api/multiplexer/#connections","text":"| @property | connections () -> Tuple [ Connection , ... ] Get the connections.","title":"connections"},{"location":"aea/api/multiplexer/#is_connected_1","text":"| @property | is_connected () -> bool Check whether the multiplexer is processing envelopes.","title":"is_connected"},{"location":"aea/api/multiplexer/#default_routing","text":"| @property | default_routing () -> Dict [ PublicId , PublicId ] Get the default routing.","title":"default_routing"},{"location":"aea/api/multiplexer/#default_routing_1","text":"| @default_routing . setter | default_routing ( default_routing : Dict [ PublicId , PublicId ]) -> None Set the default routing.","title":"default_routing"},{"location":"aea/api/multiplexer/#connection_status","text":"| @property | connection_status () -> MultiplexerStatus Get the connection status.","title":"connection_status"},{"location":"aea/api/multiplexer/#run","text":"| async run () -> None Run multiplexer connect and receive/send tasks.","title":"run"},{"location":"aea/api/multiplexer/#set_loop","text":"| set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loop related objects. Arguments : loop : asyncio event loop.","title":"set_loop"},{"location":"aea/api/multiplexer/#add_connection","text":"| add_connection ( connection : Connection , is_default : bool = False ) -> None Add a connection to the multiplexer. Arguments : connection : the connection to add. is_default : whether the connection added should be the default one.","title":"add_connection"},{"location":"aea/api/multiplexer/#connect","text":"| async connect () -> None Connect the multiplexer.","title":"connect"},{"location":"aea/api/multiplexer/#disconnect","text":"| async disconnect () -> None Disconnect the multiplexer.","title":"disconnect"},{"location":"aea/api/multiplexer/#get","text":"| get ( block : bool = False , timeout : Optional [ float ] = None ) -> Optional [ Envelope ] Get an envelope within a timeout. Arguments : block : make the call blocking (ignore the timeout). timeout : the timeout to wait until an envelope is received. Returns : the envelope, or None if no envelope is available within a timeout.","title":"get"},{"location":"aea/api/multiplexer/#async_get","text":"| async async_get () -> Envelope Get an envelope async way. Returns : the envelope","title":"async_get"},{"location":"aea/api/multiplexer/#async_wait","text":"| async async_wait () -> None Get an envelope async way. Returns : the envelope","title":"async_wait"},{"location":"aea/api/multiplexer/#put","text":"| put ( envelope : Envelope ) -> None Schedule an envelope for sending it. Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function. Arguments : envelope : the envelope to be sent.","title":"put"},{"location":"aea/api/multiplexer/#multiplexer-objects","text":"class Multiplexer ( AsyncMultiplexer ) Transit sync multiplexer for compatibility.","title":"Multiplexer Objects"},{"location":"aea/api/multiplexer/#__init___2","text":"| __init__ ( * args : Any , ** kwargs : Any ) -> None Initialize the connection multiplexer. Arguments : args : arguments kwargs : keyword arguments","title":"__init__"},{"location":"aea/api/multiplexer/#set_loop_1","text":"| set_loop ( loop : AbstractEventLoop ) -> None Set event loop and all event loop related objects. Arguments : loop : asyncio event loop.","title":"set_loop"},{"location":"aea/api/multiplexer/#connect_1","text":"| connect () -> None Connect the multiplexer. Synchronously in thread spawned if new loop created.","title":"connect"},{"location":"aea/api/multiplexer/#disconnect_1","text":"| disconnect () -> None Disconnect the multiplexer. Also stops a dedicated thread for event loop if spawned on connect.","title":"disconnect"},{"location":"aea/api/multiplexer/#put_1","text":"| put ( envelope : Envelope ) -> None Schedule an envelope for sending it. Notice that the output queue is an asyncio.Queue which uses an event loop running on a different thread than the one used in this function. Arguments : envelope : the envelope to be sent.","title":"put"},{"location":"aea/api/multiplexer/#inbox-objects","text":"class InBox () A queue from where you can only consume envelopes.","title":"InBox Objects"},{"location":"aea/api/multiplexer/#__init___3","text":"| __init__ ( multiplexer : AsyncMultiplexer ) -> None Initialize the inbox. Arguments : multiplexer : the multiplexer","title":"__init__"},{"location":"aea/api/multiplexer/#empty","text":"| empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is an envelope or not","title":"empty"},{"location":"aea/api/multiplexer/#get_1","text":"| get ( block : bool = False , timeout : Optional [ float ] = None ) -> Envelope Check for a envelope on the in queue. Arguments : block : make the call blocking (ignore the timeout). timeout : times out the block after timeout seconds. Returns : the envelope object. Raises : Empty : if the attempt to get an envelope fails.","title":"get"},{"location":"aea/api/multiplexer/#get_nowait","text":"| get_nowait () -> Optional [ Envelope ] Check for a envelope on the in queue and wait for no time. Returns : the envelope object","title":"get_nowait"},{"location":"aea/api/multiplexer/#async_get_1","text":"| async async_get () -> Envelope Check for a envelope on the in queue. Returns : the envelope object.","title":"async_get"},{"location":"aea/api/multiplexer/#async_wait_1","text":"| async async_wait () -> None Check for a envelope on the in queue.","title":"async_wait"},{"location":"aea/api/multiplexer/#outbox-objects","text":"class OutBox () A queue from where you can only enqueue envelopes.","title":"OutBox Objects"},{"location":"aea/api/multiplexer/#__init___4","text":"| __init__ ( multiplexer : AsyncMultiplexer ) -> None Initialize the outbox. Arguments : multiplexer : the multiplexer","title":"__init__"},{"location":"aea/api/multiplexer/#empty_1","text":"| empty () -> bool Check for a envelope on the in queue. Returns : boolean indicating whether there is an envelope or not","title":"empty"},{"location":"aea/api/multiplexer/#put_2","text":"| put ( envelope : Envelope ) -> None Put an envelope into the queue. Arguments : envelope : the envelope.","title":"put"},{"location":"aea/api/multiplexer/#put_message","text":"| put_message ( message : Message , context : Optional [ EnvelopeContext ] = None ) -> None Put a message in the outbox. This constructs an envelope with the input arguments. Arguments : message : the message context : the envelope context","title":"put_message"},{"location":"aea/api/runner/","text":"aea.runner This module contains the implementation of AEA multiple instances runner. AEAInstanceTask Objects class AEAInstanceTask ( AbstractExecutorTask ) Task to run agent instance. __ init __ | __init__ ( agent : AEA ) -> None Init aea instance task. Arguments : agent : AEA instance to run within task. id | @property | id () -> str Return agent name. start | start () -> None Start task. stop | stop () -> None Stop task. create _ async _ task | create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Return asyncio Task for task run in asyncio loop. Arguments : loop : abstract event loop Returns : task to run runtime AEARunner Objects class AEARunner ( AbstractMultipleRunner ) Run multiple AEA instances. __ init __ | __init__ ( agents : Sequence [ AEA ], mode : str , fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate ) -> None Init AEARunner. Arguments : agents : sequence of AEA instances to run. mode : executor name to use. fail_policy : one of ExecutorExceptionPolicies to be used with Executor","title":"Runner"},{"location":"aea/api/runner/#aearunner","text":"This module contains the implementation of AEA multiple instances runner.","title":"aea.runner"},{"location":"aea/api/runner/#aeainstancetask-objects","text":"class AEAInstanceTask ( AbstractExecutorTask ) Task to run agent instance.","title":"AEAInstanceTask Objects"},{"location":"aea/api/runner/#__init__","text":"| __init__ ( agent : AEA ) -> None Init aea instance task. Arguments : agent : AEA instance to run within task.","title":"__init__"},{"location":"aea/api/runner/#id","text":"| @property | id () -> str Return agent name.","title":"id"},{"location":"aea/api/runner/#start","text":"| start () -> None Start task.","title":"start"},{"location":"aea/api/runner/#stop","text":"| stop () -> None Stop task.","title":"stop"},{"location":"aea/api/runner/#create_async_task","text":"| create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Return asyncio Task for task run in asyncio loop. Arguments : loop : abstract event loop Returns : task to run runtime","title":"create_async_task"},{"location":"aea/api/runner/#aearunner-objects","text":"class AEARunner ( AbstractMultipleRunner ) Run multiple AEA instances.","title":"AEARunner Objects"},{"location":"aea/api/runner/#__init___1","text":"| __init__ ( agents : Sequence [ AEA ], mode : str , fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate ) -> None Init AEARunner. Arguments : agents : sequence of AEA instances to run. mode : executor name to use. fail_policy : one of ExecutorExceptionPolicies to be used with Executor","title":"__init__"},{"location":"aea/api/runtime/","text":"aea.runtime This module contains the implementation of runtime for economic agent (AEA). RuntimeStates Objects class RuntimeStates ( Enum ) Runtime states. BaseRuntime Objects class BaseRuntime ( Runnable , WithLogger ) Abstract runtime class to create implementations. __ init __ | __init__ ( agent : AbstractAgent , multiplexer_options : Dict , loop_mode : Optional [ str ] = None , loop : Optional [ AbstractEventLoop ] = None , threaded : bool = False , task_manager_mode : Optional [ str ] = None ) -> None Init runtime. Arguments : agent : Agent to run. multiplexer_options : options for the multiplexer. loop_mode : agent main loop mode. loop : optional event loop. if not provided a new one will be created. threaded : if True, run in threaded mode, else async task_manager_mode : mode of the task manager. storage | @property | storage () -> Optional [ Storage ] Get optional storage. loop _ mode | @property | loop_mode () -> str Get current loop mode. task _ manager | @property | task_manager () -> TaskManager Get the task manager. loop | @property | loop () -> Optional [ AbstractEventLoop ] Get event loop. agent _ loop | @property | agent_loop () -> BaseAgentLoop Get the agent loop. multiplexer | @property | multiplexer () -> AsyncMultiplexer Get multiplexer. is _ running | @property | is_running () -> bool Get running state of the runtime. is _ stopped | @property | is_stopped () -> bool Get stopped state of the runtime. state | @property | state () -> RuntimeStates Get runtime state. Returns : RuntimeStates decision _ maker | @property | decision_maker () -> DecisionMaker Return decision maker if set. set _ decision _ maker | set_decision_maker ( decision_maker_handler : DecisionMakerHandler ) -> None Set decision maker with handler provided. set _ loop | set_loop ( loop : AbstractEventLoop ) -> None Set event loop to be used. Arguments : loop : event loop to use. AsyncRuntime Objects class AsyncRuntime ( BaseRuntime ) Asynchronous runtime: uses asyncio loop for multiplexer and async agent main loop. __ init __ | __init__ ( agent : AbstractAgent , multiplexer_options : Dict , loop_mode : Optional [ str ] = None , loop : Optional [ AbstractEventLoop ] = None , threaded : bool = False , task_manager_mode : Optional [ str ] = None ) -> None Init runtime. Arguments : agent : Agent to run. multiplexer_options : options for the multiplexer. loop_mode : agent main loop mode. loop : optional event loop. if not provided a new one will be created. threaded : if True, run in threaded mode, else async task_manager_mode : mode of the task manager. set _ loop | set_loop ( loop : AbstractEventLoop ) -> None Set event loop to be used. Arguments : loop : event loop to use. run | async run () -> None Start runtime task. Starts multiplexer and agent loop. stop _ runtime | async stop_runtime () -> None Stop runtime coroutine. Stop main loop. Tear down the agent.. Disconnect multiplexer. run _ runtime | async run_runtime () -> None Run runtime which means start agent loop, multiplexer and storage. ThreadedRuntime Objects class ThreadedRuntime ( AsyncRuntime ) Run agent and multiplexer in different threads with own asyncio loops.","title":"Runtime"},{"location":"aea/api/runtime/#aearuntime","text":"This module contains the implementation of runtime for economic agent (AEA).","title":"aea.runtime"},{"location":"aea/api/runtime/#runtimestates-objects","text":"class RuntimeStates ( Enum ) Runtime states.","title":"RuntimeStates Objects"},{"location":"aea/api/runtime/#baseruntime-objects","text":"class BaseRuntime ( Runnable , WithLogger ) Abstract runtime class to create implementations.","title":"BaseRuntime Objects"},{"location":"aea/api/runtime/#__init__","text":"| __init__ ( agent : AbstractAgent , multiplexer_options : Dict , loop_mode : Optional [ str ] = None , loop : Optional [ AbstractEventLoop ] = None , threaded : bool = False , task_manager_mode : Optional [ str ] = None ) -> None Init runtime. Arguments : agent : Agent to run. multiplexer_options : options for the multiplexer. loop_mode : agent main loop mode. loop : optional event loop. if not provided a new one will be created. threaded : if True, run in threaded mode, else async task_manager_mode : mode of the task manager.","title":"__init__"},{"location":"aea/api/runtime/#storage","text":"| @property | storage () -> Optional [ Storage ] Get optional storage.","title":"storage"},{"location":"aea/api/runtime/#loop_mode","text":"| @property | loop_mode () -> str Get current loop mode.","title":"loop_mode"},{"location":"aea/api/runtime/#task_manager","text":"| @property | task_manager () -> TaskManager Get the task manager.","title":"task_manager"},{"location":"aea/api/runtime/#loop","text":"| @property | loop () -> Optional [ AbstractEventLoop ] Get event loop.","title":"loop"},{"location":"aea/api/runtime/#agent_loop","text":"| @property | agent_loop () -> BaseAgentLoop Get the agent loop.","title":"agent_loop"},{"location":"aea/api/runtime/#multiplexer","text":"| @property | multiplexer () -> AsyncMultiplexer Get multiplexer.","title":"multiplexer"},{"location":"aea/api/runtime/#is_running","text":"| @property | is_running () -> bool Get running state of the runtime.","title":"is_running"},{"location":"aea/api/runtime/#is_stopped","text":"| @property | is_stopped () -> bool Get stopped state of the runtime.","title":"is_stopped"},{"location":"aea/api/runtime/#state","text":"| @property | state () -> RuntimeStates Get runtime state. Returns : RuntimeStates","title":"state"},{"location":"aea/api/runtime/#decision_maker","text":"| @property | decision_maker () -> DecisionMaker Return decision maker if set.","title":"decision_maker"},{"location":"aea/api/runtime/#set_decision_maker","text":"| set_decision_maker ( decision_maker_handler : DecisionMakerHandler ) -> None Set decision maker with handler provided.","title":"set_decision_maker"},{"location":"aea/api/runtime/#set_loop","text":"| set_loop ( loop : AbstractEventLoop ) -> None Set event loop to be used. Arguments : loop : event loop to use.","title":"set_loop"},{"location":"aea/api/runtime/#asyncruntime-objects","text":"class AsyncRuntime ( BaseRuntime ) Asynchronous runtime: uses asyncio loop for multiplexer and async agent main loop.","title":"AsyncRuntime Objects"},{"location":"aea/api/runtime/#__init___1","text":"| __init__ ( agent : AbstractAgent , multiplexer_options : Dict , loop_mode : Optional [ str ] = None , loop : Optional [ AbstractEventLoop ] = None , threaded : bool = False , task_manager_mode : Optional [ str ] = None ) -> None Init runtime. Arguments : agent : Agent to run. multiplexer_options : options for the multiplexer. loop_mode : agent main loop mode. loop : optional event loop. if not provided a new one will be created. threaded : if True, run in threaded mode, else async task_manager_mode : mode of the task manager.","title":"__init__"},{"location":"aea/api/runtime/#set_loop_1","text":"| set_loop ( loop : AbstractEventLoop ) -> None Set event loop to be used. Arguments : loop : event loop to use.","title":"set_loop"},{"location":"aea/api/runtime/#run","text":"| async run () -> None Start runtime task. Starts multiplexer and agent loop.","title":"run"},{"location":"aea/api/runtime/#stop_runtime","text":"| async stop_runtime () -> None Stop runtime coroutine. Stop main loop. Tear down the agent.. Disconnect multiplexer.","title":"stop_runtime"},{"location":"aea/api/runtime/#run_runtime","text":"| async run_runtime () -> None Run runtime which means start agent loop, multiplexer and storage.","title":"run_runtime"},{"location":"aea/api/runtime/#threadedruntime-objects","text":"class ThreadedRuntime ( AsyncRuntime ) Run agent and multiplexer in different threads with own asyncio loops.","title":"ThreadedRuntime Objects"},{"location":"aea/api/components/base/","text":"aea.components.base This module contains definitions of agent components. Component Objects class Component ( ABC , WithLogger ) Abstract class for an agent component. __ init __ | __init__ ( configuration : Optional [ ComponentConfiguration ] = None , is_vendor : bool = False , ** kwargs : Any , ,) -> None Initialize a package. Arguments : configuration : the package configuration. is_vendor : whether the package is vendorized. kwargs : the keyword arguments for the logger. component _ type | @property | component_type () -> ComponentType Get the component type. is _ vendor | @property | is_vendor () -> bool Get whether the component is vendorized or not. prefix _ import _ path | @property | prefix_import_path () -> str Get the prefix import path for this component. component _ id | @property | component_id () -> ComponentId Ge the package id. public _ id | @property | public_id () -> PublicId Get the public id. configuration | @property | configuration () -> ComponentConfiguration Get the component configuration. directory | @property | directory () -> Path Get the directory. Raise error if it has not been set yet. directory | @directory . setter | directory ( path : Path ) -> None Set the directory. Raise error if already set. build _ directory | @property | build_directory () -> Optional [ str ] Get build directory for the component. load _ aea _ package load_aea_package ( configuration : ComponentConfiguration ) -> None Load the AEA package from configuration. It adds all the init .py modules into sys.modules . Arguments : configuration : the configuration object. perform _ load _ aea _ package perform_load_aea_package ( dir_ : Path , author : str , package_type_plural : str , package_name : str ) -> None Load the AEA package from values provided. It adds all the init .py modules into sys.modules . Arguments : dir_ : path of the component. author : str package_type_plural : str package_name : str","title":"Base"},{"location":"aea/api/components/base/#aeacomponentsbase","text":"This module contains definitions of agent components.","title":"aea.components.base"},{"location":"aea/api/components/base/#component-objects","text":"class Component ( ABC , WithLogger ) Abstract class for an agent component.","title":"Component Objects"},{"location":"aea/api/components/base/#__init__","text":"| __init__ ( configuration : Optional [ ComponentConfiguration ] = None , is_vendor : bool = False , ** kwargs : Any , ,) -> None Initialize a package. Arguments : configuration : the package configuration. is_vendor : whether the package is vendorized. kwargs : the keyword arguments for the logger.","title":"__init__"},{"location":"aea/api/components/base/#component_type","text":"| @property | component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"aea/api/components/base/#is_vendor","text":"| @property | is_vendor () -> bool Get whether the component is vendorized or not.","title":"is_vendor"},{"location":"aea/api/components/base/#prefix_import_path","text":"| @property | prefix_import_path () -> str Get the prefix import path for this component.","title":"prefix_import_path"},{"location":"aea/api/components/base/#component_id","text":"| @property | component_id () -> ComponentId Ge the package id.","title":"component_id"},{"location":"aea/api/components/base/#public_id","text":"| @property | public_id () -> PublicId Get the public id.","title":"public_id"},{"location":"aea/api/components/base/#configuration","text":"| @property | configuration () -> ComponentConfiguration Get the component configuration.","title":"configuration"},{"location":"aea/api/components/base/#directory","text":"| @property | directory () -> Path Get the directory. Raise error if it has not been set yet.","title":"directory"},{"location":"aea/api/components/base/#directory_1","text":"| @directory . setter | directory ( path : Path ) -> None Set the directory. Raise error if already set.","title":"directory"},{"location":"aea/api/components/base/#build_directory","text":"| @property | build_directory () -> Optional [ str ] Get build directory for the component.","title":"build_directory"},{"location":"aea/api/components/base/#load_aea_package","text":"load_aea_package ( configuration : ComponentConfiguration ) -> None Load the AEA package from configuration. It adds all the init .py modules into sys.modules . Arguments : configuration : the configuration object.","title":"load_aea_package"},{"location":"aea/api/components/base/#perform_load_aea_package","text":"perform_load_aea_package ( dir_ : Path , author : str , package_type_plural : str , package_name : str ) -> None Load the AEA package from values provided. It adds all the init .py modules into sys.modules . Arguments : dir_ : path of the component. author : str package_type_plural : str package_name : str","title":"perform_load_aea_package"},{"location":"aea/api/components/loader/","text":"aea.components.loader This module contains utilities for loading components. component _ type _ to _ class component_type_to_class ( component_type : ComponentType ) -> Type [ Component ] Get the component class from the component type. Arguments : component_type : the component type Returns : the component class load _ component _ from _ config load_component_from_config ( configuration : ComponentConfiguration , * args , ** kwargs ) -> Component Load a component from a directory. Arguments : configuration : the component configuration. args : the positional arguments. kwargs : the keyword arguments. Returns : the component instance. AEAPackageNotFound Objects class AEAPackageNotFound ( Exception ) Exception when failed to import package, cause not exists.","title":"Loader"},{"location":"aea/api/components/loader/#aeacomponentsloader","text":"This module contains utilities for loading components.","title":"aea.components.loader"},{"location":"aea/api/components/loader/#component_type_to_class","text":"component_type_to_class ( component_type : ComponentType ) -> Type [ Component ] Get the component class from the component type. Arguments : component_type : the component type Returns : the component class","title":"component_type_to_class"},{"location":"aea/api/components/loader/#load_component_from_config","text":"load_component_from_config ( configuration : ComponentConfiguration , * args , ** kwargs ) -> Component Load a component from a directory. Arguments : configuration : the component configuration. args : the positional arguments. kwargs : the keyword arguments. Returns : the component instance.","title":"load_component_from_config"},{"location":"aea/api/components/loader/#aeapackagenotfound-objects","text":"class AEAPackageNotFound ( Exception ) Exception when failed to import package, cause not exists.","title":"AEAPackageNotFound Objects"},{"location":"aea/api/components/utils/","text":"aea.components.utils This module contains the component loading utils.","title":"Utils"},{"location":"aea/api/components/utils/#aeacomponentsutils","text":"This module contains the component loading utils.","title":"aea.components.utils"},{"location":"aea/api/configurations/base/","text":"aea.configurations.base Classes to handle AEA configurations. dependencies _ from _ json dependencies_from_json ( obj : Dict [ str , Dict ]) -> Dependencies Parse a JSON object to get an instance of Dependencies. Arguments : obj : a dictionary whose keys are package names and values are dictionary with package specifications. Returns : a Dependencies object. dependencies _ to _ json dependencies_to_json ( dependencies : Dependencies ) -> Dict [ str , Dict ] Transform a Dependencies object into a JSON object. Arguments : dependencies : an instance of \"Dependencies\" type. Returns : a dictionary whose keys are package names and values are the JSON version of a Dependency object. ProtocolSpecificationParseError Objects class ProtocolSpecificationParseError ( Exception ) Exception for parsing a protocol specification file. Configuration Objects class Configuration ( JSONSerializable , ABC ) Configuration class. __ init __ | __init__ () -> None Initialize a configuration object. from _ json | @classmethod | from_json ( cls , obj : Dict ) -> \"Configuration\" Build from a JSON object. ordered _ json | @property | ordered_json () -> OrderedDict Reorder the dictionary according to a key ordering. This method takes all the keys in the key_order list and get the associated value in the dictionary (if present). For the remaining keys not considered in the order, it will use alphanumerical ordering. In particular, if key_order is an empty sequence, this reduces to alphanumerical sorting. It does not do side-effect. Returns : the ordered dictionary. PackageConfiguration Objects class PackageConfiguration ( Configuration , ABC ) This class represent a package configuration. A package can be one of: - agents - protocols - connections - skills - contracts __ init __ | __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None ) -> None Initialize a package configuration. Arguments : name : the name of the package. author : the author of the package. version : the version of the package (SemVer format). license_ : the license. aea_version : either a fixed version, or a set of specifiers describing the AEA versions allowed. (default: empty string - no constraint). The fixed version is interpreted with the specifier '=='. fingerprint : the fingerprint. fingerprint_ignore_patterns : a list of file patterns to ignore files to fingerprint. build_entrypoint : path to a script to execute at build time. name | @property | name () -> str Get the name. name | @name . setter | name ( value : SimpleIdOrStr ) -> None Set the name. author | @property | author () -> str Get the author. author | @author . setter | author ( value : SimpleIdOrStr ) -> None Set the author. aea _ version | @property | aea_version () -> str Get the 'aea_version' attribute. aea _ version | @aea_version . setter | aea_version ( new_aea_version : str ) -> None Set the 'aea_version' attribute. check _ aea _ version | check_aea_version () -> None Check that the AEA version matches the specifier set. :raises ValueError if the version of the aea framework falls within a specifier. directory | @property | directory () -> Optional [ Path ] Get the path to the configuration file associated to this file, if any. directory | @directory . setter | directory ( directory : Path ) -> None Set directory if not already set. package _ id | @property | package_id () -> PackageId Get package id. parse _ aea _ version _ specifier | @staticmethod | parse_aea_version_specifier ( aea_version_specifiers : str ) -> SpecifierSet Parse an 'aea_version' field. If 'aea_version' is a version, then output the specifier set \"==${version}\" Else, interpret it as specifier set. Arguments : aea_version_specifiers : the AEA version, or a specifier set. Returns : A specifier set object. aea _ version _ specifiers | @property | aea_version_specifiers () -> SpecifierSet Get the AEA version set specifier. public _ id | @property | public_id () -> PublicId Get the public id. package _ dependencies | @property | package_dependencies () -> Set [ ComponentId ] Get the package dependencies. update | update ( data : Dict , env_vars_friendly : bool = False ) -> None Update configuration with other data. Arguments : data : the data to replace. env_vars_friendly : whether or not it is env vars friendly. validate _ config _ data | @classmethod | validate_config_data ( cls , json_data : Dict , env_vars_friendly : bool = False ) -> None Perform config validation. from _ json | @classmethod | from_json ( cls , obj : Dict ) -> \"PackageConfiguration\" Initialize from a JSON object. make _ resulting _ config _ data | make_resulting_config_data ( overrides : Dict ) -> Dict Make config data with overrides applied. Does not update config, just creates json representation. Arguments : overrides : the overrides Returns : config with overrides applied check _ overrides _ valid | check_overrides_valid ( overrides : Dict , env_vars_friendly : bool = False ) -> None Check overrides is correct, return list of errors if present. get _ overridable | get_overridable () -> dict Get dictionary of values that can be updated for this config. ComponentConfiguration Objects class ComponentConfiguration ( PackageConfiguration , ABC ) Class to represent an agent component configuration. __ init __ | __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , dependencies : Optional [ Dependencies ] = None ) -> None Set component configuration. build _ directory | @property | build_directory () -> Optional [ str ] Get the component type. build _ directory | @build_directory . setter | build_directory ( value : Optional [ str ]) -> None Get the component type. component _ type | @property | component_type () -> ComponentType Get the component type. component _ id | @property | component_id () -> ComponentId Get the component id. prefix _ import _ path | @property | prefix_import_path () -> str Get the prefix import path for this component. is _ abstract _ component | @property | is_abstract_component () -> bool Check whether the component is abstract. check _ fingerprint | check_fingerprint ( directory : Path ) -> None Check that the fingerprint are correct against a directory path. Arguments : directory : the directory path. Raises : ValueError : if the argument is not a valid package directory the fingerprints do not match. check _ public _ id _ consistency | check_public_id_consistency ( directory : Path ) -> None Check that the public ids in the init file match the config. Arguments : directory : the directory path. Raises : ValueError : if the argument is not a valid package directory the public ids do not match. ConnectionConfig Objects class ConnectionConfig ( ComponentConfiguration ) Handle connection configuration. __ init __ | __init__ ( name : SimpleIdOrStr = \"\" , author : SimpleIdOrStr = \"\" , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , class_name : str = \"\" , protocols : Optional [ Set [ PublicId ]] = None , connections : Optional [ Set [ PublicId ]] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , connection_id : Optional [ PublicId ] = None , is_abstract : bool = False , cert_requests : Optional [ List [ CertRequest ]] = None , ** config : Any , ,) -> None Initialize a connection configuration object. package _ dependencies | @property | package_dependencies () -> Set [ ComponentId ] Get the connection dependencies. is _ abstract _ component | @property | is_abstract_component () -> bool Check whether the component is abstract. json | @property | json () -> Dict Return the JSON representation. ProtocolConfig Objects class ProtocolConfig ( ComponentConfiguration ) Handle protocol configuration. __ init __ | __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , aea_version : str = \"\" , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , protocol_specification_id : Optional [ str ] = None ) -> None Initialize a connection configuration object. json | @property | json () -> Dict Return the JSON representation. SkillComponentConfiguration Objects class SkillComponentConfiguration () This class represent a skill component configuration. __ init __ | __init__ ( class_name : str , file_path : Optional [ str ] = None , ** args : Any ) -> None Initialize a skill component configuration. Arguments : class_name : the class name of the component. file_path : the file path. args : keyword arguments. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) -> \"SkillComponentConfiguration\" Initialize from a JSON object. SkillConfig Objects class SkillConfig ( ComponentConfiguration ) Class to represent a skill configuration file. __ init __ | __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , connections : Optional [ Set [ PublicId ]] = None , protocols : Optional [ Set [ PublicId ]] = None , contracts : Optional [ Set [ PublicId ]] = None , skills : Optional [ Set [ PublicId ]] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , is_abstract : bool = False ) -> None Initialize a skill configuration. package _ dependencies | @property | package_dependencies () -> Set [ ComponentId ] Get the skill dependencies. is _ abstract _ component | @property | is_abstract_component () -> bool Check whether the component is abstract. json | @property | json () -> Dict Return the JSON representation. get _ overridable | get_overridable () -> dict Get overridable configuration data. AgentConfig Objects class AgentConfig ( PackageConfiguration ) Class to represent the agent configuration file. __ init __ | __init__ ( agent_name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , description : str = \"\" , logging_config : Optional [ Dict ] = None , period : Optional [ float ] = None , execution_timeout : Optional [ float ] = None , max_reactions : Optional [ int ] = None , error_handler : Optional [ Dict ] = None , decision_maker_handler : Optional [ Dict ] = None , skill_exception_policy : Optional [ str ] = None , connection_exception_policy : Optional [ str ] = None , default_ledger : Optional [ str ] = None , required_ledgers : Optional [ List [ str ]] = None , currency_denominations : Optional [ Dict [ str , str ]] = None , default_connection : Optional [ str ] = None , default_routing : Optional [ Dict [ str , str ]] = None , loop_mode : Optional [ str ] = None , runtime_mode : Optional [ str ] = None , task_manager_mode : Optional [ str ] = None , storage_uri : Optional [ str ] = None , data_dir : Optional [ str ] = None , component_configurations : Optional [ Dict [ ComponentId , Dict ]] = None , dependencies : Optional [ Dependencies ] = None ) -> None Instantiate the agent configuration object. component _ configurations | @property | component_configurations () -> Dict [ ComponentId , Dict ] Get the custom component configurations. component _ configurations | @component_configurations . setter | component_configurations ( d : Dict [ ComponentId , Dict ]) -> None Set the component configurations. package _ dependencies | @property | package_dependencies () -> Set [ ComponentId ] Get the package dependencies. private _ key _ paths _ dict | @property | private_key_paths_dict () -> Dict [ str , str ] Get dictionary version of private key paths. connection _ private _ key _ paths _ dict | @property | connection_private_key_paths_dict () -> Dict [ str , str ] Get dictionary version of connection private key paths. component _ configurations _ json | component_configurations_json () -> List [ OrderedDict ] Get the component configurations in JSON format. json | @property | json () -> Dict Return the JSON representation. all _ components _ id | @property | all_components_id () -> List [ ComponentId ] Get list of the all components for this agent config. update | update ( data : Dict , env_vars_friendly : bool = False ) -> None Update configuration with other data. To update the component parts, populate the field \"component_configurations\" as a mapping from ComponentId to configurations. Arguments : data : the data to replace. env_vars_friendly : whether or not it is env vars friendly. SpeechActContentConfig Objects class SpeechActContentConfig ( Configuration ) Handle a speech_act content configuration. __ init __ | __init__ ( ** args : Any ) -> None Initialize a speech_act content configuration. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) -> \"SpeechActContentConfig\" Initialize from a JSON object. ProtocolSpecification Objects class ProtocolSpecification ( ProtocolConfig ) Handle protocol specification. __ init __ | __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , description : str = \"\" , protocol_specification_id : Optional [ str ] = None ) -> None Initialize a protocol specification configuration object. protobuf _ snippets | @property | protobuf_snippets () -> Dict Get the protobuf snippets. protobuf _ snippets | @protobuf_snippets . setter | protobuf_snippets ( protobuf_snippets : Dict ) -> None Set the protobuf snippets. dialogue _ config | @property | dialogue_config () -> Dict Get the dialogue config. dialogue _ config | @dialogue_config . setter | dialogue_config ( dialogue_config : Dict ) -> None Set the dialogue config. json | @property | json () -> Dict Return the JSON representation. ContractConfig Objects class ContractConfig ( ComponentConfiguration ) Handle contract configuration. __ init __ | __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , contract_interface_paths : Optional [ Dict [ str , str ]] = None , class_name : str = \"\" ) -> None Initialize a protocol configuration object. json | @property | json () -> Dict Return the JSON representation. AEAVersionError Objects class AEAVersionError ( ValueError ) Special Exception for version error. __ init __ | __init__ ( package_id : PublicId , aea_version_specifiers : SpecifierSet ) -> None Init exception.","title":"Base"},{"location":"aea/api/configurations/base/#aeaconfigurationsbase","text":"Classes to handle AEA configurations.","title":"aea.configurations.base"},{"location":"aea/api/configurations/base/#dependencies_from_json","text":"dependencies_from_json ( obj : Dict [ str , Dict ]) -> Dependencies Parse a JSON object to get an instance of Dependencies. Arguments : obj : a dictionary whose keys are package names and values are dictionary with package specifications. Returns : a Dependencies object.","title":"dependencies_from_json"},{"location":"aea/api/configurations/base/#dependencies_to_json","text":"dependencies_to_json ( dependencies : Dependencies ) -> Dict [ str , Dict ] Transform a Dependencies object into a JSON object. Arguments : dependencies : an instance of \"Dependencies\" type. Returns : a dictionary whose keys are package names and values are the JSON version of a Dependency object.","title":"dependencies_to_json"},{"location":"aea/api/configurations/base/#protocolspecificationparseerror-objects","text":"class ProtocolSpecificationParseError ( Exception ) Exception for parsing a protocol specification file.","title":"ProtocolSpecificationParseError Objects"},{"location":"aea/api/configurations/base/#configuration-objects","text":"class Configuration ( JSONSerializable , ABC ) Configuration class.","title":"Configuration Objects"},{"location":"aea/api/configurations/base/#__init__","text":"| __init__ () -> None Initialize a configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#from_json","text":"| @classmethod | from_json ( cls , obj : Dict ) -> \"Configuration\" Build from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#ordered_json","text":"| @property | ordered_json () -> OrderedDict Reorder the dictionary according to a key ordering. This method takes all the keys in the key_order list and get the associated value in the dictionary (if present). For the remaining keys not considered in the order, it will use alphanumerical ordering. In particular, if key_order is an empty sequence, this reduces to alphanumerical sorting. It does not do side-effect. Returns : the ordered dictionary.","title":"ordered_json"},{"location":"aea/api/configurations/base/#packageconfiguration-objects","text":"class PackageConfiguration ( Configuration , ABC ) This class represent a package configuration. A package can be one of: - agents - protocols - connections - skills - contracts","title":"PackageConfiguration Objects"},{"location":"aea/api/configurations/base/#__init___1","text":"| __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None ) -> None Initialize a package configuration. Arguments : name : the name of the package. author : the author of the package. version : the version of the package (SemVer format). license_ : the license. aea_version : either a fixed version, or a set of specifiers describing the AEA versions allowed. (default: empty string - no constraint). The fixed version is interpreted with the specifier '=='. fingerprint : the fingerprint. fingerprint_ignore_patterns : a list of file patterns to ignore files to fingerprint. build_entrypoint : path to a script to execute at build time.","title":"__init__"},{"location":"aea/api/configurations/base/#name","text":"| @property | name () -> str Get the name.","title":"name"},{"location":"aea/api/configurations/base/#name_1","text":"| @name . setter | name ( value : SimpleIdOrStr ) -> None Set the name.","title":"name"},{"location":"aea/api/configurations/base/#author","text":"| @property | author () -> str Get the author.","title":"author"},{"location":"aea/api/configurations/base/#author_1","text":"| @author . setter | author ( value : SimpleIdOrStr ) -> None Set the author.","title":"author"},{"location":"aea/api/configurations/base/#aea_version","text":"| @property | aea_version () -> str Get the 'aea_version' attribute.","title":"aea_version"},{"location":"aea/api/configurations/base/#aea_version_1","text":"| @aea_version . setter | aea_version ( new_aea_version : str ) -> None Set the 'aea_version' attribute.","title":"aea_version"},{"location":"aea/api/configurations/base/#check_aea_version","text":"| check_aea_version () -> None Check that the AEA version matches the specifier set. :raises ValueError if the version of the aea framework falls within a specifier.","title":"check_aea_version"},{"location":"aea/api/configurations/base/#directory","text":"| @property | directory () -> Optional [ Path ] Get the path to the configuration file associated to this file, if any.","title":"directory"},{"location":"aea/api/configurations/base/#directory_1","text":"| @directory . setter | directory ( directory : Path ) -> None Set directory if not already set.","title":"directory"},{"location":"aea/api/configurations/base/#package_id","text":"| @property | package_id () -> PackageId Get package id.","title":"package_id"},{"location":"aea/api/configurations/base/#parse_aea_version_specifier","text":"| @staticmethod | parse_aea_version_specifier ( aea_version_specifiers : str ) -> SpecifierSet Parse an 'aea_version' field. If 'aea_version' is a version, then output the specifier set \"==${version}\" Else, interpret it as specifier set. Arguments : aea_version_specifiers : the AEA version, or a specifier set. Returns : A specifier set object.","title":"parse_aea_version_specifier"},{"location":"aea/api/configurations/base/#aea_version_specifiers","text":"| @property | aea_version_specifiers () -> SpecifierSet Get the AEA version set specifier.","title":"aea_version_specifiers"},{"location":"aea/api/configurations/base/#public_id","text":"| @property | public_id () -> PublicId Get the public id.","title":"public_id"},{"location":"aea/api/configurations/base/#package_dependencies","text":"| @property | package_dependencies () -> Set [ ComponentId ] Get the package dependencies.","title":"package_dependencies"},{"location":"aea/api/configurations/base/#update","text":"| update ( data : Dict , env_vars_friendly : bool = False ) -> None Update configuration with other data. Arguments : data : the data to replace. env_vars_friendly : whether or not it is env vars friendly.","title":"update"},{"location":"aea/api/configurations/base/#validate_config_data","text":"| @classmethod | validate_config_data ( cls , json_data : Dict , env_vars_friendly : bool = False ) -> None Perform config validation.","title":"validate_config_data"},{"location":"aea/api/configurations/base/#from_json_1","text":"| @classmethod | from_json ( cls , obj : Dict ) -> \"PackageConfiguration\" Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#make_resulting_config_data","text":"| make_resulting_config_data ( overrides : Dict ) -> Dict Make config data with overrides applied. Does not update config, just creates json representation. Arguments : overrides : the overrides Returns : config with overrides applied","title":"make_resulting_config_data"},{"location":"aea/api/configurations/base/#check_overrides_valid","text":"| check_overrides_valid ( overrides : Dict , env_vars_friendly : bool = False ) -> None Check overrides is correct, return list of errors if present.","title":"check_overrides_valid"},{"location":"aea/api/configurations/base/#get_overridable","text":"| get_overridable () -> dict Get dictionary of values that can be updated for this config.","title":"get_overridable"},{"location":"aea/api/configurations/base/#componentconfiguration-objects","text":"class ComponentConfiguration ( PackageConfiguration , ABC ) Class to represent an agent component configuration.","title":"ComponentConfiguration Objects"},{"location":"aea/api/configurations/base/#__init___2","text":"| __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , dependencies : Optional [ Dependencies ] = None ) -> None Set component configuration.","title":"__init__"},{"location":"aea/api/configurations/base/#build_directory","text":"| @property | build_directory () -> Optional [ str ] Get the component type.","title":"build_directory"},{"location":"aea/api/configurations/base/#build_directory_1","text":"| @build_directory . setter | build_directory ( value : Optional [ str ]) -> None Get the component type.","title":"build_directory"},{"location":"aea/api/configurations/base/#component_type","text":"| @property | component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"aea/api/configurations/base/#component_id","text":"| @property | component_id () -> ComponentId Get the component id.","title":"component_id"},{"location":"aea/api/configurations/base/#prefix_import_path","text":"| @property | prefix_import_path () -> str Get the prefix import path for this component.","title":"prefix_import_path"},{"location":"aea/api/configurations/base/#is_abstract_component","text":"| @property | is_abstract_component () -> bool Check whether the component is abstract.","title":"is_abstract_component"},{"location":"aea/api/configurations/base/#check_fingerprint","text":"| check_fingerprint ( directory : Path ) -> None Check that the fingerprint are correct against a directory path. Arguments : directory : the directory path. Raises : ValueError : if the argument is not a valid package directory the fingerprints do not match.","title":"check_fingerprint"},{"location":"aea/api/configurations/base/#check_public_id_consistency","text":"| check_public_id_consistency ( directory : Path ) -> None Check that the public ids in the init file match the config. Arguments : directory : the directory path. Raises : ValueError : if the argument is not a valid package directory the public ids do not match.","title":"check_public_id_consistency"},{"location":"aea/api/configurations/base/#connectionconfig-objects","text":"class ConnectionConfig ( ComponentConfiguration ) Handle connection configuration.","title":"ConnectionConfig Objects"},{"location":"aea/api/configurations/base/#__init___3","text":"| __init__ ( name : SimpleIdOrStr = \"\" , author : SimpleIdOrStr = \"\" , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , class_name : str = \"\" , protocols : Optional [ Set [ PublicId ]] = None , connections : Optional [ Set [ PublicId ]] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , connection_id : Optional [ PublicId ] = None , is_abstract : bool = False , cert_requests : Optional [ List [ CertRequest ]] = None , ** config : Any , ,) -> None Initialize a connection configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#package_dependencies_1","text":"| @property | package_dependencies () -> Set [ ComponentId ] Get the connection dependencies.","title":"package_dependencies"},{"location":"aea/api/configurations/base/#is_abstract_component_1","text":"| @property | is_abstract_component () -> bool Check whether the component is abstract.","title":"is_abstract_component"},{"location":"aea/api/configurations/base/#json","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#protocolconfig-objects","text":"class ProtocolConfig ( ComponentConfiguration ) Handle protocol configuration.","title":"ProtocolConfig Objects"},{"location":"aea/api/configurations/base/#__init___4","text":"| __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , aea_version : str = \"\" , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , protocol_specification_id : Optional [ str ] = None ) -> None Initialize a connection configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#json_1","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#skillcomponentconfiguration-objects","text":"class SkillComponentConfiguration () This class represent a skill component configuration.","title":"SkillComponentConfiguration Objects"},{"location":"aea/api/configurations/base/#__init___5","text":"| __init__ ( class_name : str , file_path : Optional [ str ] = None , ** args : Any ) -> None Initialize a skill component configuration. Arguments : class_name : the class name of the component. file_path : the file path. args : keyword arguments.","title":"__init__"},{"location":"aea/api/configurations/base/#json_2","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_2","text":"| @classmethod | from_json ( cls , obj : Dict ) -> \"SkillComponentConfiguration\" Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#skillconfig-objects","text":"class SkillConfig ( ComponentConfiguration ) Class to represent a skill configuration file.","title":"SkillConfig Objects"},{"location":"aea/api/configurations/base/#__init___6","text":"| __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , connections : Optional [ Set [ PublicId ]] = None , protocols : Optional [ Set [ PublicId ]] = None , contracts : Optional [ Set [ PublicId ]] = None , skills : Optional [ Set [ PublicId ]] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , is_abstract : bool = False ) -> None Initialize a skill configuration.","title":"__init__"},{"location":"aea/api/configurations/base/#package_dependencies_2","text":"| @property | package_dependencies () -> Set [ ComponentId ] Get the skill dependencies.","title":"package_dependencies"},{"location":"aea/api/configurations/base/#is_abstract_component_2","text":"| @property | is_abstract_component () -> bool Check whether the component is abstract.","title":"is_abstract_component"},{"location":"aea/api/configurations/base/#json_3","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#get_overridable_1","text":"| get_overridable () -> dict Get overridable configuration data.","title":"get_overridable"},{"location":"aea/api/configurations/base/#agentconfig-objects","text":"class AgentConfig ( PackageConfiguration ) Class to represent the agent configuration file.","title":"AgentConfig Objects"},{"location":"aea/api/configurations/base/#__init___7","text":"| __init__ ( agent_name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , description : str = \"\" , logging_config : Optional [ Dict ] = None , period : Optional [ float ] = None , execution_timeout : Optional [ float ] = None , max_reactions : Optional [ int ] = None , error_handler : Optional [ Dict ] = None , decision_maker_handler : Optional [ Dict ] = None , skill_exception_policy : Optional [ str ] = None , connection_exception_policy : Optional [ str ] = None , default_ledger : Optional [ str ] = None , required_ledgers : Optional [ List [ str ]] = None , currency_denominations : Optional [ Dict [ str , str ]] = None , default_connection : Optional [ str ] = None , default_routing : Optional [ Dict [ str , str ]] = None , loop_mode : Optional [ str ] = None , runtime_mode : Optional [ str ] = None , task_manager_mode : Optional [ str ] = None , storage_uri : Optional [ str ] = None , data_dir : Optional [ str ] = None , component_configurations : Optional [ Dict [ ComponentId , Dict ]] = None , dependencies : Optional [ Dependencies ] = None ) -> None Instantiate the agent configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#component_configurations","text":"| @property | component_configurations () -> Dict [ ComponentId , Dict ] Get the custom component configurations.","title":"component_configurations"},{"location":"aea/api/configurations/base/#component_configurations_1","text":"| @component_configurations . setter | component_configurations ( d : Dict [ ComponentId , Dict ]) -> None Set the component configurations.","title":"component_configurations"},{"location":"aea/api/configurations/base/#package_dependencies_3","text":"| @property | package_dependencies () -> Set [ ComponentId ] Get the package dependencies.","title":"package_dependencies"},{"location":"aea/api/configurations/base/#private_key_paths_dict","text":"| @property | private_key_paths_dict () -> Dict [ str , str ] Get dictionary version of private key paths.","title":"private_key_paths_dict"},{"location":"aea/api/configurations/base/#connection_private_key_paths_dict","text":"| @property | connection_private_key_paths_dict () -> Dict [ str , str ] Get dictionary version of connection private key paths.","title":"connection_private_key_paths_dict"},{"location":"aea/api/configurations/base/#component_configurations_json","text":"| component_configurations_json () -> List [ OrderedDict ] Get the component configurations in JSON format.","title":"component_configurations_json"},{"location":"aea/api/configurations/base/#json_4","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#all_components_id","text":"| @property | all_components_id () -> List [ ComponentId ] Get list of the all components for this agent config.","title":"all_components_id"},{"location":"aea/api/configurations/base/#update_1","text":"| update ( data : Dict , env_vars_friendly : bool = False ) -> None Update configuration with other data. To update the component parts, populate the field \"component_configurations\" as a mapping from ComponentId to configurations. Arguments : data : the data to replace. env_vars_friendly : whether or not it is env vars friendly.","title":"update"},{"location":"aea/api/configurations/base/#speechactcontentconfig-objects","text":"class SpeechActContentConfig ( Configuration ) Handle a speech_act content configuration.","title":"SpeechActContentConfig Objects"},{"location":"aea/api/configurations/base/#__init___8","text":"| __init__ ( ** args : Any ) -> None Initialize a speech_act content configuration.","title":"__init__"},{"location":"aea/api/configurations/base/#json_5","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#from_json_3","text":"| @classmethod | from_json ( cls , obj : Dict ) -> \"SpeechActContentConfig\" Initialize from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/base/#protocolspecification-objects","text":"class ProtocolSpecification ( ProtocolConfig ) Handle protocol specification.","title":"ProtocolSpecification Objects"},{"location":"aea/api/configurations/base/#__init___9","text":"| __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , description : str = \"\" , protocol_specification_id : Optional [ str ] = None ) -> None Initialize a protocol specification configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#protobuf_snippets","text":"| @property | protobuf_snippets () -> Dict Get the protobuf snippets.","title":"protobuf_snippets"},{"location":"aea/api/configurations/base/#protobuf_snippets_1","text":"| @protobuf_snippets . setter | protobuf_snippets ( protobuf_snippets : Dict ) -> None Set the protobuf snippets.","title":"protobuf_snippets"},{"location":"aea/api/configurations/base/#dialogue_config","text":"| @property | dialogue_config () -> Dict Get the dialogue config.","title":"dialogue_config"},{"location":"aea/api/configurations/base/#dialogue_config_1","text":"| @dialogue_config . setter | dialogue_config ( dialogue_config : Dict ) -> None Set the dialogue config.","title":"dialogue_config"},{"location":"aea/api/configurations/base/#json_6","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#contractconfig-objects","text":"class ContractConfig ( ComponentConfiguration ) Handle contract configuration.","title":"ContractConfig Objects"},{"location":"aea/api/configurations/base/#__init___10","text":"| __init__ ( name : SimpleIdOrStr , author : SimpleIdOrStr , version : str = \"\" , license_ : str = \"\" , aea_version : str = \"\" , fingerprint : Optional [ Dict [ str , str ]] = None , fingerprint_ignore_patterns : Optional [ Sequence [ str ]] = None , build_entrypoint : Optional [ str ] = None , build_directory : Optional [ str ] = None , dependencies : Optional [ Dependencies ] = None , description : str = \"\" , contract_interface_paths : Optional [ Dict [ str , str ]] = None , class_name : str = \"\" ) -> None Initialize a protocol configuration object.","title":"__init__"},{"location":"aea/api/configurations/base/#json_7","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/configurations/base/#aeaversionerror-objects","text":"class AEAVersionError ( ValueError ) Special Exception for version error.","title":"AEAVersionError Objects"},{"location":"aea/api/configurations/base/#__init___11","text":"| __init__ ( package_id : PublicId , aea_version_specifiers : SpecifierSet ) -> None Init exception.","title":"__init__"},{"location":"aea/api/configurations/constants/","text":"aea.configurations.constants Module to declare constants.","title":"Constants"},{"location":"aea/api/configurations/constants/#aeaconfigurationsconstants","text":"Module to declare constants.","title":"aea.configurations.constants"},{"location":"aea/api/configurations/data_types/","text":"aea.configurations.data _ types Base config data types. JSONSerializable Objects class JSONSerializable ( ABC ) Interface for JSON-serializable objects. json | @property | @abstractmethod | json () -> Dict Compute the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) -> \"JSONSerializable\" Build from a JSON object. PackageVersion Objects @functools . total_ordering class PackageVersion () A package version. __ init __ | __init__ ( version_like : PackageVersionLike ) -> None Initialize a package version. Arguments : version_like : a string, os a semver.VersionInfo object. is _ latest | @property | is_latest () -> bool Check whether the version is 'latest'. __ str __ | __str__ () -> str Get the string representation. __ eq __ | __eq__ ( other : Any ) -> bool Check equality. __ lt __ | __lt__ ( other : Any ) -> bool Compare with another object. PackageType Objects class PackageType ( Enum ) Package types. to _ plural | to_plural () -> str Get the plural name. PackageType.AGENT.to_plural() 'agents' PackageType.PROTOCOL.to_plural() 'protocols' PackageType.CONNECTION.to_plural() 'connections' PackageType.SKILL.to_plural() 'skills' PackageType.CONTRACT.to_plural() 'contracts' Returns : pluralised package type __ str __ | __str__ () -> str Convert to string. ComponentType Objects class ComponentType ( Enum ) Enum of component types supported. to _ package _ type | to_package_type () -> PackageType Get package type for component type. plurals | @staticmethod | plurals () -> Collection [ str ] Get the collection of type names, plural. ComponentType.plurals() ['protocols', 'connections', 'skills', 'contracts'] Returns : list of all pluralised component types to _ plural | to_plural () -> str Get the plural version of the component type. ComponentType.PROTOCOL.to_plural() 'protocols' ComponentType.CONNECTION.to_plural() 'connections' ComponentType.SKILL.to_plural() 'skills' ComponentType.CONTRACT.to_plural() 'contracts' Returns : pluralised component type __ str __ | __str__ () -> str Get the string representation. PublicId Objects class PublicId ( JSONSerializable ) This class implement a public identifier. A public identifier is composed of three elements: - author - name - version The concatenation of those three elements gives the public identifier: author/name:version public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert public_id.author == \"author\" assert public_id.name == \"my_package\" assert public_id.version == \"0.1.0\" another_public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert hash(public_id) == hash(another_public_id) assert public_id == another_public_id latest_public_id = PublicId(\"author\", \"my_package\", \"latest\") latest_public_id latest_public_id.package_version.is_latest True __ init __ | __init__ ( author : SimpleIdOrStr , name : SimpleIdOrStr , version : Optional [ PackageVersionLike ] = None ) -> None Initialize the public identifier. author | @property | author () -> str Get the author. name | @property | name () -> str Get the name. version | @property | version () -> str Get the version string. package _ version | @property | package_version () -> PackageVersion Get the package version object. to _ any | to_any () -> \"PublicId\" Return the same public id, but with any version. same _ prefix | same_prefix ( other : \"PublicId\" ) -> bool Check if the other public id has the same author and name of this. to _ latest | to_latest () -> \"PublicId\" Return the same public id, but with latest version. is _ valid _ str | @classmethod | is_valid_str ( cls , public_id_string : str ) -> bool Check if a string is a public id. Arguments : public_id_string : the public id in string format. Returns : bool indicating validity from _ str | @classmethod | from_str ( cls , public_id_string : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_str(\"author/package_name:0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_str(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_string : the public id in string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted. try _ from _ str | @classmethod | try_from_str ( cls , public_id_string : str ) -> Optional [ \"PublicId\" ] Safely try to get public id from string. Arguments : public_id_string : the public id in string format. Returns : the public id object or None from _ uri _ path | @classmethod | from_uri_path ( cls , public_id_uri_path : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_uri_path(\"author/package_name/0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_uri_path(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_uri_path : the public id in uri path string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted. to _ uri _ path | @property | to_uri_path () -> str Turn the public id into a uri path string. Returns : uri path string json | @property | json () -> Dict Compute the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) -> \"PublicId\" Build from a JSON object. __ hash __ | __hash__ () -> int Get the hash. __ str __ | __str__ () -> str Get the string representation. __ repr __ | __repr__ () -> str Get the representation. __ eq __ | __eq__ ( other : Any ) -> bool Compare with another object. __ lt __ | __lt__ ( other : Any ) -> bool Compare two public ids. public_id_1 = PublicId(\"author_1\", \"name_1\", \"0.1.0\") public_id_2 = PublicId(\"author_1\", \"name_1\", \"0.1.1\") public_id_3 = PublicId(\"author_1\", \"name_2\", \"0.1.0\") public_id_1 > public_id_2 False public_id_1 < public_id_2 True public_id_1 < public_id_3 Traceback (most recent call last): ... ValueError: The public IDs author_1/name_1:0.1.0 and author_1/name_2:0.1.0 cannot be compared. Their author or name attributes are different. Arguments : other : the object to compate to Raises : ValueError : if the public ids cannot be confirmed Returns : whether or not the inequality is satisfied PackageId Objects class PackageId () A package identifier. __ init __ | __init__ ( package_type : Union [ PackageType , str ], public_id : PublicId ) -> None Initialize the package id. Arguments : package_type : the package type. public_id : the public id. package _ type | @property | package_type () -> PackageType Get the package type. public _ id | @property | public_id () -> PublicId Get the public id. author | @property | author () -> str Get the author of the package. name | @property | name () -> str Get the name of the package. version | @property | version () -> str Get the version of the package. package _ prefix | @property | package_prefix () -> Tuple [ PackageType , str , str ] Get the package identifier without the version. from _ uri _ path | @classmethod | from_uri_path ( cls , package_id_uri_path : str ) -> \"PackageId\" Initialize the package id from the string. str(PackageId.from_uri_path(\"skill/author/package_name/0.1.0\")) '(skill, author/package_name:0.1.0)' A bad formatted input raises value error: PackageId.from_uri_path(\"very/bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'very/bad/formatted:input' is not well formatted. Arguments : package_id_uri_path : the package id in uri path string format. Returns : the package id object. Raises : ValueError : if the string in input is not well formatted. to _ uri _ path | @property | to_uri_path () -> str Turn the package id into a uri path string. Returns : uri path string __ hash __ | __hash__ () -> int Get the hash. __ str __ | __str__ () -> str Get the string representation. __ repr __ | __repr__ () -> str Get the object representation in string. __ eq __ | __eq__ ( other : Any ) -> bool Compare with another object. __ lt __ | __lt__ ( other : Any ) -> bool Compare two public ids. ComponentId Objects class ComponentId ( PackageId ) Class to represent a component identifier. A component id is a package id, but excludes the case when the package is an agent. pacakge_id = PackageId(PackageType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) component_id = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) pacakge_id == component_id True component_id2 = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.1\")) pacakge_id == component_id2 False __ init __ | __init__ ( component_type : Union [ ComponentType , str ], public_id : PublicId ) -> None Initialize the component id. Arguments : component_type : the component type. public_id : the public id. component _ type | @property | component_type () -> ComponentType Get the component type. component _ prefix | @property | component_prefix () -> PackageIdPrefix Get the component identifier without the version. same _ prefix | same_prefix ( other : \"ComponentId\" ) -> bool Check if the other component id has the same type, author and name of this. prefix _ import _ path | @property | prefix_import_path () -> str Get the prefix import path for this component. json | @property | json () -> Dict Get the JSON representation. from _ json | @classmethod | from_json ( cls , json_data : Dict ) -> \"ComponentId\" Create component id from json data. PyPIPackageName Objects class PyPIPackageName ( RegexConstrainedString ) A PyPI Package name. GitRef Objects class GitRef ( RegexConstrainedString ) A Git reference. It can be a branch name, a commit hash or a tag. Dependency Objects class Dependency () This class represents a PyPI dependency. It contains the following information: - version: a version specifier(s) (e.g. '==0.1.0'). - index: the PyPI index where to download the package from (default: https://pypi.org) - git: the URL to the Git repository (e.g. https://github.com/fetchai/agents-aea.git) - ref: either the branch name, the tag, the commit number or a Git reference (default: 'master'.) If the 'git' field is set, the 'version' field will be ignored. These fields will be forwarded to the 'pip' command. __ init __ | __init__ ( name : Union [ PyPIPackageName , str ], version : Union [ str , SpecifierSet ] = \"\" , index : Optional [ str ] = None , git : Optional [ str ] = None , ref : Optional [ Union [ GitRef , str ]] = None ) -> None Initialize a PyPI dependency. Arguments : name : the package name. version : the specifier set object index : the URL to the PyPI server. git : the URL to a git repository. ref : the Git reference (branch/commit/tag). name | @property | name () -> str Get the name. version | @property | version () -> str Get the version. index | @property | index () -> Optional [ str ] Get the index. git | @property | git () -> Optional [ str ] Get the git. ref | @property | ref () -> Optional [ str ] Get the ref. from _ json | @classmethod | from_json ( cls , obj : Dict [ str , Dict [ str , str ]]) -> \"Dependency\" Parse a dependency object from a dictionary. to _ json | to_json () -> Dict [ str , Dict [ str , str ]] Transform the object to JSON. get _ pip _ install _ args | get_pip_install_args () -> List [ str ] Get 'pip install' arguments. __ str __ | __str__ () -> str Get the string representation. __ eq __ | __eq__ ( other : Any ) -> bool Compare with another object. Dependencies A dictionary from package name to dependency data structure (see above). The package name must satisfy the constraints on Python packages names . The main advantage of having a dictionary is that we implicitly filter out dependency duplicates. We cannot have two items with the same package name since the keys of a YAML object form a set. CRUDCollection Objects class CRUDCollection ( Generic [ T ]) Interface of a CRUD collection. __ init __ | __init__ () -> None Instantiate a CRUD collection. create | create ( item_id : str , item : T ) -> None Add an item. Arguments : item_id : the item id. item : the item to be added. Raises : ValueError : if the item with the same id is already in the collection. read | read ( item_id : str ) -> Optional [ T ] Get an item by its name. Arguments : item_id : the item id. Returns : the associated item, or None if the item id is not present. update | update ( item_id : str , item : T ) -> None Update an existing item. Arguments : item_id : the item id. item : the item to be added. delete | delete ( item_id : str ) -> None Delete an item. read _ all | read_all () -> List [ Tuple [ str , T ]] Read all the items. keys | keys () -> Set [ str ] Get the set of keys.","title":"Data Types"},{"location":"aea/api/configurations/data_types/#aeaconfigurationsdata_types","text":"Base config data types.","title":"aea.configurations.data_types"},{"location":"aea/api/configurations/data_types/#jsonserializable-objects","text":"class JSONSerializable ( ABC ) Interface for JSON-serializable objects.","title":"JSONSerializable Objects"},{"location":"aea/api/configurations/data_types/#json","text":"| @property | @abstractmethod | json () -> Dict Compute the JSON representation.","title":"json"},{"location":"aea/api/configurations/data_types/#from_json","text":"| @classmethod | from_json ( cls , obj : Dict ) -> \"JSONSerializable\" Build from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/data_types/#packageversion-objects","text":"@functools . total_ordering class PackageVersion () A package version.","title":"PackageVersion Objects"},{"location":"aea/api/configurations/data_types/#__init__","text":"| __init__ ( version_like : PackageVersionLike ) -> None Initialize a package version. Arguments : version_like : a string, os a semver.VersionInfo object.","title":"__init__"},{"location":"aea/api/configurations/data_types/#is_latest","text":"| @property | is_latest () -> bool Check whether the version is 'latest'.","title":"is_latest"},{"location":"aea/api/configurations/data_types/#__str__","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/configurations/data_types/#__eq__","text":"| __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"aea/api/configurations/data_types/#__lt__","text":"| __lt__ ( other : Any ) -> bool Compare with another object.","title":"__lt__"},{"location":"aea/api/configurations/data_types/#packagetype-objects","text":"class PackageType ( Enum ) Package types.","title":"PackageType Objects"},{"location":"aea/api/configurations/data_types/#to_plural","text":"| to_plural () -> str Get the plural name. PackageType.AGENT.to_plural() 'agents' PackageType.PROTOCOL.to_plural() 'protocols' PackageType.CONNECTION.to_plural() 'connections' PackageType.SKILL.to_plural() 'skills' PackageType.CONTRACT.to_plural() 'contracts' Returns : pluralised package type","title":"to_plural"},{"location":"aea/api/configurations/data_types/#__str___1","text":"| __str__ () -> str Convert to string.","title":"__str__"},{"location":"aea/api/configurations/data_types/#componenttype-objects","text":"class ComponentType ( Enum ) Enum of component types supported.","title":"ComponentType Objects"},{"location":"aea/api/configurations/data_types/#to_package_type","text":"| to_package_type () -> PackageType Get package type for component type.","title":"to_package_type"},{"location":"aea/api/configurations/data_types/#plurals","text":"| @staticmethod | plurals () -> Collection [ str ] Get the collection of type names, plural. ComponentType.plurals() ['protocols', 'connections', 'skills', 'contracts'] Returns : list of all pluralised component types","title":"plurals"},{"location":"aea/api/configurations/data_types/#to_plural_1","text":"| to_plural () -> str Get the plural version of the component type. ComponentType.PROTOCOL.to_plural() 'protocols' ComponentType.CONNECTION.to_plural() 'connections' ComponentType.SKILL.to_plural() 'skills' ComponentType.CONTRACT.to_plural() 'contracts' Returns : pluralised component type","title":"to_plural"},{"location":"aea/api/configurations/data_types/#__str___2","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/configurations/data_types/#publicid-objects","text":"class PublicId ( JSONSerializable ) This class implement a public identifier. A public identifier is composed of three elements: - author - name - version The concatenation of those three elements gives the public identifier: author/name:version public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert public_id.author == \"author\" assert public_id.name == \"my_package\" assert public_id.version == \"0.1.0\" another_public_id = PublicId(\"author\", \"my_package\", \"0.1.0\") assert hash(public_id) == hash(another_public_id) assert public_id == another_public_id latest_public_id = PublicId(\"author\", \"my_package\", \"latest\") latest_public_id latest_public_id.package_version.is_latest True","title":"PublicId Objects"},{"location":"aea/api/configurations/data_types/#__init___1","text":"| __init__ ( author : SimpleIdOrStr , name : SimpleIdOrStr , version : Optional [ PackageVersionLike ] = None ) -> None Initialize the public identifier.","title":"__init__"},{"location":"aea/api/configurations/data_types/#author","text":"| @property | author () -> str Get the author.","title":"author"},{"location":"aea/api/configurations/data_types/#name","text":"| @property | name () -> str Get the name.","title":"name"},{"location":"aea/api/configurations/data_types/#version","text":"| @property | version () -> str Get the version string.","title":"version"},{"location":"aea/api/configurations/data_types/#package_version","text":"| @property | package_version () -> PackageVersion Get the package version object.","title":"package_version"},{"location":"aea/api/configurations/data_types/#to_any","text":"| to_any () -> \"PublicId\" Return the same public id, but with any version.","title":"to_any"},{"location":"aea/api/configurations/data_types/#same_prefix","text":"| same_prefix ( other : \"PublicId\" ) -> bool Check if the other public id has the same author and name of this.","title":"same_prefix"},{"location":"aea/api/configurations/data_types/#to_latest","text":"| to_latest () -> \"PublicId\" Return the same public id, but with latest version.","title":"to_latest"},{"location":"aea/api/configurations/data_types/#is_valid_str","text":"| @classmethod | is_valid_str ( cls , public_id_string : str ) -> bool Check if a string is a public id. Arguments : public_id_string : the public id in string format. Returns : bool indicating validity","title":"is_valid_str"},{"location":"aea/api/configurations/data_types/#from_str","text":"| @classmethod | from_str ( cls , public_id_string : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_str(\"author/package_name:0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_str(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_string : the public id in string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted.","title":"from_str"},{"location":"aea/api/configurations/data_types/#try_from_str","text":"| @classmethod | try_from_str ( cls , public_id_string : str ) -> Optional [ \"PublicId\" ] Safely try to get public id from string. Arguments : public_id_string : the public id in string format. Returns : the public id object or None","title":"try_from_str"},{"location":"aea/api/configurations/data_types/#from_uri_path","text":"| @classmethod | from_uri_path ( cls , public_id_uri_path : str ) -> \"PublicId\" Initialize the public id from the string. str(PublicId.from_uri_path(\"author/package_name/0.1.0\")) 'author/package_name:0.1.0' A bad formatted input raises value error: PublicId.from_uri_path(\"bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'bad/formatted:input' is not well formatted. Arguments : public_id_uri_path : the public id in uri path string format. Returns : the public id object. Raises : ValueError : if the string in input is not well formatted.","title":"from_uri_path"},{"location":"aea/api/configurations/data_types/#to_uri_path","text":"| @property | to_uri_path () -> str Turn the public id into a uri path string. Returns : uri path string","title":"to_uri_path"},{"location":"aea/api/configurations/data_types/#json_1","text":"| @property | json () -> Dict Compute the JSON representation.","title":"json"},{"location":"aea/api/configurations/data_types/#from_json_1","text":"| @classmethod | from_json ( cls , obj : Dict ) -> \"PublicId\" Build from a JSON object.","title":"from_json"},{"location":"aea/api/configurations/data_types/#__hash__","text":"| __hash__ () -> int Get the hash.","title":"__hash__"},{"location":"aea/api/configurations/data_types/#__str___3","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/configurations/data_types/#__repr__","text":"| __repr__ () -> str Get the representation.","title":"__repr__"},{"location":"aea/api/configurations/data_types/#__eq___1","text":"| __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/configurations/data_types/#__lt___1","text":"| __lt__ ( other : Any ) -> bool Compare two public ids. public_id_1 = PublicId(\"author_1\", \"name_1\", \"0.1.0\") public_id_2 = PublicId(\"author_1\", \"name_1\", \"0.1.1\") public_id_3 = PublicId(\"author_1\", \"name_2\", \"0.1.0\") public_id_1 > public_id_2 False public_id_1 < public_id_2 True public_id_1 < public_id_3 Traceback (most recent call last): ... ValueError: The public IDs author_1/name_1:0.1.0 and author_1/name_2:0.1.0 cannot be compared. Their author or name attributes are different. Arguments : other : the object to compate to Raises : ValueError : if the public ids cannot be confirmed Returns : whether or not the inequality is satisfied","title":"__lt__"},{"location":"aea/api/configurations/data_types/#packageid-objects","text":"class PackageId () A package identifier.","title":"PackageId Objects"},{"location":"aea/api/configurations/data_types/#__init___2","text":"| __init__ ( package_type : Union [ PackageType , str ], public_id : PublicId ) -> None Initialize the package id. Arguments : package_type : the package type. public_id : the public id.","title":"__init__"},{"location":"aea/api/configurations/data_types/#package_type","text":"| @property | package_type () -> PackageType Get the package type.","title":"package_type"},{"location":"aea/api/configurations/data_types/#public_id","text":"| @property | public_id () -> PublicId Get the public id.","title":"public_id"},{"location":"aea/api/configurations/data_types/#author_1","text":"| @property | author () -> str Get the author of the package.","title":"author"},{"location":"aea/api/configurations/data_types/#name_1","text":"| @property | name () -> str Get the name of the package.","title":"name"},{"location":"aea/api/configurations/data_types/#version_1","text":"| @property | version () -> str Get the version of the package.","title":"version"},{"location":"aea/api/configurations/data_types/#package_prefix","text":"| @property | package_prefix () -> Tuple [ PackageType , str , str ] Get the package identifier without the version.","title":"package_prefix"},{"location":"aea/api/configurations/data_types/#from_uri_path_1","text":"| @classmethod | from_uri_path ( cls , package_id_uri_path : str ) -> \"PackageId\" Initialize the package id from the string. str(PackageId.from_uri_path(\"skill/author/package_name/0.1.0\")) '(skill, author/package_name:0.1.0)' A bad formatted input raises value error: PackageId.from_uri_path(\"very/bad/formatted:input\") Traceback (most recent call last): ... ValueError: Input 'very/bad/formatted:input' is not well formatted. Arguments : package_id_uri_path : the package id in uri path string format. Returns : the package id object. Raises : ValueError : if the string in input is not well formatted.","title":"from_uri_path"},{"location":"aea/api/configurations/data_types/#to_uri_path_1","text":"| @property | to_uri_path () -> str Turn the package id into a uri path string. Returns : uri path string","title":"to_uri_path"},{"location":"aea/api/configurations/data_types/#__hash___1","text":"| __hash__ () -> int Get the hash.","title":"__hash__"},{"location":"aea/api/configurations/data_types/#__str___4","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/configurations/data_types/#__repr___1","text":"| __repr__ () -> str Get the object representation in string.","title":"__repr__"},{"location":"aea/api/configurations/data_types/#__eq___2","text":"| __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/configurations/data_types/#__lt___2","text":"| __lt__ ( other : Any ) -> bool Compare two public ids.","title":"__lt__"},{"location":"aea/api/configurations/data_types/#componentid-objects","text":"class ComponentId ( PackageId ) Class to represent a component identifier. A component id is a package id, but excludes the case when the package is an agent. pacakge_id = PackageId(PackageType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) component_id = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.0\")) pacakge_id == component_id True component_id2 = ComponentId(ComponentType.PROTOCOL, PublicId(\"author\", \"name\", \"0.1.1\")) pacakge_id == component_id2 False","title":"ComponentId Objects"},{"location":"aea/api/configurations/data_types/#__init___3","text":"| __init__ ( component_type : Union [ ComponentType , str ], public_id : PublicId ) -> None Initialize the component id. Arguments : component_type : the component type. public_id : the public id.","title":"__init__"},{"location":"aea/api/configurations/data_types/#component_type","text":"| @property | component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"aea/api/configurations/data_types/#component_prefix","text":"| @property | component_prefix () -> PackageIdPrefix Get the component identifier without the version.","title":"component_prefix"},{"location":"aea/api/configurations/data_types/#same_prefix_1","text":"| same_prefix ( other : \"ComponentId\" ) -> bool Check if the other component id has the same type, author and name of this.","title":"same_prefix"},{"location":"aea/api/configurations/data_types/#prefix_import_path","text":"| @property | prefix_import_path () -> str Get the prefix import path for this component.","title":"prefix_import_path"},{"location":"aea/api/configurations/data_types/#json_2","text":"| @property | json () -> Dict Get the JSON representation.","title":"json"},{"location":"aea/api/configurations/data_types/#from_json_2","text":"| @classmethod | from_json ( cls , json_data : Dict ) -> \"ComponentId\" Create component id from json data.","title":"from_json"},{"location":"aea/api/configurations/data_types/#pypipackagename-objects","text":"class PyPIPackageName ( RegexConstrainedString ) A PyPI Package name.","title":"PyPIPackageName Objects"},{"location":"aea/api/configurations/data_types/#gitref-objects","text":"class GitRef ( RegexConstrainedString ) A Git reference. It can be a branch name, a commit hash or a tag.","title":"GitRef Objects"},{"location":"aea/api/configurations/data_types/#dependency-objects","text":"class Dependency () This class represents a PyPI dependency. It contains the following information: - version: a version specifier(s) (e.g. '==0.1.0'). - index: the PyPI index where to download the package from (default: https://pypi.org) - git: the URL to the Git repository (e.g. https://github.com/fetchai/agents-aea.git) - ref: either the branch name, the tag, the commit number or a Git reference (default: 'master'.) If the 'git' field is set, the 'version' field will be ignored. These fields will be forwarded to the 'pip' command.","title":"Dependency Objects"},{"location":"aea/api/configurations/data_types/#__init___4","text":"| __init__ ( name : Union [ PyPIPackageName , str ], version : Union [ str , SpecifierSet ] = \"\" , index : Optional [ str ] = None , git : Optional [ str ] = None , ref : Optional [ Union [ GitRef , str ]] = None ) -> None Initialize a PyPI dependency. Arguments : name : the package name. version : the specifier set object index : the URL to the PyPI server. git : the URL to a git repository. ref : the Git reference (branch/commit/tag).","title":"__init__"},{"location":"aea/api/configurations/data_types/#name_2","text":"| @property | name () -> str Get the name.","title":"name"},{"location":"aea/api/configurations/data_types/#version_2","text":"| @property | version () -> str Get the version.","title":"version"},{"location":"aea/api/configurations/data_types/#index","text":"| @property | index () -> Optional [ str ] Get the index.","title":"index"},{"location":"aea/api/configurations/data_types/#git","text":"| @property | git () -> Optional [ str ] Get the git.","title":"git"},{"location":"aea/api/configurations/data_types/#ref","text":"| @property | ref () -> Optional [ str ] Get the ref.","title":"ref"},{"location":"aea/api/configurations/data_types/#from_json_3","text":"| @classmethod | from_json ( cls , obj : Dict [ str , Dict [ str , str ]]) -> \"Dependency\" Parse a dependency object from a dictionary.","title":"from_json"},{"location":"aea/api/configurations/data_types/#to_json","text":"| to_json () -> Dict [ str , Dict [ str , str ]] Transform the object to JSON.","title":"to_json"},{"location":"aea/api/configurations/data_types/#get_pip_install_args","text":"| get_pip_install_args () -> List [ str ] Get 'pip install' arguments.","title":"get_pip_install_args"},{"location":"aea/api/configurations/data_types/#__str___5","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/configurations/data_types/#__eq___3","text":"| __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/configurations/data_types/#dependencies","text":"A dictionary from package name to dependency data structure (see above). The package name must satisfy the constraints on Python packages names . The main advantage of having a dictionary is that we implicitly filter out dependency duplicates. We cannot have two items with the same package name since the keys of a YAML object form a set.","title":"Dependencies"},{"location":"aea/api/configurations/data_types/#crudcollection-objects","text":"class CRUDCollection ( Generic [ T ]) Interface of a CRUD collection.","title":"CRUDCollection Objects"},{"location":"aea/api/configurations/data_types/#__init___5","text":"| __init__ () -> None Instantiate a CRUD collection.","title":"__init__"},{"location":"aea/api/configurations/data_types/#create","text":"| create ( item_id : str , item : T ) -> None Add an item. Arguments : item_id : the item id. item : the item to be added. Raises : ValueError : if the item with the same id is already in the collection.","title":"create"},{"location":"aea/api/configurations/data_types/#read","text":"| read ( item_id : str ) -> Optional [ T ] Get an item by its name. Arguments : item_id : the item id. Returns : the associated item, or None if the item id is not present.","title":"read"},{"location":"aea/api/configurations/data_types/#update","text":"| update ( item_id : str , item : T ) -> None Update an existing item. Arguments : item_id : the item id. item : the item to be added.","title":"update"},{"location":"aea/api/configurations/data_types/#delete","text":"| delete ( item_id : str ) -> None Delete an item.","title":"delete"},{"location":"aea/api/configurations/data_types/#read_all","text":"| read_all () -> List [ Tuple [ str , T ]] Read all the items.","title":"read_all"},{"location":"aea/api/configurations/data_types/#keys","text":"| keys () -> Set [ str ] Get the set of keys.","title":"keys"},{"location":"aea/api/configurations/loader/","text":"aea.configurations.loader Implementation of the parser for configuration file. BaseConfigLoader Objects class BaseConfigLoader () Base class for configuration loader classes. __ init __ | __init__ ( schema_filename : str ) -> None Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'. validator | @property | validator () -> ConfigValidator Get the json schema validator. validate | validate ( json_data : Dict ) -> None Validate a JSON object. Arguments : json_data : the JSON data. required _ fields | @property | required_fields () -> List [ str ] Get the required fields. Returns : list of required fields. ConfigLoader Objects class ConfigLoader ( Generic [ T ], BaseConfigLoader ) Parsing, serialization and validation for package configuration files. __ init __ | __init__ ( schema_filename : str , configuration_class : Type [ T ], skip_aea_validation : bool = True ) -> None Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'. configuration_class : the configuration class (e.g. AgentConfig, SkillConfig etc.) skip_aea_validation : if True, the validation of the AEA version is skipped. configuration _ class | @property | configuration_class () -> Type [ T ] Get the configuration class of the loader. validate | validate ( json_data : Dict ) -> None Validate a JSON representation of an AEA package. First, checks whether the AEA version is compatible with the configuration file. Then, validates the JSON object against the specific schema. Arguments : json_data : the JSON data. load _ protocol _ specification | load_protocol_specification ( file_pointer : TextIO ) -> ProtocolSpecification Load an agent configuration file. Arguments : file_pointer : the file pointer to the configuration file Returns : the configuration object. :raises load | load ( file_pointer : TextIO ) -> T Load a configuration file. Arguments : file_pointer : the file pointer to the configuration file Returns : the configuration object. dump | dump ( configuration : T , file_pointer : TextIO ) -> None Dump a configuration. Arguments : configuration : the configuration to be dumped. file_pointer : the file pointer to the configuration file from _ configuration _ type | @classmethod | from_configuration_type ( cls , configuration_type : Union [ PackageType , str ], ** kwargs : Any ) -> \"ConfigLoader\" Get the configuration loader from the type. Arguments : configuration_type : the type of configuration kwargs : keyword arguments to the configuration loader constructor. Returns : the configuration loader load _ agent _ config _ from _ json | load_agent_config_from_json ( configuration_json : List [ Dict ], validate : bool = True ) -> AgentConfig Load agent configuration from configuration json data. Arguments : configuration_json : list of dicts with aea configuration validate : whether or not to validate Returns : AgentConfig instance ConfigLoaders Objects class ConfigLoaders () Configuration Loader class to load any package type. from _ package _ type | @classmethod | from_package_type ( cls , configuration_type : Union [ PackageType , str ], ** kwargs : Any ) -> \"ConfigLoader\" Get a config loader from the configuration type. Arguments : configuration_type : the configuration type. kwargs : keyword arguments to the configuration loader constructor. Returns : configuration loader load _ component _ configuration load_component_configuration ( component_type : ComponentType , directory : Path , skip_consistency_check : bool = False , skip_aea_validation : bool = True ) -> ComponentConfiguration Load configuration and check that it is consistent against the directory. Arguments : component_type : the component type. directory : the root of the package skip_consistency_check : if True, the consistency check are skipped. skip_aea_validation : if True, the validation of the AEA version is skipped. Returns : the configuration object. load _ package _ configuration load_package_configuration ( package_type : PackageType , directory : Path , skip_consistency_check : bool = False , skip_aea_validation : bool = True ) -> PackageConfiguration Load configuration and check that it is consistent against the directory. Arguments : package_type : the package type. directory : the root of the package skip_consistency_check : if True, the consistency check are skipped. skip_aea_validation : if True, the validation of the AEA version is skipped. Returns : the configuration object.","title":"Loader"},{"location":"aea/api/configurations/loader/#aeaconfigurationsloader","text":"Implementation of the parser for configuration file.","title":"aea.configurations.loader"},{"location":"aea/api/configurations/loader/#baseconfigloader-objects","text":"class BaseConfigLoader () Base class for configuration loader classes.","title":"BaseConfigLoader Objects"},{"location":"aea/api/configurations/loader/#__init__","text":"| __init__ ( schema_filename : str ) -> None Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'.","title":"__init__"},{"location":"aea/api/configurations/loader/#validator","text":"| @property | validator () -> ConfigValidator Get the json schema validator.","title":"validator"},{"location":"aea/api/configurations/loader/#validate","text":"| validate ( json_data : Dict ) -> None Validate a JSON object. Arguments : json_data : the JSON data.","title":"validate"},{"location":"aea/api/configurations/loader/#required_fields","text":"| @property | required_fields () -> List [ str ] Get the required fields. Returns : list of required fields.","title":"required_fields"},{"location":"aea/api/configurations/loader/#configloader-objects","text":"class ConfigLoader ( Generic [ T ], BaseConfigLoader ) Parsing, serialization and validation for package configuration files.","title":"ConfigLoader Objects"},{"location":"aea/api/configurations/loader/#__init___1","text":"| __init__ ( schema_filename : str , configuration_class : Type [ T ], skip_aea_validation : bool = True ) -> None Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'. configuration_class : the configuration class (e.g. AgentConfig, SkillConfig etc.) skip_aea_validation : if True, the validation of the AEA version is skipped.","title":"__init__"},{"location":"aea/api/configurations/loader/#configuration_class","text":"| @property | configuration_class () -> Type [ T ] Get the configuration class of the loader.","title":"configuration_class"},{"location":"aea/api/configurations/loader/#validate_1","text":"| validate ( json_data : Dict ) -> None Validate a JSON representation of an AEA package. First, checks whether the AEA version is compatible with the configuration file. Then, validates the JSON object against the specific schema. Arguments : json_data : the JSON data.","title":"validate"},{"location":"aea/api/configurations/loader/#load_protocol_specification","text":"| load_protocol_specification ( file_pointer : TextIO ) -> ProtocolSpecification Load an agent configuration file. Arguments : file_pointer : the file pointer to the configuration file Returns : the configuration object. :raises","title":"load_protocol_specification"},{"location":"aea/api/configurations/loader/#load","text":"| load ( file_pointer : TextIO ) -> T Load a configuration file. Arguments : file_pointer : the file pointer to the configuration file Returns : the configuration object.","title":"load"},{"location":"aea/api/configurations/loader/#dump","text":"| dump ( configuration : T , file_pointer : TextIO ) -> None Dump a configuration. Arguments : configuration : the configuration to be dumped. file_pointer : the file pointer to the configuration file","title":"dump"},{"location":"aea/api/configurations/loader/#from_configuration_type","text":"| @classmethod | from_configuration_type ( cls , configuration_type : Union [ PackageType , str ], ** kwargs : Any ) -> \"ConfigLoader\" Get the configuration loader from the type. Arguments : configuration_type : the type of configuration kwargs : keyword arguments to the configuration loader constructor. Returns : the configuration loader","title":"from_configuration_type"},{"location":"aea/api/configurations/loader/#load_agent_config_from_json","text":"| load_agent_config_from_json ( configuration_json : List [ Dict ], validate : bool = True ) -> AgentConfig Load agent configuration from configuration json data. Arguments : configuration_json : list of dicts with aea configuration validate : whether or not to validate Returns : AgentConfig instance","title":"load_agent_config_from_json"},{"location":"aea/api/configurations/loader/#configloaders-objects","text":"class ConfigLoaders () Configuration Loader class to load any package type.","title":"ConfigLoaders Objects"},{"location":"aea/api/configurations/loader/#from_package_type","text":"| @classmethod | from_package_type ( cls , configuration_type : Union [ PackageType , str ], ** kwargs : Any ) -> \"ConfigLoader\" Get a config loader from the configuration type. Arguments : configuration_type : the configuration type. kwargs : keyword arguments to the configuration loader constructor. Returns : configuration loader","title":"from_package_type"},{"location":"aea/api/configurations/loader/#load_component_configuration","text":"load_component_configuration ( component_type : ComponentType , directory : Path , skip_consistency_check : bool = False , skip_aea_validation : bool = True ) -> ComponentConfiguration Load configuration and check that it is consistent against the directory. Arguments : component_type : the component type. directory : the root of the package skip_consistency_check : if True, the consistency check are skipped. skip_aea_validation : if True, the validation of the AEA version is skipped. Returns : the configuration object.","title":"load_component_configuration"},{"location":"aea/api/configurations/loader/#load_package_configuration","text":"load_package_configuration ( package_type : PackageType , directory : Path , skip_consistency_check : bool = False , skip_aea_validation : bool = True ) -> PackageConfiguration Load configuration and check that it is consistent against the directory. Arguments : package_type : the package type. directory : the root of the package skip_consistency_check : if True, the consistency check are skipped. skip_aea_validation : if True, the validation of the AEA version is skipped. Returns : the configuration object.","title":"load_package_configuration"},{"location":"aea/api/configurations/manager/","text":"aea.configurations.manager Implementation of the AgentConfigManager. VariableDoesNotExist Objects class VariableDoesNotExist ( ValueError ) Variable does not exist in a config exception. handle _ dotted _ path handle_dotted_path ( value : str , author : str , aea_project_path : Union [ str , Path ] = \".\" ) -> Tuple [ List [ str ], Path , ConfigLoader , Optional [ ComponentId ]] Separate the path between path to resource and json path to attribute. Allowed values: 'agent.an_attribute_name' 'protocols.my_protocol.an_attribute_name' 'connections.my_connection.an_attribute_name' 'contracts.my_contract.an_attribute_name' 'skills.my_skill.an_attribute_name' 'vendor.author.[protocols|contracts|connections|skills].package_name.attribute_name We also return the component id to retrieve the configuration of a specific component. Notice that at this point we don't know the version, so we put 'latest' as version, but later we will ignore it because we will filter with only the component prefix (i.e. the triple type, author and name). Arguments : value : dotted path. author : the author string. aea_project_path : project path Returns : Tuple[list of settings dict keys, filepath, config loader, component id]. find _ component _ directory _ from _ component _ id find_component_directory_from_component_id ( aea_project_directory : Path , component_id : ComponentId ) -> Path Find a component directory from component id. AgentConfigManager Objects class AgentConfigManager () AeaConfig manager. __ init __ | __init__ ( agent_config : AgentConfig , aea_project_directory : Union [ str , Path ], env_vars_friendly : bool = False ) -> None Init manager. Arguments : agent_config : AgentConfig to manage. aea_project_directory : directory where project for agent_config placed. env_vars_friendly : whether or not it is env vars friendly load _ component _ configuration | load_component_configuration ( component_id : ComponentId , skip_consistency_check : bool = True ) -> ComponentConfiguration Load component configuration from the project directory. Arguments : component_id : Id of the component to load config for. skip_consistency_check : bool. Returns : ComponentConfiguration agent _ config _ file _ path | @property | agent_config_file_path () -> Path Return agent config file path. load | @classmethod | load ( cls , aea_project_path : Union [ Path , str ], substitude_env_vars : bool = False ) -> \"AgentConfigManager\" Create AgentConfigManager instance from agent project path. set _ variable | set_variable ( path : VariablePath , value : JSON_TYPES ) -> None Set config variable. Arguments : path : str dotted path or List[Union[ComponentId, str]] value : one of the json friendly objects. get _ variable | get_variable ( path : VariablePath ) -> JSON_TYPES Set config variable. Arguments : path : str dotted path or List[Union[ComponentId, str]] Returns : json friendly value. update _ config | update_config ( overrides : Dict ) -> None Apply overrides for agent config. Validates and applies agent config and component overrides. Does not save it on the disc! Arguments : overrides : overridden values dictionary Returns : None validate _ current _ config | validate_current_config () -> None Check is current config valid. json | @property | json () -> Dict Return current agent config json representation. dump _ config | dump_config () -> None Save agent config on the disc. verify _ private _ keys | @classmethod | verify_private_keys ( cls , aea_project_path : Union [ Path , str ], private_key_helper : Callable [[ AgentConfig , Path , Optional [ str ]], None ], substitude_env_vars : bool = False , password : Optional [ str ] = None ) -> \"AgentConfigManager\" Verify private keys. Does not saves the config! Use AgentConfigManager.dump_config() Arguments : aea_project_path : path to an AEA project. private_key_helper : private_key_helper is a function that use agent config to check the keys substitude_env_vars : replace env vars with values, does not dump config password : the password to encrypt/decrypt the private key. Returns : the agent configuration manager. get _ overridables | get_overridables () -> Tuple [ Dict , Dict [ ComponentId , Dict ]] Get config overridables.","title":"Manager"},{"location":"aea/api/configurations/manager/#aeaconfigurationsmanager","text":"Implementation of the AgentConfigManager.","title":"aea.configurations.manager"},{"location":"aea/api/configurations/manager/#variabledoesnotexist-objects","text":"class VariableDoesNotExist ( ValueError ) Variable does not exist in a config exception.","title":"VariableDoesNotExist Objects"},{"location":"aea/api/configurations/manager/#handle_dotted_path","text":"handle_dotted_path ( value : str , author : str , aea_project_path : Union [ str , Path ] = \".\" ) -> Tuple [ List [ str ], Path , ConfigLoader , Optional [ ComponentId ]] Separate the path between path to resource and json path to attribute. Allowed values: 'agent.an_attribute_name' 'protocols.my_protocol.an_attribute_name' 'connections.my_connection.an_attribute_name' 'contracts.my_contract.an_attribute_name' 'skills.my_skill.an_attribute_name' 'vendor.author.[protocols|contracts|connections|skills].package_name.attribute_name We also return the component id to retrieve the configuration of a specific component. Notice that at this point we don't know the version, so we put 'latest' as version, but later we will ignore it because we will filter with only the component prefix (i.e. the triple type, author and name). Arguments : value : dotted path. author : the author string. aea_project_path : project path Returns : Tuple[list of settings dict keys, filepath, config loader, component id].","title":"handle_dotted_path"},{"location":"aea/api/configurations/manager/#find_component_directory_from_component_id","text":"find_component_directory_from_component_id ( aea_project_directory : Path , component_id : ComponentId ) -> Path Find a component directory from component id.","title":"find_component_directory_from_component_id"},{"location":"aea/api/configurations/manager/#agentconfigmanager-objects","text":"class AgentConfigManager () AeaConfig manager.","title":"AgentConfigManager Objects"},{"location":"aea/api/configurations/manager/#__init__","text":"| __init__ ( agent_config : AgentConfig , aea_project_directory : Union [ str , Path ], env_vars_friendly : bool = False ) -> None Init manager. Arguments : agent_config : AgentConfig to manage. aea_project_directory : directory where project for agent_config placed. env_vars_friendly : whether or not it is env vars friendly","title":"__init__"},{"location":"aea/api/configurations/manager/#load_component_configuration","text":"| load_component_configuration ( component_id : ComponentId , skip_consistency_check : bool = True ) -> ComponentConfiguration Load component configuration from the project directory. Arguments : component_id : Id of the component to load config for. skip_consistency_check : bool. Returns : ComponentConfiguration","title":"load_component_configuration"},{"location":"aea/api/configurations/manager/#agent_config_file_path","text":"| @property | agent_config_file_path () -> Path Return agent config file path.","title":"agent_config_file_path"},{"location":"aea/api/configurations/manager/#load","text":"| @classmethod | load ( cls , aea_project_path : Union [ Path , str ], substitude_env_vars : bool = False ) -> \"AgentConfigManager\" Create AgentConfigManager instance from agent project path.","title":"load"},{"location":"aea/api/configurations/manager/#set_variable","text":"| set_variable ( path : VariablePath , value : JSON_TYPES ) -> None Set config variable. Arguments : path : str dotted path or List[Union[ComponentId, str]] value : one of the json friendly objects.","title":"set_variable"},{"location":"aea/api/configurations/manager/#get_variable","text":"| get_variable ( path : VariablePath ) -> JSON_TYPES Set config variable. Arguments : path : str dotted path or List[Union[ComponentId, str]] Returns : json friendly value.","title":"get_variable"},{"location":"aea/api/configurations/manager/#update_config","text":"| update_config ( overrides : Dict ) -> None Apply overrides for agent config. Validates and applies agent config and component overrides. Does not save it on the disc! Arguments : overrides : overridden values dictionary Returns : None","title":"update_config"},{"location":"aea/api/configurations/manager/#validate_current_config","text":"| validate_current_config () -> None Check is current config valid.","title":"validate_current_config"},{"location":"aea/api/configurations/manager/#json","text":"| @property | json () -> Dict Return current agent config json representation.","title":"json"},{"location":"aea/api/configurations/manager/#dump_config","text":"| dump_config () -> None Save agent config on the disc.","title":"dump_config"},{"location":"aea/api/configurations/manager/#verify_private_keys","text":"| @classmethod | verify_private_keys ( cls , aea_project_path : Union [ Path , str ], private_key_helper : Callable [[ AgentConfig , Path , Optional [ str ]], None ], substitude_env_vars : bool = False , password : Optional [ str ] = None ) -> \"AgentConfigManager\" Verify private keys. Does not saves the config! Use AgentConfigManager.dump_config() Arguments : aea_project_path : path to an AEA project. private_key_helper : private_key_helper is a function that use agent config to check the keys substitude_env_vars : replace env vars with values, does not dump config password : the password to encrypt/decrypt the private key. Returns : the agent configuration manager.","title":"verify_private_keys"},{"location":"aea/api/configurations/manager/#get_overridables","text":"| get_overridables () -> Tuple [ Dict , Dict [ ComponentId , Dict ]] Get config overridables.","title":"get_overridables"},{"location":"aea/api/configurations/pypi/","text":"aea.configurations.pypi This module contains a checker for PyPI version consistency. and _ and_ ( s1 : SpecifierSet , s2 : SpecifierSet ) -> SpecifierSet Do the and between two specifier sets. is _ satisfiable is_satisfiable ( specifier_set : SpecifierSet ) -> bool Check if the specifier set is satisfiable. Satisfiable means that there exists a version number that satisfies all the constraints. It is worth noticing that it doesn't mean that that version number with that package actually exists. from packaging.specifiers import SpecifierSet The specifier set \">0.9, ==1.0\" is satisfiable: the version number \"1.0\" satisfies the constraints s1 = SpecifierSet(\">0.9,==1.0\") \"1.0\" in s1 True is_satisfiable(s1) True The specifier set \"==1.0, >1.1\" is not satisfiable: s1 = SpecifierSet(\"==1.0,>1.1\") is_satisfiable(s1) False For other details, please refer to PEP440: https://www.python.org/dev/peps/pep-0440 Arguments : specifier_set : the specifier set. Returns : False if the constraints are surely non-satisfiable, True if we don't know. is _ simple _ dep is_simple_dep ( dep : Dependency ) -> bool Check if it is a simple dependency. Namely, if it has no field specified, or only the 'version' field set. Arguments : dep : the dependency Returns : whether it is a simple dependency or not to _ set _ specifier to_set_specifier ( dep : Dependency ) -> SpecifierSet Get the set specifier. It assumes to be a simple dependency (see above). merge _ dependencies merge_dependencies ( dep1 : Dependencies , dep2 : Dependencies ) -> Dependencies Merge two groups of dependencies. If some of them are not \"simple\" (see above), and there is no risk of conflict because there is no other package with the same name, we leave them; otherwise we raise an error. Arguments : dep1 : the first operand dep2 : the second operand. Returns : the merged dependencies. merge _ dependencies _ list merge_dependencies_list ( * deps : Dependencies ) -> Dependencies Merge a list of dependencies. Arguments : deps : the list of dependencies Returns : the merged dependencies.","title":"Pypi"},{"location":"aea/api/configurations/pypi/#aeaconfigurationspypi","text":"This module contains a checker for PyPI version consistency.","title":"aea.configurations.pypi"},{"location":"aea/api/configurations/pypi/#and_","text":"and_ ( s1 : SpecifierSet , s2 : SpecifierSet ) -> SpecifierSet Do the and between two specifier sets.","title":"and_"},{"location":"aea/api/configurations/pypi/#is_satisfiable","text":"is_satisfiable ( specifier_set : SpecifierSet ) -> bool Check if the specifier set is satisfiable. Satisfiable means that there exists a version number that satisfies all the constraints. It is worth noticing that it doesn't mean that that version number with that package actually exists. from packaging.specifiers import SpecifierSet The specifier set \">0.9, ==1.0\" is satisfiable: the version number \"1.0\" satisfies the constraints s1 = SpecifierSet(\">0.9,==1.0\") \"1.0\" in s1 True is_satisfiable(s1) True The specifier set \"==1.0, >1.1\" is not satisfiable: s1 = SpecifierSet(\"==1.0,>1.1\") is_satisfiable(s1) False For other details, please refer to PEP440: https://www.python.org/dev/peps/pep-0440 Arguments : specifier_set : the specifier set. Returns : False if the constraints are surely non-satisfiable, True if we don't know.","title":"is_satisfiable"},{"location":"aea/api/configurations/pypi/#is_simple_dep","text":"is_simple_dep ( dep : Dependency ) -> bool Check if it is a simple dependency. Namely, if it has no field specified, or only the 'version' field set. Arguments : dep : the dependency Returns : whether it is a simple dependency or not","title":"is_simple_dep"},{"location":"aea/api/configurations/pypi/#to_set_specifier","text":"to_set_specifier ( dep : Dependency ) -> SpecifierSet Get the set specifier. It assumes to be a simple dependency (see above).","title":"to_set_specifier"},{"location":"aea/api/configurations/pypi/#merge_dependencies","text":"merge_dependencies ( dep1 : Dependencies , dep2 : Dependencies ) -> Dependencies Merge two groups of dependencies. If some of them are not \"simple\" (see above), and there is no risk of conflict because there is no other package with the same name, we leave them; otherwise we raise an error. Arguments : dep1 : the first operand dep2 : the second operand. Returns : the merged dependencies.","title":"merge_dependencies"},{"location":"aea/api/configurations/pypi/#merge_dependencies_list","text":"merge_dependencies_list ( * deps : Dependencies ) -> Dependencies Merge a list of dependencies. Arguments : deps : the list of dependencies Returns : the merged dependencies.","title":"merge_dependencies_list"},{"location":"aea/api/configurations/utils/","text":"aea.configurations.utils AEA configuration utils. replace _ component _ ids @singledispatch replace_component_ids ( _arg : PackageConfiguration , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Update public id references in a package configuration. This depends on the actual configuration being considered. _ @replace_component_ids . register ( AgentConfig ) # type: ignore _ ( arg : AgentConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Replace references in agent configuration. It breaks down in: 1) replace public ids in 'protocols', 'connections', 'contracts' and 'skills'; 2) replace public ids in default routing; 3) replace public id of default connection; 4) replace custom component configurations. Arguments : arg : the agent configuration. replacements : the replacement mapping. _ @replace_component_ids . register ( ProtocolConfig ) # type: ignore _ ( _arg : ProtocolConfig , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Do nothing - protocols have no references. _ @replace_component_ids . register ( ConnectionConfig ) # type: ignore _ ( arg : ConnectionConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Replace references in a connection configuration. _ @replace_component_ids . register ( ContractConfig ) # type: ignore _ ( _arg : ContractConfig , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Do nothing - contracts have no references. _ @replace_component_ids . register ( SkillConfig ) # type: ignore _ ( arg : SkillConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Replace references in a skill configuration. get _ latest _ component _ id _ from _ prefix get_latest_component_id_from_prefix ( agent_config : AgentConfig , component_prefix : PackageIdPrefix ) -> Optional [ ComponentId ] Get component id with the greatest version in an agent configuration given its prefix. Arguments : agent_config : the agent configuration. component_prefix : the package prefix. Returns : the package id with the greatest version, or None if not found.","title":"Utils"},{"location":"aea/api/configurations/utils/#aeaconfigurationsutils","text":"AEA configuration utils.","title":"aea.configurations.utils"},{"location":"aea/api/configurations/utils/#replace_component_ids","text":"@singledispatch replace_component_ids ( _arg : PackageConfiguration , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Update public id references in a package configuration. This depends on the actual configuration being considered.","title":"replace_component_ids"},{"location":"aea/api/configurations/utils/#_","text":"@replace_component_ids . register ( AgentConfig ) # type: ignore _ ( arg : AgentConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Replace references in agent configuration. It breaks down in: 1) replace public ids in 'protocols', 'connections', 'contracts' and 'skills'; 2) replace public ids in default routing; 3) replace public id of default connection; 4) replace custom component configurations. Arguments : arg : the agent configuration. replacements : the replacement mapping.","title":"_"},{"location":"aea/api/configurations/utils/#__1","text":"@replace_component_ids . register ( ProtocolConfig ) # type: ignore _ ( _arg : ProtocolConfig , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Do nothing - protocols have no references.","title":"_"},{"location":"aea/api/configurations/utils/#__2","text":"@replace_component_ids . register ( ConnectionConfig ) # type: ignore _ ( arg : ConnectionConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Replace references in a connection configuration.","title":"_"},{"location":"aea/api/configurations/utils/#__3","text":"@replace_component_ids . register ( ContractConfig ) # type: ignore _ ( _arg : ContractConfig , _replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Do nothing - contracts have no references.","title":"_"},{"location":"aea/api/configurations/utils/#__4","text":"@replace_component_ids . register ( SkillConfig ) # type: ignore _ ( arg : SkillConfig , replacements : Dict [ ComponentType , Dict [ PublicId , PublicId ]]) -> None Replace references in a skill configuration.","title":"_"},{"location":"aea/api/configurations/utils/#get_latest_component_id_from_prefix","text":"get_latest_component_id_from_prefix ( agent_config : AgentConfig , component_prefix : PackageIdPrefix ) -> Optional [ ComponentId ] Get component id with the greatest version in an agent configuration given its prefix. Arguments : agent_config : the agent configuration. component_prefix : the package prefix. Returns : the package id with the greatest version, or None if not found.","title":"get_latest_component_id_from_prefix"},{"location":"aea/api/configurations/validation/","text":"aea.configurations.validation Implementation of the configuration validation. make _ jsonschema _ base _ uri make_jsonschema_base_uri ( base_uri_path : Path ) -> str Make the JSONSchema base URI, cross-platform. Arguments : base_uri_path : the path to the base directory. Returns : the string in URI form. ExtraPropertiesError Objects class ExtraPropertiesError ( ValueError ) Extra properties exception. __ str __ | __str__ () -> str Get string representation of the object. __ repr __ | __repr__ () -> str Get string representation of the object. CustomTypeChecker Objects class CustomTypeChecker ( TypeChecker ) Custom type checker to handle env variables. is _ type | is_type ( instance , type ) -> bool Check is instance of type. own _ additional _ properties own_additional_properties ( validator , aP , instance , schema ) -> Iterator Additional properties validator. ConfigValidator Objects class ConfigValidator () Configuration validator implementation. __ init __ | __init__ ( schema_filename : str , env_vars_friendly : bool = False ) -> None Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'. env_vars_friendly : whether or not it is env var friendly. split _ component _ id _ and _ config | @staticmethod | split_component_id_and_config ( component_index : int , component_configuration_json : Dict ) -> ComponentId Split component id and configuration. Arguments : component_index : the position of the component configuration in the agent config file.. component_configuration_json : the JSON object to process. Returns : the component id and the configuration object. Raises : ValueError : if the component id cannot be extracted. validate _ component _ configuration | @classmethod | validate_component_configuration ( cls , component_id : ComponentId , configuration : Dict , env_vars_friendly : bool = False ) -> None Validate the component configuration of an agent configuration file. This check is to detect inconsistencies in the specified fields. Arguments : component_id : the component id. configuration : the configuration dictionary. env_vars_friendly : bool, if set True, will not raise errors over the env variable definitions. Raises : ValueError : if the configuration is not valid. validate | validate ( json_data : Dict ) -> None Validate a JSON object against the right JSON schema. Arguments : json_data : the JSON data. validate _ agent _ components _ configuration | validate_agent_components_configuration ( component_configurations : Dict ) -> None Validate agent component configurations overrides. Arguments : component_configurations : the component configurations to validate. required _ fields | @property | required_fields () -> List [ str ] Get the required fields. Returns : list of required fields. validate _ data _ with _ pattern validate_data_with_pattern ( data : dict , pattern : dict , excludes : Optional [ List [ Tuple [ str ]]] = None , skip_env_vars : bool = False ) -> List [ str ] Validate data dict with pattern dict for attributes present and type match. Arguments : data : data dict to validate pattern : dict with pattern to check over excludes : list of tuples of str of paths to be skipped during the check skip_env_vars : is set True will not check data type over env variables. Returns : list of str with error descriptions filter _ data filter_data ( base : Any , updates : Any ) -> Any Return difference in values or SAME_MARK object if values are the same.","title":"Validation"},{"location":"aea/api/configurations/validation/#aeaconfigurationsvalidation","text":"Implementation of the configuration validation.","title":"aea.configurations.validation"},{"location":"aea/api/configurations/validation/#make_jsonschema_base_uri","text":"make_jsonschema_base_uri ( base_uri_path : Path ) -> str Make the JSONSchema base URI, cross-platform. Arguments : base_uri_path : the path to the base directory. Returns : the string in URI form.","title":"make_jsonschema_base_uri"},{"location":"aea/api/configurations/validation/#extrapropertieserror-objects","text":"class ExtraPropertiesError ( ValueError ) Extra properties exception.","title":"ExtraPropertiesError Objects"},{"location":"aea/api/configurations/validation/#__str__","text":"| __str__ () -> str Get string representation of the object.","title":"__str__"},{"location":"aea/api/configurations/validation/#__repr__","text":"| __repr__ () -> str Get string representation of the object.","title":"__repr__"},{"location":"aea/api/configurations/validation/#customtypechecker-objects","text":"class CustomTypeChecker ( TypeChecker ) Custom type checker to handle env variables.","title":"CustomTypeChecker Objects"},{"location":"aea/api/configurations/validation/#is_type","text":"| is_type ( instance , type ) -> bool Check is instance of type.","title":"is_type"},{"location":"aea/api/configurations/validation/#own_additional_properties","text":"own_additional_properties ( validator , aP , instance , schema ) -> Iterator Additional properties validator.","title":"own_additional_properties"},{"location":"aea/api/configurations/validation/#configvalidator-objects","text":"class ConfigValidator () Configuration validator implementation.","title":"ConfigValidator Objects"},{"location":"aea/api/configurations/validation/#__init__","text":"| __init__ ( schema_filename : str , env_vars_friendly : bool = False ) -> None Initialize the parser for configuration files. Arguments : schema_filename : the path to the JSON-schema file in 'aea/configurations/schemas'. env_vars_friendly : whether or not it is env var friendly.","title":"__init__"},{"location":"aea/api/configurations/validation/#split_component_id_and_config","text":"| @staticmethod | split_component_id_and_config ( component_index : int , component_configuration_json : Dict ) -> ComponentId Split component id and configuration. Arguments : component_index : the position of the component configuration in the agent config file.. component_configuration_json : the JSON object to process. Returns : the component id and the configuration object. Raises : ValueError : if the component id cannot be extracted.","title":"split_component_id_and_config"},{"location":"aea/api/configurations/validation/#validate_component_configuration","text":"| @classmethod | validate_component_configuration ( cls , component_id : ComponentId , configuration : Dict , env_vars_friendly : bool = False ) -> None Validate the component configuration of an agent configuration file. This check is to detect inconsistencies in the specified fields. Arguments : component_id : the component id. configuration : the configuration dictionary. env_vars_friendly : bool, if set True, will not raise errors over the env variable definitions. Raises : ValueError : if the configuration is not valid.","title":"validate_component_configuration"},{"location":"aea/api/configurations/validation/#validate","text":"| validate ( json_data : Dict ) -> None Validate a JSON object against the right JSON schema. Arguments : json_data : the JSON data.","title":"validate"},{"location":"aea/api/configurations/validation/#validate_agent_components_configuration","text":"| validate_agent_components_configuration ( component_configurations : Dict ) -> None Validate agent component configurations overrides. Arguments : component_configurations : the component configurations to validate.","title":"validate_agent_components_configuration"},{"location":"aea/api/configurations/validation/#required_fields","text":"| @property | required_fields () -> List [ str ] Get the required fields. Returns : list of required fields.","title":"required_fields"},{"location":"aea/api/configurations/validation/#validate_data_with_pattern","text":"validate_data_with_pattern ( data : dict , pattern : dict , excludes : Optional [ List [ Tuple [ str ]]] = None , skip_env_vars : bool = False ) -> List [ str ] Validate data dict with pattern dict for attributes present and type match. Arguments : data : data dict to validate pattern : dict with pattern to check over excludes : list of tuples of str of paths to be skipped during the check skip_env_vars : is set True will not check data type over env variables. Returns : list of str with error descriptions","title":"validate_data_with_pattern"},{"location":"aea/api/configurations/validation/#filter_data","text":"filter_data ( base : Any , updates : Any ) -> Any Return difference in values or SAME_MARK object if values are the same.","title":"filter_data"},{"location":"aea/api/connections/base/","text":"aea.connections.base The base connection package. ConnectionStates Objects class ConnectionStates ( Enum ) Connection states enum. Connection Objects class Connection ( Component , ABC ) Abstract definition of a connection. __ init __ | __init__ ( configuration : ConnectionConfig , data_dir : str , identity : Optional [ Identity ] = None , crypto_store : Optional [ CryptoStore ] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None , ** kwargs : Any , ,) -> None Initialize the connection. The configuration must be specified if and only if the following parameters are None: connection_id, excluded_protocols or restricted_to_protocols. Arguments : configuration : the connection configuration. data_dir : directory where to put local files. identity : the identity object held by the agent. crypto_store : the crypto store for encrypted communication. restricted_to_protocols : the set of protocols ids of the only supported protocols for this connection. excluded_protocols : the set of protocols ids that we want to exclude for this connection. kwargs : keyword arguments passed to component base loop | @property | loop () -> asyncio . AbstractEventLoop Get the event loop. address | @property | address () -> \"Address\" Get the address. crypto _ store | @property | crypto_store () -> CryptoStore Get the crypto store. has _ crypto _ store | @property | has_crypto_store () -> bool Check if the connection has the crypto store. data _ dir | @property | data_dir () -> str Get the data directory. component _ type | @property | component_type () -> ComponentType Get the component type. configuration | @property | configuration () -> ConnectionConfig Get the connection configuration. restricted _ to _ protocols | @property | restricted_to_protocols () -> Set [ PublicId ] Get the ids of the protocols this connection is restricted to. excluded _ protocols | @property | excluded_protocols () -> Set [ PublicId ] Get the ids of the excluded protocols for this connection. state | @property | state () -> ConnectionStates Get the connection status. state | @state . setter | state ( value : ConnectionStates ) -> None Set the connection status. connect | @abstractmethod | async connect () -> None Set up the connection. disconnect | @abstractmethod | async disconnect () -> None Tear down the connection. send | @abstractmethod | async send ( envelope : \"Envelope\" ) -> None Send an envelope. Arguments : envelope : the envelope to send. Returns : None receive | @abstractmethod | async receive ( * args : Any , ** kwargs : Any ) -> Optional [ \"Envelope\" ] Receive an envelope. Arguments : args : positional arguments kwargs : keyword arguments Returns : the received envelope, or None if an error occurred. from _ dir | @classmethod | from_dir ( cls , directory : str , identity : Identity , crypto_store : CryptoStore , data_dir : str , ** kwargs : Any , ,) -> \"Connection\" Load the connection from a directory. Arguments : directory : the directory to the connection package. identity : the identity object. crypto_store : object to access the connection crypto objects. data_dir : the assets directory. kwargs : keyword arguments passed to connection base Returns : the connection object. from _ config | @classmethod | from_config ( cls , configuration : ConnectionConfig , identity : Identity , crypto_store : CryptoStore , data_dir : str , ** kwargs : Any , ,) -> \"Connection\" Load a connection from a configuration. Arguments : configuration : the connection configuration. identity : the identity object. crypto_store : object to access the connection crypto objects. data_dir : the directory of the AEA project data. kwargs : keyword arguments passed to component base Returns : an instance of the concrete connection class. is _ connected | @property | is_connected () -> bool Return is connected state. is _ connecting | @property | is_connecting () -> bool Return is connecting state. is _ disconnected | @property | is_disconnected () -> bool Return is disconnected state. BaseSyncConnection Objects class BaseSyncConnection ( Connection ) Base sync connection class to write connections with sync code. __ init __ | __init__ ( configuration : ConnectionConfig , data_dir : str , identity : Optional [ Identity ] = None , crypto_store : Optional [ CryptoStore ] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None , ** kwargs : Any , ,) -> None Initialize the connection. The configuration must be specified if and only if the following parameters are None: connection_id, excluded_protocols or restricted_to_protocols. Arguments : configuration : the connection configuration. data_dir : directory where to put local files. identity : the identity object held by the agent. crypto_store : the crypto store for encrypted communication. restricted_to_protocols : the set of protocols ids of the only supported protocols for this connection. excluded_protocols : the set of protocols ids that we want to exclude for this connection. kwargs : keyword arguments passed to connection base put _ envelope | put_envelope ( envelope : Optional [ \"Envelope\" ]) -> None Put envelope in to the incoming queue. connect | async connect () -> None Connect connection. disconnect | async disconnect () -> None Disconnect connection. send | async send ( envelope : \"Envelope\" ) -> None Send envelope to connection. receive | async receive ( * args : Any , ** kwargs : Any ) -> Optional [ \"Envelope\" ] Get an envelope from the connection. start _ main | start_main () -> None Start main function of the connection. main | main () -> None Run main body of the connection in dedicated thread. on _ connect | @abstractmethod | on_connect () -> None Run on connect method called. on _ disconnect | @abstractmethod | on_disconnect () -> None Run on disconnect method called. on _ send | @abstractmethod | on_send ( envelope : \"Envelope\" ) -> None Run on send method called.","title":"Base"},{"location":"aea/api/connections/base/#aeaconnectionsbase","text":"The base connection package.","title":"aea.connections.base"},{"location":"aea/api/connections/base/#connectionstates-objects","text":"class ConnectionStates ( Enum ) Connection states enum.","title":"ConnectionStates Objects"},{"location":"aea/api/connections/base/#connection-objects","text":"class Connection ( Component , ABC ) Abstract definition of a connection.","title":"Connection Objects"},{"location":"aea/api/connections/base/#__init__","text":"| __init__ ( configuration : ConnectionConfig , data_dir : str , identity : Optional [ Identity ] = None , crypto_store : Optional [ CryptoStore ] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None , ** kwargs : Any , ,) -> None Initialize the connection. The configuration must be specified if and only if the following parameters are None: connection_id, excluded_protocols or restricted_to_protocols. Arguments : configuration : the connection configuration. data_dir : directory where to put local files. identity : the identity object held by the agent. crypto_store : the crypto store for encrypted communication. restricted_to_protocols : the set of protocols ids of the only supported protocols for this connection. excluded_protocols : the set of protocols ids that we want to exclude for this connection. kwargs : keyword arguments passed to component base","title":"__init__"},{"location":"aea/api/connections/base/#loop","text":"| @property | loop () -> asyncio . AbstractEventLoop Get the event loop.","title":"loop"},{"location":"aea/api/connections/base/#address","text":"| @property | address () -> \"Address\" Get the address.","title":"address"},{"location":"aea/api/connections/base/#crypto_store","text":"| @property | crypto_store () -> CryptoStore Get the crypto store.","title":"crypto_store"},{"location":"aea/api/connections/base/#has_crypto_store","text":"| @property | has_crypto_store () -> bool Check if the connection has the crypto store.","title":"has_crypto_store"},{"location":"aea/api/connections/base/#data_dir","text":"| @property | data_dir () -> str Get the data directory.","title":"data_dir"},{"location":"aea/api/connections/base/#component_type","text":"| @property | component_type () -> ComponentType Get the component type.","title":"component_type"},{"location":"aea/api/connections/base/#configuration","text":"| @property | configuration () -> ConnectionConfig Get the connection configuration.","title":"configuration"},{"location":"aea/api/connections/base/#restricted_to_protocols","text":"| @property | restricted_to_protocols () -> Set [ PublicId ] Get the ids of the protocols this connection is restricted to.","title":"restricted_to_protocols"},{"location":"aea/api/connections/base/#excluded_protocols","text":"| @property | excluded_protocols () -> Set [ PublicId ] Get the ids of the excluded protocols for this connection.","title":"excluded_protocols"},{"location":"aea/api/connections/base/#state","text":"| @property | state () -> ConnectionStates Get the connection status.","title":"state"},{"location":"aea/api/connections/base/#state_1","text":"| @state . setter | state ( value : ConnectionStates ) -> None Set the connection status.","title":"state"},{"location":"aea/api/connections/base/#connect","text":"| @abstractmethod | async connect () -> None Set up the connection.","title":"connect"},{"location":"aea/api/connections/base/#disconnect","text":"| @abstractmethod | async disconnect () -> None Tear down the connection.","title":"disconnect"},{"location":"aea/api/connections/base/#send","text":"| @abstractmethod | async send ( envelope : \"Envelope\" ) -> None Send an envelope. Arguments : envelope : the envelope to send. Returns : None","title":"send"},{"location":"aea/api/connections/base/#receive","text":"| @abstractmethod | async receive ( * args : Any , ** kwargs : Any ) -> Optional [ \"Envelope\" ] Receive an envelope. Arguments : args : positional arguments kwargs : keyword arguments Returns : the received envelope, or None if an error occurred.","title":"receive"},{"location":"aea/api/connections/base/#from_dir","text":"| @classmethod | from_dir ( cls , directory : str , identity : Identity , crypto_store : CryptoStore , data_dir : str , ** kwargs : Any , ,) -> \"Connection\" Load the connection from a directory. Arguments : directory : the directory to the connection package. identity : the identity object. crypto_store : object to access the connection crypto objects. data_dir : the assets directory. kwargs : keyword arguments passed to connection base Returns : the connection object.","title":"from_dir"},{"location":"aea/api/connections/base/#from_config","text":"| @classmethod | from_config ( cls , configuration : ConnectionConfig , identity : Identity , crypto_store : CryptoStore , data_dir : str , ** kwargs : Any , ,) -> \"Connection\" Load a connection from a configuration. Arguments : configuration : the connection configuration. identity : the identity object. crypto_store : object to access the connection crypto objects. data_dir : the directory of the AEA project data. kwargs : keyword arguments passed to component base Returns : an instance of the concrete connection class.","title":"from_config"},{"location":"aea/api/connections/base/#is_connected","text":"| @property | is_connected () -> bool Return is connected state.","title":"is_connected"},{"location":"aea/api/connections/base/#is_connecting","text":"| @property | is_connecting () -> bool Return is connecting state.","title":"is_connecting"},{"location":"aea/api/connections/base/#is_disconnected","text":"| @property | is_disconnected () -> bool Return is disconnected state.","title":"is_disconnected"},{"location":"aea/api/connections/base/#basesyncconnection-objects","text":"class BaseSyncConnection ( Connection ) Base sync connection class to write connections with sync code.","title":"BaseSyncConnection Objects"},{"location":"aea/api/connections/base/#__init___1","text":"| __init__ ( configuration : ConnectionConfig , data_dir : str , identity : Optional [ Identity ] = None , crypto_store : Optional [ CryptoStore ] = None , restricted_to_protocols : Optional [ Set [ PublicId ]] = None , excluded_protocols : Optional [ Set [ PublicId ]] = None , ** kwargs : Any , ,) -> None Initialize the connection. The configuration must be specified if and only if the following parameters are None: connection_id, excluded_protocols or restricted_to_protocols. Arguments : configuration : the connection configuration. data_dir : directory where to put local files. identity : the identity object held by the agent. crypto_store : the crypto store for encrypted communication. restricted_to_protocols : the set of protocols ids of the only supported protocols for this connection. excluded_protocols : the set of protocols ids that we want to exclude for this connection. kwargs : keyword arguments passed to connection base","title":"__init__"},{"location":"aea/api/connections/base/#put_envelope","text":"| put_envelope ( envelope : Optional [ \"Envelope\" ]) -> None Put envelope in to the incoming queue.","title":"put_envelope"},{"location":"aea/api/connections/base/#connect_1","text":"| async connect () -> None Connect connection.","title":"connect"},{"location":"aea/api/connections/base/#disconnect_1","text":"| async disconnect () -> None Disconnect connection.","title":"disconnect"},{"location":"aea/api/connections/base/#send_1","text":"| async send ( envelope : \"Envelope\" ) -> None Send envelope to connection.","title":"send"},{"location":"aea/api/connections/base/#receive_1","text":"| async receive ( * args : Any , ** kwargs : Any ) -> Optional [ \"Envelope\" ] Get an envelope from the connection.","title":"receive"},{"location":"aea/api/connections/base/#start_main","text":"| start_main () -> None Start main function of the connection.","title":"start_main"},{"location":"aea/api/connections/base/#main","text":"| main () -> None Run main body of the connection in dedicated thread.","title":"main"},{"location":"aea/api/connections/base/#on_connect","text":"| @abstractmethod | on_connect () -> None Run on connect method called.","title":"on_connect"},{"location":"aea/api/connections/base/#on_disconnect","text":"| @abstractmethod | on_disconnect () -> None Run on disconnect method called.","title":"on_disconnect"},{"location":"aea/api/connections/base/#on_send","text":"| @abstractmethod | on_send ( envelope : \"Envelope\" ) -> None Run on send method called.","title":"on_send"},{"location":"aea/api/context/base/","text":"aea.context.base This module contains the agent context class. AgentContext Objects class AgentContext () Provide read access to relevant objects of the agent for the skills. __ init __ | __init__ ( identity : Identity , connection_status : MultiplexerStatus , outbox : OutBox , decision_maker_message_queue : Queue , decision_maker_handler_context : SimpleNamespace , task_manager : TaskManager , default_ledger_id : str , currency_denominations : Dict [ str , str ], default_connection : Optional [ PublicId ], default_routing : Dict [ PublicId , PublicId ], search_service_address : Address , decision_maker_address : Address , data_dir : str , storage_callable : Callable [[], Optional [ Storage ]] = lambda : None , send_to_skill : Optional [ Callable ] = None , ** kwargs : Any ) -> None Initialize an agent context. Arguments : identity : the identity object connection_status : the connection status of the multiplexer outbox : the outbox decision_maker_message_queue : the (in) queue of the decision maker decision_maker_handler_context : the decision maker's name space task_manager : the task manager default_ledger_id : the default ledger id currency_denominations : mapping from ledger ids to currency denominations default_connection : the default connection default_routing : the default routing search_service_address : the address of the search service decision_maker_address : the address of the decision maker data_dir : directory where to put local files. storage_callable : function that returns optional storage attached to agent. send_to_skill : callable for sending envelopes to skills. kwargs : keyword arguments to be attached in the agent context namespace. send _ to _ skill | send_to_skill ( message_or_envelope : Union [ Message , Envelope ], context : Optional [ EnvelopeContext ] = None ) -> None Send message or envelope to another skill. If message passed it will be wrapped into envelope with optional envelope context. Arguments : message_or_envelope : envelope to send to another skill. context : the optional envelope context storage | @property | storage () -> Optional [ Storage ] Return storage instance if enabled in AEA. data _ dir | @property | data_dir () -> str Return assets directory. shared _ state | @property | shared_state () -> Dict [ str , Any ] Get the shared state dictionary. The shared state is the only object which skills can use to exchange state directly. It is accessible (read and write) from all skills. Returns : dictionary of the shared state. identity | @property | identity () -> Identity Get the identity. agent _ name | @property | agent_name () -> str Get agent name. addresses | @property | addresses () -> Dict [ str , Address ] Get addresses. public _ keys | @property | public_keys () -> Dict [ str , str ] Get public keys. address | @property | address () -> Address Get the default address. public _ key | @property | public_key () -> str Get the default public key. connection _ status | @property | connection_status () -> MultiplexerStatus Get connection status of the multiplexer. outbox | @property | outbox () -> OutBox Get outbox. decision _ maker _ message _ queue | @property | decision_maker_message_queue () -> Queue Get decision maker queue. decision _ maker _ handler _ context | @property | decision_maker_handler_context () -> SimpleNamespace Get the decision maker handler context. task _ manager | @property | task_manager () -> TaskManager Get the task manager. search _ service _ address | @property | search_service_address () -> Address Get the address of the search service. decision _ maker _ address | @property | decision_maker_address () -> Address Get the address of the decision maker. default _ ledger _ id | @property | default_ledger_id () -> str Get the default ledger id. currency _ denominations | @property | currency_denominations () -> Dict [ str , str ] Get a dictionary mapping ledger ids to currency denominations. default _ connection | @property | default_connection () -> Optional [ PublicId ] Get the default connection. default _ routing | @property | default_routing () -> Dict [ PublicId , PublicId ] Get the default routing. namespace | @property | namespace () -> SimpleNamespace Get the agent context namespace.","title":"Context"},{"location":"aea/api/context/base/#aeacontextbase","text":"This module contains the agent context class.","title":"aea.context.base"},{"location":"aea/api/context/base/#agentcontext-objects","text":"class AgentContext () Provide read access to relevant objects of the agent for the skills.","title":"AgentContext Objects"},{"location":"aea/api/context/base/#__init__","text":"| __init__ ( identity : Identity , connection_status : MultiplexerStatus , outbox : OutBox , decision_maker_message_queue : Queue , decision_maker_handler_context : SimpleNamespace , task_manager : TaskManager , default_ledger_id : str , currency_denominations : Dict [ str , str ], default_connection : Optional [ PublicId ], default_routing : Dict [ PublicId , PublicId ], search_service_address : Address , decision_maker_address : Address , data_dir : str , storage_callable : Callable [[], Optional [ Storage ]] = lambda : None , send_to_skill : Optional [ Callable ] = None , ** kwargs : Any ) -> None Initialize an agent context. Arguments : identity : the identity object connection_status : the connection status of the multiplexer outbox : the outbox decision_maker_message_queue : the (in) queue of the decision maker decision_maker_handler_context : the decision maker's name space task_manager : the task manager default_ledger_id : the default ledger id currency_denominations : mapping from ledger ids to currency denominations default_connection : the default connection default_routing : the default routing search_service_address : the address of the search service decision_maker_address : the address of the decision maker data_dir : directory where to put local files. storage_callable : function that returns optional storage attached to agent. send_to_skill : callable for sending envelopes to skills. kwargs : keyword arguments to be attached in the agent context namespace.","title":"__init__"},{"location":"aea/api/context/base/#send_to_skill","text":"| send_to_skill ( message_or_envelope : Union [ Message , Envelope ], context : Optional [ EnvelopeContext ] = None ) -> None Send message or envelope to another skill. If message passed it will be wrapped into envelope with optional envelope context. Arguments : message_or_envelope : envelope to send to another skill. context : the optional envelope context","title":"send_to_skill"},{"location":"aea/api/context/base/#storage","text":"| @property | storage () -> Optional [ Storage ] Return storage instance if enabled in AEA.","title":"storage"},{"location":"aea/api/context/base/#data_dir","text":"| @property | data_dir () -> str Return assets directory.","title":"data_dir"},{"location":"aea/api/context/base/#shared_state","text":"| @property | shared_state () -> Dict [ str , Any ] Get the shared state dictionary. The shared state is the only object which skills can use to exchange state directly. It is accessible (read and write) from all skills. Returns : dictionary of the shared state.","title":"shared_state"},{"location":"aea/api/context/base/#identity","text":"| @property | identity () -> Identity Get the identity.","title":"identity"},{"location":"aea/api/context/base/#agent_name","text":"| @property | agent_name () -> str Get agent name.","title":"agent_name"},{"location":"aea/api/context/base/#addresses","text":"| @property | addresses () -> Dict [ str , Address ] Get addresses.","title":"addresses"},{"location":"aea/api/context/base/#public_keys","text":"| @property | public_keys () -> Dict [ str , str ] Get public keys.","title":"public_keys"},{"location":"aea/api/context/base/#address","text":"| @property | address () -> Address Get the default address.","title":"address"},{"location":"aea/api/context/base/#public_key","text":"| @property | public_key () -> str Get the default public key.","title":"public_key"},{"location":"aea/api/context/base/#connection_status","text":"| @property | connection_status () -> MultiplexerStatus Get connection status of the multiplexer.","title":"connection_status"},{"location":"aea/api/context/base/#outbox","text":"| @property | outbox () -> OutBox Get outbox.","title":"outbox"},{"location":"aea/api/context/base/#decision_maker_message_queue","text":"| @property | decision_maker_message_queue () -> Queue Get decision maker queue.","title":"decision_maker_message_queue"},{"location":"aea/api/context/base/#decision_maker_handler_context","text":"| @property | decision_maker_handler_context () -> SimpleNamespace Get the decision maker handler context.","title":"decision_maker_handler_context"},{"location":"aea/api/context/base/#task_manager","text":"| @property | task_manager () -> TaskManager Get the task manager.","title":"task_manager"},{"location":"aea/api/context/base/#search_service_address","text":"| @property | search_service_address () -> Address Get the address of the search service.","title":"search_service_address"},{"location":"aea/api/context/base/#decision_maker_address","text":"| @property | decision_maker_address () -> Address Get the address of the decision maker.","title":"decision_maker_address"},{"location":"aea/api/context/base/#default_ledger_id","text":"| @property | default_ledger_id () -> str Get the default ledger id.","title":"default_ledger_id"},{"location":"aea/api/context/base/#currency_denominations","text":"| @property | currency_denominations () -> Dict [ str , str ] Get a dictionary mapping ledger ids to currency denominations.","title":"currency_denominations"},{"location":"aea/api/context/base/#default_connection","text":"| @property | default_connection () -> Optional [ PublicId ] Get the default connection.","title":"default_connection"},{"location":"aea/api/context/base/#default_routing","text":"| @property | default_routing () -> Dict [ PublicId , PublicId ] Get the default routing.","title":"default_routing"},{"location":"aea/api/context/base/#namespace","text":"| @property | namespace () -> SimpleNamespace Get the agent context namespace.","title":"namespace"},{"location":"aea/api/contracts/base/","text":"aea.contracts.base The base contract. Contract Objects class Contract ( Component ) Abstract definition of a contract. __ init __ | __init__ ( contract_config : ContractConfig , ** kwargs : Any ) -> None Initialize the contract. Arguments : contract_config : the contract configurations. kwargs : the keyword arguments. id | @property | id () -> PublicId Get the name. configuration | @property | configuration () -> ContractConfig Get the configuration. get _ instance | @classmethod | get_instance ( cls , ledger_api : LedgerApi , contract_address : Optional [ str ] = None ) -> Any Get the instance. Arguments : ledger_api : the ledger api we are using. contract_address : the contract address. Returns : the contract instance from _ dir | @classmethod | from_dir ( cls , directory : str , ** kwargs : Any ) -> \"Contract\" Load the protocol from a directory. Arguments : directory : the directory to the skill package. kwargs : the keyword arguments. Returns : the contract object. from _ config | @classmethod | from_config ( cls , configuration : ContractConfig , ** kwargs : Any ) -> \"Contract\" Load contract from configuration. Arguments : configuration : the contract configuration. kwargs : the keyword arguments. Returns : the contract object. get _ deploy _ transaction | @classmethod | get_deploy_transaction ( cls , ledger_api : LedgerApi , deployer_address : str , ** kwargs : Any ) -> Optional [ JSONLike ] Handler method for the 'GET_DEPLOY_TRANSACTION' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. deployer_address : The address that will deploy the contract. kwargs : keyword arguments. Returns : the tx get _ raw _ transaction | @classmethod | get_raw_transaction ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs : Any ) -> Optional [ JSONLike ] Handler method for the 'GET_RAW_TRANSACTION' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. kwargs : the keyword arguments. Returns : the tx # noqa: DAR202 get _ raw _ message | @classmethod | get_raw_message ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs : Any ) -> Optional [ bytes ] Handler method for the 'GET_RAW_MESSAGE' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. kwargs : the keyword arguments. Returns : the tx # noqa: DAR202 get _ state | @classmethod | get_state ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs : Any ) -> Optional [ JSONLike ] Handler method for the 'GET_STATE' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. kwargs : the keyword arguments. Returns : the tx # noqa: DAR202","title":"Base"},{"location":"aea/api/contracts/base/#aeacontractsbase","text":"The base contract.","title":"aea.contracts.base"},{"location":"aea/api/contracts/base/#contract-objects","text":"class Contract ( Component ) Abstract definition of a contract.","title":"Contract Objects"},{"location":"aea/api/contracts/base/#__init__","text":"| __init__ ( contract_config : ContractConfig , ** kwargs : Any ) -> None Initialize the contract. Arguments : contract_config : the contract configurations. kwargs : the keyword arguments.","title":"__init__"},{"location":"aea/api/contracts/base/#id","text":"| @property | id () -> PublicId Get the name.","title":"id"},{"location":"aea/api/contracts/base/#configuration","text":"| @property | configuration () -> ContractConfig Get the configuration.","title":"configuration"},{"location":"aea/api/contracts/base/#get_instance","text":"| @classmethod | get_instance ( cls , ledger_api : LedgerApi , contract_address : Optional [ str ] = None ) -> Any Get the instance. Arguments : ledger_api : the ledger api we are using. contract_address : the contract address. Returns : the contract instance","title":"get_instance"},{"location":"aea/api/contracts/base/#from_dir","text":"| @classmethod | from_dir ( cls , directory : str , ** kwargs : Any ) -> \"Contract\" Load the protocol from a directory. Arguments : directory : the directory to the skill package. kwargs : the keyword arguments. Returns : the contract object.","title":"from_dir"},{"location":"aea/api/contracts/base/#from_config","text":"| @classmethod | from_config ( cls , configuration : ContractConfig , ** kwargs : Any ) -> \"Contract\" Load contract from configuration. Arguments : configuration : the contract configuration. kwargs : the keyword arguments. Returns : the contract object.","title":"from_config"},{"location":"aea/api/contracts/base/#get_deploy_transaction","text":"| @classmethod | get_deploy_transaction ( cls , ledger_api : LedgerApi , deployer_address : str , ** kwargs : Any ) -> Optional [ JSONLike ] Handler method for the 'GET_DEPLOY_TRANSACTION' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. deployer_address : The address that will deploy the contract. kwargs : keyword arguments. Returns : the tx","title":"get_deploy_transaction"},{"location":"aea/api/contracts/base/#get_raw_transaction","text":"| @classmethod | get_raw_transaction ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs : Any ) -> Optional [ JSONLike ] Handler method for the 'GET_RAW_TRANSACTION' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. kwargs : the keyword arguments. Returns : the tx # noqa: DAR202","title":"get_raw_transaction"},{"location":"aea/api/contracts/base/#get_raw_message","text":"| @classmethod | get_raw_message ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs : Any ) -> Optional [ bytes ] Handler method for the 'GET_RAW_MESSAGE' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. kwargs : the keyword arguments. Returns : the tx # noqa: DAR202","title":"get_raw_message"},{"location":"aea/api/contracts/base/#get_state","text":"| @classmethod | get_state ( cls , ledger_api : LedgerApi , contract_address : str , ** kwargs : Any ) -> Optional [ JSONLike ] Handler method for the 'GET_STATE' requests. Implement this method in the sub class if you want to handle the contract requests manually. Arguments : ledger_api : the ledger apis. contract_address : the contract address. kwargs : the keyword arguments. Returns : the tx # noqa: DAR202","title":"get_state"},{"location":"aea/api/crypto/base/","text":"aea.crypto.base Abstract module wrapping the public and private key cryptography and ledger api. Crypto Objects class Crypto ( Generic [ EntityClass ], ABC ) Base class for a crypto object. __ init __ | __init__ ( private_key_path : Optional [ str ] = None , password : Optional [ str ] = None , ** kwargs : Any , ,) -> None Initialize the crypto object. The actual behaviour of this constructor is determined by the abstract methods 'generate_private_key()' and 'load_private_key_from_path(). Either way, the entity object will be accessible as a property. Arguments : private_key_path : the path to the private key. If None, the key will be generated by 'generate_private_key()'. If not None, the path will be processed by 'load_private_key_from_path()'. password : the password to encrypt/decrypt the private key. kwargs : keyword arguments. generate _ private _ key | @classmethod | @abstractmethod | generate_private_key ( cls ) -> EntityClass Generate a private key. Returns : the entity object. Implementation dependent. load _ private _ key _ from _ path | @classmethod | @abstractmethod | load_private_key_from_path ( cls , file_name : str , password : Optional [ str ] = None ) -> EntityClass Load a private key in hex format for raw private key and json format for encrypted private key from a file. Arguments : file_name : the path to the hex/json file. password : the password to encrypt/decrypt the private key. Returns : the entity object. entity | @property | entity () -> EntityClass Return an entity object. Returns : an entity object private _ key | @property | @abstractmethod | private_key () -> str Return a private key. Returns : a private key string public _ key | @property | @abstractmethod | public_key () -> str Return a public key. Returns : a public key string address | @property | @abstractmethod | address () -> str Return the address. Returns : an address string sign _ message | @abstractmethod | sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form sign _ transaction | @abstractmethod | sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in dict form. Arguments : transaction : the transaction to be signed Returns : signed transaction load | @classmethod | load ( cls , private_key_file : str , password : Optional [ str ] = None ) -> str Load private key from file. Arguments : private_key_file : the file where the key is stored. password : the password to encrypt/decrypt the private key. Returns : private_key in hex string format dump | dump ( private_key_file : str , password : Optional [ str ] = None ) -> None Dump private key to file. Arguments : private_key_file : the file where the key is stored. password : the password to encrypt/decrypt the private key. encrypt | @abstractmethod | encrypt ( password : str ) -> str Encrypt the private key and return in json. Arguments : password : the password to decrypt. Returns : json string containing encrypted private key. decrypt | @classmethod | @abstractmethod | decrypt ( cls , keyfile_json : str , password : str ) -> str Decrypt the private key and return in raw form. Arguments : keyfile_json : json string containing encrypted private key. password : the password to decrypt. Returns : the raw private key. Helper Objects class Helper ( ABC ) Interface for helper class usable as Mixin for LedgerApi or as standalone class. is _ transaction _ settled | @staticmethod | @abstractmethod | is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_receipt : the receipt associated to the transaction. Returns : True if the transaction has been settled, False o/w. is _ transaction _ valid | @staticmethod | @abstractmethod | is_transaction_valid ( tx : JSONLike , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input'] get _ contract _ address | @staticmethod | @abstractmethod | get_contract_address ( tx_receipt : JSONLike ) -> Optional [ str ] Get the contract address from a transaction receipt. Arguments : tx_receipt : the transaction digest Returns : the contract address if successful generate _ tx _ nonce | @staticmethod | @abstractmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish transactions with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. get _ address _ from _ public _ key | @classmethod | @abstractmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str recover _ message | @classmethod | @abstractmethod | recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses recover _ public _ keys _ from _ message | @classmethod | @abstractmethod | recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys get _ hash | @staticmethod | @abstractmethod | get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message. is _ valid _ address | @classmethod | @abstractmethod | is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate load _ contract _ interface | @classmethod | @abstractmethod | load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface LedgerApi Objects class LedgerApi ( Helper , ABC ) Interface for ledger APIs. api | @property | @abstractmethod | api () -> Any Get the underlying API object. This can be used for low-level operations with the concrete ledger APIs. If there is no such object, return None. get _ balance | @abstractmethod | get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. This usually takes the form of a web request to be waited synchronously. Arguments : address : the address. Returns : the balance. get _ state | @abstractmethod | get_state ( callable_name : str , * args : Any , ** kwargs : Any ) -> Optional [ JSONLike ] Call a specified function on the underlying ledger API. This usually takes the form of a web request to be waited synchronously. Arguments : callable_name : the name of the API function to be called. args : the positional arguments for the API function. kwargs : the keyword arguments for the API function. Returns : the ledger API response. get _ transfer _ transaction | @abstractmethod | get_transfer_transaction ( sender_address : Address , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , ** kwargs : Any , ,) -> Optional [ JSONLike ] Submit a transfer transaction to the ledger. Arguments : sender_address : the sender address of the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx kwargs : the keyword arguments. Returns : the transfer transaction send _ signed _ transaction | @abstractmethod | send_signed_transaction ( tx_signed : JSONLike ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Use keyword arguments for the specifying the signed transaction payload. Arguments : tx_signed : the signed transaction get _ transaction _ receipt | @abstractmethod | get_transaction_receipt ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction receipt for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present get _ transaction | @abstractmethod | get_transaction ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx, if present get _ contract _ instance | @abstractmethod | get_contract_instance ( contract_interface : Dict [ str , str ], contract_address : Optional [ str ] = None ) -> Any Get the instance of a contract. Arguments : contract_interface : the contract interface. contract_address : the contract address. Returns : the contract instance get _ deploy _ transaction | @abstractmethod | get_deploy_transaction ( contract_interface : Dict [ str , str ], deployer_address : Address , ** kwargs : Any , ,) -> Optional [ JSONLike ] Get the transaction to deploy the smart contract. Arguments : contract_interface : the contract interface. deployer_address : The address that will deploy the contract. kwargs : the keyword arguments. :returns tx: the transaction dictionary. update _ with _ gas _ estimate | @abstractmethod | update_with_gas_estimate ( transaction : JSONLike ) -> JSONLike Attempts to update the transaction with a gas estimate Arguments : transaction : the transaction Returns : the updated transaction FaucetApi Objects class FaucetApi ( ABC ) Interface for testnet faucet APIs. get _ wealth | @abstractmethod | get_wealth ( address : Address , url : Optional [ str ] = None ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. url : the url Returns : None","title":"Base"},{"location":"aea/api/crypto/base/#aeacryptobase","text":"Abstract module wrapping the public and private key cryptography and ledger api.","title":"aea.crypto.base"},{"location":"aea/api/crypto/base/#crypto-objects","text":"class Crypto ( Generic [ EntityClass ], ABC ) Base class for a crypto object.","title":"Crypto Objects"},{"location":"aea/api/crypto/base/#__init__","text":"| __init__ ( private_key_path : Optional [ str ] = None , password : Optional [ str ] = None , ** kwargs : Any , ,) -> None Initialize the crypto object. The actual behaviour of this constructor is determined by the abstract methods 'generate_private_key()' and 'load_private_key_from_path(). Either way, the entity object will be accessible as a property. Arguments : private_key_path : the path to the private key. If None, the key will be generated by 'generate_private_key()'. If not None, the path will be processed by 'load_private_key_from_path()'. password : the password to encrypt/decrypt the private key. kwargs : keyword arguments.","title":"__init__"},{"location":"aea/api/crypto/base/#generate_private_key","text":"| @classmethod | @abstractmethod | generate_private_key ( cls ) -> EntityClass Generate a private key. Returns : the entity object. Implementation dependent.","title":"generate_private_key"},{"location":"aea/api/crypto/base/#load_private_key_from_path","text":"| @classmethod | @abstractmethod | load_private_key_from_path ( cls , file_name : str , password : Optional [ str ] = None ) -> EntityClass Load a private key in hex format for raw private key and json format for encrypted private key from a file. Arguments : file_name : the path to the hex/json file. password : the password to encrypt/decrypt the private key. Returns : the entity object.","title":"load_private_key_from_path"},{"location":"aea/api/crypto/base/#entity","text":"| @property | entity () -> EntityClass Return an entity object. Returns : an entity object","title":"entity"},{"location":"aea/api/crypto/base/#private_key","text":"| @property | @abstractmethod | private_key () -> str Return a private key. Returns : a private key string","title":"private_key"},{"location":"aea/api/crypto/base/#public_key","text":"| @property | @abstractmethod | public_key () -> str Return a public key. Returns : a public key string","title":"public_key"},{"location":"aea/api/crypto/base/#address","text":"| @property | @abstractmethod | address () -> str Return the address. Returns : an address string","title":"address"},{"location":"aea/api/crypto/base/#sign_message","text":"| @abstractmethod | sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form","title":"sign_message"},{"location":"aea/api/crypto/base/#sign_transaction","text":"| @abstractmethod | sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in dict form. Arguments : transaction : the transaction to be signed Returns : signed transaction","title":"sign_transaction"},{"location":"aea/api/crypto/base/#load","text":"| @classmethod | load ( cls , private_key_file : str , password : Optional [ str ] = None ) -> str Load private key from file. Arguments : private_key_file : the file where the key is stored. password : the password to encrypt/decrypt the private key. Returns : private_key in hex string format","title":"load"},{"location":"aea/api/crypto/base/#dump","text":"| dump ( private_key_file : str , password : Optional [ str ] = None ) -> None Dump private key to file. Arguments : private_key_file : the file where the key is stored. password : the password to encrypt/decrypt the private key.","title":"dump"},{"location":"aea/api/crypto/base/#encrypt","text":"| @abstractmethod | encrypt ( password : str ) -> str Encrypt the private key and return in json. Arguments : password : the password to decrypt. Returns : json string containing encrypted private key.","title":"encrypt"},{"location":"aea/api/crypto/base/#decrypt","text":"| @classmethod | @abstractmethod | decrypt ( cls , keyfile_json : str , password : str ) -> str Decrypt the private key and return in raw form. Arguments : keyfile_json : json string containing encrypted private key. password : the password to decrypt. Returns : the raw private key.","title":"decrypt"},{"location":"aea/api/crypto/base/#helper-objects","text":"class Helper ( ABC ) Interface for helper class usable as Mixin for LedgerApi or as standalone class.","title":"Helper Objects"},{"location":"aea/api/crypto/base/#is_transaction_settled","text":"| @staticmethod | @abstractmethod | is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_receipt : the receipt associated to the transaction. Returns : True if the transaction has been settled, False o/w.","title":"is_transaction_settled"},{"location":"aea/api/crypto/base/#is_transaction_valid","text":"| @staticmethod | @abstractmethod | is_transaction_valid ( tx : JSONLike , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input']","title":"is_transaction_valid"},{"location":"aea/api/crypto/base/#get_contract_address","text":"| @staticmethod | @abstractmethod | get_contract_address ( tx_receipt : JSONLike ) -> Optional [ str ] Get the contract address from a transaction receipt. Arguments : tx_receipt : the transaction digest Returns : the contract address if successful","title":"get_contract_address"},{"location":"aea/api/crypto/base/#generate_tx_nonce","text":"| @staticmethod | @abstractmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish transactions with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/crypto/base/#get_address_from_public_key","text":"| @classmethod | @abstractmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"aea/api/crypto/base/#recover_message","text":"| @classmethod | @abstractmethod | recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses","title":"recover_message"},{"location":"aea/api/crypto/base/#recover_public_keys_from_message","text":"| @classmethod | @abstractmethod | recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys","title":"recover_public_keys_from_message"},{"location":"aea/api/crypto/base/#get_hash","text":"| @staticmethod | @abstractmethod | get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message.","title":"get_hash"},{"location":"aea/api/crypto/base/#is_valid_address","text":"| @classmethod | @abstractmethod | is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate","title":"is_valid_address"},{"location":"aea/api/crypto/base/#load_contract_interface","text":"| @classmethod | @abstractmethod | load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface","title":"load_contract_interface"},{"location":"aea/api/crypto/base/#ledgerapi-objects","text":"class LedgerApi ( Helper , ABC ) Interface for ledger APIs.","title":"LedgerApi Objects"},{"location":"aea/api/crypto/base/#api","text":"| @property | @abstractmethod | api () -> Any Get the underlying API object. This can be used for low-level operations with the concrete ledger APIs. If there is no such object, return None.","title":"api"},{"location":"aea/api/crypto/base/#get_balance","text":"| @abstractmethod | get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. This usually takes the form of a web request to be waited synchronously. Arguments : address : the address. Returns : the balance.","title":"get_balance"},{"location":"aea/api/crypto/base/#get_state","text":"| @abstractmethod | get_state ( callable_name : str , * args : Any , ** kwargs : Any ) -> Optional [ JSONLike ] Call a specified function on the underlying ledger API. This usually takes the form of a web request to be waited synchronously. Arguments : callable_name : the name of the API function to be called. args : the positional arguments for the API function. kwargs : the keyword arguments for the API function. Returns : the ledger API response.","title":"get_state"},{"location":"aea/api/crypto/base/#get_transfer_transaction","text":"| @abstractmethod | get_transfer_transaction ( sender_address : Address , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , ** kwargs : Any , ,) -> Optional [ JSONLike ] Submit a transfer transaction to the ledger. Arguments : sender_address : the sender address of the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx kwargs : the keyword arguments. Returns : the transfer transaction","title":"get_transfer_transaction"},{"location":"aea/api/crypto/base/#send_signed_transaction","text":"| @abstractmethod | send_signed_transaction ( tx_signed : JSONLike ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Use keyword arguments for the specifying the signed transaction payload. Arguments : tx_signed : the signed transaction","title":"send_signed_transaction"},{"location":"aea/api/crypto/base/#get_transaction_receipt","text":"| @abstractmethod | get_transaction_receipt ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction receipt for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present","title":"get_transaction_receipt"},{"location":"aea/api/crypto/base/#get_transaction","text":"| @abstractmethod | get_transaction ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx, if present","title":"get_transaction"},{"location":"aea/api/crypto/base/#get_contract_instance","text":"| @abstractmethod | get_contract_instance ( contract_interface : Dict [ str , str ], contract_address : Optional [ str ] = None ) -> Any Get the instance of a contract. Arguments : contract_interface : the contract interface. contract_address : the contract address. Returns : the contract instance","title":"get_contract_instance"},{"location":"aea/api/crypto/base/#get_deploy_transaction","text":"| @abstractmethod | get_deploy_transaction ( contract_interface : Dict [ str , str ], deployer_address : Address , ** kwargs : Any , ,) -> Optional [ JSONLike ] Get the transaction to deploy the smart contract. Arguments : contract_interface : the contract interface. deployer_address : The address that will deploy the contract. kwargs : the keyword arguments. :returns tx: the transaction dictionary.","title":"get_deploy_transaction"},{"location":"aea/api/crypto/base/#update_with_gas_estimate","text":"| @abstractmethod | update_with_gas_estimate ( transaction : JSONLike ) -> JSONLike Attempts to update the transaction with a gas estimate Arguments : transaction : the transaction Returns : the updated transaction","title":"update_with_gas_estimate"},{"location":"aea/api/crypto/base/#faucetapi-objects","text":"class FaucetApi ( ABC ) Interface for testnet faucet APIs.","title":"FaucetApi Objects"},{"location":"aea/api/crypto/base/#get_wealth","text":"| @abstractmethod | get_wealth ( address : Address , url : Optional [ str ] = None ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. url : the url Returns : None","title":"get_wealth"},{"location":"aea/api/crypto/helpers/","text":"aea.crypto.helpers Module wrapping the helpers of public and private key cryptography. try _ validate _ private _ key _ path try_validate_private_key_path ( ledger_id : str , private_key_path : str , password : Optional [ str ] = None ) -> None Try validate a private key path. Arguments : ledger_id : one of 'fetchai', 'ethereum' private_key_path : the path to the private key. password : the password to encrypt/decrypt the private key. :raises: ValueError if the identifier is invalid. create _ private _ key create_private_key ( ledger_id : str , private_key_file : str , password : Optional [ str ] = None ) -> None Create a private key for the specified ledger identifier. Arguments : ledger_id : the ledger identifier. private_key_file : the private key file. password : the password to encrypt/decrypt the private key. :raises: ValueError if the identifier is invalid. try _ generate _ testnet _ wealth try_generate_testnet_wealth ( identifier : str , address : str , url : Optional [ str ] = None , _sync : bool = True ) -> None Try generate wealth on a testnet. Arguments : identifier : the identifier of the ledger address : the address to check for url : the url _sync : whether to wait to sync or not; currently unused private _ key _ verify private_key_verify ( aea_conf : AgentConfig , aea_project_path : Path , password : Optional [ str ] = None ) -> None Check key. Arguments : aea_conf : AgentConfig aea_project_path : Path, where project placed. password : the password to encrypt/decrypt the private key. make _ certificate make_certificate ( ledger_id : str , crypto_private_key_path : str , message : bytes , output_path : str , password : Optional [ str ] = None ) -> str Create certificate. Arguments : ledger_id : the ledger id crypto_private_key_path : the path to the private key. message : the message to be signed. output_path : the location where to save the certificate. password : the password to encrypt/decrypt the private keys. Returns : the signature/certificate get _ wallet _ from _ agent _ config get_wallet_from_agent_config ( agent_config : AgentConfig , password : Optional [ str ] = None ) -> Wallet Get wallet from agent_cofig provided. Arguments : agent_config : the agent configuration object password : the password to encrypt/decrypt the private keys. Returns : wallet DecryptError Objects class DecryptError ( ValueError ) Error on bytes decryption with password. __ init __ | __init__ ( msg : Optional [ str ] = None ) -> None Init exception. KeyIsIncorrect Objects class KeyIsIncorrect ( ValueError ) Error decoding hex string to bytes for private key. hex _ to _ bytes _ for _ key hex_to_bytes_for_key ( data : str ) -> bytes Convert hex string to bytes with error handling.","title":"Helpers"},{"location":"aea/api/crypto/helpers/#aeacryptohelpers","text":"Module wrapping the helpers of public and private key cryptography.","title":"aea.crypto.helpers"},{"location":"aea/api/crypto/helpers/#try_validate_private_key_path","text":"try_validate_private_key_path ( ledger_id : str , private_key_path : str , password : Optional [ str ] = None ) -> None Try validate a private key path. Arguments : ledger_id : one of 'fetchai', 'ethereum' private_key_path : the path to the private key. password : the password to encrypt/decrypt the private key. :raises: ValueError if the identifier is invalid.","title":"try_validate_private_key_path"},{"location":"aea/api/crypto/helpers/#create_private_key","text":"create_private_key ( ledger_id : str , private_key_file : str , password : Optional [ str ] = None ) -> None Create a private key for the specified ledger identifier. Arguments : ledger_id : the ledger identifier. private_key_file : the private key file. password : the password to encrypt/decrypt the private key. :raises: ValueError if the identifier is invalid.","title":"create_private_key"},{"location":"aea/api/crypto/helpers/#try_generate_testnet_wealth","text":"try_generate_testnet_wealth ( identifier : str , address : str , url : Optional [ str ] = None , _sync : bool = True ) -> None Try generate wealth on a testnet. Arguments : identifier : the identifier of the ledger address : the address to check for url : the url _sync : whether to wait to sync or not; currently unused","title":"try_generate_testnet_wealth"},{"location":"aea/api/crypto/helpers/#private_key_verify","text":"private_key_verify ( aea_conf : AgentConfig , aea_project_path : Path , password : Optional [ str ] = None ) -> None Check key. Arguments : aea_conf : AgentConfig aea_project_path : Path, where project placed. password : the password to encrypt/decrypt the private key.","title":"private_key_verify"},{"location":"aea/api/crypto/helpers/#make_certificate","text":"make_certificate ( ledger_id : str , crypto_private_key_path : str , message : bytes , output_path : str , password : Optional [ str ] = None ) -> str Create certificate. Arguments : ledger_id : the ledger id crypto_private_key_path : the path to the private key. message : the message to be signed. output_path : the location where to save the certificate. password : the password to encrypt/decrypt the private keys. Returns : the signature/certificate","title":"make_certificate"},{"location":"aea/api/crypto/helpers/#get_wallet_from_agent_config","text":"get_wallet_from_agent_config ( agent_config : AgentConfig , password : Optional [ str ] = None ) -> Wallet Get wallet from agent_cofig provided. Arguments : agent_config : the agent configuration object password : the password to encrypt/decrypt the private keys. Returns : wallet","title":"get_wallet_from_agent_config"},{"location":"aea/api/crypto/helpers/#decrypterror-objects","text":"class DecryptError ( ValueError ) Error on bytes decryption with password.","title":"DecryptError Objects"},{"location":"aea/api/crypto/helpers/#__init__","text":"| __init__ ( msg : Optional [ str ] = None ) -> None Init exception.","title":"__init__"},{"location":"aea/api/crypto/helpers/#keyisincorrect-objects","text":"class KeyIsIncorrect ( ValueError ) Error decoding hex string to bytes for private key.","title":"KeyIsIncorrect Objects"},{"location":"aea/api/crypto/helpers/#hex_to_bytes_for_key","text":"hex_to_bytes_for_key ( data : str ) -> bytes Convert hex string to bytes with error handling.","title":"hex_to_bytes_for_key"},{"location":"aea/api/crypto/ledger_apis/","text":"aea.crypto.ledger _ apis Module wrapping all the public and private keys cryptography. LedgerApis Objects class LedgerApis () Store all the ledger apis we initialise. has _ ledger | @staticmethod | has_ledger ( identifier : str ) -> bool Check if it has the api. get _ api | @classmethod | get_api ( cls , identifier : str ) -> LedgerApi Get the ledger API. get _ balance | @classmethod | get_balance ( cls , identifier : str , address : str ) -> Optional [ int ] Get the token balance. Arguments : identifier : the identifier of the ledger address : the address to check for Returns : the token balance get _ transfer _ transaction | @classmethod | get_transfer_transaction ( cls , identifier : str , sender_address : str , destination_address : str , amount : int , tx_fee : int , tx_nonce : str , ** kwargs : Any , ,) -> Optional [ Any ] Get a transaction to transfer from self to destination. Arguments : identifier : the identifier of the ledger sender_address : the address of the sender destination_address : the address of the receiver amount : the amount tx_nonce : verifies the authenticity of the tx tx_fee : the tx fee kwargs : the keyword arguments. Returns : tx send _ signed _ transaction | @classmethod | send_signed_transaction ( cls , identifier : str , tx_signed : Any ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : identifier : the identifier of the ledger tx_signed : the signed transaction Returns : the tx_digest, if present get _ transaction _ receipt | @classmethod | get_transaction_receipt ( cls , identifier : str , tx_digest : str ) -> Optional [ Any ] Get the transaction receipt for a transaction digest. Arguments : identifier : the identifier of the ledger tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present get _ transaction | @classmethod | get_transaction ( cls , identifier : str , tx_digest : str ) -> Optional [ Any ] Get the transaction for a transaction digest. Arguments : identifier : the identifier of the ledger tx_digest : the digest associated to the transaction. Returns : the tx, if present get _ contract _ address | @staticmethod | get_contract_address ( identifier : str , tx_receipt : Any ) -> Optional [ Address ] Get the contract address from a transaction receipt. Arguments : identifier : the identifier of the ledger tx_receipt : the transaction receipt Returns : the contract address if successful is _ transaction _ settled | @staticmethod | is_transaction_settled ( identifier : str , tx_receipt : Any ) -> bool Check whether the transaction is settled and correct. Arguments : identifier : the identifier of the ledger tx_receipt : the transaction digest Returns : True if correctly settled, False otherwise is _ transaction _ valid | @staticmethod | is_transaction_valid ( identifier : str , tx : Any , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether the transaction is valid. Arguments : identifier : Ledger identifier tx : the transaction seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if is valid , False otherwise generate _ tx _ nonce | @staticmethod | generate_tx_nonce ( identifier : str , seller : Address , client : Address ) -> str Generate a random str message. Arguments : identifier : ledger identifier. seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. recover _ message | @staticmethod | recover_message ( identifier : str , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : identifier : ledger identifier. message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses get _ hash | @staticmethod | get_hash ( identifier : str , message : bytes ) -> str Get the hash of a message. Arguments : identifier : ledger identifier. message : the message to be hashed. Returns : the hash of the message. is _ valid _ address | @staticmethod | is_valid_address ( identifier : str , address : Address ) -> bool Check if the address is valid. Arguments : identifier : ledger identifier. address : the address to validate. Returns : whether it is a valid address or not.","title":"LedgerApis"},{"location":"aea/api/crypto/ledger_apis/#aeacryptoledger_apis","text":"Module wrapping all the public and private keys cryptography.","title":"aea.crypto.ledger_apis"},{"location":"aea/api/crypto/ledger_apis/#ledgerapis-objects","text":"class LedgerApis () Store all the ledger apis we initialise.","title":"LedgerApis Objects"},{"location":"aea/api/crypto/ledger_apis/#has_ledger","text":"| @staticmethod | has_ledger ( identifier : str ) -> bool Check if it has the api.","title":"has_ledger"},{"location":"aea/api/crypto/ledger_apis/#get_api","text":"| @classmethod | get_api ( cls , identifier : str ) -> LedgerApi Get the ledger API.","title":"get_api"},{"location":"aea/api/crypto/ledger_apis/#get_balance","text":"| @classmethod | get_balance ( cls , identifier : str , address : str ) -> Optional [ int ] Get the token balance. Arguments : identifier : the identifier of the ledger address : the address to check for Returns : the token balance","title":"get_balance"},{"location":"aea/api/crypto/ledger_apis/#get_transfer_transaction","text":"| @classmethod | get_transfer_transaction ( cls , identifier : str , sender_address : str , destination_address : str , amount : int , tx_fee : int , tx_nonce : str , ** kwargs : Any , ,) -> Optional [ Any ] Get a transaction to transfer from self to destination. Arguments : identifier : the identifier of the ledger sender_address : the address of the sender destination_address : the address of the receiver amount : the amount tx_nonce : verifies the authenticity of the tx tx_fee : the tx fee kwargs : the keyword arguments. Returns : tx","title":"get_transfer_transaction"},{"location":"aea/api/crypto/ledger_apis/#send_signed_transaction","text":"| @classmethod | send_signed_transaction ( cls , identifier : str , tx_signed : Any ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : identifier : the identifier of the ledger tx_signed : the signed transaction Returns : the tx_digest, if present","title":"send_signed_transaction"},{"location":"aea/api/crypto/ledger_apis/#get_transaction_receipt","text":"| @classmethod | get_transaction_receipt ( cls , identifier : str , tx_digest : str ) -> Optional [ Any ] Get the transaction receipt for a transaction digest. Arguments : identifier : the identifier of the ledger tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present","title":"get_transaction_receipt"},{"location":"aea/api/crypto/ledger_apis/#get_transaction","text":"| @classmethod | get_transaction ( cls , identifier : str , tx_digest : str ) -> Optional [ Any ] Get the transaction for a transaction digest. Arguments : identifier : the identifier of the ledger tx_digest : the digest associated to the transaction. Returns : the tx, if present","title":"get_transaction"},{"location":"aea/api/crypto/ledger_apis/#get_contract_address","text":"| @staticmethod | get_contract_address ( identifier : str , tx_receipt : Any ) -> Optional [ Address ] Get the contract address from a transaction receipt. Arguments : identifier : the identifier of the ledger tx_receipt : the transaction receipt Returns : the contract address if successful","title":"get_contract_address"},{"location":"aea/api/crypto/ledger_apis/#is_transaction_settled","text":"| @staticmethod | is_transaction_settled ( identifier : str , tx_receipt : Any ) -> bool Check whether the transaction is settled and correct. Arguments : identifier : the identifier of the ledger tx_receipt : the transaction digest Returns : True if correctly settled, False otherwise","title":"is_transaction_settled"},{"location":"aea/api/crypto/ledger_apis/#is_transaction_valid","text":"| @staticmethod | is_transaction_valid ( identifier : str , tx : Any , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether the transaction is valid. Arguments : identifier : Ledger identifier tx : the transaction seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if is valid , False otherwise","title":"is_transaction_valid"},{"location":"aea/api/crypto/ledger_apis/#generate_tx_nonce","text":"| @staticmethod | generate_tx_nonce ( identifier : str , seller : Address , client : Address ) -> str Generate a random str message. Arguments : identifier : ledger identifier. seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/crypto/ledger_apis/#recover_message","text":"| @staticmethod | recover_message ( identifier : str , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : identifier : ledger identifier. message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses","title":"recover_message"},{"location":"aea/api/crypto/ledger_apis/#get_hash","text":"| @staticmethod | get_hash ( identifier : str , message : bytes ) -> str Get the hash of a message. Arguments : identifier : ledger identifier. message : the message to be hashed. Returns : the hash of the message.","title":"get_hash"},{"location":"aea/api/crypto/ledger_apis/#is_valid_address","text":"| @staticmethod | is_valid_address ( identifier : str , address : Address ) -> bool Check if the address is valid. Arguments : identifier : ledger identifier. address : the address to validate. Returns : whether it is a valid address or not.","title":"is_valid_address"},{"location":"aea/api/crypto/plugin/","text":"aea.crypto.plugin Implementation of plug-in mechanism for cryptos. Plugin Objects class Plugin () Class that implements an AEA plugin. __ init __ | __init__ ( group : str , entry_point : EntryPoint ) Initialize the plugin. Arguments : group : the group the plugin belongs to. entry_point : the entrypoint. name | @property | name () -> str Get the plugin identifier. group | @property | group () -> str Get the group. attr | @property | attr () -> str Get the class name. entry _ point _ path | @property | entry_point_path () -> str Get the entry point path. load _ all _ plugins load_all_plugins ( is_raising_exception : bool = True ) -> None Load all plugins.","title":"Plugin"},{"location":"aea/api/crypto/plugin/#aeacryptoplugin","text":"Implementation of plug-in mechanism for cryptos.","title":"aea.crypto.plugin"},{"location":"aea/api/crypto/plugin/#plugin-objects","text":"class Plugin () Class that implements an AEA plugin.","title":"Plugin Objects"},{"location":"aea/api/crypto/plugin/#__init__","text":"| __init__ ( group : str , entry_point : EntryPoint ) Initialize the plugin. Arguments : group : the group the plugin belongs to. entry_point : the entrypoint.","title":"__init__"},{"location":"aea/api/crypto/plugin/#name","text":"| @property | name () -> str Get the plugin identifier.","title":"name"},{"location":"aea/api/crypto/plugin/#group","text":"| @property | group () -> str Get the group.","title":"group"},{"location":"aea/api/crypto/plugin/#attr","text":"| @property | attr () -> str Get the class name.","title":"attr"},{"location":"aea/api/crypto/plugin/#entry_point_path","text":"| @property | entry_point_path () -> str Get the entry point path.","title":"entry_point_path"},{"location":"aea/api/crypto/plugin/#load_all_plugins","text":"load_all_plugins ( is_raising_exception : bool = True ) -> None Load all plugins.","title":"load_all_plugins"},{"location":"aea/api/crypto/wallet/","text":"aea.crypto.wallet Module wrapping all the public and private keys cryptography. CryptoStore Objects class CryptoStore () Utility class to store and retrieve crypto objects. __ init __ | __init__ ( crypto_id_to_path : Optional [ Dict [ str , Optional [ str ]]] = None , password : Optional [ str ] = None ) -> None Initialize the crypto store. Arguments : crypto_id_to_path : dictionary from crypto id to an (optional) path to the private key. password : the password to encrypt/decrypt the private key. public _ keys | @property | public_keys () -> Dict [ str , str ] Get the public_key dictionary. crypto _ objects | @property | crypto_objects () -> Dict [ str , Crypto ] Get the crypto objects (key pair). addresses | @property | addresses () -> Dict [ str , str ] Get the crypto addresses. private _ keys | @property | private_keys () -> Dict [ str , str ] Get the crypto addresses. Wallet Objects class Wallet () Container for crypto objects. The cryptos are separated into two categories: main cryptos: used by the AEA for the economic side (i.e. signing transaction) connection cryptos: exposed to the connection objects for encrypted communication. __ init __ | __init__ ( private_key_paths : Dict [ str , Optional [ str ]], connection_private_key_paths : Optional [ Dict [ str , Optional [ str ]]] = None , password : Optional [ str ] = None ) Instantiate a wallet object. Arguments : private_key_paths : the private key paths connection_private_key_paths : the private key paths for the connections. password : the password to encrypt/decrypt the private key. public _ keys | @property | public_keys () -> Dict [ str , str ] Get the public_key dictionary. crypto _ objects | @property | crypto_objects () -> Dict [ str , Crypto ] Get the crypto objects (key pair). addresses | @property | addresses () -> Dict [ str , str ] Get the crypto addresses. private _ keys | @property | private_keys () -> Dict [ str , str ] Get the crypto addresses. main _ cryptos | @property | main_cryptos () -> CryptoStore Get the main crypto store. connection _ cryptos | @property | connection_cryptos () -> CryptoStore Get the connection crypto store. sign _ message | sign_message ( crypto_id : str , message : bytes , is_deprecated_mode : bool = False ) -> Optional [ str ] Sign a message. Arguments : crypto_id : the id of the crypto message : the message to be signed is_deprecated_mode : what signing mode to use Returns : the signature of the message sign _ transaction | sign_transaction ( crypto_id : str , transaction : Any ) -> Optional [ JSONLike ] Sign a tx. Arguments : crypto_id : the id of the crypto transaction : the transaction to be signed Returns : the signed tx","title":"Wallet"},{"location":"aea/api/crypto/wallet/#aeacryptowallet","text":"Module wrapping all the public and private keys cryptography.","title":"aea.crypto.wallet"},{"location":"aea/api/crypto/wallet/#cryptostore-objects","text":"class CryptoStore () Utility class to store and retrieve crypto objects.","title":"CryptoStore Objects"},{"location":"aea/api/crypto/wallet/#__init__","text":"| __init__ ( crypto_id_to_path : Optional [ Dict [ str , Optional [ str ]]] = None , password : Optional [ str ] = None ) -> None Initialize the crypto store. Arguments : crypto_id_to_path : dictionary from crypto id to an (optional) path to the private key. password : the password to encrypt/decrypt the private key.","title":"__init__"},{"location":"aea/api/crypto/wallet/#public_keys","text":"| @property | public_keys () -> Dict [ str , str ] Get the public_key dictionary.","title":"public_keys"},{"location":"aea/api/crypto/wallet/#crypto_objects","text":"| @property | crypto_objects () -> Dict [ str , Crypto ] Get the crypto objects (key pair).","title":"crypto_objects"},{"location":"aea/api/crypto/wallet/#addresses","text":"| @property | addresses () -> Dict [ str , str ] Get the crypto addresses.","title":"addresses"},{"location":"aea/api/crypto/wallet/#private_keys","text":"| @property | private_keys () -> Dict [ str , str ] Get the crypto addresses.","title":"private_keys"},{"location":"aea/api/crypto/wallet/#wallet-objects","text":"class Wallet () Container for crypto objects. The cryptos are separated into two categories: main cryptos: used by the AEA for the economic side (i.e. signing transaction) connection cryptos: exposed to the connection objects for encrypted communication.","title":"Wallet Objects"},{"location":"aea/api/crypto/wallet/#__init___1","text":"| __init__ ( private_key_paths : Dict [ str , Optional [ str ]], connection_private_key_paths : Optional [ Dict [ str , Optional [ str ]]] = None , password : Optional [ str ] = None ) Instantiate a wallet object. Arguments : private_key_paths : the private key paths connection_private_key_paths : the private key paths for the connections. password : the password to encrypt/decrypt the private key.","title":"__init__"},{"location":"aea/api/crypto/wallet/#public_keys_1","text":"| @property | public_keys () -> Dict [ str , str ] Get the public_key dictionary.","title":"public_keys"},{"location":"aea/api/crypto/wallet/#crypto_objects_1","text":"| @property | crypto_objects () -> Dict [ str , Crypto ] Get the crypto objects (key pair).","title":"crypto_objects"},{"location":"aea/api/crypto/wallet/#addresses_1","text":"| @property | addresses () -> Dict [ str , str ] Get the crypto addresses.","title":"addresses"},{"location":"aea/api/crypto/wallet/#private_keys_1","text":"| @property | private_keys () -> Dict [ str , str ] Get the crypto addresses.","title":"private_keys"},{"location":"aea/api/crypto/wallet/#main_cryptos","text":"| @property | main_cryptos () -> CryptoStore Get the main crypto store.","title":"main_cryptos"},{"location":"aea/api/crypto/wallet/#connection_cryptos","text":"| @property | connection_cryptos () -> CryptoStore Get the connection crypto store.","title":"connection_cryptos"},{"location":"aea/api/crypto/wallet/#sign_message","text":"| sign_message ( crypto_id : str , message : bytes , is_deprecated_mode : bool = False ) -> Optional [ str ] Sign a message. Arguments : crypto_id : the id of the crypto message : the message to be signed is_deprecated_mode : what signing mode to use Returns : the signature of the message","title":"sign_message"},{"location":"aea/api/crypto/wallet/#sign_transaction","text":"| sign_transaction ( crypto_id : str , transaction : Any ) -> Optional [ JSONLike ] Sign a tx. Arguments : crypto_id : the id of the crypto transaction : the transaction to be signed Returns : the signed tx","title":"sign_transaction"},{"location":"aea/api/crypto/registries/base/","text":"aea.crypto.registries.base This module implements the base registry. ItemId Objects class ItemId ( RegexConstrainedString ) The identifier of an item class. name | @property | name () -> str Get the id name. EntryPoint Objects class EntryPoint ( Generic [ ItemType ], RegexConstrainedString ) The entry point for a resource. The regular expression matches the strings in the following format: path.to.module:className __ init __ | __init__ ( seq : Union [ \"EntryPoint\" , str ]) -> None Initialize the entrypoint. import _ path | @property | import_path () -> str Get the import path. class _ name | @property | class_name () -> str Get the class name. load | load () -> Type [ ItemType ] Load the item object. Returns : the crypto object, loaded following the spec. ItemSpec Objects class ItemSpec ( Generic [ ItemType ]) A specification for a particular instance of an object. __ init __ | __init__ ( id_ : ItemId , entry_point : EntryPoint [ ItemType ], class_kwargs : Optional [ Dict [ str , Any ]] = None , ** kwargs : Dict , ,) -> None Initialize an item specification. Arguments : id_ : the id associated to this specification entry_point : The Python entry_point of the environment class (e.g. module.name:Class). class_kwargs : keyword arguments to be attached on the class as class variables. kwargs : other custom keyword arguments. make | make ( ** kwargs : Any ) -> ItemType Instantiate an instance of the item object with appropriate arguments. Arguments : kwargs : the key word arguments Returns : an item get _ class | get_class () -> Type [ ItemType ] Get the class of the item with class variables instantiated. Returns : an item class Registry Objects class Registry ( Generic [ ItemType ]) Registry for generic classes. __ init __ | __init__ () -> None Initialize the registry. supported _ ids | @property | supported_ids () -> Set [ str ] Get the supported item ids. register | register ( id_ : Union [ ItemId , str ], entry_point : Union [ EntryPoint [ ItemType ], str ], class_kwargs : Optional [ Dict [ str , Any ]] = None , ** kwargs : Any , ,) -> None Register an item type. Arguments : id_ : the identifier for the crypto type. entry_point : the entry point to load the crypto object. class_kwargs : keyword arguments to be attached on the class as class variables. kwargs : arguments to provide to the crypto class. make | make ( id_ : Union [ ItemId , str ], module : Optional [ str ] = None , ** kwargs : Any ) -> ItemType Create an instance of the associated type item id. Arguments : id_ : the id of the item class. Make sure it has been registered earlier before calling this function. module : dotted path to a module. whether a module should be loaded before creating the object. this argument is useful when the item might not be registered beforehand, and loading the specified module will make the registration. E.g. suppose the call to 'register' for a custom object is located in some_package/ init .py. By providing module=\"some_package\", the call to 'register' in such module gets triggered and the make can then find the identifier. kwargs : keyword arguments to be forwarded to the object. Returns : the new item instance. make _ cls | make_cls ( id_ : Union [ ItemId , str ], module : Optional [ str ] = None ) -> Type [ ItemType ] Load a class of the associated type item id. Arguments : id_ : the id of the item class. Make sure it has been registered earlier before calling this function. module : dotted path to a module. whether a module should be loaded before creating the object. this argument is useful when the item might not be registered beforehand, and loading the specified module will make the registration. E.g. suppose the call to 'register' for a custom object is located in some_package/ init .py. By providing module=\"some_package\", the call to 'register' in such module gets triggered and the make can then find the identifier. Returns : the new item class. has _ spec | has_spec ( item_id : ItemId ) -> bool Check whether there exist a spec associated with an item id. Arguments : item_id : the item identifier. Returns : True if it is registered, False otherwise.","title":"Base"},{"location":"aea/api/crypto/registries/base/#aeacryptoregistriesbase","text":"This module implements the base registry.","title":"aea.crypto.registries.base"},{"location":"aea/api/crypto/registries/base/#itemid-objects","text":"class ItemId ( RegexConstrainedString ) The identifier of an item class.","title":"ItemId Objects"},{"location":"aea/api/crypto/registries/base/#name","text":"| @property | name () -> str Get the id name.","title":"name"},{"location":"aea/api/crypto/registries/base/#entrypoint-objects","text":"class EntryPoint ( Generic [ ItemType ], RegexConstrainedString ) The entry point for a resource. The regular expression matches the strings in the following format: path.to.module:className","title":"EntryPoint Objects"},{"location":"aea/api/crypto/registries/base/#__init__","text":"| __init__ ( seq : Union [ \"EntryPoint\" , str ]) -> None Initialize the entrypoint.","title":"__init__"},{"location":"aea/api/crypto/registries/base/#import_path","text":"| @property | import_path () -> str Get the import path.","title":"import_path"},{"location":"aea/api/crypto/registries/base/#class_name","text":"| @property | class_name () -> str Get the class name.","title":"class_name"},{"location":"aea/api/crypto/registries/base/#load","text":"| load () -> Type [ ItemType ] Load the item object. Returns : the crypto object, loaded following the spec.","title":"load"},{"location":"aea/api/crypto/registries/base/#itemspec-objects","text":"class ItemSpec ( Generic [ ItemType ]) A specification for a particular instance of an object.","title":"ItemSpec Objects"},{"location":"aea/api/crypto/registries/base/#__init___1","text":"| __init__ ( id_ : ItemId , entry_point : EntryPoint [ ItemType ], class_kwargs : Optional [ Dict [ str , Any ]] = None , ** kwargs : Dict , ,) -> None Initialize an item specification. Arguments : id_ : the id associated to this specification entry_point : The Python entry_point of the environment class (e.g. module.name:Class). class_kwargs : keyword arguments to be attached on the class as class variables. kwargs : other custom keyword arguments.","title":"__init__"},{"location":"aea/api/crypto/registries/base/#make","text":"| make ( ** kwargs : Any ) -> ItemType Instantiate an instance of the item object with appropriate arguments. Arguments : kwargs : the key word arguments Returns : an item","title":"make"},{"location":"aea/api/crypto/registries/base/#get_class","text":"| get_class () -> Type [ ItemType ] Get the class of the item with class variables instantiated. Returns : an item class","title":"get_class"},{"location":"aea/api/crypto/registries/base/#registry-objects","text":"class Registry ( Generic [ ItemType ]) Registry for generic classes.","title":"Registry Objects"},{"location":"aea/api/crypto/registries/base/#__init___2","text":"| __init__ () -> None Initialize the registry.","title":"__init__"},{"location":"aea/api/crypto/registries/base/#supported_ids","text":"| @property | supported_ids () -> Set [ str ] Get the supported item ids.","title":"supported_ids"},{"location":"aea/api/crypto/registries/base/#register","text":"| register ( id_ : Union [ ItemId , str ], entry_point : Union [ EntryPoint [ ItemType ], str ], class_kwargs : Optional [ Dict [ str , Any ]] = None , ** kwargs : Any , ,) -> None Register an item type. Arguments : id_ : the identifier for the crypto type. entry_point : the entry point to load the crypto object. class_kwargs : keyword arguments to be attached on the class as class variables. kwargs : arguments to provide to the crypto class.","title":"register"},{"location":"aea/api/crypto/registries/base/#make_1","text":"| make ( id_ : Union [ ItemId , str ], module : Optional [ str ] = None , ** kwargs : Any ) -> ItemType Create an instance of the associated type item id. Arguments : id_ : the id of the item class. Make sure it has been registered earlier before calling this function. module : dotted path to a module. whether a module should be loaded before creating the object. this argument is useful when the item might not be registered beforehand, and loading the specified module will make the registration. E.g. suppose the call to 'register' for a custom object is located in some_package/ init .py. By providing module=\"some_package\", the call to 'register' in such module gets triggered and the make can then find the identifier. kwargs : keyword arguments to be forwarded to the object. Returns : the new item instance.","title":"make"},{"location":"aea/api/crypto/registries/base/#make_cls","text":"| make_cls ( id_ : Union [ ItemId , str ], module : Optional [ str ] = None ) -> Type [ ItemType ] Load a class of the associated type item id. Arguments : id_ : the id of the item class. Make sure it has been registered earlier before calling this function. module : dotted path to a module. whether a module should be loaded before creating the object. this argument is useful when the item might not be registered beforehand, and loading the specified module will make the registration. E.g. suppose the call to 'register' for a custom object is located in some_package/ init .py. By providing module=\"some_package\", the call to 'register' in such module gets triggered and the make can then find the identifier. Returns : the new item class.","title":"make_cls"},{"location":"aea/api/crypto/registries/base/#has_spec","text":"| has_spec ( item_id : ItemId ) -> bool Check whether there exist a spec associated with an item id. Arguments : item_id : the item identifier. Returns : True if it is registered, False otherwise.","title":"has_spec"},{"location":"aea/api/decision_maker/base/","text":"aea.decision _ maker.base This module contains the decision maker class. OwnershipState Objects class OwnershipState ( ABC ) Represent the ownership state of an agent (can proxy a ledger). set | @abstractmethod | set ( ** kwargs : Any ) -> None Set values on the ownership state. Arguments : kwargs : the relevant keyword arguments apply _ delta | @abstractmethod | apply_delta ( ** kwargs : Any ) -> None Apply a state update to the ownership state. This method is used to apply a raw state update without a transaction. Arguments : kwargs : the relevant keyword arguments is _ initialized | @property | @abstractmethod | is_initialized () -> bool Get the initialization status. is _ affordable _ transaction | @abstractmethod | is_affordable_transaction ( terms : Terms ) -> bool Check if the transaction is affordable (and consistent). Arguments : terms : the transaction terms Returns : True if the transaction is legal wrt the current state, false otherwise. apply _ transactions | @abstractmethod | apply_transactions ( list_of_terms : List [ Terms ]) -> \"OwnershipState\" Apply a list of transactions to (a copy of) the current state. Arguments : list_of_terms : the sequence of transaction terms. Returns : the final state. __ copy __ | @abstractmethod | __copy__ () -> \"OwnershipState\" Copy the object. Preferences Objects class Preferences ( ABC ) Class to represent the preferences. set | @abstractmethod | set ( ** kwargs : Any ) -> None Set values on the preferences. Arguments : kwargs : the relevant key word arguments is _ initialized | @property | @abstractmethod | is_initialized () -> bool Get the initialization status. Returns True if exchange_params_by_currency_id and utility_params_by_good_id are not None. marginal _ utility | @abstractmethod | marginal_utility ( ownership_state : OwnershipState , ** kwargs : Any ) -> float Compute the marginal utility. Arguments : ownership_state : the ownership state against which to compute the marginal utility. kwargs : optional keyword arguments Returns : the marginal utility score utility _ diff _ from _ transaction | @abstractmethod | utility_diff_from_transaction ( ownership_state : OwnershipState , terms : Terms ) -> float Simulate a transaction and get the resulting utility difference (taking into account the fee). Arguments : ownership_state : the ownership state against which to apply the transaction. terms : the transaction terms. Returns : the score. __ copy __ | @abstractmethod | __copy__ () -> \"Preferences\" Copy the object. ProtectedQueue Objects class ProtectedQueue ( Queue ) A wrapper of a queue to protect which object can read from it. __ init __ | __init__ ( access_code : str ) -> None Initialize the protected queue. Arguments : access_code : the access code to read from the queue put | put ( internal_message : Optional [ Message ], block : bool = True , timeout : Optional [ float ] = None ) -> None Put an internal message on the queue. If optional args block is true and timeout is None (the default), block if necessary until a free slot is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Full exception if no free slot was available within that time. Otherwise (block is false), put an item on the queue if a free slot is immediately available, else raise the Full exception (timeout is ignored in that case). Arguments : internal_message : the internal message to put on the queue block : whether to block or not timeout : timeout on block :raises: ValueError, if the item is not an internal message put _ nowait | put_nowait ( internal_message : Optional [ Message ]) -> None Put an internal message on the queue. Equivalent to put(item, False). Arguments : internal_message : the internal message to put on the queue :raises: ValueError, if the item is not an internal message get | get ( block : bool = True , timeout : Optional [ float ] = None ) -> None Inaccessible get method. Arguments : block : whether to block or not timeout : timeout on block :raises: ValueError, access not permitted. get _ nowait | get_nowait () -> None Inaccessible get_nowait method. :raises: ValueError, access not permitted. protected _ get | protected_get ( access_code : str , block : bool = True , timeout : Optional [ float ] = None ) -> Optional [ Message ] Access protected get method. Arguments : access_code : the access code block : If optional args block is true and timeout is None (the default), block if necessary until an item is available. timeout : If timeout is a positive number, it blocks at most timeout seconds and raises the Empty exception if no item was available within that time. :raises: ValueError, if caller is not permitted Returns : internal message DecisionMakerHandler Objects class DecisionMakerHandler ( WithLogger , ABC ) This class implements the decision maker. __ init __ | __init__ ( identity : Identity , wallet : Wallet , config : Dict [ str , Any ], ** kwargs : Any ) -> None Initialize the decision maker handler. Arguments : identity : the identity wallet : the wallet config : the user defined configuration of the handler kwargs : the key word arguments agent _ name | @property | agent_name () -> str Get the agent name. identity | @property | identity () -> Identity Get identity of the agent. wallet | @property | wallet () -> Wallet Get wallet of the agent. config | @property | config () -> Dict [ str , Any ] Get user defined configuration context | @property | context () -> SimpleNamespace Get the context. message _ out _ queue | @property | message_out_queue () -> AsyncFriendlyQueue Get (out) queue. handle | @abstractmethod | handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message DecisionMaker Objects class DecisionMaker ( WithLogger ) This class implements the decision maker. __ init __ | __init__ ( decision_maker_handler : DecisionMakerHandler ) -> None Initialize the decision maker. Arguments : decision_maker_handler : the decision maker handler agent _ name | @property | agent_name () -> str Get the agent name. message _ in _ queue | @property | message_in_queue () -> ProtectedQueue Get (in) queue. message _ out _ queue | @property | message_out_queue () -> AsyncFriendlyQueue Get (out) queue. decision _ maker _ handler | @property | decision_maker_handler () -> DecisionMakerHandler Get the decision maker handler. start | start () -> None Start the decision maker. stop | stop () -> None Stop the decision maker. execute | execute () -> None Execute the decision maker. Performs the following while not stopped: gets internal messages from the in queue and calls handle() on them handle | handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message","title":"Base"},{"location":"aea/api/decision_maker/base/#aeadecision_makerbase","text":"This module contains the decision maker class.","title":"aea.decision_maker.base"},{"location":"aea/api/decision_maker/base/#ownershipstate-objects","text":"class OwnershipState ( ABC ) Represent the ownership state of an agent (can proxy a ledger).","title":"OwnershipState Objects"},{"location":"aea/api/decision_maker/base/#set","text":"| @abstractmethod | set ( ** kwargs : Any ) -> None Set values on the ownership state. Arguments : kwargs : the relevant keyword arguments","title":"set"},{"location":"aea/api/decision_maker/base/#apply_delta","text":"| @abstractmethod | apply_delta ( ** kwargs : Any ) -> None Apply a state update to the ownership state. This method is used to apply a raw state update without a transaction. Arguments : kwargs : the relevant keyword arguments","title":"apply_delta"},{"location":"aea/api/decision_maker/base/#is_initialized","text":"| @property | @abstractmethod | is_initialized () -> bool Get the initialization status.","title":"is_initialized"},{"location":"aea/api/decision_maker/base/#is_affordable_transaction","text":"| @abstractmethod | is_affordable_transaction ( terms : Terms ) -> bool Check if the transaction is affordable (and consistent). Arguments : terms : the transaction terms Returns : True if the transaction is legal wrt the current state, false otherwise.","title":"is_affordable_transaction"},{"location":"aea/api/decision_maker/base/#apply_transactions","text":"| @abstractmethod | apply_transactions ( list_of_terms : List [ Terms ]) -> \"OwnershipState\" Apply a list of transactions to (a copy of) the current state. Arguments : list_of_terms : the sequence of transaction terms. Returns : the final state.","title":"apply_transactions"},{"location":"aea/api/decision_maker/base/#__copy__","text":"| @abstractmethod | __copy__ () -> \"OwnershipState\" Copy the object.","title":"__copy__"},{"location":"aea/api/decision_maker/base/#preferences-objects","text":"class Preferences ( ABC ) Class to represent the preferences.","title":"Preferences Objects"},{"location":"aea/api/decision_maker/base/#set_1","text":"| @abstractmethod | set ( ** kwargs : Any ) -> None Set values on the preferences. Arguments : kwargs : the relevant key word arguments","title":"set"},{"location":"aea/api/decision_maker/base/#is_initialized_1","text":"| @property | @abstractmethod | is_initialized () -> bool Get the initialization status. Returns True if exchange_params_by_currency_id and utility_params_by_good_id are not None.","title":"is_initialized"},{"location":"aea/api/decision_maker/base/#marginal_utility","text":"| @abstractmethod | marginal_utility ( ownership_state : OwnershipState , ** kwargs : Any ) -> float Compute the marginal utility. Arguments : ownership_state : the ownership state against which to compute the marginal utility. kwargs : optional keyword arguments Returns : the marginal utility score","title":"marginal_utility"},{"location":"aea/api/decision_maker/base/#utility_diff_from_transaction","text":"| @abstractmethod | utility_diff_from_transaction ( ownership_state : OwnershipState , terms : Terms ) -> float Simulate a transaction and get the resulting utility difference (taking into account the fee). Arguments : ownership_state : the ownership state against which to apply the transaction. terms : the transaction terms. Returns : the score.","title":"utility_diff_from_transaction"},{"location":"aea/api/decision_maker/base/#__copy___1","text":"| @abstractmethod | __copy__ () -> \"Preferences\" Copy the object.","title":"__copy__"},{"location":"aea/api/decision_maker/base/#protectedqueue-objects","text":"class ProtectedQueue ( Queue ) A wrapper of a queue to protect which object can read from it.","title":"ProtectedQueue Objects"},{"location":"aea/api/decision_maker/base/#__init__","text":"| __init__ ( access_code : str ) -> None Initialize the protected queue. Arguments : access_code : the access code to read from the queue","title":"__init__"},{"location":"aea/api/decision_maker/base/#put","text":"| put ( internal_message : Optional [ Message ], block : bool = True , timeout : Optional [ float ] = None ) -> None Put an internal message on the queue. If optional args block is true and timeout is None (the default), block if necessary until a free slot is available. If timeout is a positive number, it blocks at most timeout seconds and raises the Full exception if no free slot was available within that time. Otherwise (block is false), put an item on the queue if a free slot is immediately available, else raise the Full exception (timeout is ignored in that case). Arguments : internal_message : the internal message to put on the queue block : whether to block or not timeout : timeout on block :raises: ValueError, if the item is not an internal message","title":"put"},{"location":"aea/api/decision_maker/base/#put_nowait","text":"| put_nowait ( internal_message : Optional [ Message ]) -> None Put an internal message on the queue. Equivalent to put(item, False). Arguments : internal_message : the internal message to put on the queue :raises: ValueError, if the item is not an internal message","title":"put_nowait"},{"location":"aea/api/decision_maker/base/#get","text":"| get ( block : bool = True , timeout : Optional [ float ] = None ) -> None Inaccessible get method. Arguments : block : whether to block or not timeout : timeout on block :raises: ValueError, access not permitted.","title":"get"},{"location":"aea/api/decision_maker/base/#get_nowait","text":"| get_nowait () -> None Inaccessible get_nowait method. :raises: ValueError, access not permitted.","title":"get_nowait"},{"location":"aea/api/decision_maker/base/#protected_get","text":"| protected_get ( access_code : str , block : bool = True , timeout : Optional [ float ] = None ) -> Optional [ Message ] Access protected get method. Arguments : access_code : the access code block : If optional args block is true and timeout is None (the default), block if necessary until an item is available. timeout : If timeout is a positive number, it blocks at most timeout seconds and raises the Empty exception if no item was available within that time. :raises: ValueError, if caller is not permitted Returns : internal message","title":"protected_get"},{"location":"aea/api/decision_maker/base/#decisionmakerhandler-objects","text":"class DecisionMakerHandler ( WithLogger , ABC ) This class implements the decision maker.","title":"DecisionMakerHandler Objects"},{"location":"aea/api/decision_maker/base/#__init___1","text":"| __init__ ( identity : Identity , wallet : Wallet , config : Dict [ str , Any ], ** kwargs : Any ) -> None Initialize the decision maker handler. Arguments : identity : the identity wallet : the wallet config : the user defined configuration of the handler kwargs : the key word arguments","title":"__init__"},{"location":"aea/api/decision_maker/base/#agent_name","text":"| @property | agent_name () -> str Get the agent name.","title":"agent_name"},{"location":"aea/api/decision_maker/base/#identity","text":"| @property | identity () -> Identity Get identity of the agent.","title":"identity"},{"location":"aea/api/decision_maker/base/#wallet","text":"| @property | wallet () -> Wallet Get wallet of the agent.","title":"wallet"},{"location":"aea/api/decision_maker/base/#config","text":"| @property | config () -> Dict [ str , Any ] Get user defined configuration","title":"config"},{"location":"aea/api/decision_maker/base/#context","text":"| @property | context () -> SimpleNamespace Get the context.","title":"context"},{"location":"aea/api/decision_maker/base/#message_out_queue","text":"| @property | message_out_queue () -> AsyncFriendlyQueue Get (out) queue.","title":"message_out_queue"},{"location":"aea/api/decision_maker/base/#handle","text":"| @abstractmethod | handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message","title":"handle"},{"location":"aea/api/decision_maker/base/#decisionmaker-objects","text":"class DecisionMaker ( WithLogger ) This class implements the decision maker.","title":"DecisionMaker Objects"},{"location":"aea/api/decision_maker/base/#__init___2","text":"| __init__ ( decision_maker_handler : DecisionMakerHandler ) -> None Initialize the decision maker. Arguments : decision_maker_handler : the decision maker handler","title":"__init__"},{"location":"aea/api/decision_maker/base/#agent_name_1","text":"| @property | agent_name () -> str Get the agent name.","title":"agent_name"},{"location":"aea/api/decision_maker/base/#message_in_queue","text":"| @property | message_in_queue () -> ProtectedQueue Get (in) queue.","title":"message_in_queue"},{"location":"aea/api/decision_maker/base/#message_out_queue_1","text":"| @property | message_out_queue () -> AsyncFriendlyQueue Get (out) queue.","title":"message_out_queue"},{"location":"aea/api/decision_maker/base/#decision_maker_handler","text":"| @property | decision_maker_handler () -> DecisionMakerHandler Get the decision maker handler.","title":"decision_maker_handler"},{"location":"aea/api/decision_maker/base/#start","text":"| start () -> None Start the decision maker.","title":"start"},{"location":"aea/api/decision_maker/base/#stop","text":"| stop () -> None Stop the decision maker.","title":"stop"},{"location":"aea/api/decision_maker/base/#execute","text":"| execute () -> None Execute the decision maker. Performs the following while not stopped: gets internal messages from the in queue and calls handle() on them","title":"execute"},{"location":"aea/api/decision_maker/base/#handle_1","text":"| handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message","title":"handle"},{"location":"aea/api/decision_maker/default/","text":"aea.decision _ maker.default This module contains the decision maker class. DecisionMakerHandler Objects class DecisionMakerHandler ( BaseDecisionMakerHandler ) This class implements the decision maker. SigningDialogues Objects class SigningDialogues ( BaseSigningDialogues ) This class keeps track of all oef_search dialogues. __ init __ | __init__ ( self_address : Address , ** kwargs : Any ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained kwargs : the keyword arguments __ init __ | __init__ ( identity : Identity , wallet : Wallet , config : Dict [ str , Any ]) -> None Initialize the decision maker. Arguments : identity : the identity wallet : the wallet config : the user defined configuration of the handler handle | handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message","title":"Default"},{"location":"aea/api/decision_maker/default/#aeadecision_makerdefault","text":"This module contains the decision maker class.","title":"aea.decision_maker.default"},{"location":"aea/api/decision_maker/default/#decisionmakerhandler-objects","text":"class DecisionMakerHandler ( BaseDecisionMakerHandler ) This class implements the decision maker.","title":"DecisionMakerHandler Objects"},{"location":"aea/api/decision_maker/default/#signingdialogues-objects","text":"class SigningDialogues ( BaseSigningDialogues ) This class keeps track of all oef_search dialogues.","title":"SigningDialogues Objects"},{"location":"aea/api/decision_maker/default/#__init__","text":"| __init__ ( self_address : Address , ** kwargs : Any ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained kwargs : the keyword arguments","title":"__init__"},{"location":"aea/api/decision_maker/default/#__init___1","text":"| __init__ ( identity : Identity , wallet : Wallet , config : Dict [ str , Any ]) -> None Initialize the decision maker. Arguments : identity : the identity wallet : the wallet config : the user defined configuration of the handler","title":"__init__"},{"location":"aea/api/decision_maker/default/#handle","text":"| handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message","title":"handle"},{"location":"aea/api/decision_maker/gop/","text":"aea.decision _ maker.gop This module contains the decision maker class. GoalPursuitReadiness Objects class GoalPursuitReadiness () The goal pursuit readiness. Status Objects class Status ( Enum ) The enum of the readiness status. In particular, it can be one of the following: Status.READY: when the agent is ready to pursuit its goal Status.NOT_READY: when the agent is not ready to pursuit its goal __ init __ | __init__ () -> None Instantiate the goal pursuit readiness. is _ ready | @property | is_ready () -> bool Get the readiness. update | update ( new_status : Status ) -> None Update the goal pursuit readiness. Arguments : new_status : the new status OwnershipState Objects class OwnershipState ( BaseOwnershipState ) Represent the ownership state of an agent (can proxy a ledger). __ init __ | __init__ () -> None Instantiate an ownership state object. set | set ( amount_by_currency_id : CurrencyHoldings = None , quantities_by_good_id : GoodHoldings = None , ** kwargs : Any , ,) -> None Set values on the ownership state. Arguments : amount_by_currency_id : the currency endowment of the agent in this state. quantities_by_good_id : the good endowment of the agent in this state. kwargs : the keyword arguments. apply _ delta | apply_delta ( delta_amount_by_currency_id : Dict [ str , int ] = None , delta_quantities_by_good_id : Dict [ str , int ] = None , ** kwargs : Any , ,) -> None Apply a state update to the ownership state. This method is used to apply a raw state update without a transaction. Arguments : delta_amount_by_currency_id : the delta in the currency amounts delta_quantities_by_good_id : the delta in the quantities by good kwargs : the keyword arguments is _ initialized | @property | is_initialized () -> bool Get the initialization status. amount _ by _ currency _ id | @property | amount_by_currency_id () -> CurrencyHoldings Get currency holdings in this state. quantities _ by _ good _ id | @property | quantities_by_good_id () -> GoodHoldings Get good holdings in this state. is _ affordable _ transaction | is_affordable_transaction ( terms : Terms ) -> bool Check if the transaction is affordable (and consistent). E.g. check that the agent state has enough money if it is a buyer or enough holdings if it is a seller. Note, the agent is the sender of the transaction message by design. Arguments : terms : the transaction terms Returns : True if the transaction is legal wrt the current state, false otherwise. is _ affordable | is_affordable ( terms : Terms ) -> bool Check if the tx is affordable. Arguments : terms : the transaction terms Returns : whether the transaction is affordable or not update | update ( terms : Terms ) -> None Update the agent state from a transaction. Arguments : terms : the transaction terms apply _ transactions | apply_transactions ( list_of_terms : List [ Terms ]) -> \"OwnershipState\" Apply a list of transactions to (a copy of) the current state. Arguments : list_of_terms : the sequence of transaction terms. Returns : the final state. __ copy __ | __copy__ () -> \"OwnershipState\" Copy the object. Preferences Objects class Preferences ( BasePreferences ) Class to represent the preferences. __ init __ | __init__ () -> None Instantiate an agent preference object. set | set ( exchange_params_by_currency_id : ExchangeParams = None , utility_params_by_good_id : UtilityParams = None , ** kwargs : Any , ,) -> None Set values on the preferences. Arguments : exchange_params_by_currency_id : the exchange params. utility_params_by_good_id : the utility params for every asset. kwargs : the keyword arguments. is _ initialized | @property | is_initialized () -> bool Get the initialization status. Returns : True if exchange_params_by_currency_id and utility_params_by_good_id are not None. exchange _ params _ by _ currency _ id | @property | exchange_params_by_currency_id () -> ExchangeParams Get exchange parameter for each currency. utility _ params _ by _ good _ id | @property | utility_params_by_good_id () -> UtilityParams Get utility parameter for each good. logarithmic _ utility | logarithmic_utility ( quantities_by_good_id : GoodHoldings ) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : quantities_by_good_id : the good holdings (dictionary) with the identifier (key) and quantity (value) for each good Returns : utility value linear _ utility | linear_utility ( amount_by_currency_id : CurrencyHoldings ) -> float Compute agent's utility given her utility function params and a currency bundle. Arguments : amount_by_currency_id : the currency holdings (dictionary) with the identifier (key) and quantity (value) for each currency Returns : utility value utility | utility ( quantities_by_good_id : GoodHoldings , amount_by_currency_id : CurrencyHoldings ) -> float Compute the utility given the good and currency holdings. Arguments : quantities_by_good_id : the good holdings amount_by_currency_id : the currency holdings Returns : the utility value. marginal _ utility | marginal_utility ( ownership_state : BaseOwnershipState , delta_quantities_by_good_id : Optional [ GoodHoldings ] = None , delta_amount_by_currency_id : Optional [ CurrencyHoldings ] = None , ** kwargs : Any , ,) -> float Compute the marginal utility. Arguments : ownership_state : the ownership state against which to compute the marginal utility. delta_quantities_by_good_id : the change in good holdings delta_amount_by_currency_id : the change in money holdings kwargs : the keyword arguments Returns : the marginal utility score utility _ diff _ from _ transaction | utility_diff_from_transaction ( ownership_state : BaseOwnershipState , terms : Terms ) -> float Simulate a transaction and get the resulting utility difference (taking into account the fee). Arguments : ownership_state : the ownership state against which to apply the transaction. terms : the transaction terms. Returns : the score. is _ utility _ enhancing | is_utility_enhancing ( ownership_state : BaseOwnershipState , terms : Terms ) -> bool Check if the tx is utility enhancing. Arguments : ownership_state : the ownership state against which to apply the transaction. terms : the transaction terms Returns : whether the transaction is utility enhancing or not __ copy __ | __copy__ () -> \"Preferences\" Copy the object. DecisionMakerHandler Objects class DecisionMakerHandler ( BaseDecisionMakerHandler ) This class implements the decision maker. SigningDialogues Objects class SigningDialogues ( BaseSigningDialogues ) This class keeps track of all oef_search dialogues. __ init __ | __init__ ( self_address : Address , ** kwargs : Any ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained kwargs : the keyword arguments StateUpdateDialogues Objects class StateUpdateDialogues ( BaseStateUpdateDialogues ) This class keeps track of all oef_search dialogues. __ init __ | __init__ ( self_address : Address , ** kwargs : Any ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained kwargs : the keyword arguments __ init __ | __init__ ( identity : Identity , wallet : Wallet , config : Dict [ str , Any ]) -> None Initialize the decision maker. Arguments : identity : the identity wallet : the wallet config : the user defined configuration of the handler handle | handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message","title":"GOP"},{"location":"aea/api/decision_maker/gop/#aeadecision_makergop","text":"This module contains the decision maker class.","title":"aea.decision_maker.gop"},{"location":"aea/api/decision_maker/gop/#goalpursuitreadiness-objects","text":"class GoalPursuitReadiness () The goal pursuit readiness.","title":"GoalPursuitReadiness Objects"},{"location":"aea/api/decision_maker/gop/#status-objects","text":"class Status ( Enum ) The enum of the readiness status. In particular, it can be one of the following: Status.READY: when the agent is ready to pursuit its goal Status.NOT_READY: when the agent is not ready to pursuit its goal","title":"Status Objects"},{"location":"aea/api/decision_maker/gop/#__init__","text":"| __init__ () -> None Instantiate the goal pursuit readiness.","title":"__init__"},{"location":"aea/api/decision_maker/gop/#is_ready","text":"| @property | is_ready () -> bool Get the readiness.","title":"is_ready"},{"location":"aea/api/decision_maker/gop/#update","text":"| update ( new_status : Status ) -> None Update the goal pursuit readiness. Arguments : new_status : the new status","title":"update"},{"location":"aea/api/decision_maker/gop/#ownershipstate-objects","text":"class OwnershipState ( BaseOwnershipState ) Represent the ownership state of an agent (can proxy a ledger).","title":"OwnershipState Objects"},{"location":"aea/api/decision_maker/gop/#__init___1","text":"| __init__ () -> None Instantiate an ownership state object.","title":"__init__"},{"location":"aea/api/decision_maker/gop/#set","text":"| set ( amount_by_currency_id : CurrencyHoldings = None , quantities_by_good_id : GoodHoldings = None , ** kwargs : Any , ,) -> None Set values on the ownership state. Arguments : amount_by_currency_id : the currency endowment of the agent in this state. quantities_by_good_id : the good endowment of the agent in this state. kwargs : the keyword arguments.","title":"set"},{"location":"aea/api/decision_maker/gop/#apply_delta","text":"| apply_delta ( delta_amount_by_currency_id : Dict [ str , int ] = None , delta_quantities_by_good_id : Dict [ str , int ] = None , ** kwargs : Any , ,) -> None Apply a state update to the ownership state. This method is used to apply a raw state update without a transaction. Arguments : delta_amount_by_currency_id : the delta in the currency amounts delta_quantities_by_good_id : the delta in the quantities by good kwargs : the keyword arguments","title":"apply_delta"},{"location":"aea/api/decision_maker/gop/#is_initialized","text":"| @property | is_initialized () -> bool Get the initialization status.","title":"is_initialized"},{"location":"aea/api/decision_maker/gop/#amount_by_currency_id","text":"| @property | amount_by_currency_id () -> CurrencyHoldings Get currency holdings in this state.","title":"amount_by_currency_id"},{"location":"aea/api/decision_maker/gop/#quantities_by_good_id","text":"| @property | quantities_by_good_id () -> GoodHoldings Get good holdings in this state.","title":"quantities_by_good_id"},{"location":"aea/api/decision_maker/gop/#is_affordable_transaction","text":"| is_affordable_transaction ( terms : Terms ) -> bool Check if the transaction is affordable (and consistent). E.g. check that the agent state has enough money if it is a buyer or enough holdings if it is a seller. Note, the agent is the sender of the transaction message by design. Arguments : terms : the transaction terms Returns : True if the transaction is legal wrt the current state, false otherwise.","title":"is_affordable_transaction"},{"location":"aea/api/decision_maker/gop/#is_affordable","text":"| is_affordable ( terms : Terms ) -> bool Check if the tx is affordable. Arguments : terms : the transaction terms Returns : whether the transaction is affordable or not","title":"is_affordable"},{"location":"aea/api/decision_maker/gop/#update_1","text":"| update ( terms : Terms ) -> None Update the agent state from a transaction. Arguments : terms : the transaction terms","title":"update"},{"location":"aea/api/decision_maker/gop/#apply_transactions","text":"| apply_transactions ( list_of_terms : List [ Terms ]) -> \"OwnershipState\" Apply a list of transactions to (a copy of) the current state. Arguments : list_of_terms : the sequence of transaction terms. Returns : the final state.","title":"apply_transactions"},{"location":"aea/api/decision_maker/gop/#__copy__","text":"| __copy__ () -> \"OwnershipState\" Copy the object.","title":"__copy__"},{"location":"aea/api/decision_maker/gop/#preferences-objects","text":"class Preferences ( BasePreferences ) Class to represent the preferences.","title":"Preferences Objects"},{"location":"aea/api/decision_maker/gop/#__init___2","text":"| __init__ () -> None Instantiate an agent preference object.","title":"__init__"},{"location":"aea/api/decision_maker/gop/#set_1","text":"| set ( exchange_params_by_currency_id : ExchangeParams = None , utility_params_by_good_id : UtilityParams = None , ** kwargs : Any , ,) -> None Set values on the preferences. Arguments : exchange_params_by_currency_id : the exchange params. utility_params_by_good_id : the utility params for every asset. kwargs : the keyword arguments.","title":"set"},{"location":"aea/api/decision_maker/gop/#is_initialized_1","text":"| @property | is_initialized () -> bool Get the initialization status. Returns : True if exchange_params_by_currency_id and utility_params_by_good_id are not None.","title":"is_initialized"},{"location":"aea/api/decision_maker/gop/#exchange_params_by_currency_id","text":"| @property | exchange_params_by_currency_id () -> ExchangeParams Get exchange parameter for each currency.","title":"exchange_params_by_currency_id"},{"location":"aea/api/decision_maker/gop/#utility_params_by_good_id","text":"| @property | utility_params_by_good_id () -> UtilityParams Get utility parameter for each good.","title":"utility_params_by_good_id"},{"location":"aea/api/decision_maker/gop/#logarithmic_utility","text":"| logarithmic_utility ( quantities_by_good_id : GoodHoldings ) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : quantities_by_good_id : the good holdings (dictionary) with the identifier (key) and quantity (value) for each good Returns : utility value","title":"logarithmic_utility"},{"location":"aea/api/decision_maker/gop/#linear_utility","text":"| linear_utility ( amount_by_currency_id : CurrencyHoldings ) -> float Compute agent's utility given her utility function params and a currency bundle. Arguments : amount_by_currency_id : the currency holdings (dictionary) with the identifier (key) and quantity (value) for each currency Returns : utility value","title":"linear_utility"},{"location":"aea/api/decision_maker/gop/#utility","text":"| utility ( quantities_by_good_id : GoodHoldings , amount_by_currency_id : CurrencyHoldings ) -> float Compute the utility given the good and currency holdings. Arguments : quantities_by_good_id : the good holdings amount_by_currency_id : the currency holdings Returns : the utility value.","title":"utility"},{"location":"aea/api/decision_maker/gop/#marginal_utility","text":"| marginal_utility ( ownership_state : BaseOwnershipState , delta_quantities_by_good_id : Optional [ GoodHoldings ] = None , delta_amount_by_currency_id : Optional [ CurrencyHoldings ] = None , ** kwargs : Any , ,) -> float Compute the marginal utility. Arguments : ownership_state : the ownership state against which to compute the marginal utility. delta_quantities_by_good_id : the change in good holdings delta_amount_by_currency_id : the change in money holdings kwargs : the keyword arguments Returns : the marginal utility score","title":"marginal_utility"},{"location":"aea/api/decision_maker/gop/#utility_diff_from_transaction","text":"| utility_diff_from_transaction ( ownership_state : BaseOwnershipState , terms : Terms ) -> float Simulate a transaction and get the resulting utility difference (taking into account the fee). Arguments : ownership_state : the ownership state against which to apply the transaction. terms : the transaction terms. Returns : the score.","title":"utility_diff_from_transaction"},{"location":"aea/api/decision_maker/gop/#is_utility_enhancing","text":"| is_utility_enhancing ( ownership_state : BaseOwnershipState , terms : Terms ) -> bool Check if the tx is utility enhancing. Arguments : ownership_state : the ownership state against which to apply the transaction. terms : the transaction terms Returns : whether the transaction is utility enhancing or not","title":"is_utility_enhancing"},{"location":"aea/api/decision_maker/gop/#__copy___1","text":"| __copy__ () -> \"Preferences\" Copy the object.","title":"__copy__"},{"location":"aea/api/decision_maker/gop/#decisionmakerhandler-objects","text":"class DecisionMakerHandler ( BaseDecisionMakerHandler ) This class implements the decision maker.","title":"DecisionMakerHandler Objects"},{"location":"aea/api/decision_maker/gop/#signingdialogues-objects","text":"class SigningDialogues ( BaseSigningDialogues ) This class keeps track of all oef_search dialogues.","title":"SigningDialogues Objects"},{"location":"aea/api/decision_maker/gop/#__init___3","text":"| __init__ ( self_address : Address , ** kwargs : Any ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained kwargs : the keyword arguments","title":"__init__"},{"location":"aea/api/decision_maker/gop/#stateupdatedialogues-objects","text":"class StateUpdateDialogues ( BaseStateUpdateDialogues ) This class keeps track of all oef_search dialogues.","title":"StateUpdateDialogues Objects"},{"location":"aea/api/decision_maker/gop/#__init___4","text":"| __init__ ( self_address : Address , ** kwargs : Any ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained kwargs : the keyword arguments","title":"__init__"},{"location":"aea/api/decision_maker/gop/#__init___5","text":"| __init__ ( identity : Identity , wallet : Wallet , config : Dict [ str , Any ]) -> None Initialize the decision maker. Arguments : identity : the identity wallet : the wallet config : the user defined configuration of the handler","title":"__init__"},{"location":"aea/api/decision_maker/gop/#handle","text":"| handle ( message : Message ) -> None Handle an internal message from the skills. Arguments : message : the internal message","title":"handle"},{"location":"aea/api/error_handler/base/","text":"aea.error _ handler.base This module contains the abstract error handler class. AbstractErrorHandler Objects class AbstractErrorHandler ( ABC ) Error handler class for handling problematic envelopes. __ init __ | __init__ ( ** kwargs : Any ) Instantiate error handler. config | @property | config () -> Dict [ str , Any ] Get handler config. send _ unsupported _ protocol | @abstractmethod | send_unsupported_protocol ( envelope : Envelope , logger : Logger ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope logger : the logger Returns : None send _ decoding _ error | @abstractmethod | send_decoding_error ( envelope : Envelope , exception : Exception , logger : Logger ) -> None Handle a decoding error. Arguments : envelope : the envelope exception : the exception raised during decoding logger : the logger Returns : None send _ no _ active _ handler | @abstractmethod | send_no_active_handler ( envelope : Envelope , reason : str , logger : Logger ) -> None Handle the received envelope in case the handler is not supported. Arguments : envelope : the envelope reason : the reason for the failure logger : the logger Returns : None","title":"Base"},{"location":"aea/api/error_handler/base/#aeaerror_handlerbase","text":"This module contains the abstract error handler class.","title":"aea.error_handler.base"},{"location":"aea/api/error_handler/base/#abstracterrorhandler-objects","text":"class AbstractErrorHandler ( ABC ) Error handler class for handling problematic envelopes.","title":"AbstractErrorHandler Objects"},{"location":"aea/api/error_handler/base/#__init__","text":"| __init__ ( ** kwargs : Any ) Instantiate error handler.","title":"__init__"},{"location":"aea/api/error_handler/base/#config","text":"| @property | config () -> Dict [ str , Any ] Get handler config.","title":"config"},{"location":"aea/api/error_handler/base/#send_unsupported_protocol","text":"| @abstractmethod | send_unsupported_protocol ( envelope : Envelope , logger : Logger ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope logger : the logger Returns : None","title":"send_unsupported_protocol"},{"location":"aea/api/error_handler/base/#send_decoding_error","text":"| @abstractmethod | send_decoding_error ( envelope : Envelope , exception : Exception , logger : Logger ) -> None Handle a decoding error. Arguments : envelope : the envelope exception : the exception raised during decoding logger : the logger Returns : None","title":"send_decoding_error"},{"location":"aea/api/error_handler/base/#send_no_active_handler","text":"| @abstractmethod | send_no_active_handler ( envelope : Envelope , reason : str , logger : Logger ) -> None Handle the received envelope in case the handler is not supported. Arguments : envelope : the envelope reason : the reason for the failure logger : the logger Returns : None","title":"send_no_active_handler"},{"location":"aea/api/error_handler/default/","text":"aea.error _ handler.default This module contains the default error handler class. ErrorHandler Objects class ErrorHandler ( AbstractErrorHandler ) Error handler class for handling problematic envelopes. __ init __ | __init__ ( ** kwargs : Any ) Instantiate error handler. send _ unsupported _ protocol | send_unsupported_protocol ( envelope : Envelope , logger : Logger ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope logger : the logger send _ decoding _ error | send_decoding_error ( envelope : Envelope , exception : Exception , logger : Logger ) -> None Handle a decoding error. Arguments : envelope : the envelope exception : the exception raised during decoding logger : the logger send _ no _ active _ handler | send_no_active_handler ( envelope : Envelope , reason : str , logger : Logger ) -> None Handle the received envelope in case the handler is not supported. Arguments : envelope : the envelope reason : the reason for the failure logger : the logger","title":"Default"},{"location":"aea/api/error_handler/default/#aeaerror_handlerdefault","text":"This module contains the default error handler class.","title":"aea.error_handler.default"},{"location":"aea/api/error_handler/default/#errorhandler-objects","text":"class ErrorHandler ( AbstractErrorHandler ) Error handler class for handling problematic envelopes.","title":"ErrorHandler Objects"},{"location":"aea/api/error_handler/default/#__init__","text":"| __init__ ( ** kwargs : Any ) Instantiate error handler.","title":"__init__"},{"location":"aea/api/error_handler/default/#send_unsupported_protocol","text":"| send_unsupported_protocol ( envelope : Envelope , logger : Logger ) -> None Handle the received envelope in case the protocol is not supported. Arguments : envelope : the envelope logger : the logger","title":"send_unsupported_protocol"},{"location":"aea/api/error_handler/default/#send_decoding_error","text":"| send_decoding_error ( envelope : Envelope , exception : Exception , logger : Logger ) -> None Handle a decoding error. Arguments : envelope : the envelope exception : the exception raised during decoding logger : the logger","title":"send_decoding_error"},{"location":"aea/api/error_handler/default/#send_no_active_handler","text":"| send_no_active_handler ( envelope : Envelope , reason : str , logger : Logger ) -> None Handle the received envelope in case the handler is not supported. Arguments : envelope : the envelope reason : the reason for the failure logger : the logger","title":"send_no_active_handler"},{"location":"aea/api/helpers/async_friendly_queue/","text":"aea.helpers.async _ friendly _ queue This module contains the implementation of AsyncFriendlyQueue. AsyncFriendlyQueue Objects class AsyncFriendlyQueue ( queue . Queue ) queue.Queue with async_get method. __ init __ | __init__ ( * args : Any , ** kwargs : Any ) -> None Init queue. put | put ( item : Any , * args : Any , ** kwargs : Any ) -> None Put an item into the queue. Arguments : item : item to put in the queue args : similar to queue.Queue.put kwargs : similar to queue.Queue.put get | get ( * args : Any , ** kwargs : Any ) -> Any Get an item into the queue. Arguments : args : similar to queue.Queue.get kwargs : similar to queue.Queue.get Returns : similar to queue.Queue.get async _ wait | async async_wait () -> None Wait an item appears in the queue. Returns : None async _ get | async async_get () -> Any Wait and get an item from the queue. Returns : item from queue","title":"Async Friendly Queue"},{"location":"aea/api/helpers/async_friendly_queue/#aeahelpersasync_friendly_queue","text":"This module contains the implementation of AsyncFriendlyQueue.","title":"aea.helpers.async_friendly_queue"},{"location":"aea/api/helpers/async_friendly_queue/#asyncfriendlyqueue-objects","text":"class AsyncFriendlyQueue ( queue . Queue ) queue.Queue with async_get method.","title":"AsyncFriendlyQueue Objects"},{"location":"aea/api/helpers/async_friendly_queue/#__init__","text":"| __init__ ( * args : Any , ** kwargs : Any ) -> None Init queue.","title":"__init__"},{"location":"aea/api/helpers/async_friendly_queue/#put","text":"| put ( item : Any , * args : Any , ** kwargs : Any ) -> None Put an item into the queue. Arguments : item : item to put in the queue args : similar to queue.Queue.put kwargs : similar to queue.Queue.put","title":"put"},{"location":"aea/api/helpers/async_friendly_queue/#get","text":"| get ( * args : Any , ** kwargs : Any ) -> Any Get an item into the queue. Arguments : args : similar to queue.Queue.get kwargs : similar to queue.Queue.get Returns : similar to queue.Queue.get","title":"get"},{"location":"aea/api/helpers/async_friendly_queue/#async_wait","text":"| async async_wait () -> None Wait an item appears in the queue. Returns : None","title":"async_wait"},{"location":"aea/api/helpers/async_friendly_queue/#async_get","text":"| async async_get () -> Any Wait and get an item from the queue. Returns : item from queue","title":"async_get"},{"location":"aea/api/helpers/async_utils/","text":"aea.helpers.async _ utils This module contains the misc utils for async code. ensure _ list ensure_list ( value : Any ) -> List Return [value] or list(value) if value is a sequence. AsyncState Objects class AsyncState () Awaitable state. __ init __ | __init__ ( initial_state : Any = None , states_enum : Optional [ Container [ Any ]] = None ) -> None Init async state. Arguments : initial_state : state to set on start. states_enum : container of valid states if not provided state not checked on set. set | set ( state : Any ) -> None Set state. add _ callback | add_callback ( callback_fn : Callable [[ Any ], None ]) -> None Add callback to track state changes. Arguments : callback_fn : callable object to be called on state changed. get | get () -> Any Get state. wait | async wait ( state_or_states : Union [ Any , Sequence [ Any ]]) -> Tuple [ Any , Any ] Wait state to be set. Arguments : state_or_states : state or list of states. Returns : tuple of previous state and new state. transit | @contextmanager | transit ( initial : Any = not_set , success : Any = not_set , fail : Any = not_set ) -> Generator Change state context according to success or not. Arguments : initial : set state on context enter, not_set by default success : set state on context block done, not_set by default fail : set state on context block raises exception, not_set by default :yield: generator PeriodicCaller Objects class PeriodicCaller () Schedule a periodic call of callable using event loop. Used for periodic function run using asyncio. __ init __ | __init__ ( callback : Callable , period : float , start_at : Optional [ datetime . datetime ] = None , exception_callback : Optional [ Callable [[ Callable , Exception ], None ]] = None , loop : Optional [ AbstractEventLoop ] = None ) -> None Init periodic caller. Arguments : callback : function to call periodically period : period in seconds. start_at : optional first call datetime exception_callback : optional handler to call on exception raised. loop : optional asyncio event loop start | start () -> None Activate period calls. stop | stop () -> None Remove from schedule. AnotherThreadTask Objects class AnotherThreadTask () Schedule a task to run on the loop in another thread. Provides better cancel behaviour: on cancel it will wait till cancelled completely. __ init __ | __init__ ( coro : Awaitable , loop : AbstractEventLoop ) -> None Init the task. Arguments : coro : coroutine to schedule loop : an event loop to schedule on. result | result ( timeout : Optional [ float ] = None ) -> Any Wait for coroutine execution result. Arguments : timeout : optional timeout to wait in seconds. Returns : result cancel | cancel () -> None Cancel coroutine task execution in a target loop. done | done () -> bool Check task is done. ThreadedAsyncRunner Objects class ThreadedAsyncRunner ( Thread ) Util to run thread with event loop and execute coroutines inside. __ init __ | __init__ ( loop : Optional [ AbstractEventLoop ] = None ) -> None Init threaded runner. Arguments : loop : optional event loop. is it's running loop, threaded runner will use it. start | start () -> None Start event loop in dedicated thread. run | run () -> None Run code inside thread. call | call ( coro : Awaitable ) -> Any Run a coroutine inside the event loop. Arguments : coro : a coroutine to run. Returns : task stop | stop () -> None Stop event loop in thread. Runnable Objects class Runnable ( ABC ) Abstract Runnable class. Use to run async task in same event loop or in dedicated thread. Provides: start, stop sync methods to start and stop task Use wait_completed to await task was completed. __ init __ | __init__ ( loop : asyncio . AbstractEventLoop = None , threaded : bool = False ) -> None Init runnable. Arguments : loop : asyncio event loop to use. threaded : bool. start in thread if True. start | start () -> bool Start runnable. Returns : bool started or not. is _ running | @property | is_running () -> bool Get running state. run | @abstractmethod | async run () -> Any Implement run logic respectful to CancelError on termination. wait _ completed | wait_completed ( sync : bool = False , timeout : float = None , force_result : bool = False ) -> Awaitable Wait runnable execution completed. Arguments : sync : bool. blocking wait timeout : float seconds force_result : check result even it was waited. Returns : awaitable if sync is False, otherwise None stop | stop ( force : bool = False ) -> None Stop runnable. start _ and _ wait _ completed | start_and_wait_completed ( * args : Any , ** kwargs : Any ) -> Awaitable Alias for start and wait methods.","title":"Async Utils"},{"location":"aea/api/helpers/async_utils/#aeahelpersasync_utils","text":"This module contains the misc utils for async code.","title":"aea.helpers.async_utils"},{"location":"aea/api/helpers/async_utils/#ensure_list","text":"ensure_list ( value : Any ) -> List Return [value] or list(value) if value is a sequence.","title":"ensure_list"},{"location":"aea/api/helpers/async_utils/#asyncstate-objects","text":"class AsyncState () Awaitable state.","title":"AsyncState Objects"},{"location":"aea/api/helpers/async_utils/#__init__","text":"| __init__ ( initial_state : Any = None , states_enum : Optional [ Container [ Any ]] = None ) -> None Init async state. Arguments : initial_state : state to set on start. states_enum : container of valid states if not provided state not checked on set.","title":"__init__"},{"location":"aea/api/helpers/async_utils/#set","text":"| set ( state : Any ) -> None Set state.","title":"set"},{"location":"aea/api/helpers/async_utils/#add_callback","text":"| add_callback ( callback_fn : Callable [[ Any ], None ]) -> None Add callback to track state changes. Arguments : callback_fn : callable object to be called on state changed.","title":"add_callback"},{"location":"aea/api/helpers/async_utils/#get","text":"| get () -> Any Get state.","title":"get"},{"location":"aea/api/helpers/async_utils/#wait","text":"| async wait ( state_or_states : Union [ Any , Sequence [ Any ]]) -> Tuple [ Any , Any ] Wait state to be set. Arguments : state_or_states : state or list of states. Returns : tuple of previous state and new state.","title":"wait"},{"location":"aea/api/helpers/async_utils/#transit","text":"| @contextmanager | transit ( initial : Any = not_set , success : Any = not_set , fail : Any = not_set ) -> Generator Change state context according to success or not. Arguments : initial : set state on context enter, not_set by default success : set state on context block done, not_set by default fail : set state on context block raises exception, not_set by default :yield: generator","title":"transit"},{"location":"aea/api/helpers/async_utils/#periodiccaller-objects","text":"class PeriodicCaller () Schedule a periodic call of callable using event loop. Used for periodic function run using asyncio.","title":"PeriodicCaller Objects"},{"location":"aea/api/helpers/async_utils/#__init___1","text":"| __init__ ( callback : Callable , period : float , start_at : Optional [ datetime . datetime ] = None , exception_callback : Optional [ Callable [[ Callable , Exception ], None ]] = None , loop : Optional [ AbstractEventLoop ] = None ) -> None Init periodic caller. Arguments : callback : function to call periodically period : period in seconds. start_at : optional first call datetime exception_callback : optional handler to call on exception raised. loop : optional asyncio event loop","title":"__init__"},{"location":"aea/api/helpers/async_utils/#start","text":"| start () -> None Activate period calls.","title":"start"},{"location":"aea/api/helpers/async_utils/#stop","text":"| stop () -> None Remove from schedule.","title":"stop"},{"location":"aea/api/helpers/async_utils/#anotherthreadtask-objects","text":"class AnotherThreadTask () Schedule a task to run on the loop in another thread. Provides better cancel behaviour: on cancel it will wait till cancelled completely.","title":"AnotherThreadTask Objects"},{"location":"aea/api/helpers/async_utils/#__init___2","text":"| __init__ ( coro : Awaitable , loop : AbstractEventLoop ) -> None Init the task. Arguments : coro : coroutine to schedule loop : an event loop to schedule on.","title":"__init__"},{"location":"aea/api/helpers/async_utils/#result","text":"| result ( timeout : Optional [ float ] = None ) -> Any Wait for coroutine execution result. Arguments : timeout : optional timeout to wait in seconds. Returns : result","title":"result"},{"location":"aea/api/helpers/async_utils/#cancel","text":"| cancel () -> None Cancel coroutine task execution in a target loop.","title":"cancel"},{"location":"aea/api/helpers/async_utils/#done","text":"| done () -> bool Check task is done.","title":"done"},{"location":"aea/api/helpers/async_utils/#threadedasyncrunner-objects","text":"class ThreadedAsyncRunner ( Thread ) Util to run thread with event loop and execute coroutines inside.","title":"ThreadedAsyncRunner Objects"},{"location":"aea/api/helpers/async_utils/#__init___3","text":"| __init__ ( loop : Optional [ AbstractEventLoop ] = None ) -> None Init threaded runner. Arguments : loop : optional event loop. is it's running loop, threaded runner will use it.","title":"__init__"},{"location":"aea/api/helpers/async_utils/#start_1","text":"| start () -> None Start event loop in dedicated thread.","title":"start"},{"location":"aea/api/helpers/async_utils/#run","text":"| run () -> None Run code inside thread.","title":"run"},{"location":"aea/api/helpers/async_utils/#call","text":"| call ( coro : Awaitable ) -> Any Run a coroutine inside the event loop. Arguments : coro : a coroutine to run. Returns : task","title":"call"},{"location":"aea/api/helpers/async_utils/#stop_1","text":"| stop () -> None Stop event loop in thread.","title":"stop"},{"location":"aea/api/helpers/async_utils/#runnable-objects","text":"class Runnable ( ABC ) Abstract Runnable class. Use to run async task in same event loop or in dedicated thread. Provides: start, stop sync methods to start and stop task Use wait_completed to await task was completed.","title":"Runnable Objects"},{"location":"aea/api/helpers/async_utils/#__init___4","text":"| __init__ ( loop : asyncio . AbstractEventLoop = None , threaded : bool = False ) -> None Init runnable. Arguments : loop : asyncio event loop to use. threaded : bool. start in thread if True.","title":"__init__"},{"location":"aea/api/helpers/async_utils/#start_2","text":"| start () -> bool Start runnable. Returns : bool started or not.","title":"start"},{"location":"aea/api/helpers/async_utils/#is_running","text":"| @property | is_running () -> bool Get running state.","title":"is_running"},{"location":"aea/api/helpers/async_utils/#run_1","text":"| @abstractmethod | async run () -> Any Implement run logic respectful to CancelError on termination.","title":"run"},{"location":"aea/api/helpers/async_utils/#wait_completed","text":"| wait_completed ( sync : bool = False , timeout : float = None , force_result : bool = False ) -> Awaitable Wait runnable execution completed. Arguments : sync : bool. blocking wait timeout : float seconds force_result : check result even it was waited. Returns : awaitable if sync is False, otherwise None","title":"wait_completed"},{"location":"aea/api/helpers/async_utils/#stop_2","text":"| stop ( force : bool = False ) -> None Stop runnable.","title":"stop"},{"location":"aea/api/helpers/async_utils/#start_and_wait_completed","text":"| start_and_wait_completed ( * args : Any , ** kwargs : Any ) -> Awaitable Alias for start and wait methods.","title":"start_and_wait_completed"},{"location":"aea/api/helpers/base/","text":"aea.helpers.base Miscellaneous helpers. locate locate ( path : str ) -> Any Locate an object by name or dotted save_path, importing as necessary. load _ module load_module ( dotted_path : str , filepath : Path ) -> types . ModuleType Load a module. Arguments : dotted_path : the dotted save_path of the package/module. filepath : the file to the package/module. Returns : module type Raises : ValueError : if the filepath provided is not a module. # noqa: DAR402 Exception : if the execution of the module raises exception. # noqa: DAR402 load _ env _ file load_env_file ( env_file : str ) -> None Load the content of the environment file into the process environment. Arguments : env_file : save_path to the env file. sigint _ crossplatform sigint_crossplatform ( process : subprocess . Popen ) -> None Send a SIGINT, cross-platform. The reason is because the subprocess module doesn't have an API to send a SIGINT-like signal both on Posix and Windows with a single method. However, a subprocess.Popen class has the method 'send_signal' that gives more flexibility in this terms. Arguments : process : the process to send the signal to. win _ popen _ kwargs win_popen_kwargs () -> dict Return kwargs to start a process in windows with new process group. Help to handle ctrl c properly. Return empty dict if platform is not win32 Returns : windows popen kwargs send _ control _ c send_control_c ( process : subprocess . Popen , kill_group : bool = False ) -> None Send ctrl-C cross-platform to terminate a subprocess. Arguments : process : the process to send the signal to. kill_group : whether or not to kill group RegexConstrainedString Objects class RegexConstrainedString ( UserString ) A string that is constrained by a regex. The default behaviour is to match anything. Subclass this class and change the 'REGEX' class attribute to implement a different behaviour. __ init __ | __init__ ( seq : Union [ UserString , str ]) -> None Initialize a regex constrained string. SimpleId Objects class SimpleId ( RegexConstrainedString ) A simple identifier. The allowed strings are all the strings that: - have at least length 1 - have at most length 128 - the first character must be between a-z,A-Z or underscore - the other characters must be either the above or digits. Examples of allowed strings: SimpleId(\"an_identifier\") 'an_identifier' Examples of not allowed strings: SimpleId(\"0an_identifier\") Traceback (most recent call last): ... ValueError: Value 0an_identifier does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') SimpleId(\"an identifier\") Traceback (most recent call last): ... ValueError: Value an identifier does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') SimpleId(\"\") Traceback (most recent call last): ... ValueError: Value does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') cd @contextlib . contextmanager cd ( path : PathLike ) -> Generator Change working directory temporarily. get _ logger _ method get_logger_method ( fn : Callable , logger_method : Union [ str , Callable ]) -> Callable Get logger method for function. Get logger in fn definition module or creates logger is module. name . Or return logger_method if it's callable. Arguments : fn : function to get logger for. logger_method : logger name or callable. Returns : callable to write log with try _ decorator try_decorator ( error_message : str , default_return : Callable = None , logger_method : Any = \"error\" ) -> Callable Run function, log and return default value on exception. Does not support async or coroutines! Arguments : error_message : message template with one {} for exception default_return : value to return on exception, by default None logger_method : name of the logger method or callable to print logs Returns : the callable MaxRetriesError Objects class MaxRetriesError ( Exception ) Exception for retry decorator. retry _ decorator retry_decorator ( number_of_retries : int , error_message : str , delay : float = 0 , logger_method : str = \"error\" ) -> Callable Run function with several attempts. Does not support async or coroutines! Arguments : number_of_retries : amount of attempts error_message : message template with one {} for exception delay : number of seconds to sleep between retries. default 0 logger_method : name of the logger method or callable to print logs Returns : the callable exception _ log _ and _ reraise @contextlib . contextmanager exception_log_and_reraise ( log_method : Callable , message : str ) -> Generator Run code in context to log and re raise exception. Arguments : log_method : function to print log message : message template to add error text. :yield: the generator recursive _ update recursive_update ( to_update : Dict , new_values : Dict , allow_new_values : bool = False ) -> None Update a dictionary by replacing conflicts with the new values. It does side-effects to the first dictionary. to_update = dict(a=1, b=2, subdict=dict(subfield1=1)) new_values = dict(b=3, subdict=dict(subfield1=2)) recursive_update(to_update, new_values) to_update {'a': 1, 'b': 3, 'subdict': {'subfield1': 2}} Arguments : to_update : the dictionary to update. new_values : the dictionary of new values to replace. allow_new_values : whether or not to allow new values. find _ topological _ order find_topological_order ( adjacency_list : Dict [ T , Set [ T ]]) -> List [ T ] Compute the topological order of a graph (using Kahn's algorithm). Arguments : adjacency_list : the adjacency list of the graph. Returns : the topological order for the graph (as a sequence of nodes) Raises : ValueError : if the graph contains a cycle. reachable _ nodes reachable_nodes ( adjacency_list : Dict [ T , Set [ T ]], starting_nodes : Set [ T ]) -> Dict [ T , Set [ T ]] Find the reachable subgraph induced by a set of starting nodes. Arguments : adjacency_list : the adjacency list of the full graph. starting_nodes : the starting nodes of the new graph. Returns : the adjacency list of the subgraph. cached _ property Objects class cached_property () Cached property from python3.8 functools. __ init __ | __init__ ( func : Callable ) -> None Init cached property. __ set _ name __ | __set_name__ ( _ : Any , name : Any ) -> None Set name. __ get __ | __get__ ( instance : Any , _ : Optional [ Any ] = None ) -> Any Get instance. ensure _ dir ensure_dir ( dir_path : str ) -> None Check if dir_path is a directory or create it. dict _ to _ path _ value dict_to_path_value ( data : Mapping , path : Optional [ List ] = None ) -> Iterable [ Tuple [ List [ str ], Any ]] Convert dict to sequence of terminal path build of keys and value. parse _ datetime _ from _ str parse_datetime_from_str ( date_string : str ) -> datetime . datetime Parse datetime from string. CertRequest Objects class CertRequest () Certificate request for proof of representation. __ init __ | __init__ ( public_key : str , identifier : SimpleIdOrStr , ledger_id : SimpleIdOrStr , not_before : str , not_after : str , message_format : str , save_path : str ) -> None Initialize the certificate request. Arguments : public_key : the public key, or the key id. identifier : certificate identifier. ledger_id : ledger identifier the request is referring to. not_before : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0. not_after : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0. message_format : message format used for signing save_path : the save_path where to save the certificate. public _ key | @property | public_key () -> Optional [ str ] Get the public key. ledger _ id | @property | ledger_id () -> str Get the ledger id. key _ identifier | @property | key_identifier () -> Optional [ str ] Get the key identifier. identifier | @property | identifier () -> str Get the identifier. not _ before _ string | @property | not_before_string () -> str Get the not_before field as string. not _ after _ string | @property | not_after_string () -> str Get the not_after field as string. not _ before | @property | not_before () -> datetime . datetime Get the not_before field. not _ after | @property | not_after () -> datetime . datetime Get the not_after field. message _ format | @property | message_format () -> str Get the message format. save _ path | @property | save_path () -> Path Get the save path for the certificate. Note: if the path is not absolute, then the actual save path might depend on the context. Returns : the save path get _ absolute _ save _ path | get_absolute_save_path ( path_prefix : Optional [ PathLike ] = None ) -> Path Get the absolute save path. If save_path is an absolute path, then the prefix is ignored. Otherwise, the path prefix is prepended. Arguments : path_prefix : the (absolute) path to prepend to the save path. Returns : the actual save path. public _ key _ or _ identifier | @property | public_key_or_identifier () -> str Get the public key or identifier. get _ message | get_message ( public_key : str ) -> bytes Get the message to sign. construct _ message | @classmethod | construct_message ( cls , public_key : str , identifier : SimpleIdOrStr , not_before_string : str , not_after_string : str , message_format : str ) -> bytes Construct message for singning. Arguments : public_key : the public key identifier : identifier to be signed not_before_string : signature not valid before not_after_string : signature not valid after message_format : message format used for signing Returns : the message get _ signature | get_signature ( path_prefix : Optional [ PathLike ] = None ) -> str Get signature from save_path. Arguments : path_prefix : the path prefix to be prepended to save_path. Defaults to cwd. Returns : the signature. json | @property | json () -> Dict Compute the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict ) -> \"CertRequest\" Compute the JSON representation. __ eq __ | __eq__ ( other : Any ) -> bool Check equality. compute _ specifier _ from _ version compute_specifier_from_version ( version : Version ) -> str Compute the specifier set from a version. version specifier is: >=major.minor.0, <next_major.0.0 Arguments : version : the version Returns : the specifier set decorator _ with _ optional _ params decorator_with_optional_params ( decorator : Callable ) -> Callable Make a decorator usable either with or without parameters. In other words, if a decorator \"mydecorator\" is decorated with this decorator, It can be used both as: @mydecorator def myfunction(): ... or as: @mydecorator(arg1, kwarg1=\"value\") def myfunction(): ... Arguments : decorator : a decorator callable Returns : a decorator callable delete _ directory _ contents delete_directory_contents ( directory : Path ) -> None Delete the content of a directory, without deleting it. prepend _ if _ not _ absolute prepend_if_not_absolute ( path : PathLike , prefix : PathLike ) -> PathLike Prepend a path with a prefix, but only if not absolute Arguments : path : the path to process. prefix : the path prefix. Returns : the same path if absolute, else the prepended path.","title":"Base"},{"location":"aea/api/helpers/base/#aeahelpersbase","text":"Miscellaneous helpers.","title":"aea.helpers.base"},{"location":"aea/api/helpers/base/#locate","text":"locate ( path : str ) -> Any Locate an object by name or dotted save_path, importing as necessary.","title":"locate"},{"location":"aea/api/helpers/base/#load_module","text":"load_module ( dotted_path : str , filepath : Path ) -> types . ModuleType Load a module. Arguments : dotted_path : the dotted save_path of the package/module. filepath : the file to the package/module. Returns : module type Raises : ValueError : if the filepath provided is not a module. # noqa: DAR402 Exception : if the execution of the module raises exception. # noqa: DAR402","title":"load_module"},{"location":"aea/api/helpers/base/#load_env_file","text":"load_env_file ( env_file : str ) -> None Load the content of the environment file into the process environment. Arguments : env_file : save_path to the env file.","title":"load_env_file"},{"location":"aea/api/helpers/base/#sigint_crossplatform","text":"sigint_crossplatform ( process : subprocess . Popen ) -> None Send a SIGINT, cross-platform. The reason is because the subprocess module doesn't have an API to send a SIGINT-like signal both on Posix and Windows with a single method. However, a subprocess.Popen class has the method 'send_signal' that gives more flexibility in this terms. Arguments : process : the process to send the signal to.","title":"sigint_crossplatform"},{"location":"aea/api/helpers/base/#win_popen_kwargs","text":"win_popen_kwargs () -> dict Return kwargs to start a process in windows with new process group. Help to handle ctrl c properly. Return empty dict if platform is not win32 Returns : windows popen kwargs","title":"win_popen_kwargs"},{"location":"aea/api/helpers/base/#send_control_c","text":"send_control_c ( process : subprocess . Popen , kill_group : bool = False ) -> None Send ctrl-C cross-platform to terminate a subprocess. Arguments : process : the process to send the signal to. kill_group : whether or not to kill group","title":"send_control_c"},{"location":"aea/api/helpers/base/#regexconstrainedstring-objects","text":"class RegexConstrainedString ( UserString ) A string that is constrained by a regex. The default behaviour is to match anything. Subclass this class and change the 'REGEX' class attribute to implement a different behaviour.","title":"RegexConstrainedString Objects"},{"location":"aea/api/helpers/base/#__init__","text":"| __init__ ( seq : Union [ UserString , str ]) -> None Initialize a regex constrained string.","title":"__init__"},{"location":"aea/api/helpers/base/#simpleid-objects","text":"class SimpleId ( RegexConstrainedString ) A simple identifier. The allowed strings are all the strings that: - have at least length 1 - have at most length 128 - the first character must be between a-z,A-Z or underscore - the other characters must be either the above or digits. Examples of allowed strings: SimpleId(\"an_identifier\") 'an_identifier' Examples of not allowed strings: SimpleId(\"0an_identifier\") Traceback (most recent call last): ... ValueError: Value 0an_identifier does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') SimpleId(\"an identifier\") Traceback (most recent call last): ... ValueError: Value an identifier does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}') SimpleId(\"\") Traceback (most recent call last): ... ValueError: Value does not match the regular expression re.compile('[a-zA-Z_][a-zA-Z0-9_]{0,127}')","title":"SimpleId Objects"},{"location":"aea/api/helpers/base/#cd","text":"@contextlib . contextmanager cd ( path : PathLike ) -> Generator Change working directory temporarily.","title":"cd"},{"location":"aea/api/helpers/base/#get_logger_method","text":"get_logger_method ( fn : Callable , logger_method : Union [ str , Callable ]) -> Callable Get logger method for function. Get logger in fn definition module or creates logger is module. name . Or return logger_method if it's callable. Arguments : fn : function to get logger for. logger_method : logger name or callable. Returns : callable to write log with","title":"get_logger_method"},{"location":"aea/api/helpers/base/#try_decorator","text":"try_decorator ( error_message : str , default_return : Callable = None , logger_method : Any = \"error\" ) -> Callable Run function, log and return default value on exception. Does not support async or coroutines! Arguments : error_message : message template with one {} for exception default_return : value to return on exception, by default None logger_method : name of the logger method or callable to print logs Returns : the callable","title":"try_decorator"},{"location":"aea/api/helpers/base/#maxretrieserror-objects","text":"class MaxRetriesError ( Exception ) Exception for retry decorator.","title":"MaxRetriesError Objects"},{"location":"aea/api/helpers/base/#retry_decorator","text":"retry_decorator ( number_of_retries : int , error_message : str , delay : float = 0 , logger_method : str = \"error\" ) -> Callable Run function with several attempts. Does not support async or coroutines! Arguments : number_of_retries : amount of attempts error_message : message template with one {} for exception delay : number of seconds to sleep between retries. default 0 logger_method : name of the logger method or callable to print logs Returns : the callable","title":"retry_decorator"},{"location":"aea/api/helpers/base/#exception_log_and_reraise","text":"@contextlib . contextmanager exception_log_and_reraise ( log_method : Callable , message : str ) -> Generator Run code in context to log and re raise exception. Arguments : log_method : function to print log message : message template to add error text. :yield: the generator","title":"exception_log_and_reraise"},{"location":"aea/api/helpers/base/#recursive_update","text":"recursive_update ( to_update : Dict , new_values : Dict , allow_new_values : bool = False ) -> None Update a dictionary by replacing conflicts with the new values. It does side-effects to the first dictionary. to_update = dict(a=1, b=2, subdict=dict(subfield1=1)) new_values = dict(b=3, subdict=dict(subfield1=2)) recursive_update(to_update, new_values) to_update {'a': 1, 'b': 3, 'subdict': {'subfield1': 2}} Arguments : to_update : the dictionary to update. new_values : the dictionary of new values to replace. allow_new_values : whether or not to allow new values.","title":"recursive_update"},{"location":"aea/api/helpers/base/#find_topological_order","text":"find_topological_order ( adjacency_list : Dict [ T , Set [ T ]]) -> List [ T ] Compute the topological order of a graph (using Kahn's algorithm). Arguments : adjacency_list : the adjacency list of the graph. Returns : the topological order for the graph (as a sequence of nodes) Raises : ValueError : if the graph contains a cycle.","title":"find_topological_order"},{"location":"aea/api/helpers/base/#reachable_nodes","text":"reachable_nodes ( adjacency_list : Dict [ T , Set [ T ]], starting_nodes : Set [ T ]) -> Dict [ T , Set [ T ]] Find the reachable subgraph induced by a set of starting nodes. Arguments : adjacency_list : the adjacency list of the full graph. starting_nodes : the starting nodes of the new graph. Returns : the adjacency list of the subgraph.","title":"reachable_nodes"},{"location":"aea/api/helpers/base/#cached_property-objects","text":"class cached_property () Cached property from python3.8 functools.","title":"cached_property Objects"},{"location":"aea/api/helpers/base/#__init___1","text":"| __init__ ( func : Callable ) -> None Init cached property.","title":"__init__"},{"location":"aea/api/helpers/base/#__set_name__","text":"| __set_name__ ( _ : Any , name : Any ) -> None Set name.","title":"__set_name__"},{"location":"aea/api/helpers/base/#__get__","text":"| __get__ ( instance : Any , _ : Optional [ Any ] = None ) -> Any Get instance.","title":"__get__"},{"location":"aea/api/helpers/base/#ensure_dir","text":"ensure_dir ( dir_path : str ) -> None Check if dir_path is a directory or create it.","title":"ensure_dir"},{"location":"aea/api/helpers/base/#dict_to_path_value","text":"dict_to_path_value ( data : Mapping , path : Optional [ List ] = None ) -> Iterable [ Tuple [ List [ str ], Any ]] Convert dict to sequence of terminal path build of keys and value.","title":"dict_to_path_value"},{"location":"aea/api/helpers/base/#parse_datetime_from_str","text":"parse_datetime_from_str ( date_string : str ) -> datetime . datetime Parse datetime from string.","title":"parse_datetime_from_str"},{"location":"aea/api/helpers/base/#certrequest-objects","text":"class CertRequest () Certificate request for proof of representation.","title":"CertRequest Objects"},{"location":"aea/api/helpers/base/#__init___2","text":"| __init__ ( public_key : str , identifier : SimpleIdOrStr , ledger_id : SimpleIdOrStr , not_before : str , not_after : str , message_format : str , save_path : str ) -> None Initialize the certificate request. Arguments : public_key : the public key, or the key id. identifier : certificate identifier. ledger_id : ledger identifier the request is referring to. not_before : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0. not_after : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0. message_format : message format used for signing save_path : the save_path where to save the certificate.","title":"__init__"},{"location":"aea/api/helpers/base/#public_key","text":"| @property | public_key () -> Optional [ str ] Get the public key.","title":"public_key"},{"location":"aea/api/helpers/base/#ledger_id","text":"| @property | ledger_id () -> str Get the ledger id.","title":"ledger_id"},{"location":"aea/api/helpers/base/#key_identifier","text":"| @property | key_identifier () -> Optional [ str ] Get the key identifier.","title":"key_identifier"},{"location":"aea/api/helpers/base/#identifier","text":"| @property | identifier () -> str Get the identifier.","title":"identifier"},{"location":"aea/api/helpers/base/#not_before_string","text":"| @property | not_before_string () -> str Get the not_before field as string.","title":"not_before_string"},{"location":"aea/api/helpers/base/#not_after_string","text":"| @property | not_after_string () -> str Get the not_after field as string.","title":"not_after_string"},{"location":"aea/api/helpers/base/#not_before","text":"| @property | not_before () -> datetime . datetime Get the not_before field.","title":"not_before"},{"location":"aea/api/helpers/base/#not_after","text":"| @property | not_after () -> datetime . datetime Get the not_after field.","title":"not_after"},{"location":"aea/api/helpers/base/#message_format","text":"| @property | message_format () -> str Get the message format.","title":"message_format"},{"location":"aea/api/helpers/base/#save_path","text":"| @property | save_path () -> Path Get the save path for the certificate. Note: if the path is not absolute, then the actual save path might depend on the context. Returns : the save path","title":"save_path"},{"location":"aea/api/helpers/base/#get_absolute_save_path","text":"| get_absolute_save_path ( path_prefix : Optional [ PathLike ] = None ) -> Path Get the absolute save path. If save_path is an absolute path, then the prefix is ignored. Otherwise, the path prefix is prepended. Arguments : path_prefix : the (absolute) path to prepend to the save path. Returns : the actual save path.","title":"get_absolute_save_path"},{"location":"aea/api/helpers/base/#public_key_or_identifier","text":"| @property | public_key_or_identifier () -> str Get the public key or identifier.","title":"public_key_or_identifier"},{"location":"aea/api/helpers/base/#get_message","text":"| get_message ( public_key : str ) -> bytes Get the message to sign.","title":"get_message"},{"location":"aea/api/helpers/base/#construct_message","text":"| @classmethod | construct_message ( cls , public_key : str , identifier : SimpleIdOrStr , not_before_string : str , not_after_string : str , message_format : str ) -> bytes Construct message for singning. Arguments : public_key : the public key identifier : identifier to be signed not_before_string : signature not valid before not_after_string : signature not valid after message_format : message format used for signing Returns : the message","title":"construct_message"},{"location":"aea/api/helpers/base/#get_signature","text":"| get_signature ( path_prefix : Optional [ PathLike ] = None ) -> str Get signature from save_path. Arguments : path_prefix : the path prefix to be prepended to save_path. Defaults to cwd. Returns : the signature.","title":"get_signature"},{"location":"aea/api/helpers/base/#json","text":"| @property | json () -> Dict Compute the JSON representation.","title":"json"},{"location":"aea/api/helpers/base/#from_json","text":"| @classmethod | from_json ( cls , obj : Dict ) -> \"CertRequest\" Compute the JSON representation.","title":"from_json"},{"location":"aea/api/helpers/base/#__eq__","text":"| __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"aea/api/helpers/base/#compute_specifier_from_version","text":"compute_specifier_from_version ( version : Version ) -> str Compute the specifier set from a version. version specifier is: >=major.minor.0, <next_major.0.0 Arguments : version : the version Returns : the specifier set","title":"compute_specifier_from_version"},{"location":"aea/api/helpers/base/#decorator_with_optional_params","text":"decorator_with_optional_params ( decorator : Callable ) -> Callable Make a decorator usable either with or without parameters. In other words, if a decorator \"mydecorator\" is decorated with this decorator, It can be used both as: @mydecorator def myfunction(): ... or as: @mydecorator(arg1, kwarg1=\"value\") def myfunction(): ... Arguments : decorator : a decorator callable Returns : a decorator callable","title":"decorator_with_optional_params"},{"location":"aea/api/helpers/base/#delete_directory_contents","text":"delete_directory_contents ( directory : Path ) -> None Delete the content of a directory, without deleting it.","title":"delete_directory_contents"},{"location":"aea/api/helpers/base/#prepend_if_not_absolute","text":"prepend_if_not_absolute ( path : PathLike , prefix : PathLike ) -> PathLike Prepend a path with a prefix, but only if not absolute Arguments : path : the path to process. prefix : the path prefix. Returns : the same path if absolute, else the prepended path.","title":"prepend_if_not_absolute"},{"location":"aea/api/helpers/constants/","text":"aea.helpers.constants Module with helpers constants.","title":"Constants"},{"location":"aea/api/helpers/constants/#aeahelpersconstants","text":"Module with helpers constants.","title":"aea.helpers.constants"},{"location":"aea/api/helpers/env_vars/","text":"aea.helpers.env _ vars Implementation of the environment variables support. is _ env _ variable is_env_variable ( value : Any ) -> bool Check is variable string with env variable pattern. replace _ with _ env _ var replace_with_env_var ( value : str , env_variables : dict , default_value : Any = NotSet ) -> JSON_TYPES Replace env var with value. apply _ env _ variables apply_env_variables ( data : Union [ Dict , List [ Dict ]], env_variables : Mapping [ str , Any ], default_value : Any = NotSet ) -> JSON_TYPES Create new resulting dict with env variables applied. convert _ value _ str _ to _ type convert_value_str_to_type ( value : str , type_str : str ) -> JSON_TYPES Convert value by type name to native python type.","title":"Env Vars"},{"location":"aea/api/helpers/env_vars/#aeahelpersenv_vars","text":"Implementation of the environment variables support.","title":"aea.helpers.env_vars"},{"location":"aea/api/helpers/env_vars/#is_env_variable","text":"is_env_variable ( value : Any ) -> bool Check is variable string with env variable pattern.","title":"is_env_variable"},{"location":"aea/api/helpers/env_vars/#replace_with_env_var","text":"replace_with_env_var ( value : str , env_variables : dict , default_value : Any = NotSet ) -> JSON_TYPES Replace env var with value.","title":"replace_with_env_var"},{"location":"aea/api/helpers/env_vars/#apply_env_variables","text":"apply_env_variables ( data : Union [ Dict , List [ Dict ]], env_variables : Mapping [ str , Any ], default_value : Any = NotSet ) -> JSON_TYPES Create new resulting dict with env variables applied.","title":"apply_env_variables"},{"location":"aea/api/helpers/env_vars/#convert_value_str_to_type","text":"convert_value_str_to_type ( value : str , type_str : str ) -> JSON_TYPES Convert value by type name to native python type.","title":"convert_value_str_to_type"},{"location":"aea/api/helpers/exception_policy/","text":"aea.helpers.exception _ policy This module contains enum of aea exception policies. ExceptionPolicyEnum Objects class ExceptionPolicyEnum ( Enum ) AEA Exception policies.","title":"Exception Policy"},{"location":"aea/api/helpers/exception_policy/#aeahelpersexception_policy","text":"This module contains enum of aea exception policies.","title":"aea.helpers.exception_policy"},{"location":"aea/api/helpers/exception_policy/#exceptionpolicyenum-objects","text":"class ExceptionPolicyEnum ( Enum ) AEA Exception policies.","title":"ExceptionPolicyEnum Objects"},{"location":"aea/api/helpers/exec_timeout/","text":"aea.helpers.exec _ timeout Python code execution time limit tools. TimeoutResult Objects class TimeoutResult () Result of ExecTimeout context manager. __ init __ | __init__ () -> None Init. set _ cancelled _ by _ timeout | set_cancelled_by_timeout () -> None Set code was terminated cause timeout. is _ cancelled _ by _ timeout | is_cancelled_by_timeout () -> bool Return True if code was terminated by ExecTimeout cause timeout. Returns : bool TimeoutException Objects class TimeoutException ( BaseException ) TimeoutException raised by ExecTimeout context managers in thread with limited execution time. Used internally, does not propagated outside of context manager BaseExecTimeout Objects class BaseExecTimeout ( ABC ) Base class for implementing context managers to limit python code execution time. exception_class - is exception type to raise in code controlled in case of timeout. __ init __ | __init__ ( timeout : float = 0.0 ) -> None Init. Arguments : timeout : number of seconds to execute code before interruption __ enter __ | __enter__ () -> TimeoutResult Enter context manager. Returns : TimeoutResult __ exit __ | __exit__ ( exc_type : Type [ Exception ], exc_val : Exception , exc_tb : TracebackType ) -> None Exit context manager. Arguments : exc_type : the exception type exc_val : the exception exc_tb : the traceback ExecTimeoutSigAlarm Objects class ExecTimeoutSigAlarm ( BaseExecTimeout ) ExecTimeout context manager implementation using signals and SIGALARM. Does not support threads, have to be used only in main thread. ExecTimeoutThreadGuard Objects class ExecTimeoutThreadGuard ( BaseExecTimeout ) ExecTimeout context manager implementation using threads and PyThreadState_SetAsyncExc. Support threads. Requires supervisor thread start/stop to control execution time control. Possible will be not accurate in case of long c functions used inside code controlled. __ init __ | __init__ ( timeout : float = 0.0 ) -> None Init ExecTimeoutThreadGuard variables. Arguments : timeout : number of seconds to execute code before interruption start | @classmethod | start ( cls ) -> None Start supervisor thread to check timeouts. Supervisor starts once but number of start counted. stop | @classmethod | stop ( cls , force : bool = False ) -> None Stop supervisor thread. Actual stop performed on force == True or if number of stops == number of starts Arguments : force : force stop regardless number of start.","title":"Exec Timeout"},{"location":"aea/api/helpers/exec_timeout/#aeahelpersexec_timeout","text":"Python code execution time limit tools.","title":"aea.helpers.exec_timeout"},{"location":"aea/api/helpers/exec_timeout/#timeoutresult-objects","text":"class TimeoutResult () Result of ExecTimeout context manager.","title":"TimeoutResult Objects"},{"location":"aea/api/helpers/exec_timeout/#__init__","text":"| __init__ () -> None Init.","title":"__init__"},{"location":"aea/api/helpers/exec_timeout/#set_cancelled_by_timeout","text":"| set_cancelled_by_timeout () -> None Set code was terminated cause timeout.","title":"set_cancelled_by_timeout"},{"location":"aea/api/helpers/exec_timeout/#is_cancelled_by_timeout","text":"| is_cancelled_by_timeout () -> bool Return True if code was terminated by ExecTimeout cause timeout. Returns : bool","title":"is_cancelled_by_timeout"},{"location":"aea/api/helpers/exec_timeout/#timeoutexception-objects","text":"class TimeoutException ( BaseException ) TimeoutException raised by ExecTimeout context managers in thread with limited execution time. Used internally, does not propagated outside of context manager","title":"TimeoutException Objects"},{"location":"aea/api/helpers/exec_timeout/#baseexectimeout-objects","text":"class BaseExecTimeout ( ABC ) Base class for implementing context managers to limit python code execution time. exception_class - is exception type to raise in code controlled in case of timeout.","title":"BaseExecTimeout Objects"},{"location":"aea/api/helpers/exec_timeout/#__init___1","text":"| __init__ ( timeout : float = 0.0 ) -> None Init. Arguments : timeout : number of seconds to execute code before interruption","title":"__init__"},{"location":"aea/api/helpers/exec_timeout/#__enter__","text":"| __enter__ () -> TimeoutResult Enter context manager. Returns : TimeoutResult","title":"__enter__"},{"location":"aea/api/helpers/exec_timeout/#__exit__","text":"| __exit__ ( exc_type : Type [ Exception ], exc_val : Exception , exc_tb : TracebackType ) -> None Exit context manager. Arguments : exc_type : the exception type exc_val : the exception exc_tb : the traceback","title":"__exit__"},{"location":"aea/api/helpers/exec_timeout/#exectimeoutsigalarm-objects","text":"class ExecTimeoutSigAlarm ( BaseExecTimeout ) ExecTimeout context manager implementation using signals and SIGALARM. Does not support threads, have to be used only in main thread.","title":"ExecTimeoutSigAlarm Objects"},{"location":"aea/api/helpers/exec_timeout/#exectimeoutthreadguard-objects","text":"class ExecTimeoutThreadGuard ( BaseExecTimeout ) ExecTimeout context manager implementation using threads and PyThreadState_SetAsyncExc. Support threads. Requires supervisor thread start/stop to control execution time control. Possible will be not accurate in case of long c functions used inside code controlled.","title":"ExecTimeoutThreadGuard Objects"},{"location":"aea/api/helpers/exec_timeout/#__init___2","text":"| __init__ ( timeout : float = 0.0 ) -> None Init ExecTimeoutThreadGuard variables. Arguments : timeout : number of seconds to execute code before interruption","title":"__init__"},{"location":"aea/api/helpers/exec_timeout/#start","text":"| @classmethod | start ( cls ) -> None Start supervisor thread to check timeouts. Supervisor starts once but number of start counted.","title":"start"},{"location":"aea/api/helpers/exec_timeout/#stop","text":"| @classmethod | stop ( cls , force : bool = False ) -> None Stop supervisor thread. Actual stop performed on force == True or if number of stops == number of starts Arguments : force : force stop regardless number of start.","title":"stop"},{"location":"aea/api/helpers/file_io/","text":"aea.helpers.file _ io Read to and write from file with envelopes. lock _ file @contextmanager lock_file ( file_descriptor : IO [ bytes ], logger : Logger = _default_logger ) -> Generator Lock file in context manager. Arguments : file_descriptor : file descriptor of file to lock. logger : the logger. :yield: generator write _ envelope write_envelope ( envelope : Envelope , file_pointer : IO [ bytes ], separator : bytes = SEPARATOR , logger : Logger = _default_logger ) -> None Write envelope to file. write _ with _ lock write_with_lock ( file_pointer : IO [ bytes ], data : Union [ bytes ], logger : Logger = _default_logger ) -> None Write bytes to file protected with file lock. envelope _ from _ bytes envelope_from_bytes ( bytes_ : bytes , separator : bytes = SEPARATOR , logger : Logger = _default_logger ) -> Optional [ Envelope ] Decode bytes to get the envelope. Arguments : bytes_ : the encoded envelope separator : the separator used logger : the logger Returns : Envelope","title":"File IO"},{"location":"aea/api/helpers/file_io/#aeahelpersfile_io","text":"Read to and write from file with envelopes.","title":"aea.helpers.file_io"},{"location":"aea/api/helpers/file_io/#lock_file","text":"@contextmanager lock_file ( file_descriptor : IO [ bytes ], logger : Logger = _default_logger ) -> Generator Lock file in context manager. Arguments : file_descriptor : file descriptor of file to lock. logger : the logger. :yield: generator","title":"lock_file"},{"location":"aea/api/helpers/file_io/#write_envelope","text":"write_envelope ( envelope : Envelope , file_pointer : IO [ bytes ], separator : bytes = SEPARATOR , logger : Logger = _default_logger ) -> None Write envelope to file.","title":"write_envelope"},{"location":"aea/api/helpers/file_io/#write_with_lock","text":"write_with_lock ( file_pointer : IO [ bytes ], data : Union [ bytes ], logger : Logger = _default_logger ) -> None Write bytes to file protected with file lock.","title":"write_with_lock"},{"location":"aea/api/helpers/file_io/#envelope_from_bytes","text":"envelope_from_bytes ( bytes_ : bytes , separator : bytes = SEPARATOR , logger : Logger = _default_logger ) -> Optional [ Envelope ] Decode bytes to get the envelope. Arguments : bytes_ : the encoded envelope separator : the separator used logger : the logger Returns : Envelope","title":"envelope_from_bytes"},{"location":"aea/api/helpers/file_lock/","text":"aea.helpers.file _ lock Patch of 'fnctl' to make it compatible with Windows.","title":"File Lock"},{"location":"aea/api/helpers/file_lock/#aeahelpersfile_lock","text":"Patch of 'fnctl' to make it compatible with Windows.","title":"aea.helpers.file_lock"},{"location":"aea/api/helpers/http_requests/","text":"aea.helpers.http _ requests Wrapper over requests library. add _ default _ timeout add_default_timeout ( fn : Callable , timeout : float ) -> Callable Add default timeout for requests methods.","title":"HttpRequests"},{"location":"aea/api/helpers/http_requests/#aeahelpershttp_requests","text":"Wrapper over requests library.","title":"aea.helpers.http_requests"},{"location":"aea/api/helpers/http_requests/#add_default_timeout","text":"add_default_timeout ( fn : Callable , timeout : float ) -> Callable Add default timeout for requests methods.","title":"add_default_timeout"},{"location":"aea/api/helpers/install_dependency/","text":"aea.helpers.install _ dependency Helper to install python dependencies. install _ dependency install_dependency ( dependency_name : str , dependency : Dependency , logger : Logger , install_timeout : float = 300 ) -> None Install python dependency to the current python environment. Arguments : dependency_name : name of the python package dependency : Dependency specification logger : the logger install_timeout : timeout to wait pip to install install _ dependencies install_dependencies ( dependencies : List [ Dependency ], logger : Logger , install_timeout : float = 300 ) -> None Install python dependencies to the current python environment. Arguments : dependencies : dict of dependency name and specification logger : the logger install_timeout : timeout to wait pip to install call _ pip call_pip ( pip_args : List [ str ], timeout : float = 300 , retry : bool = False ) -> None Run pip install command. Arguments : pip_args : list strings of the command timeout : timeout to wait pip to install retry : bool, try one more time if command failed run _ install _ subprocess run_install_subprocess ( install_command : List [ str ], install_timeout : float = 300 ) -> int Try executing install command. Arguments : install_command : list strings of the command install_timeout : timeout to wait pip to install Returns : the return code of the subprocess","title":"Install Dependency"},{"location":"aea/api/helpers/install_dependency/#aeahelpersinstall_dependency","text":"Helper to install python dependencies.","title":"aea.helpers.install_dependency"},{"location":"aea/api/helpers/install_dependency/#install_dependency","text":"install_dependency ( dependency_name : str , dependency : Dependency , logger : Logger , install_timeout : float = 300 ) -> None Install python dependency to the current python environment. Arguments : dependency_name : name of the python package dependency : Dependency specification logger : the logger install_timeout : timeout to wait pip to install","title":"install_dependency"},{"location":"aea/api/helpers/install_dependency/#install_dependencies","text":"install_dependencies ( dependencies : List [ Dependency ], logger : Logger , install_timeout : float = 300 ) -> None Install python dependencies to the current python environment. Arguments : dependencies : dict of dependency name and specification logger : the logger install_timeout : timeout to wait pip to install","title":"install_dependencies"},{"location":"aea/api/helpers/install_dependency/#call_pip","text":"call_pip ( pip_args : List [ str ], timeout : float = 300 , retry : bool = False ) -> None Run pip install command. Arguments : pip_args : list strings of the command timeout : timeout to wait pip to install retry : bool, try one more time if command failed","title":"call_pip"},{"location":"aea/api/helpers/install_dependency/#run_install_subprocess","text":"run_install_subprocess ( install_command : List [ str ], install_timeout : float = 300 ) -> int Try executing install command. Arguments : install_command : list strings of the command install_timeout : timeout to wait pip to install Returns : the return code of the subprocess","title":"run_install_subprocess"},{"location":"aea/api/helpers/io/","text":"aea.helpers.io","title":"IO"},{"location":"aea/api/helpers/io/#aeahelpersio","text":"","title":"aea.helpers.io"},{"location":"aea/api/helpers/logging/","text":"aea.helpers.logging Logging helpers. get _ logger get_logger ( module_path : str , agent_name : str ) -> Logger Get the logger based on a module path and agent name. AgentLoggerAdapter Objects class AgentLoggerAdapter ( LoggerAdapter ) This class is a logger adapter that prepends the agent name to log messages. __ init __ | __init__ ( logger : Logger , agent_name : str ) -> None Initialize the logger adapter. Arguments : logger : the logger. agent_name : the agent name. process | process ( msg : Any , kwargs : MutableMapping [ str , Any ]) -> Tuple [ Any , MutableMapping [ str , Any ]] Prepend the agent name to every log message. WithLogger Objects class WithLogger () Interface to endow subclasses with a logger. __ init __ | __init__ ( logger : Optional [ Logger ] = None , default_logger_name : str = \"aea\" ) -> None Initialize the logger. Arguments : logger : the logger object. default_logger_name : the default logger name, if a logger is not provided. logger | @property | logger () -> Logger Get the component logger. logger | @logger . setter | logger ( logger : Optional [ Logger ]) -> None Set the logger.","title":"Logging"},{"location":"aea/api/helpers/logging/#aeahelperslogging","text":"Logging helpers.","title":"aea.helpers.logging"},{"location":"aea/api/helpers/logging/#get_logger","text":"get_logger ( module_path : str , agent_name : str ) -> Logger Get the logger based on a module path and agent name.","title":"get_logger"},{"location":"aea/api/helpers/logging/#agentloggeradapter-objects","text":"class AgentLoggerAdapter ( LoggerAdapter ) This class is a logger adapter that prepends the agent name to log messages.","title":"AgentLoggerAdapter Objects"},{"location":"aea/api/helpers/logging/#__init__","text":"| __init__ ( logger : Logger , agent_name : str ) -> None Initialize the logger adapter. Arguments : logger : the logger. agent_name : the agent name.","title":"__init__"},{"location":"aea/api/helpers/logging/#process","text":"| process ( msg : Any , kwargs : MutableMapping [ str , Any ]) -> Tuple [ Any , MutableMapping [ str , Any ]] Prepend the agent name to every log message.","title":"process"},{"location":"aea/api/helpers/logging/#withlogger-objects","text":"class WithLogger () Interface to endow subclasses with a logger.","title":"WithLogger Objects"},{"location":"aea/api/helpers/logging/#__init___1","text":"| __init__ ( logger : Optional [ Logger ] = None , default_logger_name : str = \"aea\" ) -> None Initialize the logger. Arguments : logger : the logger object. default_logger_name : the default logger name, if a logger is not provided.","title":"__init__"},{"location":"aea/api/helpers/logging/#logger","text":"| @property | logger () -> Logger Get the component logger.","title":"logger"},{"location":"aea/api/helpers/logging/#logger_1","text":"| @logger . setter | logger ( logger : Optional [ Logger ]) -> None Set the logger.","title":"logger"},{"location":"aea/api/helpers/multiple_executor/","text":"aea.helpers.multiple _ executor This module contains the helpers to run multiple stoppable tasks in different modes: async, threaded, multiprocess . ExecutorExceptionPolicies Objects class ExecutorExceptionPolicies ( Enum ) Runner exception policy modes. AbstractExecutorTask Objects class AbstractExecutorTask ( ABC ) Abstract task class to create Task classes. __ init __ | __init__ () -> None Init task. future | @property | future () -> Optional [ TaskAwaitable ] Return awaitable to get result of task execution. future | @future . setter | future ( future : TaskAwaitable ) -> None Set awaitable to get result of task execution. start | @abstractmethod | start () -> Tuple [ Callable , Sequence [ Any ]] Implement start task function here. stop | @abstractmethod | stop () -> None Implement stop task function here. create _ async _ task | @abstractmethod | create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Create asyncio task for task run in asyncio loop. Arguments : loop : the event loop Returns : task to run in asyncio loop. id | @property | id () -> Any Return task id. failed | @property | failed () -> bool Return was exception failed or not. If it's running it's not failed. Returns : bool AbstractMultiprocessExecutorTask Objects class AbstractMultiprocessExecutorTask ( AbstractExecutorTask ) Task for multiprocess executor. start | @abstractmethod | start () -> Tuple [ Callable , Sequence [ Any ]] Return function and arguments to call within subprocess. create _ async _ task | create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Create asyncio task for task run in asyncio loop. Raise error, cause async mode is not supported, cause this task for multiprocess executor only. Arguments : loop : the event loop Raises : ValueError : async task construction not possible AbstractMultipleExecutor Objects class AbstractMultipleExecutor ( ABC ) Abstract class to create multiple executors classes. __ init __ | __init__ ( tasks : Sequence [ AbstractExecutorTask ], task_fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate ) -> None Init executor. Arguments : tasks : sequence of AbstractExecutorTask instances to run. task_fail_policy : the exception policy of all the tasks is _ running | @property | is_running () -> bool Return running state of the executor. start | start () -> None Start tasks. stop | stop () -> None Stop tasks. num _ failed | @property | num_failed () -> int Return number of failed tasks. failed _ tasks | @property | failed_tasks () -> Sequence [ AbstractExecutorTask ] Return sequence failed tasks. not _ failed _ tasks | @property | not_failed_tasks () -> Sequence [ AbstractExecutorTask ] Return sequence successful tasks. ThreadExecutor Objects class ThreadExecutor ( AbstractMultipleExecutor ) Thread based executor to run multiple agents in threads. ProcessExecutor Objects class ProcessExecutor ( ThreadExecutor ) Subprocess based executor to run multiple agents in threads. AsyncExecutor Objects class AsyncExecutor ( AbstractMultipleExecutor ) Thread based executor to run multiple agents in threads. AbstractMultipleRunner Objects class AbstractMultipleRunner () Abstract multiple runner to create classes to launch tasks with selected mode. __ init __ | __init__ ( mode : str , fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate ) -> None Init with selected executor mode. Arguments : mode : one of supported executor modes fail_policy : one of ExecutorExceptionPolicies to be used with Executor is _ running | @property | is_running () -> bool Return state of the executor. start | start ( threaded : bool = False ) -> None Run agents. Arguments : threaded : run in dedicated thread without blocking current thread. stop | stop ( timeout : Optional [ float ] = None ) -> None Stop agents. Arguments : timeout : timeout in seconds to wait thread stopped, only if started in thread mode. num _ failed | @property | num_failed () -> int Return number of failed tasks. failed | @property | failed () -> Sequence [ Task ] Return sequence failed tasks. not _ failed | @property | not_failed () -> Sequence [ Task ] Return sequence successful tasks. try _ join _ thread | try_join_thread () -> None Try to join thread if running in thread mode.","title":"MultipleExecutor"},{"location":"aea/api/helpers/multiple_executor/#aeahelpersmultiple_executor","text":"This module contains the helpers to run multiple stoppable tasks in different modes: async, threaded, multiprocess .","title":"aea.helpers.multiple_executor"},{"location":"aea/api/helpers/multiple_executor/#executorexceptionpolicies-objects","text":"class ExecutorExceptionPolicies ( Enum ) Runner exception policy modes.","title":"ExecutorExceptionPolicies Objects"},{"location":"aea/api/helpers/multiple_executor/#abstractexecutortask-objects","text":"class AbstractExecutorTask ( ABC ) Abstract task class to create Task classes.","title":"AbstractExecutorTask Objects"},{"location":"aea/api/helpers/multiple_executor/#__init__","text":"| __init__ () -> None Init task.","title":"__init__"},{"location":"aea/api/helpers/multiple_executor/#future","text":"| @property | future () -> Optional [ TaskAwaitable ] Return awaitable to get result of task execution.","title":"future"},{"location":"aea/api/helpers/multiple_executor/#future_1","text":"| @future . setter | future ( future : TaskAwaitable ) -> None Set awaitable to get result of task execution.","title":"future"},{"location":"aea/api/helpers/multiple_executor/#start","text":"| @abstractmethod | start () -> Tuple [ Callable , Sequence [ Any ]] Implement start task function here.","title":"start"},{"location":"aea/api/helpers/multiple_executor/#stop","text":"| @abstractmethod | stop () -> None Implement stop task function here.","title":"stop"},{"location":"aea/api/helpers/multiple_executor/#create_async_task","text":"| @abstractmethod | create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Create asyncio task for task run in asyncio loop. Arguments : loop : the event loop Returns : task to run in asyncio loop.","title":"create_async_task"},{"location":"aea/api/helpers/multiple_executor/#id","text":"| @property | id () -> Any Return task id.","title":"id"},{"location":"aea/api/helpers/multiple_executor/#failed","text":"| @property | failed () -> bool Return was exception failed or not. If it's running it's not failed. Returns : bool","title":"failed"},{"location":"aea/api/helpers/multiple_executor/#abstractmultiprocessexecutortask-objects","text":"class AbstractMultiprocessExecutorTask ( AbstractExecutorTask ) Task for multiprocess executor.","title":"AbstractMultiprocessExecutorTask Objects"},{"location":"aea/api/helpers/multiple_executor/#start_1","text":"| @abstractmethod | start () -> Tuple [ Callable , Sequence [ Any ]] Return function and arguments to call within subprocess.","title":"start"},{"location":"aea/api/helpers/multiple_executor/#create_async_task_1","text":"| create_async_task ( loop : AbstractEventLoop ) -> TaskAwaitable Create asyncio task for task run in asyncio loop. Raise error, cause async mode is not supported, cause this task for multiprocess executor only. Arguments : loop : the event loop Raises : ValueError : async task construction not possible","title":"create_async_task"},{"location":"aea/api/helpers/multiple_executor/#abstractmultipleexecutor-objects","text":"class AbstractMultipleExecutor ( ABC ) Abstract class to create multiple executors classes.","title":"AbstractMultipleExecutor Objects"},{"location":"aea/api/helpers/multiple_executor/#__init___1","text":"| __init__ ( tasks : Sequence [ AbstractExecutorTask ], task_fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate ) -> None Init executor. Arguments : tasks : sequence of AbstractExecutorTask instances to run. task_fail_policy : the exception policy of all the tasks","title":"__init__"},{"location":"aea/api/helpers/multiple_executor/#is_running","text":"| @property | is_running () -> bool Return running state of the executor.","title":"is_running"},{"location":"aea/api/helpers/multiple_executor/#start_2","text":"| start () -> None Start tasks.","title":"start"},{"location":"aea/api/helpers/multiple_executor/#stop_1","text":"| stop () -> None Stop tasks.","title":"stop"},{"location":"aea/api/helpers/multiple_executor/#num_failed","text":"| @property | num_failed () -> int Return number of failed tasks.","title":"num_failed"},{"location":"aea/api/helpers/multiple_executor/#failed_tasks","text":"| @property | failed_tasks () -> Sequence [ AbstractExecutorTask ] Return sequence failed tasks.","title":"failed_tasks"},{"location":"aea/api/helpers/multiple_executor/#not_failed_tasks","text":"| @property | not_failed_tasks () -> Sequence [ AbstractExecutorTask ] Return sequence successful tasks.","title":"not_failed_tasks"},{"location":"aea/api/helpers/multiple_executor/#threadexecutor-objects","text":"class ThreadExecutor ( AbstractMultipleExecutor ) Thread based executor to run multiple agents in threads.","title":"ThreadExecutor Objects"},{"location":"aea/api/helpers/multiple_executor/#processexecutor-objects","text":"class ProcessExecutor ( ThreadExecutor ) Subprocess based executor to run multiple agents in threads.","title":"ProcessExecutor Objects"},{"location":"aea/api/helpers/multiple_executor/#asyncexecutor-objects","text":"class AsyncExecutor ( AbstractMultipleExecutor ) Thread based executor to run multiple agents in threads.","title":"AsyncExecutor Objects"},{"location":"aea/api/helpers/multiple_executor/#abstractmultiplerunner-objects","text":"class AbstractMultipleRunner () Abstract multiple runner to create classes to launch tasks with selected mode.","title":"AbstractMultipleRunner Objects"},{"location":"aea/api/helpers/multiple_executor/#__init___2","text":"| __init__ ( mode : str , fail_policy : ExecutorExceptionPolicies = ExecutorExceptionPolicies . propagate ) -> None Init with selected executor mode. Arguments : mode : one of supported executor modes fail_policy : one of ExecutorExceptionPolicies to be used with Executor","title":"__init__"},{"location":"aea/api/helpers/multiple_executor/#is_running_1","text":"| @property | is_running () -> bool Return state of the executor.","title":"is_running"},{"location":"aea/api/helpers/multiple_executor/#start_3","text":"| start ( threaded : bool = False ) -> None Run agents. Arguments : threaded : run in dedicated thread without blocking current thread.","title":"start"},{"location":"aea/api/helpers/multiple_executor/#stop_2","text":"| stop ( timeout : Optional [ float ] = None ) -> None Stop agents. Arguments : timeout : timeout in seconds to wait thread stopped, only if started in thread mode.","title":"stop"},{"location":"aea/api/helpers/multiple_executor/#num_failed_1","text":"| @property | num_failed () -> int Return number of failed tasks.","title":"num_failed"},{"location":"aea/api/helpers/multiple_executor/#failed_1","text":"| @property | failed () -> Sequence [ Task ] Return sequence failed tasks.","title":"failed"},{"location":"aea/api/helpers/multiple_executor/#not_failed","text":"| @property | not_failed () -> Sequence [ Task ] Return sequence successful tasks.","title":"not_failed"},{"location":"aea/api/helpers/multiple_executor/#try_join_thread","text":"| try_join_thread () -> None Try to join thread if running in thread mode.","title":"try_join_thread"},{"location":"aea/api/helpers/pipe/","text":"aea.helpers.pipe Portable pipe implementation for Linux, MacOS, and Windows. IPCChannelClient Objects class IPCChannelClient ( ABC ) Multi-platform interprocess communication channel for the client side. connect | @abstractmethod | async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to communication channel Arguments : timeout : timeout for other end to connect Returns : connection status write | @abstractmethod | async write ( data : bytes ) -> None Write data bytes to the other end of the channel Will first write the size than the actual data Arguments : data : bytes to write read | @abstractmethod | async read () -> Optional [ bytes ] Read bytes from the other end of the channel Will first read the size than the actual data Returns : read bytes close | @abstractmethod | async close () -> None Close the communication channel. IPCChannel Objects class IPCChannel ( IPCChannelClient ) Multi-platform interprocess communication channel. in _ path | @property | @abstractmethod | in_path () -> str Rendezvous point for incoming communication. Returns : path out _ path | @property | @abstractmethod | out_path () -> str Rendezvous point for outgoing communication. Returns : path PosixNamedPipeProtocol Objects class PosixNamedPipeProtocol () Posix named pipes async wrapper communication protocol. __ init __ | __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize a new posix named pipe. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing data logger : the logger loop : the event loop connect | async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the pipe Arguments : timeout : timeout before failing Returns : connection success write | async write ( data : bytes ) -> None Write to pipe. Arguments : data : bytes to write to pipe read | async read () -> Optional [ bytes ] Read from pipe. Returns : read bytes close | async close () -> None Disconnect pipe. TCPSocketProtocol Objects class TCPSocketProtocol () TCP socket communication protocol. __ init __ | __init__ ( reader : asyncio . StreamReader , writer : asyncio . StreamWriter , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize the tcp socket protocol. Arguments : reader : established asyncio reader writer : established asyncio writer logger : the logger loop : the event loop writer | @property | writer () -> StreamWriter Get a writer associated with protocol. write | async write ( data : bytes ) -> None Write to socket. Arguments : data : bytes to write read | async read () -> Optional [ bytes ] Read from socket. Returns : read bytes close | async close () -> None Disconnect socket. TCPSocketChannel Objects class TCPSocketChannel ( IPCChannel ) Interprocess communication channel implementation using tcp sockets. __ init __ | __init__ ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize tcp socket interprocess communication channel. connect | async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Setup communication channel and wait for other end to connect. Arguments : timeout : timeout for the connection to be established Returns : connection status write | async write ( data : bytes ) -> None Write to channel. Arguments : data : bytes to write read | async read () -> Optional [ bytes ] Read from channel. Returns : read bytes close | async close () -> None Disconnect from channel and clean it up. in _ path | @property | in_path () -> str Rendezvous point for incoming communication. out _ path | @property | out_path () -> str Rendezvous point for outgoing communication. PosixNamedPipeChannel Objects class PosixNamedPipeChannel ( IPCChannel ) Interprocess communication channel implementation using Posix named pipes. __ init __ | __init__ ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize posix named pipe interprocess communication channel. connect | async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Setup communication channel and wait for other end to connect. Arguments : timeout : timeout for connection to be established Returns : bool, indicating success write | async write ( data : bytes ) -> None Write to the channel. Arguments : data : data to write to channel read | async read () -> Optional [ bytes ] Read from the channel. Returns : read bytes close | async close () -> None Close the channel and clean it up. in _ path | @property | in_path () -> str Rendezvous point for incoming communication. out _ path | @property | out_path () -> str Rendezvous point for outgoing communication. TCPSocketChannelClient Objects class TCPSocketChannelClient ( IPCChannelClient ) Interprocess communication channel client using tcp sockets. __ init __ | __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize a tcp socket communication channel client. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing data logger : the logger loop : the event loop connect | async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the communication channel. Arguments : timeout : timeout for connection to be established Returns : connection status write | async write ( data : bytes ) -> None Write data to channel. Arguments : data : bytes to write read | async read () -> Optional [ bytes ] Read data from channel. Returns : read bytes close | async close () -> None Disconnect from communication channel. PosixNamedPipeChannelClient Objects class PosixNamedPipeChannelClient ( IPCChannelClient ) Interprocess communication channel client using Posix named pipes. __ init __ | __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize a posix named pipe communication channel client. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing data logger : the logger loop : the event loop connect | async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the communication channel. Arguments : timeout : timeout for connection to be established Returns : connection status write | async write ( data : bytes ) -> None Write data to channel. Arguments : data : bytes to write read | async read () -> Optional [ bytes ] Read data from channel. Returns : read bytes close | async close () -> None Disconnect from communication channel. make _ ipc _ channel make_ipc_channel ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> IPCChannel Build a portable bidirectional InterProcess Communication channel Arguments : logger : the logger loop : the loop Returns : IPCChannel make _ ipc _ channel _ client make_ipc_channel_client ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> IPCChannelClient Build a portable bidirectional InterProcess Communication client channel Arguments : in_path : rendezvous point for incoming communication out_path : rendezvous point for outgoing outgoing logger : the logger loop : the loop Returns : IPCChannel","title":"Pipe"},{"location":"aea/api/helpers/pipe/#aeahelperspipe","text":"Portable pipe implementation for Linux, MacOS, and Windows.","title":"aea.helpers.pipe"},{"location":"aea/api/helpers/pipe/#ipcchannelclient-objects","text":"class IPCChannelClient ( ABC ) Multi-platform interprocess communication channel for the client side.","title":"IPCChannelClient Objects"},{"location":"aea/api/helpers/pipe/#connect","text":"| @abstractmethod | async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to communication channel Arguments : timeout : timeout for other end to connect Returns : connection status","title":"connect"},{"location":"aea/api/helpers/pipe/#write","text":"| @abstractmethod | async write ( data : bytes ) -> None Write data bytes to the other end of the channel Will first write the size than the actual data Arguments : data : bytes to write","title":"write"},{"location":"aea/api/helpers/pipe/#read","text":"| @abstractmethod | async read () -> Optional [ bytes ] Read bytes from the other end of the channel Will first read the size than the actual data Returns : read bytes","title":"read"},{"location":"aea/api/helpers/pipe/#close","text":"| @abstractmethod | async close () -> None Close the communication channel.","title":"close"},{"location":"aea/api/helpers/pipe/#ipcchannel-objects","text":"class IPCChannel ( IPCChannelClient ) Multi-platform interprocess communication channel.","title":"IPCChannel Objects"},{"location":"aea/api/helpers/pipe/#in_path","text":"| @property | @abstractmethod | in_path () -> str Rendezvous point for incoming communication. Returns : path","title":"in_path"},{"location":"aea/api/helpers/pipe/#out_path","text":"| @property | @abstractmethod | out_path () -> str Rendezvous point for outgoing communication. Returns : path","title":"out_path"},{"location":"aea/api/helpers/pipe/#posixnamedpipeprotocol-objects","text":"class PosixNamedPipeProtocol () Posix named pipes async wrapper communication protocol.","title":"PosixNamedPipeProtocol Objects"},{"location":"aea/api/helpers/pipe/#__init__","text":"| __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize a new posix named pipe. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing data logger : the logger loop : the event loop","title":"__init__"},{"location":"aea/api/helpers/pipe/#connect_1","text":"| async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the pipe Arguments : timeout : timeout before failing Returns : connection success","title":"connect"},{"location":"aea/api/helpers/pipe/#write_1","text":"| async write ( data : bytes ) -> None Write to pipe. Arguments : data : bytes to write to pipe","title":"write"},{"location":"aea/api/helpers/pipe/#read_1","text":"| async read () -> Optional [ bytes ] Read from pipe. Returns : read bytes","title":"read"},{"location":"aea/api/helpers/pipe/#close_1","text":"| async close () -> None Disconnect pipe.","title":"close"},{"location":"aea/api/helpers/pipe/#tcpsocketprotocol-objects","text":"class TCPSocketProtocol () TCP socket communication protocol.","title":"TCPSocketProtocol Objects"},{"location":"aea/api/helpers/pipe/#__init___1","text":"| __init__ ( reader : asyncio . StreamReader , writer : asyncio . StreamWriter , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize the tcp socket protocol. Arguments : reader : established asyncio reader writer : established asyncio writer logger : the logger loop : the event loop","title":"__init__"},{"location":"aea/api/helpers/pipe/#writer","text":"| @property | writer () -> StreamWriter Get a writer associated with protocol.","title":"writer"},{"location":"aea/api/helpers/pipe/#write_2","text":"| async write ( data : bytes ) -> None Write to socket. Arguments : data : bytes to write","title":"write"},{"location":"aea/api/helpers/pipe/#read_2","text":"| async read () -> Optional [ bytes ] Read from socket. Returns : read bytes","title":"read"},{"location":"aea/api/helpers/pipe/#close_2","text":"| async close () -> None Disconnect socket.","title":"close"},{"location":"aea/api/helpers/pipe/#tcpsocketchannel-objects","text":"class TCPSocketChannel ( IPCChannel ) Interprocess communication channel implementation using tcp sockets.","title":"TCPSocketChannel Objects"},{"location":"aea/api/helpers/pipe/#__init___2","text":"| __init__ ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize tcp socket interprocess communication channel.","title":"__init__"},{"location":"aea/api/helpers/pipe/#connect_2","text":"| async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Setup communication channel and wait for other end to connect. Arguments : timeout : timeout for the connection to be established Returns : connection status","title":"connect"},{"location":"aea/api/helpers/pipe/#write_3","text":"| async write ( data : bytes ) -> None Write to channel. Arguments : data : bytes to write","title":"write"},{"location":"aea/api/helpers/pipe/#read_3","text":"| async read () -> Optional [ bytes ] Read from channel. Returns : read bytes","title":"read"},{"location":"aea/api/helpers/pipe/#close_3","text":"| async close () -> None Disconnect from channel and clean it up.","title":"close"},{"location":"aea/api/helpers/pipe/#in_path_1","text":"| @property | in_path () -> str Rendezvous point for incoming communication.","title":"in_path"},{"location":"aea/api/helpers/pipe/#out_path_1","text":"| @property | out_path () -> str Rendezvous point for outgoing communication.","title":"out_path"},{"location":"aea/api/helpers/pipe/#posixnamedpipechannel-objects","text":"class PosixNamedPipeChannel ( IPCChannel ) Interprocess communication channel implementation using Posix named pipes.","title":"PosixNamedPipeChannel Objects"},{"location":"aea/api/helpers/pipe/#__init___3","text":"| __init__ ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize posix named pipe interprocess communication channel.","title":"__init__"},{"location":"aea/api/helpers/pipe/#connect_3","text":"| async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Setup communication channel and wait for other end to connect. Arguments : timeout : timeout for connection to be established Returns : bool, indicating success","title":"connect"},{"location":"aea/api/helpers/pipe/#write_4","text":"| async write ( data : bytes ) -> None Write to the channel. Arguments : data : data to write to channel","title":"write"},{"location":"aea/api/helpers/pipe/#read_4","text":"| async read () -> Optional [ bytes ] Read from the channel. Returns : read bytes","title":"read"},{"location":"aea/api/helpers/pipe/#close_4","text":"| async close () -> None Close the channel and clean it up.","title":"close"},{"location":"aea/api/helpers/pipe/#in_path_2","text":"| @property | in_path () -> str Rendezvous point for incoming communication.","title":"in_path"},{"location":"aea/api/helpers/pipe/#out_path_2","text":"| @property | out_path () -> str Rendezvous point for outgoing communication.","title":"out_path"},{"location":"aea/api/helpers/pipe/#tcpsocketchannelclient-objects","text":"class TCPSocketChannelClient ( IPCChannelClient ) Interprocess communication channel client using tcp sockets.","title":"TCPSocketChannelClient Objects"},{"location":"aea/api/helpers/pipe/#__init___4","text":"| __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize a tcp socket communication channel client. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing data logger : the logger loop : the event loop","title":"__init__"},{"location":"aea/api/helpers/pipe/#connect_4","text":"| async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the communication channel. Arguments : timeout : timeout for connection to be established Returns : connection status","title":"connect"},{"location":"aea/api/helpers/pipe/#write_5","text":"| async write ( data : bytes ) -> None Write data to channel. Arguments : data : bytes to write","title":"write"},{"location":"aea/api/helpers/pipe/#read_5","text":"| async read () -> Optional [ bytes ] Read data from channel. Returns : read bytes","title":"read"},{"location":"aea/api/helpers/pipe/#close_5","text":"| async close () -> None Disconnect from communication channel.","title":"close"},{"location":"aea/api/helpers/pipe/#posixnamedpipechannelclient-objects","text":"class PosixNamedPipeChannelClient ( IPCChannelClient ) Interprocess communication channel client using Posix named pipes.","title":"PosixNamedPipeChannelClient Objects"},{"location":"aea/api/helpers/pipe/#__init___5","text":"| __init__ ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> None Initialize a posix named pipe communication channel client. Arguments : in_path : rendezvous point for incoming data out_path : rendezvous point for outgoing data logger : the logger loop : the event loop","title":"__init__"},{"location":"aea/api/helpers/pipe/#connect_5","text":"| async connect ( timeout : float = PIPE_CONN_TIMEOUT ) -> bool Connect to the other end of the communication channel. Arguments : timeout : timeout for connection to be established Returns : connection status","title":"connect"},{"location":"aea/api/helpers/pipe/#write_6","text":"| async write ( data : bytes ) -> None Write data to channel. Arguments : data : bytes to write","title":"write"},{"location":"aea/api/helpers/pipe/#read_6","text":"| async read () -> Optional [ bytes ] Read data from channel. Returns : read bytes","title":"read"},{"location":"aea/api/helpers/pipe/#close_6","text":"| async close () -> None Disconnect from communication channel.","title":"close"},{"location":"aea/api/helpers/pipe/#make_ipc_channel","text":"make_ipc_channel ( logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> IPCChannel Build a portable bidirectional InterProcess Communication channel Arguments : logger : the logger loop : the loop Returns : IPCChannel","title":"make_ipc_channel"},{"location":"aea/api/helpers/pipe/#make_ipc_channel_client","text":"make_ipc_channel_client ( in_path : str , out_path : str , logger : logging . Logger = _default_logger , loop : Optional [ AbstractEventLoop ] = None ) -> IPCChannelClient Build a portable bidirectional InterProcess Communication client channel Arguments : in_path : rendezvous point for incoming communication out_path : rendezvous point for outgoing outgoing logger : the logger loop : the loop Returns : IPCChannel","title":"make_ipc_channel_client"},{"location":"aea/api/helpers/profiling/","text":"aea.helpers.profiling Implementation of background profiling daemon. Profiling Objects class Profiling ( Runnable ) Profiling service. __ init __ | __init__ ( period : int = 0 , objects_instances_to_count : List [ Type ] = None , objects_created_to_count : List [ Type ] = None , output_function : Callable [[ str ], None ] = lambda x : print ( x , flush = True )) -> None Init profiler. Arguments : period : delay between profiling output in seconds. objects_instances_to_count : object to count objects_created_to_count : object created to count output_function : function to display output, one str argument. set _ counters | set_counters () -> None Modify obj. new to count objects created created. run | async run () -> None Run profiling. output _ profile _ data | output_profile_data () -> None Render profiling data and call output_function. get _ profile _ data | get_profile_data () -> Dict Get profiling data dict. get _ objects _ instances | get_objects_instances () -> Dict Return dict with counted object instances present now. get _ objecst _ created | get_objecst_created () -> Dict Return dict with counted object instances created.","title":"Profiling"},{"location":"aea/api/helpers/profiling/#aeahelpersprofiling","text":"Implementation of background profiling daemon.","title":"aea.helpers.profiling"},{"location":"aea/api/helpers/profiling/#profiling-objects","text":"class Profiling ( Runnable ) Profiling service.","title":"Profiling Objects"},{"location":"aea/api/helpers/profiling/#__init__","text":"| __init__ ( period : int = 0 , objects_instances_to_count : List [ Type ] = None , objects_created_to_count : List [ Type ] = None , output_function : Callable [[ str ], None ] = lambda x : print ( x , flush = True )) -> None Init profiler. Arguments : period : delay between profiling output in seconds. objects_instances_to_count : object to count objects_created_to_count : object created to count output_function : function to display output, one str argument.","title":"__init__"},{"location":"aea/api/helpers/profiling/#set_counters","text":"| set_counters () -> None Modify obj. new to count objects created created.","title":"set_counters"},{"location":"aea/api/helpers/profiling/#run","text":"| async run () -> None Run profiling.","title":"run"},{"location":"aea/api/helpers/profiling/#output_profile_data","text":"| output_profile_data () -> None Render profiling data and call output_function.","title":"output_profile_data"},{"location":"aea/api/helpers/profiling/#get_profile_data","text":"| get_profile_data () -> Dict Get profiling data dict.","title":"get_profile_data"},{"location":"aea/api/helpers/profiling/#get_objects_instances","text":"| get_objects_instances () -> Dict Return dict with counted object instances present now.","title":"get_objects_instances"},{"location":"aea/api/helpers/profiling/#get_objecst_created","text":"| get_objecst_created () -> Dict Return dict with counted object instances created.","title":"get_objecst_created"},{"location":"aea/api/helpers/serializers/","text":"aea.helpers.serializers This module contains Serializers that can be used for custom types. DictProtobufStructSerializer Objects class DictProtobufStructSerializer () Serialize python dictionaries of type DictType = Dict[str, ValueType] recursively conserving their dynamic type, using google.protobuf.Struct ValueType = PrimitiveType | DictType | List[ValueType]] PrimitiveType = bool | int | float | str | bytes encode | @classmethod | encode ( cls , dictionary : Dict [ str , Any ]) -> bytes Serialize compatible dictionary to bytes. Copies entire dictionary in the process. Arguments : dictionary : the dictionary to serialize Returns : serialized bytes string decode | @classmethod | decode ( cls , buffer : bytes ) -> Dict [ str , Any ] Deserialize a compatible dictionary","title":"Serializers"},{"location":"aea/api/helpers/serializers/#aeahelpersserializers","text":"This module contains Serializers that can be used for custom types.","title":"aea.helpers.serializers"},{"location":"aea/api/helpers/serializers/#dictprotobufstructserializer-objects","text":"class DictProtobufStructSerializer () Serialize python dictionaries of type DictType = Dict[str, ValueType] recursively conserving their dynamic type, using google.protobuf.Struct ValueType = PrimitiveType | DictType | List[ValueType]] PrimitiveType = bool | int | float | str | bytes","title":"DictProtobufStructSerializer Objects"},{"location":"aea/api/helpers/serializers/#encode","text":"| @classmethod | encode ( cls , dictionary : Dict [ str , Any ]) -> bytes Serialize compatible dictionary to bytes. Copies entire dictionary in the process. Arguments : dictionary : the dictionary to serialize Returns : serialized bytes string","title":"encode"},{"location":"aea/api/helpers/serializers/#decode","text":"| @classmethod | decode ( cls , buffer : bytes ) -> Dict [ str , Any ] Deserialize a compatible dictionary","title":"decode"},{"location":"aea/api/helpers/sym_link/","text":"aea.helpers.sym _ link Sym link implementation for Linux, MacOS, and Windows. make _ symlink make_symlink ( link_name : str , target : str ) -> None Make a symbolic link, cross platform. Arguments : link_name : the link name. target : the target. cd @contextlib . contextmanager cd ( path : Path ) -> Generator Change directory with context manager. create _ symlink create_symlink ( link_path : Path , target_path : Path , root_path : Path ) -> int Change directory and call the cross-platform script. The working directory must be the parent of the symbolic link name when executing 'create_symlink_crossplatform.sh'. Hence, we need to translate target_path into the relative path from the symbolic link directory to the target directory. So: 1) from link_path, extract the number of jumps to the parent directory in order to reach the repository root directory, and chain many \"../\" paths. 2) from target_path, compute the relative path to the root 3) relative_target_path is just the concatenation of the results from step (1) and (2). For instance, given - link_path: './directory_1//symbolic_link - target_path: './directory_2/target_path we want to compute: - link_path: 'symbolic_link' (just the last bit) - relative_target_path: '../../directory_1/target_path' The resulting command on UNIX systems will be: cd directory_1 && ln -s ../../directory_1/target_path symbolic_link Arguments : link_path : the source path target_path : the target path root_path : the root path Returns : exit code","title":"Sym Link"},{"location":"aea/api/helpers/sym_link/#aeahelperssym_link","text":"Sym link implementation for Linux, MacOS, and Windows.","title":"aea.helpers.sym_link"},{"location":"aea/api/helpers/sym_link/#make_symlink","text":"make_symlink ( link_name : str , target : str ) -> None Make a symbolic link, cross platform. Arguments : link_name : the link name. target : the target.","title":"make_symlink"},{"location":"aea/api/helpers/sym_link/#cd","text":"@contextlib . contextmanager cd ( path : Path ) -> Generator Change directory with context manager.","title":"cd"},{"location":"aea/api/helpers/sym_link/#create_symlink","text":"create_symlink ( link_path : Path , target_path : Path , root_path : Path ) -> int Change directory and call the cross-platform script. The working directory must be the parent of the symbolic link name when executing 'create_symlink_crossplatform.sh'. Hence, we need to translate target_path into the relative path from the symbolic link directory to the target directory. So: 1) from link_path, extract the number of jumps to the parent directory in order to reach the repository root directory, and chain many \"../\" paths. 2) from target_path, compute the relative path to the root 3) relative_target_path is just the concatenation of the results from step (1) and (2). For instance, given - link_path: './directory_1//symbolic_link - target_path: './directory_2/target_path we want to compute: - link_path: 'symbolic_link' (just the last bit) - relative_target_path: '../../directory_1/target_path' The resulting command on UNIX systems will be: cd directory_1 && ln -s ../../directory_1/target_path symbolic_link Arguments : link_path : the source path target_path : the target path root_path : the root path Returns : exit code","title":"create_symlink"},{"location":"aea/api/helpers/win32/","text":"aea.helpers.win32 Helpers for Windows. enable _ ctrl _ c _ support enable_ctrl_c_support () -> None Enable ctrl+c support for aea.cli command to be tested on windows platform.","title":"Win32"},{"location":"aea/api/helpers/win32/#aeahelperswin32","text":"Helpers for Windows.","title":"aea.helpers.win32"},{"location":"aea/api/helpers/win32/#enable_ctrl_c_support","text":"enable_ctrl_c_support () -> None Enable ctrl+c support for aea.cli command to be tested on windows platform.","title":"enable_ctrl_c_support"},{"location":"aea/api/helpers/yaml_utils/","text":"aea.helpers.yaml _ utils Helper functions related to YAML loading/dumping. _ AEAYamlLoader Objects class _AEAYamlLoader ( yaml . SafeLoader ) Custom yaml.SafeLoader for the AEA framework. It extends the default SafeLoader in two ways: - loads YAML configurations while remembering the order of the fields ; - resolves the environment variables at loading time. This class is for internal usage only; please use the public functions of the module 'yaml_load' and 'yaml_load_all'. __ init __ | __init__ ( * args : Any , ** kwargs : Any ) -> None Initialize the AEAYamlLoader. It adds a YAML Loader constructor to use 'OderedDict' to load the files. Arguments : args : the positional arguments. kwargs : the keyword arguments. _ AEAYamlDumper Objects class _AEAYamlDumper ( yaml . SafeDumper ) Custom yaml.SafeDumper for the AEA framework. It extends the default SafeDumper so to dump YAML configurations while following the order of the fields . This class is for internal usage only; please use the public functions of the module 'yaml_dump' and 'yaml_dump_all'. __ init __ | __init__ ( * args : Any , ** kwargs : Any ) -> None Initialize the AEAYamlDumper. It adds a YAML Dumper representer to use 'OderedDict' to dump the files. Arguments : args : the positional arguments. kwargs : the keyword arguments. yaml _ load yaml_load ( stream : TextIO ) -> Dict [ str , Any ] Load a yaml from a file pointer in an ordered way. Arguments : stream : file pointer to the input file. Returns : the dictionary object with the YAML file content. yaml _ load _ all yaml_load_all ( stream : TextIO ) -> List [ Dict [ str , Any ]] Load a multi-paged yaml from a file pointer in an ordered way. Arguments : stream : file pointer to the input file. Returns : the list of dictionary objects with the (multi-paged) YAML file content. yaml _ dump yaml_dump ( data : Dict , stream : Optional [ TextIO ] = None ) -> None Dump YAML data to a yaml file in an ordered way. Arguments : data : the data to write. stream : (optional) the file to write on. yaml _ dump _ all yaml_dump_all ( data : Sequence [ Dict ], stream : Optional [ TextIO ] = None ) -> None Dump YAML data to a yaml file in an ordered way. Arguments : data : the data to write. stream : (optional) the file to write on.","title":"YamlUtils"},{"location":"aea/api/helpers/yaml_utils/#aeahelpersyaml_utils","text":"Helper functions related to YAML loading/dumping.","title":"aea.helpers.yaml_utils"},{"location":"aea/api/helpers/yaml_utils/#_aeayamlloader-objects","text":"class _AEAYamlLoader ( yaml . SafeLoader ) Custom yaml.SafeLoader for the AEA framework. It extends the default SafeLoader in two ways: - loads YAML configurations while remembering the order of the fields ; - resolves the environment variables at loading time. This class is for internal usage only; please use the public functions of the module 'yaml_load' and 'yaml_load_all'.","title":"_AEAYamlLoader Objects"},{"location":"aea/api/helpers/yaml_utils/#__init__","text":"| __init__ ( * args : Any , ** kwargs : Any ) -> None Initialize the AEAYamlLoader. It adds a YAML Loader constructor to use 'OderedDict' to load the files. Arguments : args : the positional arguments. kwargs : the keyword arguments.","title":"__init__"},{"location":"aea/api/helpers/yaml_utils/#_aeayamldumper-objects","text":"class _AEAYamlDumper ( yaml . SafeDumper ) Custom yaml.SafeDumper for the AEA framework. It extends the default SafeDumper so to dump YAML configurations while following the order of the fields . This class is for internal usage only; please use the public functions of the module 'yaml_dump' and 'yaml_dump_all'.","title":"_AEAYamlDumper Objects"},{"location":"aea/api/helpers/yaml_utils/#__init___1","text":"| __init__ ( * args : Any , ** kwargs : Any ) -> None Initialize the AEAYamlDumper. It adds a YAML Dumper representer to use 'OderedDict' to dump the files. Arguments : args : the positional arguments. kwargs : the keyword arguments.","title":"__init__"},{"location":"aea/api/helpers/yaml_utils/#yaml_load","text":"yaml_load ( stream : TextIO ) -> Dict [ str , Any ] Load a yaml from a file pointer in an ordered way. Arguments : stream : file pointer to the input file. Returns : the dictionary object with the YAML file content.","title":"yaml_load"},{"location":"aea/api/helpers/yaml_utils/#yaml_load_all","text":"yaml_load_all ( stream : TextIO ) -> List [ Dict [ str , Any ]] Load a multi-paged yaml from a file pointer in an ordered way. Arguments : stream : file pointer to the input file. Returns : the list of dictionary objects with the (multi-paged) YAML file content.","title":"yaml_load_all"},{"location":"aea/api/helpers/yaml_utils/#yaml_dump","text":"yaml_dump ( data : Dict , stream : Optional [ TextIO ] = None ) -> None Dump YAML data to a yaml file in an ordered way. Arguments : data : the data to write. stream : (optional) the file to write on.","title":"yaml_dump"},{"location":"aea/api/helpers/yaml_utils/#yaml_dump_all","text":"yaml_dump_all ( data : Sequence [ Dict ], stream : Optional [ TextIO ] = None ) -> None Dump YAML data to a yaml file in an ordered way. Arguments : data : the data to write. stream : (optional) the file to write on.","title":"yaml_dump_all"},{"location":"aea/api/helpers/acn/agent_record/","text":"aea.helpers.acn.agent _ record This module contains types and helpers for ACN Proof-of-Representation. AgentRecord Objects class AgentRecord () Agent Proof-of-Representation to representative. __ init __ | __init__ ( address : str , representative_public_key : str , identifier : SimpleIdOrStr , ledger_id : SimpleIdOrStr , not_before : str , not_after : str , message_format : str , signature : str ) -> None Initialize the AgentRecord Arguments : address : agent address representative_public_key : representative's public key identifier : certificate identifier. ledger_id : ledger identifier the request is referring to. not_before : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0. not_after : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0. message_format : message format used for signing signature : proof-of-representation of this AgentRecord address | @property | address () -> str Get agent address public _ key | @property | public_key () -> str Get agent public key representative _ public _ key | @property | representative_public_key () -> str Get agent representative's public key signature | @property | signature () -> str Get record signature message | @property | message () -> bytes Get the message. identifier | @property | identifier () -> SimpleIdOrStr Get the identifier. ledger _ id | @property | ledger_id () -> SimpleIdOrStr Get ledger id. not _ before | @property | not_before () -> str Get the not_before field. not _ after | @property | not_after () -> str Get the not_after field. message _ format | @property | message_format () -> str Get the message format. __ str __ | __str__ () -> str Get string representation. from _ cert _ request | @classmethod | from_cert_request ( cls , cert_request : CertRequest , address : str , representative_public_key : str , data_dir : Optional [ PathLike ] = None ) -> \"AgentRecord\" Get agent record from cert request.","title":"Agent Record"},{"location":"aea/api/helpers/acn/agent_record/#aeahelpersacnagent_record","text":"This module contains types and helpers for ACN Proof-of-Representation.","title":"aea.helpers.acn.agent_record"},{"location":"aea/api/helpers/acn/agent_record/#agentrecord-objects","text":"class AgentRecord () Agent Proof-of-Representation to representative.","title":"AgentRecord Objects"},{"location":"aea/api/helpers/acn/agent_record/#__init__","text":"| __init__ ( address : str , representative_public_key : str , identifier : SimpleIdOrStr , ledger_id : SimpleIdOrStr , not_before : str , not_after : str , message_format : str , signature : str ) -> None Initialize the AgentRecord Arguments : address : agent address representative_public_key : representative's public key identifier : certificate identifier. ledger_id : ledger identifier the request is referring to. not_before : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0. not_after : specify the lower bound for certificate validity. If it is a string, it must follow the format: 'YYYY-MM-DD'. It will be interpreted as timezone UTC-0. message_format : message format used for signing signature : proof-of-representation of this AgentRecord","title":"__init__"},{"location":"aea/api/helpers/acn/agent_record/#address","text":"| @property | address () -> str Get agent address","title":"address"},{"location":"aea/api/helpers/acn/agent_record/#public_key","text":"| @property | public_key () -> str Get agent public key","title":"public_key"},{"location":"aea/api/helpers/acn/agent_record/#representative_public_key","text":"| @property | representative_public_key () -> str Get agent representative's public key","title":"representative_public_key"},{"location":"aea/api/helpers/acn/agent_record/#signature","text":"| @property | signature () -> str Get record signature","title":"signature"},{"location":"aea/api/helpers/acn/agent_record/#message","text":"| @property | message () -> bytes Get the message.","title":"message"},{"location":"aea/api/helpers/acn/agent_record/#identifier","text":"| @property | identifier () -> SimpleIdOrStr Get the identifier.","title":"identifier"},{"location":"aea/api/helpers/acn/agent_record/#ledger_id","text":"| @property | ledger_id () -> SimpleIdOrStr Get ledger id.","title":"ledger_id"},{"location":"aea/api/helpers/acn/agent_record/#not_before","text":"| @property | not_before () -> str Get the not_before field.","title":"not_before"},{"location":"aea/api/helpers/acn/agent_record/#not_after","text":"| @property | not_after () -> str Get the not_after field.","title":"not_after"},{"location":"aea/api/helpers/acn/agent_record/#message_format","text":"| @property | message_format () -> str Get the message format.","title":"message_format"},{"location":"aea/api/helpers/acn/agent_record/#__str__","text":"| __str__ () -> str Get string representation.","title":"__str__"},{"location":"aea/api/helpers/acn/agent_record/#from_cert_request","text":"| @classmethod | from_cert_request ( cls , cert_request : CertRequest , address : str , representative_public_key : str , data_dir : Optional [ PathLike ] = None ) -> \"AgentRecord\" Get agent record from cert request.","title":"from_cert_request"},{"location":"aea/api/helpers/acn/uri/","text":"aea.helpers.acn.uri This module contains types and helpers for libp2p connections Uris. Uri Objects class Uri () Holds a node address in format \"host:port\". __ init __ | __init__ ( uri : Optional [ str ] = None , host : Optional [ str ] = None , port : Optional [ int ] = None ) -> None Initialise Uri. __ str __ | __str__ () -> str Get string representation. __ repr __ | __repr__ () -> str Get object representation. host | @property | host () -> str Get host. port | @property | port () -> int Get port.","title":"URI"},{"location":"aea/api/helpers/acn/uri/#aeahelpersacnuri","text":"This module contains types and helpers for libp2p connections Uris.","title":"aea.helpers.acn.uri"},{"location":"aea/api/helpers/acn/uri/#uri-objects","text":"class Uri () Holds a node address in format \"host:port\".","title":"Uri Objects"},{"location":"aea/api/helpers/acn/uri/#__init__","text":"| __init__ ( uri : Optional [ str ] = None , host : Optional [ str ] = None , port : Optional [ int ] = None ) -> None Initialise Uri.","title":"__init__"},{"location":"aea/api/helpers/acn/uri/#__str__","text":"| __str__ () -> str Get string representation.","title":"__str__"},{"location":"aea/api/helpers/acn/uri/#__repr__","text":"| __repr__ () -> str Get object representation.","title":"__repr__"},{"location":"aea/api/helpers/acn/uri/#host","text":"| @property | host () -> str Get host.","title":"host"},{"location":"aea/api/helpers/acn/uri/#port","text":"| @property | port () -> int Get port.","title":"port"},{"location":"aea/api/helpers/ipfs/base/","text":"aea.helpers.ipfs.base This module contains helper methods and classes for the 'aea' package. chunks chunks ( data : Sized , size : int ) -> Generator Yield successivesize chunks from data. IPFSHashOnly Objects class IPFSHashOnly () A helper class which allows construction of an IPFS hash without interacting with an IPFS daemon. get | get ( file_path : str ) -> str Get the IPFS hash for a single file. Arguments : file_path : the file path Returns : the ipfs hash","title":"Base"},{"location":"aea/api/helpers/ipfs/base/#aeahelpersipfsbase","text":"This module contains helper methods and classes for the 'aea' package.","title":"aea.helpers.ipfs.base"},{"location":"aea/api/helpers/ipfs/base/#chunks","text":"chunks ( data : Sized , size : int ) -> Generator Yield successivesize chunks from data.","title":"chunks"},{"location":"aea/api/helpers/ipfs/base/#ipfshashonly-objects","text":"class IPFSHashOnly () A helper class which allows construction of an IPFS hash without interacting with an IPFS daemon.","title":"IPFSHashOnly Objects"},{"location":"aea/api/helpers/ipfs/base/#get","text":"| get ( file_path : str ) -> str Get the IPFS hash for a single file. Arguments : file_path : the file path Returns : the ipfs hash","title":"get"},{"location":"aea/api/helpers/ipfs/utils/","text":"aea.helpers.ipfs.utils This module contains utility methods for ipfs helpers.","title":"Utils"},{"location":"aea/api/helpers/ipfs/utils/#aeahelpersipfsutils","text":"This module contains utility methods for ipfs helpers.","title":"aea.helpers.ipfs.utils"},{"location":"aea/api/helpers/multiaddr/base/","text":"aea.helpers.multiaddr.base This module contains multiaddress class. MultiAddr Objects class MultiAddr () Protocol Labs' Multiaddress representation of a network address. __ init __ | __init__ ( host : str , port : int , public_key : Optional [ str ] = None , multihash_id : Optional [ str ] = None ) -> None Initialize a multiaddress. Arguments : host : ip host of the address port : port number of the address public_key : hex encoded public key. Must conform to Bitcoin EC encoding standard for Secp256k1 multihash_id : a multihash of the public key compute _ peerid | @staticmethod | compute_peerid ( public_key : str ) -> str Compute the peer id from a public key. In particular, compute the base58 representation of libp2p PeerID from Bitcoin EC encoded Secp256k1 public key. Arguments : public_key : the public key. Returns : the peer id. from _ string | @classmethod | from_string ( cls , maddr : str ) -> \"MultiAddr\" Construct a MultiAddr object from its string format Arguments : maddr : multiaddress string Returns : multiaddress object public _ key | @property | public_key () -> str Get the public key. peer _ id | @property | peer_id () -> str Get the peer id. host | @property | host () -> str Get the peer host. port | @property | port () -> int Get the peer port. format | format () -> str Canonical representation of a multiaddress. __ str __ | __str__ () -> str Default string representation of a multiaddress.","title":"Base"},{"location":"aea/api/helpers/multiaddr/base/#aeahelpersmultiaddrbase","text":"This module contains multiaddress class.","title":"aea.helpers.multiaddr.base"},{"location":"aea/api/helpers/multiaddr/base/#multiaddr-objects","text":"class MultiAddr () Protocol Labs' Multiaddress representation of a network address.","title":"MultiAddr Objects"},{"location":"aea/api/helpers/multiaddr/base/#__init__","text":"| __init__ ( host : str , port : int , public_key : Optional [ str ] = None , multihash_id : Optional [ str ] = None ) -> None Initialize a multiaddress. Arguments : host : ip host of the address port : port number of the address public_key : hex encoded public key. Must conform to Bitcoin EC encoding standard for Secp256k1 multihash_id : a multihash of the public key","title":"__init__"},{"location":"aea/api/helpers/multiaddr/base/#compute_peerid","text":"| @staticmethod | compute_peerid ( public_key : str ) -> str Compute the peer id from a public key. In particular, compute the base58 representation of libp2p PeerID from Bitcoin EC encoded Secp256k1 public key. Arguments : public_key : the public key. Returns : the peer id.","title":"compute_peerid"},{"location":"aea/api/helpers/multiaddr/base/#from_string","text":"| @classmethod | from_string ( cls , maddr : str ) -> \"MultiAddr\" Construct a MultiAddr object from its string format Arguments : maddr : multiaddress string Returns : multiaddress object","title":"from_string"},{"location":"aea/api/helpers/multiaddr/base/#public_key","text":"| @property | public_key () -> str Get the public key.","title":"public_key"},{"location":"aea/api/helpers/multiaddr/base/#peer_id","text":"| @property | peer_id () -> str Get the peer id.","title":"peer_id"},{"location":"aea/api/helpers/multiaddr/base/#host","text":"| @property | host () -> str Get the peer host.","title":"host"},{"location":"aea/api/helpers/multiaddr/base/#port","text":"| @property | port () -> int Get the peer port.","title":"port"},{"location":"aea/api/helpers/multiaddr/base/#format","text":"| format () -> str Canonical representation of a multiaddress.","title":"format"},{"location":"aea/api/helpers/multiaddr/base/#__str__","text":"| __str__ () -> str Default string representation of a multiaddress.","title":"__str__"},{"location":"aea/api/helpers/preference_representations/base/","text":"aea.helpers.preference _ representations.base Preference representation helpers. logarithmic _ utility logarithmic_utility ( utility_params_by_good_id : Dict [ str , float ], quantities_by_good_id : Dict [ str , int ], quantity_shift : int = 100 ) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : utility_params_by_good_id : utility params by good identifier quantities_by_good_id : quantities by good identifier quantity_shift : a non-negative factor to shift the quantities in the utility function (to ensure the natural logarithm can be used on the entire range of quantities) Returns : utility value linear _ utility linear_utility ( exchange_params_by_currency_id : Dict [ str , float ], balance_by_currency_id : Dict [ str , int ]) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : exchange_params_by_currency_id : exchange params by currency balance_by_currency_id : balance by currency Returns : utility value","title":"Base"},{"location":"aea/api/helpers/preference_representations/base/#aeahelperspreference_representationsbase","text":"Preference representation helpers.","title":"aea.helpers.preference_representations.base"},{"location":"aea/api/helpers/preference_representations/base/#logarithmic_utility","text":"logarithmic_utility ( utility_params_by_good_id : Dict [ str , float ], quantities_by_good_id : Dict [ str , int ], quantity_shift : int = 100 ) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : utility_params_by_good_id : utility params by good identifier quantities_by_good_id : quantities by good identifier quantity_shift : a non-negative factor to shift the quantities in the utility function (to ensure the natural logarithm can be used on the entire range of quantities) Returns : utility value","title":"logarithmic_utility"},{"location":"aea/api/helpers/preference_representations/base/#linear_utility","text":"linear_utility ( exchange_params_by_currency_id : Dict [ str , float ], balance_by_currency_id : Dict [ str , int ]) -> float Compute agent's utility given her utility function params and a good bundle. Arguments : exchange_params_by_currency_id : exchange params by currency balance_by_currency_id : balance by currency Returns : utility value","title":"linear_utility"},{"location":"aea/api/helpers/search/generic/","text":"aea.helpers.search.generic This module contains a generic data model. GenericDataModel Objects class GenericDataModel ( DataModel ) Generic data model. __ init __ | __init__ ( data_model_name : str , data_model_attributes : Dict [ str , Any ]) -> None Initialise the dataModel.","title":"Generic"},{"location":"aea/api/helpers/search/generic/#aeahelperssearchgeneric","text":"This module contains a generic data model.","title":"aea.helpers.search.generic"},{"location":"aea/api/helpers/search/generic/#genericdatamodel-objects","text":"class GenericDataModel ( DataModel ) Generic data model.","title":"GenericDataModel Objects"},{"location":"aea/api/helpers/search/generic/#__init__","text":"| __init__ ( data_model_name : str , data_model_attributes : Dict [ str , Any ]) -> None Initialise the dataModel.","title":"__init__"},{"location":"aea/api/helpers/search/models/","text":"aea.helpers.search.models Useful classes for the OEF search. Location Objects class Location () Data structure to represent locations (i.e. a pair of latitude and longitude). __ init __ | __init__ ( latitude : float , longitude : float ) -> None Initialize a location. Arguments : latitude : the latitude of the location. longitude : the longitude of the location. tuple | @property | tuple () -> Tuple [ float , float ] Get the tuple representation of a location. distance | distance ( other : \"Location\" ) -> float Get the distance to another location. Arguments : other : the other location Returns : the distance __ eq __ | __eq__ ( other : Any ) -> bool Compare equality of two locations. __ str __ | __str__ () -> str Get the string representation of the data model. encode | encode () -> models_pb2 . Query . Location Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object decode | @classmethod | decode ( cls , location_pb : Any ) -> \"Location\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : location_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object AttributeInconsistencyException Objects class AttributeInconsistencyException ( Exception ) Raised when the attributes in a Description are inconsistent. Inconsistency is defined when values do not meet their respective schema, or if the values are not of an allowed type. Attribute Objects class Attribute () Implements an attribute for an OEF data model. __ init __ | __init__ ( name : str , type_ : Type [ ATTRIBUTE_TYPES ], is_required : bool , description : str = \"\" ) -> None Initialize an attribute. Arguments : name : the name of the attribute. type_ : the type of the attribute. is_required : whether the attribute is required by the data model. description : an (optional) human-readable description for the attribute. __ eq __ | __eq__ ( other : Any ) -> bool Compare with another object. __ str __ | __str__ () -> str Get the string representation of the data model. encode | encode () -> models_pb2 . Query . Attribute Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object decode | @classmethod | decode ( cls , attribute_pb : models_pb2 . Query . Attribute ) -> \"Attribute\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : attribute_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object DataModel Objects class DataModel () Implements an OEF data model. __ init __ | __init__ ( name : str , attributes : List [ Attribute ], description : str = \"\" ) -> None Initialize a data model. Arguments : name : the name of the data model. attributes : the attributes of the data model. description : the data model description. attributes _ by _ name | @property | attributes_by_name () -> Dict [ str , Attribute ] Get the attributes by name. __ eq __ | __eq__ ( other : Any ) -> bool Compare with another object. __ str __ | __str__ () -> str Get the string representation of the data model. encode | encode () -> models_pb2 . Query . DataModel Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object decode | @classmethod | decode ( cls , data_model_pb : Any ) -> \"DataModel\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : data_model_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object generate _ data _ model generate_data_model ( model_name : str , attribute_values : Mapping [ str , ATTRIBUTE_TYPES ]) -> DataModel Generate a data model that matches the values stored in this description. That is, for each attribute (name, value), generate an Attribute. It is assumed that each attribute is required. Arguments : model_name : the name of the model. attribute_values : the values of each attribute Returns : the schema compliant with the values specified. Description Objects class Description () Implements an OEF description. __ init __ | __init__ ( values : Mapping [ str , ATTRIBUTE_TYPES ], data_model : Optional [ DataModel ] = None , data_model_name : str = \"\" ) -> None Initialize the description object. Arguments : values : the values in the description. data_model : the data model (optional) data_model_name : the data model name if a datamodel is created on the fly. values | @property | values () -> Dict Get the values. __ eq __ | __eq__ ( other : Any ) -> bool Compare with another object. __ iter __ | __iter__ () -> Iterator Create an iterator. __ str __ | __str__ () -> str Get the string representation of the description. encode | @classmethod | encode ( cls , description_pb : Any , description : \"Description\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the description_protobuf_object argument must be matched with the instance of this class in the 'description_object' argument. Arguments : description_pb : the protocol buffer object whose type corresponds with this class. description : an instance of this class to be encoded in the protocol buffer object. decode | @classmethod | decode ( cls , description_pb : Any ) -> \"Description\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'description_protobuf_object' argument. Arguments : description_pb : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'description_protobuf_object' argument. ConstraintTypes Objects class ConstraintTypes ( Enum ) Types of constraint. __ str __ | __str__ () -> str Get the string representation. ConstraintType Objects class ConstraintType () Type of constraint. Used with the Constraint class, this class allows to specify constraint over attributes. Examples : Equal to three equal_3 = ConstraintType(ConstraintTypes.EQUAL, 3) You can also specify a type of constraint by using its string representation, e.g.: equal_3 = ConstraintType(\"==\", 3) not_equal_london = ConstraintType(\"!=\", \"London\") less_than_pi = ConstraintType(\"<\", 3.14) within_range = ConstraintType(\"within\", (-10.0, 10.0)) in_a_set = ConstraintType(\"in\", (1, 2, 3)) not_in_a_set = ConstraintType(\"not_in\", (\"C\", \"Java\", \"Python\")) __ init __ | __init__ ( type_ : Union [ ConstraintTypes , str ], value : Any ) -> None Initialize a constraint type. Arguments : type_ : the type of the constraint. | Either an instance of the ConstraintTypes enum, | or a string representation associated with the type. value : the value that defines the constraint. Raises : AEAEnforceError : if the type of the constraint is not # noqa: DAR402 check _ validity | check_validity () -> bool Check the validity of the input provided. Returns : boolean to indicate validity Raises : AEAEnforceError : if the value is not valid wrt the constraint type. # noqa: DAR402 is _ valid | is_valid ( attribute : Attribute ) -> bool Check if the constraint type is valid wrt a given attribute. A constraint type is valid wrt an attribute if the type of its operand(s) is the same of the attribute type. attribute = Attribute(\"year\", int, True) valid_constraint_type = ConstraintType(ConstraintTypes.GREATER_THAN, 2000) valid_constraint_type.is_valid(attribute) True valid_constraint_type = ConstraintType(ConstraintTypes.WITHIN, (2000, 2001)) valid_constraint_type.is_valid(attribute) True The following constraint is invalid: the year is in a string variable, whereas the attribute is defined over integers. invalid_constraint_type = ConstraintType(ConstraintTypes.GREATER_THAN, \"2000\") invalid_constraint_type.is_valid(attribute) False Arguments : attribute : the data model used to check the validity of the constraint type. Returns : True if the constraint type is valid wrt the attribute, False otherwise. get _ data _ type | get_data_type () -> Type [ ATTRIBUTE_TYPES ] Get the type of the data used to define the constraint type. For instance: c = ConstraintType(ConstraintTypes.EQUAL, 1) c.get_data_type() Returns : data type check | check ( value : ATTRIBUTE_TYPES ) -> bool Check if an attribute value satisfies the constraint. The implementation depends on the constraint type. Arguments : value : the value to check. Returns : True if the value satisfy the constraint, False otherwise. Raises : ValueError : if the constraint type is not recognized. __ eq __ | __eq__ ( other : Any ) -> bool Check equality with another object. __ str __ | __str__ () -> str Get the string representation of the constraint type. encode | encode () -> Optional [ Any ] Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object decode | @classmethod | decode ( cls , constraint_type_pb : Any , category : str ) -> \"ConstraintType\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : constraint_type_pb : the protocol buffer object corresponding with this class. category : the category of the constraint ('relation', 'set', 'range', 'distance). Returns : A new instance of this class matching the protocol buffer object ConstraintExpr Objects class ConstraintExpr ( ABC ) Implementation of the constraint language to query the OEF node. check | @abstractmethod | check ( description : Description ) -> bool Check if a description satisfies the constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise. is _ valid | @abstractmethod | is_valid ( data_model : DataModel ) -> bool Check whether a constraint expression is valid wrt a data model. Specifically, check the following conditions: - If all the attributes referenced by the constraints are correctly associated with the Data Model attributes. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise. check _ validity | check_validity () -> None Check whether a Constraint Expression satisfies some basic requirements. Raises : AEAEnforceError : if the object does not satisfy some requirements. # noqa: DAR402 And Objects class And ( ConstraintExpr ) Implementation of the 'And' constraint expression. __ init __ | __init__ ( constraints : List [ ConstraintExpr ]) -> None Initialize an 'And' expression. Arguments : constraints : the list of constraints expression (in conjunction). check | check ( description : Description ) -> bool Check if a value satisfies the 'And' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise. is _ valid | is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise. check _ validity | check_validity () -> None Check whether the Constraint Expression satisfies some basic requirements. :return None Raises : ValueError : if the object does not satisfy some requirements. __ eq __ | __eq__ ( other : Any ) -> bool Compare with another object. encode | encode () -> models_pb2 . Query . ConstraintExpr . And Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object decode | @classmethod | decode ( cls , and_pb : Any ) -> \"And\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : and_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object Or Objects class Or ( ConstraintExpr ) Implementation of the 'Or' constraint expression. __ init __ | __init__ ( constraints : List [ ConstraintExpr ]) -> None Initialize an 'Or' expression. Arguments : constraints : the list of constraints expressions (in disjunction). check | check ( description : Description ) -> bool Check if a value satisfies the 'Or' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise. is _ valid | is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise. check _ validity | check_validity () -> None Check whether the Constraint Expression satisfies some basic requirements. :return None Raises : ValueError : if the object does not satisfy some requirements. __ eq __ | __eq__ ( other : Any ) -> bool Compare with another object. encode | encode () -> models_pb2 . Query . ConstraintExpr . Or Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object decode | @classmethod | decode ( cls , or_pb : Any ) -> \"Or\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : or_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object Not Objects class Not ( ConstraintExpr ) Implementation of the 'Not' constraint expression. __ init __ | __init__ ( constraint : ConstraintExpr ) -> None Initialize a 'Not' expression. Arguments : constraint : the constraint expression to negate. check | check ( description : Description ) -> bool Check if a value satisfies the 'Not' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise. is _ valid | is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise. __ eq __ | __eq__ ( other : Any ) -> bool Compare with another object. encode | encode () -> models_pb2 . Query . ConstraintExpr . Not Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object decode | @classmethod | decode ( cls , not_pb : Any ) -> \"Not\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : not_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object Constraint Objects class Constraint ( ConstraintExpr ) The atomic component of a constraint expression. __ init __ | __init__ ( attribute_name : str , constraint_type : ConstraintType ) -> None Initialize a constraint. Arguments : attribute_name : the name of the attribute to be constrained. constraint_type : the constraint type. check | check ( description : Description ) -> bool Check if a description satisfies the constraint. The implementation depends on the type of the constraint. Arguments : description : the description to check. Returns : True if the description satisfies the constraint, False otherwise. Examples: >>> attr_author = Attribute(\"author\" , str, True, \"The author of the book.\") >>> attr_year = Attribute(\"year\", int, True, \"The year of publication of the book.\") >>> attr_genre = Attribute(\"genre\", str, True, \"The genre of the book.\") >>> c1 = Constraint(\"author\", ConstraintType(\"==\", \"Stephen King\")) >>> c2 = Constraint(\"year\", ConstraintType(\">\", 1990)) >>> c3 = Constraint(\"genre\", ConstraintType(\"in\", (\"horror\", \"science_fiction\"))) >>> book_1 = Description({\"author\": \"Stephen King\", \"year\": 1991, \"genre\": \"horror\"}) >>> book_2 = Description({\"author\": \"George Orwell\", \"year\": 1948, \"genre\": \"horror\"}) The \"author\" attribute instantiation satisfies the constraint, so the result is True. >>> c1.check(book_1) True Here, the \"author\" does not satisfy the constraints. Hence, the result is False. >>> c1.check(book_2) False In this case, there is a missing field specified by the query, that is \"year\" So the result is False, even in the case it is not required by the schema: >>> c2.check(Description({\"author\": \"Stephen King\"})) False If the type of some attribute of the description is not correct, the result is False. In this case, the field \"year\" has a string instead of an integer: >>> c2.check(Description({\"author\": \"Stephen King\", \"year\": \"1991\"})) False >>> c3.check(Description({\"author\": \"Stephen King\", \"genre\": False})) False is _ valid | is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise. __ eq __ | __eq__ ( other : Any ) -> bool Compare with another object. __ str __ | __str__ () -> str Get the string representation of the constraint. encode | encode () -> models_pb2 . Query . ConstraintExpr . Constraint Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object decode | @classmethod | decode ( cls , constraint_pb : Any ) -> \"Constraint\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : constraint_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object Query Objects class Query () This class lets you build a query for the OEF. __ init __ | __init__ ( constraints : List [ ConstraintExpr ], model : Optional [ DataModel ] = None ) -> None Initialize a query. Arguments : constraints : a list of constraint expressions. model : the data model that the query refers to. check | check ( description : Description ) -> bool Check if a description satisfies the constraints of the query. The constraints are interpreted as conjunction. Arguments : description : the description to check. Returns : True if the description satisfies all the constraints, False otherwise. is _ valid | is_valid ( data_model : Optional [ DataModel ]) -> bool Given a data model, check whether the query is valid for that data model. Arguments : data_model : optional datamodel Returns : True if the query is compliant with the data model, False otherwise. check _ validity | check_validity () -> None Check whether the` object is valid. :return None Raises : ValueError : if the query does not satisfy some sanity requirements. __ eq __ | __eq__ ( other : Any ) -> bool Compare with another object. __ str __ | __str__ () -> str Get the string representation of the constraint. encode | @classmethod | encode ( cls , query_pb : Any , query : \"Query\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the query_protobuf_object argument must be matched with the instance of this class in the 'query_object' argument. Arguments : query_pb : the protocol buffer object wrapping an object that corresponds with this class. query : an instance of this class to be encoded in the protocol buffer object. decode | @classmethod | decode ( cls , query_pb : Any ) -> \"Query\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'query_protobuf_object' argument. Arguments : query_pb : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'query_protobuf_object' argument. haversine haversine ( lat1 : float , lon1 : float , lat2 : float , lon2 : float ) -> float Compute the Haversine distance between two locations (i.e. two pairs of latitude and longitude). Arguments : lat1 : the latitude of the first location. lon1 : the longitude of the first location. lat2 : the latitude of the second location. lon2 : the longitude of the second location. Returns : the Haversine distance.","title":"Models"},{"location":"aea/api/helpers/search/models/#aeahelperssearchmodels","text":"Useful classes for the OEF search.","title":"aea.helpers.search.models"},{"location":"aea/api/helpers/search/models/#location-objects","text":"class Location () Data structure to represent locations (i.e. a pair of latitude and longitude).","title":"Location Objects"},{"location":"aea/api/helpers/search/models/#__init__","text":"| __init__ ( latitude : float , longitude : float ) -> None Initialize a location. Arguments : latitude : the latitude of the location. longitude : the longitude of the location.","title":"__init__"},{"location":"aea/api/helpers/search/models/#tuple","text":"| @property | tuple () -> Tuple [ float , float ] Get the tuple representation of a location.","title":"tuple"},{"location":"aea/api/helpers/search/models/#distance","text":"| distance ( other : \"Location\" ) -> float Get the distance to another location. Arguments : other : the other location Returns : the distance","title":"distance"},{"location":"aea/api/helpers/search/models/#__eq__","text":"| __eq__ ( other : Any ) -> bool Compare equality of two locations.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#__str__","text":"| __str__ () -> str Get the string representation of the data model.","title":"__str__"},{"location":"aea/api/helpers/search/models/#encode","text":"| encode () -> models_pb2 . Query . Location Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object","title":"encode"},{"location":"aea/api/helpers/search/models/#decode","text":"| @classmethod | decode ( cls , location_pb : Any ) -> \"Location\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : location_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object","title":"decode"},{"location":"aea/api/helpers/search/models/#attributeinconsistencyexception-objects","text":"class AttributeInconsistencyException ( Exception ) Raised when the attributes in a Description are inconsistent. Inconsistency is defined when values do not meet their respective schema, or if the values are not of an allowed type.","title":"AttributeInconsistencyException Objects"},{"location":"aea/api/helpers/search/models/#attribute-objects","text":"class Attribute () Implements an attribute for an OEF data model.","title":"Attribute Objects"},{"location":"aea/api/helpers/search/models/#__init___1","text":"| __init__ ( name : str , type_ : Type [ ATTRIBUTE_TYPES ], is_required : bool , description : str = \"\" ) -> None Initialize an attribute. Arguments : name : the name of the attribute. type_ : the type of the attribute. is_required : whether the attribute is required by the data model. description : an (optional) human-readable description for the attribute.","title":"__init__"},{"location":"aea/api/helpers/search/models/#__eq___1","text":"| __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#__str___1","text":"| __str__ () -> str Get the string representation of the data model.","title":"__str__"},{"location":"aea/api/helpers/search/models/#encode_1","text":"| encode () -> models_pb2 . Query . Attribute Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_1","text":"| @classmethod | decode ( cls , attribute_pb : models_pb2 . Query . Attribute ) -> \"Attribute\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : attribute_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object","title":"decode"},{"location":"aea/api/helpers/search/models/#datamodel-objects","text":"class DataModel () Implements an OEF data model.","title":"DataModel Objects"},{"location":"aea/api/helpers/search/models/#__init___2","text":"| __init__ ( name : str , attributes : List [ Attribute ], description : str = \"\" ) -> None Initialize a data model. Arguments : name : the name of the data model. attributes : the attributes of the data model. description : the data model description.","title":"__init__"},{"location":"aea/api/helpers/search/models/#attributes_by_name","text":"| @property | attributes_by_name () -> Dict [ str , Attribute ] Get the attributes by name.","title":"attributes_by_name"},{"location":"aea/api/helpers/search/models/#__eq___2","text":"| __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#__str___2","text":"| __str__ () -> str Get the string representation of the data model.","title":"__str__"},{"location":"aea/api/helpers/search/models/#encode_2","text":"| encode () -> models_pb2 . Query . DataModel Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_2","text":"| @classmethod | decode ( cls , data_model_pb : Any ) -> \"DataModel\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : data_model_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object","title":"decode"},{"location":"aea/api/helpers/search/models/#generate_data_model","text":"generate_data_model ( model_name : str , attribute_values : Mapping [ str , ATTRIBUTE_TYPES ]) -> DataModel Generate a data model that matches the values stored in this description. That is, for each attribute (name, value), generate an Attribute. It is assumed that each attribute is required. Arguments : model_name : the name of the model. attribute_values : the values of each attribute Returns : the schema compliant with the values specified.","title":"generate_data_model"},{"location":"aea/api/helpers/search/models/#description-objects","text":"class Description () Implements an OEF description.","title":"Description Objects"},{"location":"aea/api/helpers/search/models/#__init___3","text":"| __init__ ( values : Mapping [ str , ATTRIBUTE_TYPES ], data_model : Optional [ DataModel ] = None , data_model_name : str = \"\" ) -> None Initialize the description object. Arguments : values : the values in the description. data_model : the data model (optional) data_model_name : the data model name if a datamodel is created on the fly.","title":"__init__"},{"location":"aea/api/helpers/search/models/#values","text":"| @property | values () -> Dict Get the values.","title":"values"},{"location":"aea/api/helpers/search/models/#__eq___3","text":"| __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#__iter__","text":"| __iter__ () -> Iterator Create an iterator.","title":"__iter__"},{"location":"aea/api/helpers/search/models/#__str___3","text":"| __str__ () -> str Get the string representation of the description.","title":"__str__"},{"location":"aea/api/helpers/search/models/#encode_3","text":"| @classmethod | encode ( cls , description_pb : Any , description : \"Description\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the description_protobuf_object argument must be matched with the instance of this class in the 'description_object' argument. Arguments : description_pb : the protocol buffer object whose type corresponds with this class. description : an instance of this class to be encoded in the protocol buffer object.","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_3","text":"| @classmethod | decode ( cls , description_pb : Any ) -> \"Description\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'description_protobuf_object' argument. Arguments : description_pb : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'description_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/search/models/#constrainttypes-objects","text":"class ConstraintTypes ( Enum ) Types of constraint.","title":"ConstraintTypes Objects"},{"location":"aea/api/helpers/search/models/#__str___4","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/helpers/search/models/#constrainttype-objects","text":"class ConstraintType () Type of constraint. Used with the Constraint class, this class allows to specify constraint over attributes. Examples : Equal to three equal_3 = ConstraintType(ConstraintTypes.EQUAL, 3) You can also specify a type of constraint by using its string representation, e.g.: equal_3 = ConstraintType(\"==\", 3) not_equal_london = ConstraintType(\"!=\", \"London\") less_than_pi = ConstraintType(\"<\", 3.14) within_range = ConstraintType(\"within\", (-10.0, 10.0)) in_a_set = ConstraintType(\"in\", (1, 2, 3)) not_in_a_set = ConstraintType(\"not_in\", (\"C\", \"Java\", \"Python\"))","title":"ConstraintType Objects"},{"location":"aea/api/helpers/search/models/#__init___4","text":"| __init__ ( type_ : Union [ ConstraintTypes , str ], value : Any ) -> None Initialize a constraint type. Arguments : type_ : the type of the constraint. | Either an instance of the ConstraintTypes enum, | or a string representation associated with the type. value : the value that defines the constraint. Raises : AEAEnforceError : if the type of the constraint is not # noqa: DAR402","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_validity","text":"| check_validity () -> bool Check the validity of the input provided. Returns : boolean to indicate validity Raises : AEAEnforceError : if the value is not valid wrt the constraint type. # noqa: DAR402","title":"check_validity"},{"location":"aea/api/helpers/search/models/#is_valid","text":"| is_valid ( attribute : Attribute ) -> bool Check if the constraint type is valid wrt a given attribute. A constraint type is valid wrt an attribute if the type of its operand(s) is the same of the attribute type. attribute = Attribute(\"year\", int, True) valid_constraint_type = ConstraintType(ConstraintTypes.GREATER_THAN, 2000) valid_constraint_type.is_valid(attribute) True valid_constraint_type = ConstraintType(ConstraintTypes.WITHIN, (2000, 2001)) valid_constraint_type.is_valid(attribute) True The following constraint is invalid: the year is in a string variable, whereas the attribute is defined over integers. invalid_constraint_type = ConstraintType(ConstraintTypes.GREATER_THAN, \"2000\") invalid_constraint_type.is_valid(attribute) False Arguments : attribute : the data model used to check the validity of the constraint type. Returns : True if the constraint type is valid wrt the attribute, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#get_data_type","text":"| get_data_type () -> Type [ ATTRIBUTE_TYPES ] Get the type of the data used to define the constraint type. For instance: c = ConstraintType(ConstraintTypes.EQUAL, 1) c.get_data_type() Returns : data type","title":"get_data_type"},{"location":"aea/api/helpers/search/models/#check","text":"| check ( value : ATTRIBUTE_TYPES ) -> bool Check if an attribute value satisfies the constraint. The implementation depends on the constraint type. Arguments : value : the value to check. Returns : True if the value satisfy the constraint, False otherwise. Raises : ValueError : if the constraint type is not recognized.","title":"check"},{"location":"aea/api/helpers/search/models/#__eq___4","text":"| __eq__ ( other : Any ) -> bool Check equality with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#__str___5","text":"| __str__ () -> str Get the string representation of the constraint type.","title":"__str__"},{"location":"aea/api/helpers/search/models/#encode_4","text":"| encode () -> Optional [ Any ] Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_4","text":"| @classmethod | decode ( cls , constraint_type_pb : Any , category : str ) -> \"ConstraintType\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : constraint_type_pb : the protocol buffer object corresponding with this class. category : the category of the constraint ('relation', 'set', 'range', 'distance). Returns : A new instance of this class matching the protocol buffer object","title":"decode"},{"location":"aea/api/helpers/search/models/#constraintexpr-objects","text":"class ConstraintExpr ( ABC ) Implementation of the constraint language to query the OEF node.","title":"ConstraintExpr Objects"},{"location":"aea/api/helpers/search/models/#check_1","text":"| @abstractmethod | check ( description : Description ) -> bool Check if a description satisfies the constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_1","text":"| @abstractmethod | is_valid ( data_model : DataModel ) -> bool Check whether a constraint expression is valid wrt a data model. Specifically, check the following conditions: - If all the attributes referenced by the constraints are correctly associated with the Data Model attributes. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#check_validity_1","text":"| check_validity () -> None Check whether a Constraint Expression satisfies some basic requirements. Raises : AEAEnforceError : if the object does not satisfy some requirements. # noqa: DAR402","title":"check_validity"},{"location":"aea/api/helpers/search/models/#and-objects","text":"class And ( ConstraintExpr ) Implementation of the 'And' constraint expression.","title":"And Objects"},{"location":"aea/api/helpers/search/models/#__init___5","text":"| __init__ ( constraints : List [ ConstraintExpr ]) -> None Initialize an 'And' expression. Arguments : constraints : the list of constraints expression (in conjunction).","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_2","text":"| check ( description : Description ) -> bool Check if a value satisfies the 'And' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_2","text":"| is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#check_validity_2","text":"| check_validity () -> None Check whether the Constraint Expression satisfies some basic requirements. :return None Raises : ValueError : if the object does not satisfy some requirements.","title":"check_validity"},{"location":"aea/api/helpers/search/models/#__eq___5","text":"| __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#encode_5","text":"| encode () -> models_pb2 . Query . ConstraintExpr . And Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_5","text":"| @classmethod | decode ( cls , and_pb : Any ) -> \"And\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : and_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object","title":"decode"},{"location":"aea/api/helpers/search/models/#or-objects","text":"class Or ( ConstraintExpr ) Implementation of the 'Or' constraint expression.","title":"Or Objects"},{"location":"aea/api/helpers/search/models/#__init___6","text":"| __init__ ( constraints : List [ ConstraintExpr ]) -> None Initialize an 'Or' expression. Arguments : constraints : the list of constraints expressions (in disjunction).","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_3","text":"| check ( description : Description ) -> bool Check if a value satisfies the 'Or' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_3","text":"| is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#check_validity_3","text":"| check_validity () -> None Check whether the Constraint Expression satisfies some basic requirements. :return None Raises : ValueError : if the object does not satisfy some requirements.","title":"check_validity"},{"location":"aea/api/helpers/search/models/#__eq___6","text":"| __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#encode_6","text":"| encode () -> models_pb2 . Query . ConstraintExpr . Or Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_6","text":"| @classmethod | decode ( cls , or_pb : Any ) -> \"Or\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : or_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object","title":"decode"},{"location":"aea/api/helpers/search/models/#not-objects","text":"class Not ( ConstraintExpr ) Implementation of the 'Not' constraint expression.","title":"Not Objects"},{"location":"aea/api/helpers/search/models/#__init___7","text":"| __init__ ( constraint : ConstraintExpr ) -> None Initialize a 'Not' expression. Arguments : constraint : the constraint expression to negate.","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_4","text":"| check ( description : Description ) -> bool Check if a value satisfies the 'Not' constraint expression. Arguments : description : the description to check. Returns : True if the description satisfy the constraint expression, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_4","text":"| is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#__eq___7","text":"| __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#encode_7","text":"| encode () -> models_pb2 . Query . ConstraintExpr . Not Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_7","text":"| @classmethod | decode ( cls , not_pb : Any ) -> \"Not\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : not_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object","title":"decode"},{"location":"aea/api/helpers/search/models/#constraint-objects","text":"class Constraint ( ConstraintExpr ) The atomic component of a constraint expression.","title":"Constraint Objects"},{"location":"aea/api/helpers/search/models/#__init___8","text":"| __init__ ( attribute_name : str , constraint_type : ConstraintType ) -> None Initialize a constraint. Arguments : attribute_name : the name of the attribute to be constrained. constraint_type : the constraint type.","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_5","text":"| check ( description : Description ) -> bool Check if a description satisfies the constraint. The implementation depends on the type of the constraint. Arguments : description : the description to check. Returns : True if the description satisfies the constraint, False otherwise. Examples: >>> attr_author = Attribute(\"author\" , str, True, \"The author of the book.\") >>> attr_year = Attribute(\"year\", int, True, \"The year of publication of the book.\") >>> attr_genre = Attribute(\"genre\", str, True, \"The genre of the book.\") >>> c1 = Constraint(\"author\", ConstraintType(\"==\", \"Stephen King\")) >>> c2 = Constraint(\"year\", ConstraintType(\">\", 1990)) >>> c3 = Constraint(\"genre\", ConstraintType(\"in\", (\"horror\", \"science_fiction\"))) >>> book_1 = Description({\"author\": \"Stephen King\", \"year\": 1991, \"genre\": \"horror\"}) >>> book_2 = Description({\"author\": \"George Orwell\", \"year\": 1948, \"genre\": \"horror\"}) The \"author\" attribute instantiation satisfies the constraint, so the result is True. >>> c1.check(book_1) True Here, the \"author\" does not satisfy the constraints. Hence, the result is False. >>> c1.check(book_2) False In this case, there is a missing field specified by the query, that is \"year\" So the result is False, even in the case it is not required by the schema: >>> c2.check(Description({\"author\": \"Stephen King\"})) False If the type of some attribute of the description is not correct, the result is False. In this case, the field \"year\" has a string instead of an integer: >>> c2.check(Description({\"author\": \"Stephen King\", \"year\": \"1991\"})) False >>> c3.check(Description({\"author\": \"Stephen King\", \"genre\": False})) False","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_5","text":"| is_valid ( data_model : DataModel ) -> bool Check whether the constraint expression is valid wrt a data model. Arguments : data_model : the data model used to check the validity of the constraint expression. Returns : True if the constraint expression is valid wrt the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#__eq___8","text":"| __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#__str___6","text":"| __str__ () -> str Get the string representation of the constraint.","title":"__str__"},{"location":"aea/api/helpers/search/models/#encode_8","text":"| encode () -> models_pb2 . Query . ConstraintExpr . Constraint Encode an instance of this class into a protocol buffer object. Returns : the matching protocol buffer object","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_8","text":"| @classmethod | decode ( cls , constraint_pb : Any ) -> \"Constraint\" Decode a protocol buffer object that corresponds with this class into an instance of this class. Arguments : constraint_pb : the protocol buffer object corresponding with this class. Returns : A new instance of this class matching the protocol buffer object","title":"decode"},{"location":"aea/api/helpers/search/models/#query-objects","text":"class Query () This class lets you build a query for the OEF.","title":"Query Objects"},{"location":"aea/api/helpers/search/models/#__init___9","text":"| __init__ ( constraints : List [ ConstraintExpr ], model : Optional [ DataModel ] = None ) -> None Initialize a query. Arguments : constraints : a list of constraint expressions. model : the data model that the query refers to.","title":"__init__"},{"location":"aea/api/helpers/search/models/#check_6","text":"| check ( description : Description ) -> bool Check if a description satisfies the constraints of the query. The constraints are interpreted as conjunction. Arguments : description : the description to check. Returns : True if the description satisfies all the constraints, False otherwise.","title":"check"},{"location":"aea/api/helpers/search/models/#is_valid_6","text":"| is_valid ( data_model : Optional [ DataModel ]) -> bool Given a data model, check whether the query is valid for that data model. Arguments : data_model : optional datamodel Returns : True if the query is compliant with the data model, False otherwise.","title":"is_valid"},{"location":"aea/api/helpers/search/models/#check_validity_4","text":"| check_validity () -> None Check whether the` object is valid. :return None Raises : ValueError : if the query does not satisfy some sanity requirements.","title":"check_validity"},{"location":"aea/api/helpers/search/models/#__eq___9","text":"| __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/helpers/search/models/#__str___7","text":"| __str__ () -> str Get the string representation of the constraint.","title":"__str__"},{"location":"aea/api/helpers/search/models/#encode_9","text":"| @classmethod | encode ( cls , query_pb : Any , query : \"Query\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the query_protobuf_object argument must be matched with the instance of this class in the 'query_object' argument. Arguments : query_pb : the protocol buffer object wrapping an object that corresponds with this class. query : an instance of this class to be encoded in the protocol buffer object.","title":"encode"},{"location":"aea/api/helpers/search/models/#decode_9","text":"| @classmethod | decode ( cls , query_pb : Any ) -> \"Query\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'query_protobuf_object' argument. Arguments : query_pb : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'query_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/search/models/#haversine","text":"haversine ( lat1 : float , lon1 : float , lat2 : float , lon2 : float ) -> float Compute the Haversine distance between two locations (i.e. two pairs of latitude and longitude). Arguments : lat1 : the latitude of the first location. lon1 : the longitude of the first location. lat2 : the latitude of the second location. lon2 : the longitude of the second location. Returns : the Haversine distance.","title":"haversine"},{"location":"aea/api/helpers/storage/generic_storage/","text":"aea.helpers.storage.generic _ storage This module contains the storage implementation. AsyncCollection Objects class AsyncCollection () Async collection. __ init __ | __init__ ( storage_backend : AbstractStorageBackend , collection_name : str ) -> None Init collection object. Arguments : storage_backend : storage backed to use. collection_name : str put | async put ( object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : object_id : str object id object_body : python dict, json compatible. Returns : None get | async get ( object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : object_id : str object id Returns : dict if object exists in collection otherwise None remove | async remove ( object_id : str ) -> None Remove object from the collection. Arguments : object_id : str object id Returns : None find | async find ( field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : None list | async list () -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Returns : Tuple of objects keys, bodies. SyncCollection Objects class SyncCollection () Async collection. __ init __ | __init__ ( async_collection_coro : Coroutine , loop : asyncio . AbstractEventLoop ) -> None Init collection object. Arguments : async_collection_coro : coroutine returns async collection. loop : abstract event loop where storage is running. put | put ( object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : object_id : str object id object_body : python dict, json compatible. Returns : None get | get ( object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : object_id : str object id Returns : dict if object exists in collection otherwise None remove | remove ( object_id : str ) -> None Remove object from the collection. Arguments : object_id : str object id Returns : None find | find ( field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : List of object bodies list | list () -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Returns : Tuple of objects keys, bodies. Storage Objects class Storage ( Runnable ) Generic storage. __ init __ | __init__ ( storage_uri : str , loop : asyncio . AbstractEventLoop = None , threaded : bool = False ) -> None Init storage. Arguments : storage_uri : configuration string for storage. loop : asyncio event loop to use. threaded : bool. start in thread if True. wait _ connected | async wait_connected () -> None Wait generic storage is connected. is _ connected | @property | is_connected () -> bool Get running state of the storage. run | async run () -> None Connect storage. get _ collection | async get_collection ( collection_name : str ) -> AsyncCollection Get async collection. get _ sync _ collection | get_sync_collection ( collection_name : str ) -> SyncCollection Get sync collection. __ repr __ | __repr__ () -> str Get string representation of the storage.","title":"GenericStorage"},{"location":"aea/api/helpers/storage/generic_storage/#aeahelpersstoragegeneric_storage","text":"This module contains the storage implementation.","title":"aea.helpers.storage.generic_storage"},{"location":"aea/api/helpers/storage/generic_storage/#asynccollection-objects","text":"class AsyncCollection () Async collection.","title":"AsyncCollection Objects"},{"location":"aea/api/helpers/storage/generic_storage/#__init__","text":"| __init__ ( storage_backend : AbstractStorageBackend , collection_name : str ) -> None Init collection object. Arguments : storage_backend : storage backed to use. collection_name : str","title":"__init__"},{"location":"aea/api/helpers/storage/generic_storage/#put","text":"| async put ( object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : object_id : str object id object_body : python dict, json compatible. Returns : None","title":"put"},{"location":"aea/api/helpers/storage/generic_storage/#get","text":"| async get ( object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : object_id : str object id Returns : dict if object exists in collection otherwise None","title":"get"},{"location":"aea/api/helpers/storage/generic_storage/#remove","text":"| async remove ( object_id : str ) -> None Remove object from the collection. Arguments : object_id : str object id Returns : None","title":"remove"},{"location":"aea/api/helpers/storage/generic_storage/#find","text":"| async find ( field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : None","title":"find"},{"location":"aea/api/helpers/storage/generic_storage/#list","text":"| async list () -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Returns : Tuple of objects keys, bodies.","title":"list"},{"location":"aea/api/helpers/storage/generic_storage/#synccollection-objects","text":"class SyncCollection () Async collection.","title":"SyncCollection Objects"},{"location":"aea/api/helpers/storage/generic_storage/#__init___1","text":"| __init__ ( async_collection_coro : Coroutine , loop : asyncio . AbstractEventLoop ) -> None Init collection object. Arguments : async_collection_coro : coroutine returns async collection. loop : abstract event loop where storage is running.","title":"__init__"},{"location":"aea/api/helpers/storage/generic_storage/#put_1","text":"| put ( object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : object_id : str object id object_body : python dict, json compatible. Returns : None","title":"put"},{"location":"aea/api/helpers/storage/generic_storage/#get_1","text":"| get ( object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : object_id : str object id Returns : dict if object exists in collection otherwise None","title":"get"},{"location":"aea/api/helpers/storage/generic_storage/#remove_1","text":"| remove ( object_id : str ) -> None Remove object from the collection. Arguments : object_id : str object id Returns : None","title":"remove"},{"location":"aea/api/helpers/storage/generic_storage/#find_1","text":"| find ( field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : List of object bodies","title":"find"},{"location":"aea/api/helpers/storage/generic_storage/#list_1","text":"| list () -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Returns : Tuple of objects keys, bodies.","title":"list"},{"location":"aea/api/helpers/storage/generic_storage/#storage-objects","text":"class Storage ( Runnable ) Generic storage.","title":"Storage Objects"},{"location":"aea/api/helpers/storage/generic_storage/#__init___2","text":"| __init__ ( storage_uri : str , loop : asyncio . AbstractEventLoop = None , threaded : bool = False ) -> None Init storage. Arguments : storage_uri : configuration string for storage. loop : asyncio event loop to use. threaded : bool. start in thread if True.","title":"__init__"},{"location":"aea/api/helpers/storage/generic_storage/#wait_connected","text":"| async wait_connected () -> None Wait generic storage is connected.","title":"wait_connected"},{"location":"aea/api/helpers/storage/generic_storage/#is_connected","text":"| @property | is_connected () -> bool Get running state of the storage.","title":"is_connected"},{"location":"aea/api/helpers/storage/generic_storage/#run","text":"| async run () -> None Connect storage.","title":"run"},{"location":"aea/api/helpers/storage/generic_storage/#get_collection","text":"| async get_collection ( collection_name : str ) -> AsyncCollection Get async collection.","title":"get_collection"},{"location":"aea/api/helpers/storage/generic_storage/#get_sync_collection","text":"| get_sync_collection ( collection_name : str ) -> SyncCollection Get sync collection.","title":"get_sync_collection"},{"location":"aea/api/helpers/storage/generic_storage/#__repr__","text":"| __repr__ () -> str Get string representation of the storage.","title":"__repr__"},{"location":"aea/api/helpers/storage/backends/base/","text":"aea.helpers.storage.backends.base This module contains storage abstract backend class. AbstractStorageBackend Objects class AbstractStorageBackend ( ABC ) Abstract base class for storage backend. __ init __ | __init__ ( uri : str ) -> None Init backend. connect | @abstractmethod | async connect () -> None Connect to backend. disconnect | @abstractmethod | async disconnect () -> None Disconnect the backend. ensure _ collection | @abstractmethod | async ensure_collection ( collection_name : str ) -> None Create collection if not exits. Arguments : collection_name : str. Returns : None put | @abstractmethod | async put ( collection_name : str , object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : collection_name : str. object_id : str object id object_body : python dict, json compatible. Returns : None get | @abstractmethod | async get ( collection_name : str , object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : collection_name : str. object_id : str object id Returns : dict if object exists in collection otherwise None remove | @abstractmethod | async remove ( collection_name : str , object_id : str ) -> None Remove object from the collection. Arguments : collection_name : str. object_id : str object id Returns : None find | @abstractmethod | async find ( collection_name : str , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : collection_name : str. field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : list of objects bodies list | @abstractmethod | async list ( collection_name : str ) -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Arguments : collection_name : str. Returns : Tuple of objects keys, bodies.","title":"Base"},{"location":"aea/api/helpers/storage/backends/base/#aeahelpersstoragebackendsbase","text":"This module contains storage abstract backend class.","title":"aea.helpers.storage.backends.base"},{"location":"aea/api/helpers/storage/backends/base/#abstractstoragebackend-objects","text":"class AbstractStorageBackend ( ABC ) Abstract base class for storage backend.","title":"AbstractStorageBackend Objects"},{"location":"aea/api/helpers/storage/backends/base/#__init__","text":"| __init__ ( uri : str ) -> None Init backend.","title":"__init__"},{"location":"aea/api/helpers/storage/backends/base/#connect","text":"| @abstractmethod | async connect () -> None Connect to backend.","title":"connect"},{"location":"aea/api/helpers/storage/backends/base/#disconnect","text":"| @abstractmethod | async disconnect () -> None Disconnect the backend.","title":"disconnect"},{"location":"aea/api/helpers/storage/backends/base/#ensure_collection","text":"| @abstractmethod | async ensure_collection ( collection_name : str ) -> None Create collection if not exits. Arguments : collection_name : str. Returns : None","title":"ensure_collection"},{"location":"aea/api/helpers/storage/backends/base/#put","text":"| @abstractmethod | async put ( collection_name : str , object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : collection_name : str. object_id : str object id object_body : python dict, json compatible. Returns : None","title":"put"},{"location":"aea/api/helpers/storage/backends/base/#get","text":"| @abstractmethod | async get ( collection_name : str , object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : collection_name : str. object_id : str object id Returns : dict if object exists in collection otherwise None","title":"get"},{"location":"aea/api/helpers/storage/backends/base/#remove","text":"| @abstractmethod | async remove ( collection_name : str , object_id : str ) -> None Remove object from the collection. Arguments : collection_name : str. object_id : str object id Returns : None","title":"remove"},{"location":"aea/api/helpers/storage/backends/base/#find","text":"| @abstractmethod | async find ( collection_name : str , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : collection_name : str. field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : list of objects bodies","title":"find"},{"location":"aea/api/helpers/storage/backends/base/#list","text":"| @abstractmethod | async list ( collection_name : str ) -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Arguments : collection_name : str. Returns : Tuple of objects keys, bodies.","title":"list"},{"location":"aea/api/helpers/storage/backends/sqlite/","text":"aea.helpers.storage.backends.sqlite This module contains sqlite storage backend implementation. SqliteStorageBackend Objects class SqliteStorageBackend ( AbstractStorageBackend ) Sqlite storage backend. __ init __ | __init__ ( uri : str ) -> None Init backend. connect | async connect () -> None Connect to backend. disconnect | async disconnect () -> None Disconnect the backend. ensure _ collection | async ensure_collection ( collection_name : str ) -> None Create collection if not exits. Arguments : collection_name : name of the collection. put | async put ( collection_name : str , object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : collection_name : str. object_id : str object id object_body : python dict, json compatible. get | async get ( collection_name : str , object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : collection_name : str. object_id : str object id Returns : dict if object exists in collection otherwise None remove | async remove ( collection_name : str , object_id : str ) -> None Remove object from the collection. Arguments : collection_name : str. object_id : str object id find | async find ( collection_name : str , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : collection_name : str. field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : list of object ids and body list | async list ( collection_name : str ) -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Arguments : collection_name : str. Returns : Tuple of objects keys, bodies.","title":"Sqlite"},{"location":"aea/api/helpers/storage/backends/sqlite/#aeahelpersstoragebackendssqlite","text":"This module contains sqlite storage backend implementation.","title":"aea.helpers.storage.backends.sqlite"},{"location":"aea/api/helpers/storage/backends/sqlite/#sqlitestoragebackend-objects","text":"class SqliteStorageBackend ( AbstractStorageBackend ) Sqlite storage backend.","title":"SqliteStorageBackend Objects"},{"location":"aea/api/helpers/storage/backends/sqlite/#__init__","text":"| __init__ ( uri : str ) -> None Init backend.","title":"__init__"},{"location":"aea/api/helpers/storage/backends/sqlite/#connect","text":"| async connect () -> None Connect to backend.","title":"connect"},{"location":"aea/api/helpers/storage/backends/sqlite/#disconnect","text":"| async disconnect () -> None Disconnect the backend.","title":"disconnect"},{"location":"aea/api/helpers/storage/backends/sqlite/#ensure_collection","text":"| async ensure_collection ( collection_name : str ) -> None Create collection if not exits. Arguments : collection_name : name of the collection.","title":"ensure_collection"},{"location":"aea/api/helpers/storage/backends/sqlite/#put","text":"| async put ( collection_name : str , object_id : str , object_body : JSON_TYPES ) -> None Put object into collection. Arguments : collection_name : str. object_id : str object id object_body : python dict, json compatible.","title":"put"},{"location":"aea/api/helpers/storage/backends/sqlite/#get","text":"| async get ( collection_name : str , object_id : str ) -> Optional [ JSON_TYPES ] Get object from the collection. Arguments : collection_name : str. object_id : str object id Returns : dict if object exists in collection otherwise None","title":"get"},{"location":"aea/api/helpers/storage/backends/sqlite/#remove","text":"| async remove ( collection_name : str , object_id : str ) -> None Remove object from the collection. Arguments : collection_name : str. object_id : str object id","title":"remove"},{"location":"aea/api/helpers/storage/backends/sqlite/#find","text":"| async find ( collection_name : str , field : str , equals : EQUALS_TYPE ) -> List [ OBJECT_ID_AND_BODY ] Get objects from the collection by filtering by field value. Arguments : collection_name : str. field : field name to search: example \"parent.field\" equals : value field should be equal to Returns : list of object ids and body","title":"find"},{"location":"aea/api/helpers/storage/backends/sqlite/#list","text":"| async list ( collection_name : str ) -> List [ OBJECT_ID_AND_BODY ] List all objects with keys from the collection. Arguments : collection_name : str. Returns : Tuple of objects keys, bodies.","title":"list"},{"location":"aea/api/helpers/transaction/base/","text":"aea.helpers.transaction.base This module contains terms related classes. RawTransaction Objects class RawTransaction () This class represents an instance of RawTransaction. __ init __ | __init__ ( ledger_id : str , body : JSONLike ) -> None Initialise an instance of RawTransaction. ledger _ id | @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body | @property | body () -> JSONLike Get the body. encode | @staticmethod | encode ( raw_transaction_protobuf_object : Any , raw_transaction_object : \"RawTransaction\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the raw_transaction_protobuf_object argument must be matched with the instance of this class in the 'raw_transaction_object' argument. Arguments : raw_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. raw_transaction_object : an instance of this class to be encoded in the protocol buffer object. decode | @classmethod | decode ( cls , raw_transaction_protobuf_object : Any ) -> \"RawTransaction\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'raw_transaction_protobuf_object' argument. Arguments : raw_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'raw_transaction_protobuf_object' argument. __ eq __ | __eq__ ( other : Any ) -> bool Check equality. __ str __ | __str__ () -> str Get string representation. RawMessage Objects class RawMessage () This class represents an instance of RawMessage. __ init __ | __init__ ( ledger_id : str , body : bytes , is_deprecated_mode : bool = False ) -> None Initialise an instance of RawMessage. ledger _ id | @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body | @property | body () -> bytes Get the body. is _ deprecated _ mode | @property | is_deprecated_mode () -> bool Get the is_deprecated_mode. encode | @staticmethod | encode ( raw_message_protobuf_object : Any , raw_message_object : \"RawMessage\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the raw_message_protobuf_object argument must be matched with the instance of this class in the 'raw_message_object' argument. Arguments : raw_message_protobuf_object : the protocol buffer object whose type corresponds with this class. raw_message_object : an instance of this class to be encoded in the protocol buffer object. decode | @classmethod | decode ( cls , raw_message_protobuf_object : Any ) -> \"RawMessage\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'raw_message_protobuf_object' argument. Arguments : raw_message_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'raw_message_protobuf_object' argument. __ eq __ | __eq__ ( other : Any ) -> bool Check equality. __ str __ | __str__ () -> str Get string representation. SignedTransaction Objects class SignedTransaction () This class represents an instance of SignedTransaction. __ init __ | __init__ ( ledger_id : str , body : JSONLike ) -> None Initialise an instance of SignedTransaction. ledger _ id | @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body | @property | body () -> JSONLike Get the body. encode | @staticmethod | encode ( signed_transaction_protobuf_object : Any , signed_transaction_object : \"SignedTransaction\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the signed_transaction_protobuf_object argument must be matched with the instance of this class in the 'signed_transaction_object' argument. Arguments : signed_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. signed_transaction_object : an instance of this class to be encoded in the protocol buffer object. decode | @classmethod | decode ( cls , signed_transaction_protobuf_object : Any ) -> \"SignedTransaction\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'signed_transaction_protobuf_object' argument. Arguments : signed_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'signed_transaction_protobuf_object' argument. __ eq __ | __eq__ ( other : Any ) -> bool Check equality. __ str __ | __str__ () -> str Get string representation. SignedMessage Objects class SignedMessage () This class represents an instance of RawMessage. __ init __ | __init__ ( ledger_id : str , body : str , is_deprecated_mode : bool = False ) -> None Initialise an instance of SignedMessage. ledger _ id | @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body | @property | body () -> str Get the body. is _ deprecated _ mode | @property | is_deprecated_mode () -> bool Get the is_deprecated_mode. encode | @staticmethod | encode ( signed_message_protobuf_object : Any , signed_message_object : \"SignedMessage\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the signed_message_protobuf_object argument must be matched with the instance of this class in the 'signed_message_object' argument. Arguments : signed_message_protobuf_object : the protocol buffer object whose type corresponds with this class. signed_message_object : an instance of this class to be encoded in the protocol buffer object. decode | @classmethod | decode ( cls , signed_message_protobuf_object : Any ) -> \"SignedMessage\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'signed_message_protobuf_object' argument. Arguments : signed_message_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'signed_message_protobuf_object' argument. __ eq __ | __eq__ ( other : Any ) -> bool Check equality. __ str __ | __str__ () -> str Get string representation. State Objects class State () This class represents an instance of State. __ init __ | __init__ ( ledger_id : str , body : JSONLike ) -> None Initialise an instance of State. ledger _ id | @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body | @property | body () -> JSONLike Get the body. encode | @staticmethod | encode ( state_protobuf_object : Any , state_object : \"State\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the state_protobuf_object argument must be matched with the instance of this class in the 'state_object' argument. Arguments : state_protobuf_object : the protocol buffer object whose type corresponds with this class. state_object : an instance of this class to be encoded in the protocol buffer object. decode | @classmethod | decode ( cls , state_protobuf_object : Any ) -> \"State\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'state_protobuf_object' argument. Arguments : state_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'state_protobuf_object' argument. __ eq __ | __eq__ ( other : Any ) -> bool Check equality. __ str __ | __str__ () -> str Get string representation. Terms Objects class Terms () Class to represent the terms of a multi-currency & multi-token ledger transaction. __ init __ | __init__ ( ledger_id : str , sender_address : Address , counterparty_address : Address , amount_by_currency_id : Dict [ str , int ], quantities_by_good_id : Dict [ str , int ], nonce : str , is_sender_payable_tx_fee : bool = True , fee_by_currency_id : Optional [ Dict [ str , int ]] = None , is_strict : bool = False , ** kwargs : Any , ,) -> None Instantiate terms of a transaction. Arguments : ledger_id : the ledger on which the terms are to be settled. sender_address : the sender address of the transaction. counterparty_address : the counterparty address of the transaction. amount_by_currency_id : the amount by the currency of the transaction. quantities_by_good_id : a map from good id to the quantity of that good involved in the transaction. nonce : nonce to be included in transaction to discriminate otherwise identical transactions. is_sender_payable_tx_fee : whether the sender or counterparty pays the tx fee. fee_by_currency_id : the fee associated with the transaction. is_strict : whether or not terms must have quantities and amounts of opposite signs. kwargs : keyword arguments id | @property | id () -> str Get hash of the terms. sender _ hash | @property | sender_hash () -> str Get the sender hash. counterparty _ hash | @property | counterparty_hash () -> str Get the sender hash. ledger _ id | @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled. sender _ address | @property | sender_address () -> Address Get the sender address. counterparty _ address | @property | counterparty_address () -> Address Get the counterparty address. counterparty _ address | @counterparty_address . setter | counterparty_address ( counterparty_address : Address ) -> None Set the counterparty address. amount _ by _ currency _ id | @property | amount_by_currency_id () -> Dict [ str , int ] Get the amount by currency id. is _ sender _ payable _ tx _ fee | @property | is_sender_payable_tx_fee () -> bool Bool indicating whether the tx fee is paid by sender or counterparty. is _ single _ currency | @property | is_single_currency () -> bool Check whether a single currency is used for payment. is _ empty _ currency | @property | is_empty_currency () -> bool Check whether a single currency is used for payment. currency _ id | @property | currency_id () -> str Get the amount the sender must pay. sender _ payable _ amount | @property | sender_payable_amount () -> int Get the amount the sender must pay. sender _ payable _ amount _ incl _ fee | @property | sender_payable_amount_incl_fee () -> int Get the amount the sender must pay inclusive fee. counterparty _ payable _ amount | @property | counterparty_payable_amount () -> int Get the amount the counterparty must pay. counterparty _ payable _ amount _ incl _ fee | @property | counterparty_payable_amount_incl_fee () -> int Get the amount the counterparty must pay. quantities _ by _ good _ id | @property | quantities_by_good_id () -> Dict [ str , int ] Get the quantities by good id. good _ ids | @property | good_ids () -> List [ str ] Get the (ordered) good ids. sender _ supplied _ quantities | @property | sender_supplied_quantities () -> List [ int ] Get the (ordered) quantities supplied by the sender. counterparty _ supplied _ quantities | @property | counterparty_supplied_quantities () -> List [ int ] Get the (ordered) quantities supplied by the counterparty. nonce | @property | nonce () -> str Get the nonce. has _ fee | @property | has_fee () -> bool Check if fee is set. fee | @property | fee () -> int Get the fee. sender _ fee | @property | sender_fee () -> int Get the sender fee. counterparty _ fee | @property | counterparty_fee () -> int Get the counterparty fee. fee _ by _ currency _ id | @property | fee_by_currency_id () -> Dict [ str , int ] Get fee by currency. kwargs | @property | kwargs () -> JSONLike Get the kwargs. is _ strict | @property | is_strict () -> bool Get is_strict. get _ hash | @staticmethod | get_hash ( ledger_id : str , sender_address : str , counterparty_address : str , good_ids : List [ str ], sender_supplied_quantities : List [ int ], counterparty_supplied_quantities : List [ int ], sender_payable_amount : int , counterparty_payable_amount : int , nonce : str ) -> str Generate a hash from transaction information. Arguments : ledger_id : the ledger id sender_address : the sender address counterparty_address : the counterparty address good_ids : the list of good ids sender_supplied_quantities : the quantities supplied by the sender (must all be positive) counterparty_supplied_quantities : the quantities supplied by the counterparty (must all be positive) sender_payable_amount : the amount payable by the sender counterparty_payable_amount : the amount payable by the counterparty nonce : the nonce of the transaction Returns : the hash encode | @staticmethod | encode ( terms_protobuf_object : Any , terms_object : \"Terms\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the terms_protobuf_object argument must be matched with the instance of this class in the 'terms_object' argument. Arguments : terms_protobuf_object : the protocol buffer object whose type corresponds with this class. terms_object : an instance of this class to be encoded in the protocol buffer object. decode | @classmethod | decode ( cls , terms_protobuf_object : Any ) -> \"Terms\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'terms_protobuf_object' argument. Arguments : terms_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'terms_protobuf_object' argument. __ eq __ | __eq__ ( other : Any ) -> bool Check equality. __ str __ | __str__ () -> str Get string representation. TransactionDigest Objects class TransactionDigest () This class represents an instance of TransactionDigest. __ init __ | __init__ ( ledger_id : str , body : str ) -> None Initialise an instance of TransactionDigest. ledger _ id | @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled. body | @property | body () -> str Get the receipt. encode | @staticmethod | encode ( transaction_digest_protobuf_object : Any , transaction_digest_object : \"TransactionDigest\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the transaction_digest_protobuf_object argument must be matched with the instance of this class in the 'transaction_digest_object' argument. Arguments : transaction_digest_protobuf_object : the protocol buffer object whose type corresponds with this class. transaction_digest_object : an instance of this class to be encoded in the protocol buffer object. decode | @classmethod | decode ( cls , transaction_digest_protobuf_object : Any ) -> \"TransactionDigest\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'transaction_digest_protobuf_object' argument. Arguments : transaction_digest_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'transaction_digest_protobuf_object' argument. __ eq __ | __eq__ ( other : Any ) -> bool Check equality. __ str __ | __str__ () -> str Get string representation. TransactionReceipt Objects class TransactionReceipt () This class represents an instance of TransactionReceipt. __ init __ | __init__ ( ledger_id : str , receipt : JSONLike , transaction : JSONLike ) -> None Initialise an instance of TransactionReceipt. ledger _ id | @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled. receipt | @property | receipt () -> JSONLike Get the receipt. transaction | @property | transaction () -> JSONLike Get the transaction. encode | @staticmethod | encode ( transaction_receipt_protobuf_object : Any , transaction_receipt_object : \"TransactionReceipt\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the transaction_receipt_protobuf_object argument must be matched with the instance of this class in the 'transaction_receipt_object' argument. Arguments : transaction_receipt_protobuf_object : the protocol buffer object whose type corresponds with this class. transaction_receipt_object : an instance of this class to be encoded in the protocol buffer object. decode | @classmethod | decode ( cls , transaction_receipt_protobuf_object : Any ) -> \"TransactionReceipt\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'transaction_receipt_protobuf_object' argument. Arguments : transaction_receipt_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'transaction_receipt_protobuf_object' argument. __ eq __ | __eq__ ( other : Any ) -> bool Check equality. __ str __ | __str__ () -> str Get string representation.","title":"Base"},{"location":"aea/api/helpers/transaction/base/#aeahelperstransactionbase","text":"This module contains terms related classes.","title":"aea.helpers.transaction.base"},{"location":"aea/api/helpers/transaction/base/#rawtransaction-objects","text":"class RawTransaction () This class represents an instance of RawTransaction.","title":"RawTransaction Objects"},{"location":"aea/api/helpers/transaction/base/#__init__","text":"| __init__ ( ledger_id : str , body : JSONLike ) -> None Initialise an instance of RawTransaction.","title":"__init__"},{"location":"aea/api/helpers/transaction/base/#ledger_id","text":"| @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"aea/api/helpers/transaction/base/#body","text":"| @property | body () -> JSONLike Get the body.","title":"body"},{"location":"aea/api/helpers/transaction/base/#encode","text":"| @staticmethod | encode ( raw_transaction_protobuf_object : Any , raw_transaction_object : \"RawTransaction\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the raw_transaction_protobuf_object argument must be matched with the instance of this class in the 'raw_transaction_object' argument. Arguments : raw_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. raw_transaction_object : an instance of this class to be encoded in the protocol buffer object.","title":"encode"},{"location":"aea/api/helpers/transaction/base/#decode","text":"| @classmethod | decode ( cls , raw_transaction_protobuf_object : Any ) -> \"RawTransaction\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'raw_transaction_protobuf_object' argument. Arguments : raw_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'raw_transaction_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/transaction/base/#__eq__","text":"| __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"aea/api/helpers/transaction/base/#__str__","text":"| __str__ () -> str Get string representation.","title":"__str__"},{"location":"aea/api/helpers/transaction/base/#rawmessage-objects","text":"class RawMessage () This class represents an instance of RawMessage.","title":"RawMessage Objects"},{"location":"aea/api/helpers/transaction/base/#__init___1","text":"| __init__ ( ledger_id : str , body : bytes , is_deprecated_mode : bool = False ) -> None Initialise an instance of RawMessage.","title":"__init__"},{"location":"aea/api/helpers/transaction/base/#ledger_id_1","text":"| @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"aea/api/helpers/transaction/base/#body_1","text":"| @property | body () -> bytes Get the body.","title":"body"},{"location":"aea/api/helpers/transaction/base/#is_deprecated_mode","text":"| @property | is_deprecated_mode () -> bool Get the is_deprecated_mode.","title":"is_deprecated_mode"},{"location":"aea/api/helpers/transaction/base/#encode_1","text":"| @staticmethod | encode ( raw_message_protobuf_object : Any , raw_message_object : \"RawMessage\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the raw_message_protobuf_object argument must be matched with the instance of this class in the 'raw_message_object' argument. Arguments : raw_message_protobuf_object : the protocol buffer object whose type corresponds with this class. raw_message_object : an instance of this class to be encoded in the protocol buffer object.","title":"encode"},{"location":"aea/api/helpers/transaction/base/#decode_1","text":"| @classmethod | decode ( cls , raw_message_protobuf_object : Any ) -> \"RawMessage\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'raw_message_protobuf_object' argument. Arguments : raw_message_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'raw_message_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/transaction/base/#__eq___1","text":"| __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"aea/api/helpers/transaction/base/#__str___1","text":"| __str__ () -> str Get string representation.","title":"__str__"},{"location":"aea/api/helpers/transaction/base/#signedtransaction-objects","text":"class SignedTransaction () This class represents an instance of SignedTransaction.","title":"SignedTransaction Objects"},{"location":"aea/api/helpers/transaction/base/#__init___2","text":"| __init__ ( ledger_id : str , body : JSONLike ) -> None Initialise an instance of SignedTransaction.","title":"__init__"},{"location":"aea/api/helpers/transaction/base/#ledger_id_2","text":"| @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"aea/api/helpers/transaction/base/#body_2","text":"| @property | body () -> JSONLike Get the body.","title":"body"},{"location":"aea/api/helpers/transaction/base/#encode_2","text":"| @staticmethod | encode ( signed_transaction_protobuf_object : Any , signed_transaction_object : \"SignedTransaction\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the signed_transaction_protobuf_object argument must be matched with the instance of this class in the 'signed_transaction_object' argument. Arguments : signed_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. signed_transaction_object : an instance of this class to be encoded in the protocol buffer object.","title":"encode"},{"location":"aea/api/helpers/transaction/base/#decode_2","text":"| @classmethod | decode ( cls , signed_transaction_protobuf_object : Any ) -> \"SignedTransaction\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'signed_transaction_protobuf_object' argument. Arguments : signed_transaction_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'signed_transaction_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/transaction/base/#__eq___2","text":"| __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"aea/api/helpers/transaction/base/#__str___2","text":"| __str__ () -> str Get string representation.","title":"__str__"},{"location":"aea/api/helpers/transaction/base/#signedmessage-objects","text":"class SignedMessage () This class represents an instance of RawMessage.","title":"SignedMessage Objects"},{"location":"aea/api/helpers/transaction/base/#__init___3","text":"| __init__ ( ledger_id : str , body : str , is_deprecated_mode : bool = False ) -> None Initialise an instance of SignedMessage.","title":"__init__"},{"location":"aea/api/helpers/transaction/base/#ledger_id_3","text":"| @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"aea/api/helpers/transaction/base/#body_3","text":"| @property | body () -> str Get the body.","title":"body"},{"location":"aea/api/helpers/transaction/base/#is_deprecated_mode_1","text":"| @property | is_deprecated_mode () -> bool Get the is_deprecated_mode.","title":"is_deprecated_mode"},{"location":"aea/api/helpers/transaction/base/#encode_3","text":"| @staticmethod | encode ( signed_message_protobuf_object : Any , signed_message_object : \"SignedMessage\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the signed_message_protobuf_object argument must be matched with the instance of this class in the 'signed_message_object' argument. Arguments : signed_message_protobuf_object : the protocol buffer object whose type corresponds with this class. signed_message_object : an instance of this class to be encoded in the protocol buffer object.","title":"encode"},{"location":"aea/api/helpers/transaction/base/#decode_3","text":"| @classmethod | decode ( cls , signed_message_protobuf_object : Any ) -> \"SignedMessage\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'signed_message_protobuf_object' argument. Arguments : signed_message_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'signed_message_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/transaction/base/#__eq___3","text":"| __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"aea/api/helpers/transaction/base/#__str___3","text":"| __str__ () -> str Get string representation.","title":"__str__"},{"location":"aea/api/helpers/transaction/base/#state-objects","text":"class State () This class represents an instance of State.","title":"State Objects"},{"location":"aea/api/helpers/transaction/base/#__init___4","text":"| __init__ ( ledger_id : str , body : JSONLike ) -> None Initialise an instance of State.","title":"__init__"},{"location":"aea/api/helpers/transaction/base/#ledger_id_4","text":"| @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"aea/api/helpers/transaction/base/#body_4","text":"| @property | body () -> JSONLike Get the body.","title":"body"},{"location":"aea/api/helpers/transaction/base/#encode_4","text":"| @staticmethod | encode ( state_protobuf_object : Any , state_object : \"State\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the state_protobuf_object argument must be matched with the instance of this class in the 'state_object' argument. Arguments : state_protobuf_object : the protocol buffer object whose type corresponds with this class. state_object : an instance of this class to be encoded in the protocol buffer object.","title":"encode"},{"location":"aea/api/helpers/transaction/base/#decode_4","text":"| @classmethod | decode ( cls , state_protobuf_object : Any ) -> \"State\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'state_protobuf_object' argument. Arguments : state_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'state_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/transaction/base/#__eq___4","text":"| __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"aea/api/helpers/transaction/base/#__str___4","text":"| __str__ () -> str Get string representation.","title":"__str__"},{"location":"aea/api/helpers/transaction/base/#terms-objects","text":"class Terms () Class to represent the terms of a multi-currency & multi-token ledger transaction.","title":"Terms Objects"},{"location":"aea/api/helpers/transaction/base/#__init___5","text":"| __init__ ( ledger_id : str , sender_address : Address , counterparty_address : Address , amount_by_currency_id : Dict [ str , int ], quantities_by_good_id : Dict [ str , int ], nonce : str , is_sender_payable_tx_fee : bool = True , fee_by_currency_id : Optional [ Dict [ str , int ]] = None , is_strict : bool = False , ** kwargs : Any , ,) -> None Instantiate terms of a transaction. Arguments : ledger_id : the ledger on which the terms are to be settled. sender_address : the sender address of the transaction. counterparty_address : the counterparty address of the transaction. amount_by_currency_id : the amount by the currency of the transaction. quantities_by_good_id : a map from good id to the quantity of that good involved in the transaction. nonce : nonce to be included in transaction to discriminate otherwise identical transactions. is_sender_payable_tx_fee : whether the sender or counterparty pays the tx fee. fee_by_currency_id : the fee associated with the transaction. is_strict : whether or not terms must have quantities and amounts of opposite signs. kwargs : keyword arguments","title":"__init__"},{"location":"aea/api/helpers/transaction/base/#id","text":"| @property | id () -> str Get hash of the terms.","title":"id"},{"location":"aea/api/helpers/transaction/base/#sender_hash","text":"| @property | sender_hash () -> str Get the sender hash.","title":"sender_hash"},{"location":"aea/api/helpers/transaction/base/#counterparty_hash","text":"| @property | counterparty_hash () -> str Get the sender hash.","title":"counterparty_hash"},{"location":"aea/api/helpers/transaction/base/#ledger_id_5","text":"| @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"aea/api/helpers/transaction/base/#sender_address","text":"| @property | sender_address () -> Address Get the sender address.","title":"sender_address"},{"location":"aea/api/helpers/transaction/base/#counterparty_address","text":"| @property | counterparty_address () -> Address Get the counterparty address.","title":"counterparty_address"},{"location":"aea/api/helpers/transaction/base/#counterparty_address_1","text":"| @counterparty_address . setter | counterparty_address ( counterparty_address : Address ) -> None Set the counterparty address.","title":"counterparty_address"},{"location":"aea/api/helpers/transaction/base/#amount_by_currency_id","text":"| @property | amount_by_currency_id () -> Dict [ str , int ] Get the amount by currency id.","title":"amount_by_currency_id"},{"location":"aea/api/helpers/transaction/base/#is_sender_payable_tx_fee","text":"| @property | is_sender_payable_tx_fee () -> bool Bool indicating whether the tx fee is paid by sender or counterparty.","title":"is_sender_payable_tx_fee"},{"location":"aea/api/helpers/transaction/base/#is_single_currency","text":"| @property | is_single_currency () -> bool Check whether a single currency is used for payment.","title":"is_single_currency"},{"location":"aea/api/helpers/transaction/base/#is_empty_currency","text":"| @property | is_empty_currency () -> bool Check whether a single currency is used for payment.","title":"is_empty_currency"},{"location":"aea/api/helpers/transaction/base/#currency_id","text":"| @property | currency_id () -> str Get the amount the sender must pay.","title":"currency_id"},{"location":"aea/api/helpers/transaction/base/#sender_payable_amount","text":"| @property | sender_payable_amount () -> int Get the amount the sender must pay.","title":"sender_payable_amount"},{"location":"aea/api/helpers/transaction/base/#sender_payable_amount_incl_fee","text":"| @property | sender_payable_amount_incl_fee () -> int Get the amount the sender must pay inclusive fee.","title":"sender_payable_amount_incl_fee"},{"location":"aea/api/helpers/transaction/base/#counterparty_payable_amount","text":"| @property | counterparty_payable_amount () -> int Get the amount the counterparty must pay.","title":"counterparty_payable_amount"},{"location":"aea/api/helpers/transaction/base/#counterparty_payable_amount_incl_fee","text":"| @property | counterparty_payable_amount_incl_fee () -> int Get the amount the counterparty must pay.","title":"counterparty_payable_amount_incl_fee"},{"location":"aea/api/helpers/transaction/base/#quantities_by_good_id","text":"| @property | quantities_by_good_id () -> Dict [ str , int ] Get the quantities by good id.","title":"quantities_by_good_id"},{"location":"aea/api/helpers/transaction/base/#good_ids","text":"| @property | good_ids () -> List [ str ] Get the (ordered) good ids.","title":"good_ids"},{"location":"aea/api/helpers/transaction/base/#sender_supplied_quantities","text":"| @property | sender_supplied_quantities () -> List [ int ] Get the (ordered) quantities supplied by the sender.","title":"sender_supplied_quantities"},{"location":"aea/api/helpers/transaction/base/#counterparty_supplied_quantities","text":"| @property | counterparty_supplied_quantities () -> List [ int ] Get the (ordered) quantities supplied by the counterparty.","title":"counterparty_supplied_quantities"},{"location":"aea/api/helpers/transaction/base/#nonce","text":"| @property | nonce () -> str Get the nonce.","title":"nonce"},{"location":"aea/api/helpers/transaction/base/#has_fee","text":"| @property | has_fee () -> bool Check if fee is set.","title":"has_fee"},{"location":"aea/api/helpers/transaction/base/#fee","text":"| @property | fee () -> int Get the fee.","title":"fee"},{"location":"aea/api/helpers/transaction/base/#sender_fee","text":"| @property | sender_fee () -> int Get the sender fee.","title":"sender_fee"},{"location":"aea/api/helpers/transaction/base/#counterparty_fee","text":"| @property | counterparty_fee () -> int Get the counterparty fee.","title":"counterparty_fee"},{"location":"aea/api/helpers/transaction/base/#fee_by_currency_id","text":"| @property | fee_by_currency_id () -> Dict [ str , int ] Get fee by currency.","title":"fee_by_currency_id"},{"location":"aea/api/helpers/transaction/base/#kwargs","text":"| @property | kwargs () -> JSONLike Get the kwargs.","title":"kwargs"},{"location":"aea/api/helpers/transaction/base/#is_strict","text":"| @property | is_strict () -> bool Get is_strict.","title":"is_strict"},{"location":"aea/api/helpers/transaction/base/#get_hash","text":"| @staticmethod | get_hash ( ledger_id : str , sender_address : str , counterparty_address : str , good_ids : List [ str ], sender_supplied_quantities : List [ int ], counterparty_supplied_quantities : List [ int ], sender_payable_amount : int , counterparty_payable_amount : int , nonce : str ) -> str Generate a hash from transaction information. Arguments : ledger_id : the ledger id sender_address : the sender address counterparty_address : the counterparty address good_ids : the list of good ids sender_supplied_quantities : the quantities supplied by the sender (must all be positive) counterparty_supplied_quantities : the quantities supplied by the counterparty (must all be positive) sender_payable_amount : the amount payable by the sender counterparty_payable_amount : the amount payable by the counterparty nonce : the nonce of the transaction Returns : the hash","title":"get_hash"},{"location":"aea/api/helpers/transaction/base/#encode_5","text":"| @staticmethod | encode ( terms_protobuf_object : Any , terms_object : \"Terms\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the terms_protobuf_object argument must be matched with the instance of this class in the 'terms_object' argument. Arguments : terms_protobuf_object : the protocol buffer object whose type corresponds with this class. terms_object : an instance of this class to be encoded in the protocol buffer object.","title":"encode"},{"location":"aea/api/helpers/transaction/base/#decode_5","text":"| @classmethod | decode ( cls , terms_protobuf_object : Any ) -> \"Terms\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'terms_protobuf_object' argument. Arguments : terms_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'terms_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/transaction/base/#__eq___5","text":"| __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"aea/api/helpers/transaction/base/#__str___5","text":"| __str__ () -> str Get string representation.","title":"__str__"},{"location":"aea/api/helpers/transaction/base/#transactiondigest-objects","text":"class TransactionDigest () This class represents an instance of TransactionDigest.","title":"TransactionDigest Objects"},{"location":"aea/api/helpers/transaction/base/#__init___6","text":"| __init__ ( ledger_id : str , body : str ) -> None Initialise an instance of TransactionDigest.","title":"__init__"},{"location":"aea/api/helpers/transaction/base/#ledger_id_6","text":"| @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"aea/api/helpers/transaction/base/#body_5","text":"| @property | body () -> str Get the receipt.","title":"body"},{"location":"aea/api/helpers/transaction/base/#encode_6","text":"| @staticmethod | encode ( transaction_digest_protobuf_object : Any , transaction_digest_object : \"TransactionDigest\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the transaction_digest_protobuf_object argument must be matched with the instance of this class in the 'transaction_digest_object' argument. Arguments : transaction_digest_protobuf_object : the protocol buffer object whose type corresponds with this class. transaction_digest_object : an instance of this class to be encoded in the protocol buffer object.","title":"encode"},{"location":"aea/api/helpers/transaction/base/#decode_6","text":"| @classmethod | decode ( cls , transaction_digest_protobuf_object : Any ) -> \"TransactionDigest\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'transaction_digest_protobuf_object' argument. Arguments : transaction_digest_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'transaction_digest_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/transaction/base/#__eq___6","text":"| __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"aea/api/helpers/transaction/base/#__str___6","text":"| __str__ () -> str Get string representation.","title":"__str__"},{"location":"aea/api/helpers/transaction/base/#transactionreceipt-objects","text":"class TransactionReceipt () This class represents an instance of TransactionReceipt.","title":"TransactionReceipt Objects"},{"location":"aea/api/helpers/transaction/base/#__init___7","text":"| __init__ ( ledger_id : str , receipt : JSONLike , transaction : JSONLike ) -> None Initialise an instance of TransactionReceipt.","title":"__init__"},{"location":"aea/api/helpers/transaction/base/#ledger_id_7","text":"| @property | ledger_id () -> str Get the id of the ledger on which the terms are to be settled.","title":"ledger_id"},{"location":"aea/api/helpers/transaction/base/#receipt","text":"| @property | receipt () -> JSONLike Get the receipt.","title":"receipt"},{"location":"aea/api/helpers/transaction/base/#transaction","text":"| @property | transaction () -> JSONLike Get the transaction.","title":"transaction"},{"location":"aea/api/helpers/transaction/base/#encode_7","text":"| @staticmethod | encode ( transaction_receipt_protobuf_object : Any , transaction_receipt_object : \"TransactionReceipt\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the transaction_receipt_protobuf_object argument must be matched with the instance of this class in the 'transaction_receipt_object' argument. Arguments : transaction_receipt_protobuf_object : the protocol buffer object whose type corresponds with this class. transaction_receipt_object : an instance of this class to be encoded in the protocol buffer object.","title":"encode"},{"location":"aea/api/helpers/transaction/base/#decode_7","text":"| @classmethod | decode ( cls , transaction_receipt_protobuf_object : Any ) -> \"TransactionReceipt\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class must be created that matches the protocol buffer object in the 'transaction_receipt_protobuf_object' argument. Arguments : transaction_receipt_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'transaction_receipt_protobuf_object' argument.","title":"decode"},{"location":"aea/api/helpers/transaction/base/#__eq___7","text":"| __eq__ ( other : Any ) -> bool Check equality.","title":"__eq__"},{"location":"aea/api/helpers/transaction/base/#__str___7","text":"| __str__ () -> str Get string representation.","title":"__str__"},{"location":"aea/api/identity/base/","text":"aea.identity.base This module contains the identity class. Identity Objects class Identity () The identity holds the public elements identifying an agent. It includes: the agent name the addresses, a map from address identifier to address (can be a single key-value pair) __ init __ | __init__ ( name : SimpleIdOrStr , address : Optional [ str ] = None , public_key : Optional [ str ] = None , addresses : Optional [ Dict [ str , Address ]] = None , public_keys : Optional [ Dict [ str , str ]] = None , default_address_key : str = DEFAULT_LEDGER ) -> None Instantiate the identity. Arguments : name : the name of the agent. address : the default address of the agent. public_key : the public key of the agent. addresses : the addresses of the agent. public_keys : the public keys of the agent. default_address_key : the key for the default address. default _ address _ key | @property | default_address_key () -> str Get the default address key. name | @property | name () -> str Get the agent name. addresses | @property | addresses () -> Dict [ str , Address ] Get the addresses. address | @property | address () -> Address Get the default address. public _ keys | @property | public_keys () -> Dict [ str , str ] Get the public keys. public _ key | @property | public_key () -> str Get the default public key.","title":"Identity"},{"location":"aea/api/identity/base/#aeaidentitybase","text":"This module contains the identity class.","title":"aea.identity.base"},{"location":"aea/api/identity/base/#identity-objects","text":"class Identity () The identity holds the public elements identifying an agent. It includes: the agent name the addresses, a map from address identifier to address (can be a single key-value pair)","title":"Identity Objects"},{"location":"aea/api/identity/base/#__init__","text":"| __init__ ( name : SimpleIdOrStr , address : Optional [ str ] = None , public_key : Optional [ str ] = None , addresses : Optional [ Dict [ str , Address ]] = None , public_keys : Optional [ Dict [ str , str ]] = None , default_address_key : str = DEFAULT_LEDGER ) -> None Instantiate the identity. Arguments : name : the name of the agent. address : the default address of the agent. public_key : the public key of the agent. addresses : the addresses of the agent. public_keys : the public keys of the agent. default_address_key : the key for the default address.","title":"__init__"},{"location":"aea/api/identity/base/#default_address_key","text":"| @property | default_address_key () -> str Get the default address key.","title":"default_address_key"},{"location":"aea/api/identity/base/#name","text":"| @property | name () -> str Get the agent name.","title":"name"},{"location":"aea/api/identity/base/#addresses","text":"| @property | addresses () -> Dict [ str , Address ] Get the addresses.","title":"addresses"},{"location":"aea/api/identity/base/#address","text":"| @property | address () -> Address Get the default address.","title":"address"},{"location":"aea/api/identity/base/#public_keys","text":"| @property | public_keys () -> Dict [ str , str ] Get the public keys.","title":"public_keys"},{"location":"aea/api/identity/base/#public_key","text":"| @property | public_key () -> str Get the default public key.","title":"public_key"},{"location":"aea/api/mail/base/","text":"aea.mail.base Mail module abstract base classes. URI Objects class URI () URI following RFC3986. __ init __ | __init__ ( uri_raw : str ) -> None Initialize the URI. Must follow: https://tools.ietf.org/html/rfc3986.html Arguments : uri_raw : the raw form uri scheme | @property | scheme () -> str Get the scheme. netloc | @property | netloc () -> str Get the netloc. path | @property | path () -> str Get the path. params | @property | params () -> str Get the params. query | @property | query () -> str Get the query. fragment | @property | fragment () -> str Get the fragment. username | @property | username () -> Optional [ str ] Get the username. password | @property | password () -> Optional [ str ] Get the password. host | @property | host () -> Optional [ str ] Get the host. port | @property | port () -> Optional [ int ] Get the port. __ str __ | __str__ () -> str Get string representation. __ eq __ | __eq__ ( other : Any ) -> bool Compare with another object. EnvelopeContext Objects class EnvelopeContext () Contains context information of an envelope. __ init __ | __init__ ( connection_id : Optional [ PublicId ] = None , uri : Optional [ URI ] = None ) -> None Initialize the envelope context. Arguments : connection_id : the connection id used for routing the outgoing envelope in the multiplexer. uri : the URI sent with the envelope. uri | @property | uri () -> Optional [ URI ] Get the URI. connection _ id | @property | connection_id () -> Optional [ PublicId ] Get the connection id to route the envelope. connection _ id | @connection_id . setter | connection_id ( connection_id : PublicId ) -> None Set the 'via' connection id. __ str __ | __str__ () -> str Get the string representation. __ eq __ | __eq__ ( other : Any ) -> bool Compare with another object. AEAConnectionError Objects class AEAConnectionError ( Exception ) Exception class for connection errors. Empty Objects class Empty ( Exception ) Exception for when the inbox is empty. EnvelopeSerializer Objects class EnvelopeSerializer ( ABC ) Abstract class to specify the serialization layer for the envelope. encode | @abstractmethod | encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. Arguments : envelope : the envelope to encode Returns : the encoded envelope decode | @abstractmethod | decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the encoded envelope Returns : the envelope ProtobufEnvelopeSerializer Objects class ProtobufEnvelopeSerializer ( EnvelopeSerializer ) Envelope serializer using Protobuf. encode | encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. Arguments : envelope : the envelope to encode Returns : the encoded envelope decode | decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. The default serializer doesn't decode the message field. Arguments : envelope_bytes : the encoded envelope Returns : the envelope Envelope Objects class Envelope () The top level message class for agent to agent communication. __ init __ | __init__ ( to : Address , sender : Address , message : Union [ Message , bytes ], context : Optional [ EnvelopeContext ] = None , protocol_specification_id : Optional [ PublicId ] = None ) -> None Initialize a Message object. Arguments : to : the address of the receiver. sender : the address of the sender. message : the protocol-specific message. context : the optional envelope context. protocol_specification_id : the protocol specification id (wire id). to | @property | to () -> Address Get address of receiver. to | @to . setter | to ( to : Address ) -> None Set address of receiver. sender | @property | sender () -> Address Get address of sender. sender | @sender . setter | sender ( sender : Address ) -> None Set address of sender. protocol _ specification _ id | @property | protocol_specification_id () -> PublicId Get protocol_specification_id. message | @property | message () -> Union [ Message , bytes ] Get the protocol-specific message. message | @message . setter | message ( message : Union [ Message , bytes ]) -> None Set the protocol-specific message. message _ bytes | @property | message_bytes () -> bytes Get the protocol-specific message. context | @property | context () -> Optional [ EnvelopeContext ] Get the envelope context. to _ as _ public _ id | @property | to_as_public_id () -> Optional [ PublicId ] Get to as public id. is _ sender _ public _ id | @property | is_sender_public_id () -> bool Check if sender is a public id. is _ to _ public _ id | @property | is_to_public_id () -> bool Check if to is a public id. is _ component _ to _ component _ message | @property | is_component_to_component_message () -> bool Whether or not the message contained is component to component. __ eq __ | __eq__ ( other : Any ) -> bool Compare with another object. encode | encode ( serializer : Optional [ EnvelopeSerializer ] = None ) -> bytes Encode the envelope. Arguments : serializer : the serializer that implements the encoding procedure. Returns : the encoded envelope. decode | @classmethod | decode ( cls , envelope_bytes : bytes , serializer : Optional [ EnvelopeSerializer ] = None ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the bytes to be decoded. serializer : the serializer that implements the decoding procedure. Returns : the decoded envelope. __ str __ | __str__ () -> str Get the string representation of an envelope.","title":"Mail"},{"location":"aea/api/mail/base/#aeamailbase","text":"Mail module abstract base classes.","title":"aea.mail.base"},{"location":"aea/api/mail/base/#uri-objects","text":"class URI () URI following RFC3986.","title":"URI Objects"},{"location":"aea/api/mail/base/#__init__","text":"| __init__ ( uri_raw : str ) -> None Initialize the URI. Must follow: https://tools.ietf.org/html/rfc3986.html Arguments : uri_raw : the raw form uri","title":"__init__"},{"location":"aea/api/mail/base/#scheme","text":"| @property | scheme () -> str Get the scheme.","title":"scheme"},{"location":"aea/api/mail/base/#netloc","text":"| @property | netloc () -> str Get the netloc.","title":"netloc"},{"location":"aea/api/mail/base/#path","text":"| @property | path () -> str Get the path.","title":"path"},{"location":"aea/api/mail/base/#params","text":"| @property | params () -> str Get the params.","title":"params"},{"location":"aea/api/mail/base/#query","text":"| @property | query () -> str Get the query.","title":"query"},{"location":"aea/api/mail/base/#fragment","text":"| @property | fragment () -> str Get the fragment.","title":"fragment"},{"location":"aea/api/mail/base/#username","text":"| @property | username () -> Optional [ str ] Get the username.","title":"username"},{"location":"aea/api/mail/base/#password","text":"| @property | password () -> Optional [ str ] Get the password.","title":"password"},{"location":"aea/api/mail/base/#host","text":"| @property | host () -> Optional [ str ] Get the host.","title":"host"},{"location":"aea/api/mail/base/#port","text":"| @property | port () -> Optional [ int ] Get the port.","title":"port"},{"location":"aea/api/mail/base/#__str__","text":"| __str__ () -> str Get string representation.","title":"__str__"},{"location":"aea/api/mail/base/#__eq__","text":"| __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/mail/base/#envelopecontext-objects","text":"class EnvelopeContext () Contains context information of an envelope.","title":"EnvelopeContext Objects"},{"location":"aea/api/mail/base/#__init___1","text":"| __init__ ( connection_id : Optional [ PublicId ] = None , uri : Optional [ URI ] = None ) -> None Initialize the envelope context. Arguments : connection_id : the connection id used for routing the outgoing envelope in the multiplexer. uri : the URI sent with the envelope.","title":"__init__"},{"location":"aea/api/mail/base/#uri","text":"| @property | uri () -> Optional [ URI ] Get the URI.","title":"uri"},{"location":"aea/api/mail/base/#connection_id","text":"| @property | connection_id () -> Optional [ PublicId ] Get the connection id to route the envelope.","title":"connection_id"},{"location":"aea/api/mail/base/#connection_id_1","text":"| @connection_id . setter | connection_id ( connection_id : PublicId ) -> None Set the 'via' connection id.","title":"connection_id"},{"location":"aea/api/mail/base/#__str___1","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/mail/base/#__eq___1","text":"| __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/mail/base/#aeaconnectionerror-objects","text":"class AEAConnectionError ( Exception ) Exception class for connection errors.","title":"AEAConnectionError Objects"},{"location":"aea/api/mail/base/#empty-objects","text":"class Empty ( Exception ) Exception for when the inbox is empty.","title":"Empty Objects"},{"location":"aea/api/mail/base/#envelopeserializer-objects","text":"class EnvelopeSerializer ( ABC ) Abstract class to specify the serialization layer for the envelope.","title":"EnvelopeSerializer Objects"},{"location":"aea/api/mail/base/#encode","text":"| @abstractmethod | encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. Arguments : envelope : the envelope to encode Returns : the encoded envelope","title":"encode"},{"location":"aea/api/mail/base/#decode","text":"| @abstractmethod | decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the encoded envelope Returns : the envelope","title":"decode"},{"location":"aea/api/mail/base/#protobufenvelopeserializer-objects","text":"class ProtobufEnvelopeSerializer ( EnvelopeSerializer ) Envelope serializer using Protobuf.","title":"ProtobufEnvelopeSerializer Objects"},{"location":"aea/api/mail/base/#encode_1","text":"| encode ( envelope : \"Envelope\" ) -> bytes Encode the envelope. Arguments : envelope : the envelope to encode Returns : the encoded envelope","title":"encode"},{"location":"aea/api/mail/base/#decode_1","text":"| decode ( envelope_bytes : bytes ) -> \"Envelope\" Decode the envelope. The default serializer doesn't decode the message field. Arguments : envelope_bytes : the encoded envelope Returns : the envelope","title":"decode"},{"location":"aea/api/mail/base/#envelope-objects","text":"class Envelope () The top level message class for agent to agent communication.","title":"Envelope Objects"},{"location":"aea/api/mail/base/#__init___2","text":"| __init__ ( to : Address , sender : Address , message : Union [ Message , bytes ], context : Optional [ EnvelopeContext ] = None , protocol_specification_id : Optional [ PublicId ] = None ) -> None Initialize a Message object. Arguments : to : the address of the receiver. sender : the address of the sender. message : the protocol-specific message. context : the optional envelope context. protocol_specification_id : the protocol specification id (wire id).","title":"__init__"},{"location":"aea/api/mail/base/#to","text":"| @property | to () -> Address Get address of receiver.","title":"to"},{"location":"aea/api/mail/base/#to_1","text":"| @to . setter | to ( to : Address ) -> None Set address of receiver.","title":"to"},{"location":"aea/api/mail/base/#sender","text":"| @property | sender () -> Address Get address of sender.","title":"sender"},{"location":"aea/api/mail/base/#sender_1","text":"| @sender . setter | sender ( sender : Address ) -> None Set address of sender.","title":"sender"},{"location":"aea/api/mail/base/#protocol_specification_id","text":"| @property | protocol_specification_id () -> PublicId Get protocol_specification_id.","title":"protocol_specification_id"},{"location":"aea/api/mail/base/#message","text":"| @property | message () -> Union [ Message , bytes ] Get the protocol-specific message.","title":"message"},{"location":"aea/api/mail/base/#message_1","text":"| @message . setter | message ( message : Union [ Message , bytes ]) -> None Set the protocol-specific message.","title":"message"},{"location":"aea/api/mail/base/#message_bytes","text":"| @property | message_bytes () -> bytes Get the protocol-specific message.","title":"message_bytes"},{"location":"aea/api/mail/base/#context","text":"| @property | context () -> Optional [ EnvelopeContext ] Get the envelope context.","title":"context"},{"location":"aea/api/mail/base/#to_as_public_id","text":"| @property | to_as_public_id () -> Optional [ PublicId ] Get to as public id.","title":"to_as_public_id"},{"location":"aea/api/mail/base/#is_sender_public_id","text":"| @property | is_sender_public_id () -> bool Check if sender is a public id.","title":"is_sender_public_id"},{"location":"aea/api/mail/base/#is_to_public_id","text":"| @property | is_to_public_id () -> bool Check if to is a public id.","title":"is_to_public_id"},{"location":"aea/api/mail/base/#is_component_to_component_message","text":"| @property | is_component_to_component_message () -> bool Whether or not the message contained is component to component.","title":"is_component_to_component_message"},{"location":"aea/api/mail/base/#__eq___2","text":"| __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/mail/base/#encode_2","text":"| encode ( serializer : Optional [ EnvelopeSerializer ] = None ) -> bytes Encode the envelope. Arguments : serializer : the serializer that implements the encoding procedure. Returns : the encoded envelope.","title":"encode"},{"location":"aea/api/mail/base/#decode_2","text":"| @classmethod | decode ( cls , envelope_bytes : bytes , serializer : Optional [ EnvelopeSerializer ] = None ) -> \"Envelope\" Decode the envelope. Arguments : envelope_bytes : the bytes to be decoded. serializer : the serializer that implements the decoding procedure. Returns : the decoded envelope.","title":"decode"},{"location":"aea/api/mail/base/#__str___2","text":"| __str__ () -> str Get the string representation of an envelope.","title":"__str__"},{"location":"aea/api/manager/manager/","text":"aea.manager.manager This module contains the implementation of AEA agents manager. ProjectNotFoundError Objects class ProjectNotFoundError ( ValueError ) Project not found exception. ProjectCheckError Objects class ProjectCheckError ( ValueError ) Project check error exception. __ init __ | __init__ ( msg : str , source_exception : Exception ) Init exception. ProjectPackageConsistencyCheckError Objects class ProjectPackageConsistencyCheckError ( ValueError ) Check consistency of package versions against already added project. __ init __ | __init__ ( agent_project_id : PublicId , conflicting_packages : List [ Tuple [ PackageIdPrefix , str , str , Set [ PublicId ]]]) Initialize the exception. Arguments : agent_project_id : the agent project id whose addition has failed. conflicting_packages : the conflicting packages. BaseAgentRunTask Objects class BaseAgentRunTask ( ABC ) Base abstract class for agent run tasks. start | @abstractmethod | start () -> None Start task. wait | @abstractmethod | wait () -> asyncio . Future Return future to wait task completed. stop | @abstractmethod | stop () -> None Stop task. is _ running | @property | @abstractmethod | is_running () -> bool Return is task running. AgentRunAsyncTask Objects class AgentRunAsyncTask ( BaseAgentRunTask ) Async task wrapper for agent. __ init __ | __init__ ( agent : AEA , loop : asyncio . AbstractEventLoop ) -> None Init task with agent alias and loop. create _ run _ loop | create_run_loop () -> None Create run loop. start | start () -> None Start task. wait | wait () -> asyncio . Future Return future to wait task completed. stop | stop () -> None Stop task. run | async run () -> None Run task body. is _ running | @property | is_running () -> bool Return is task running. AgentRunThreadTask Objects class AgentRunThreadTask ( AgentRunAsyncTask ) Threaded wrapper to run agent. __ init __ | __init__ ( agent : AEA , loop : asyncio . AbstractEventLoop ) -> None Init task with agent alias and loop. create _ run _ loop | create_run_loop () -> None Create run loop. start | start () -> None Run task in a dedicated thread. stop | stop () -> None Stop the task. AgentRunProcessTask Objects class AgentRunProcessTask ( BaseAgentRunTask ) Subprocess wrapper to run agent. __ init __ | __init__ ( agent_alias : AgentAlias , loop : asyncio . AbstractEventLoop ) -> None Init task with agent alias and loop. start | start () -> None Run task in a dedicated process. wait | wait () -> asyncio . Future Return future to wait task completed. stop | stop () -> None Stop the task. is _ running | @property | is_running () -> bool Is agent running. MultiAgentManager Objects class MultiAgentManager () Multi agents manager. __ init __ | __init__ ( working_dir : str , mode : str = \"async\" , registry_path : str = DEFAULT_REGISTRY_NAME , auto_add_remove_project : bool = False , password : Optional [ str ] = None ) -> None Initialize manager. Arguments : working_dir : directory to store base agents. mode : str. async or threaded registry_path : str. path to the local packages registry auto_add_remove_project : bool. add/remove project on the first agent add/last agent remove password : the password to encrypt/decrypt the private key. data _ dir | @property | data_dir () -> str Get the certs directory. get _ data _ dir _ of _ agent | get_data_dir_of_agent ( agent_name : str ) -> str Get the data directory of a specific agent. is _ running | @property | is_running () -> bool Is manager running. dict _ state | @property | dict_state () -> Dict [ str , Any ] Create MultiAgentManager dist state. projects | @property | projects () -> Dict [ PublicId , Project ] Get all projects. add _ error _ callback | add_error_callback ( error_callback : Callable [[ str , BaseException ], None ]) -> \"MultiAgentManager\" Add error callback to call on error raised. start _ manager | start_manager ( local : bool = False , remote : bool = False ) -> \"MultiAgentManager\" Start manager. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : local : whether or not to fetch from local registry. remote : whether or not to fetch from remote registry. Returns : the MultiAgentManager instance. last _ start _ status | @property | last_start_status () -> Tuple [ | bool , Dict [ PublicId , List [ Dict ]], List [ Tuple [ PublicId , List [ Dict ], Exception ]], | ] Get status of the last agents start loading state. stop _ manager | stop_manager ( cleanup : bool = True , save : bool = False ) -> \"MultiAgentManager\" Stop manager. Stops all running agents and stop agent. Arguments : cleanup : bool is cleanup on stop. save : bool is save state to file on stop. Returns : None add _ project | add_project ( public_id : PublicId , local : bool = False , remote : bool = False , restore : bool = False ) -> \"MultiAgentManager\" Fetch agent project and all dependencies to working_dir. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : public_id : the public if of the agent project. local : whether or not to fetch from local registry. remote : whether or not to fetch from remote registry. restore : bool flag for restoring already fetched agent. Returns : self remove _ project | remove_project ( public_id : PublicId , keep_files : bool = False ) -> \"MultiAgentManager\" Remove agent project. list _ projects | list_projects () -> List [ PublicId ] List all agents projects added. Returns : list of public ids of projects add _ agent | add_agent ( public_id : PublicId , agent_name : Optional [ str ] = None , agent_overrides : Optional [ dict ] = None , component_overrides : Optional [ List [ dict ]] = None , local : bool = False , remote : bool = False , restore : bool = False ) -> \"MultiAgentManager\" Create new agent configuration based on project with config overrides applied. Alias is stored in memory only! Arguments : public_id : base agent project public id agent_name : unique name for the agent agent_overrides : overrides for agent config. component_overrides : overrides for component section. local : whether or not to fetch from local registry. remote : whether or not to fetch from remote registry. restore : bool flag for restoring already fetched agent. Returns : self add _ agent _ with _ config | add_agent_with_config ( public_id : PublicId , config : List [ dict ], agent_name : Optional [ str ] = None ) -> \"MultiAgentManager\" Create new agent configuration based on project with config provided. Alias is stored in memory only! Arguments : public_id : base agent project public id agent_name : unique name for the agent config : agent config (used for agent re-creation). Returns : manager get _ agent _ overridables | get_agent_overridables ( agent_name : str ) -> Tuple [ Dict , List [ Dict ]] Get agent config overridables. Arguments : agent_name : str Returns : Tuple of agent overridables dict and and list of component overridables dict. set _ agent _ overrides | set_agent_overrides ( agent_name : str , agent_overides : Optional [ Dict ], components_overrides : Optional [ List [ Dict ]]) -> \"MultiAgentManager\" Set agent overrides. Arguments : agent_name : str agent_overides : optional dict of agent config overrides components_overrides : optional list of dict of components overrides Returns : self list _ agents _ info | list_agents_info () -> List [ Dict [ str , Any ]] List agents detailed info. Returns : list of dicts that represents agent info: public_id, name, is_running. list _ agents | list_agents ( running_only : bool = False ) -> List [ str ] List all agents. Arguments : running_only : returns only running if set to True Returns : list of agents names remove _ agent | remove_agent ( agent_name : str , skip_project_auto_remove : bool = False ) -> \"MultiAgentManager\" Remove agent alias definition from registry. Arguments : agent_name : agent name to remove skip_project_auto_remove : disable auto project remove on last agent removed. Returns : None start _ agent | start_agent ( agent_name : str ) -> \"MultiAgentManager\" Start selected agent. Arguments : agent_name : agent name to start Returns : None start _ all _ agents | start_all_agents () -> \"MultiAgentManager\" Start all not started agents. Returns : None stop _ agent | stop_agent ( agent_name : str ) -> \"MultiAgentManager\" Stop running agent. Arguments : agent_name : agent name to stop Returns : self stop _ all _ agents | stop_all_agents () -> \"MultiAgentManager\" Stop all agents running. Returns : self stop _ agents | stop_agents ( agent_names : List [ str ]) -> \"MultiAgentManager\" Stop specified agents. Arguments : agent_names : names of agents Returns : self start _ agents | start_agents ( agent_names : List [ str ]) -> \"MultiAgentManager\" Stop specified agents. Arguments : agent_names : names of agents Returns : self get _ agent _ alias | get_agent_alias ( agent_name : str ) -> AgentAlias Return details about agent alias definition. Arguments : agent_name : name of agent Returns : AgentAlias","title":"Manager"},{"location":"aea/api/manager/manager/#aeamanagermanager","text":"This module contains the implementation of AEA agents manager.","title":"aea.manager.manager"},{"location":"aea/api/manager/manager/#projectnotfounderror-objects","text":"class ProjectNotFoundError ( ValueError ) Project not found exception.","title":"ProjectNotFoundError Objects"},{"location":"aea/api/manager/manager/#projectcheckerror-objects","text":"class ProjectCheckError ( ValueError ) Project check error exception.","title":"ProjectCheckError Objects"},{"location":"aea/api/manager/manager/#__init__","text":"| __init__ ( msg : str , source_exception : Exception ) Init exception.","title":"__init__"},{"location":"aea/api/manager/manager/#projectpackageconsistencycheckerror-objects","text":"class ProjectPackageConsistencyCheckError ( ValueError ) Check consistency of package versions against already added project.","title":"ProjectPackageConsistencyCheckError Objects"},{"location":"aea/api/manager/manager/#__init___1","text":"| __init__ ( agent_project_id : PublicId , conflicting_packages : List [ Tuple [ PackageIdPrefix , str , str , Set [ PublicId ]]]) Initialize the exception. Arguments : agent_project_id : the agent project id whose addition has failed. conflicting_packages : the conflicting packages.","title":"__init__"},{"location":"aea/api/manager/manager/#baseagentruntask-objects","text":"class BaseAgentRunTask ( ABC ) Base abstract class for agent run tasks.","title":"BaseAgentRunTask Objects"},{"location":"aea/api/manager/manager/#start","text":"| @abstractmethod | start () -> None Start task.","title":"start"},{"location":"aea/api/manager/manager/#wait","text":"| @abstractmethod | wait () -> asyncio . Future Return future to wait task completed.","title":"wait"},{"location":"aea/api/manager/manager/#stop","text":"| @abstractmethod | stop () -> None Stop task.","title":"stop"},{"location":"aea/api/manager/manager/#is_running","text":"| @property | @abstractmethod | is_running () -> bool Return is task running.","title":"is_running"},{"location":"aea/api/manager/manager/#agentrunasynctask-objects","text":"class AgentRunAsyncTask ( BaseAgentRunTask ) Async task wrapper for agent.","title":"AgentRunAsyncTask Objects"},{"location":"aea/api/manager/manager/#__init___2","text":"| __init__ ( agent : AEA , loop : asyncio . AbstractEventLoop ) -> None Init task with agent alias and loop.","title":"__init__"},{"location":"aea/api/manager/manager/#create_run_loop","text":"| create_run_loop () -> None Create run loop.","title":"create_run_loop"},{"location":"aea/api/manager/manager/#start_1","text":"| start () -> None Start task.","title":"start"},{"location":"aea/api/manager/manager/#wait_1","text":"| wait () -> asyncio . Future Return future to wait task completed.","title":"wait"},{"location":"aea/api/manager/manager/#stop_1","text":"| stop () -> None Stop task.","title":"stop"},{"location":"aea/api/manager/manager/#run","text":"| async run () -> None Run task body.","title":"run"},{"location":"aea/api/manager/manager/#is_running_1","text":"| @property | is_running () -> bool Return is task running.","title":"is_running"},{"location":"aea/api/manager/manager/#agentrunthreadtask-objects","text":"class AgentRunThreadTask ( AgentRunAsyncTask ) Threaded wrapper to run agent.","title":"AgentRunThreadTask Objects"},{"location":"aea/api/manager/manager/#__init___3","text":"| __init__ ( agent : AEA , loop : asyncio . AbstractEventLoop ) -> None Init task with agent alias and loop.","title":"__init__"},{"location":"aea/api/manager/manager/#create_run_loop_1","text":"| create_run_loop () -> None Create run loop.","title":"create_run_loop"},{"location":"aea/api/manager/manager/#start_2","text":"| start () -> None Run task in a dedicated thread.","title":"start"},{"location":"aea/api/manager/manager/#stop_2","text":"| stop () -> None Stop the task.","title":"stop"},{"location":"aea/api/manager/manager/#agentrunprocesstask-objects","text":"class AgentRunProcessTask ( BaseAgentRunTask ) Subprocess wrapper to run agent.","title":"AgentRunProcessTask Objects"},{"location":"aea/api/manager/manager/#__init___4","text":"| __init__ ( agent_alias : AgentAlias , loop : asyncio . AbstractEventLoop ) -> None Init task with agent alias and loop.","title":"__init__"},{"location":"aea/api/manager/manager/#start_3","text":"| start () -> None Run task in a dedicated process.","title":"start"},{"location":"aea/api/manager/manager/#wait_2","text":"| wait () -> asyncio . Future Return future to wait task completed.","title":"wait"},{"location":"aea/api/manager/manager/#stop_3","text":"| stop () -> None Stop the task.","title":"stop"},{"location":"aea/api/manager/manager/#is_running_2","text":"| @property | is_running () -> bool Is agent running.","title":"is_running"},{"location":"aea/api/manager/manager/#multiagentmanager-objects","text":"class MultiAgentManager () Multi agents manager.","title":"MultiAgentManager Objects"},{"location":"aea/api/manager/manager/#__init___5","text":"| __init__ ( working_dir : str , mode : str = \"async\" , registry_path : str = DEFAULT_REGISTRY_NAME , auto_add_remove_project : bool = False , password : Optional [ str ] = None ) -> None Initialize manager. Arguments : working_dir : directory to store base agents. mode : str. async or threaded registry_path : str. path to the local packages registry auto_add_remove_project : bool. add/remove project on the first agent add/last agent remove password : the password to encrypt/decrypt the private key.","title":"__init__"},{"location":"aea/api/manager/manager/#data_dir","text":"| @property | data_dir () -> str Get the certs directory.","title":"data_dir"},{"location":"aea/api/manager/manager/#get_data_dir_of_agent","text":"| get_data_dir_of_agent ( agent_name : str ) -> str Get the data directory of a specific agent.","title":"get_data_dir_of_agent"},{"location":"aea/api/manager/manager/#is_running_3","text":"| @property | is_running () -> bool Is manager running.","title":"is_running"},{"location":"aea/api/manager/manager/#dict_state","text":"| @property | dict_state () -> Dict [ str , Any ] Create MultiAgentManager dist state.","title":"dict_state"},{"location":"aea/api/manager/manager/#projects","text":"| @property | projects () -> Dict [ PublicId , Project ] Get all projects.","title":"projects"},{"location":"aea/api/manager/manager/#add_error_callback","text":"| add_error_callback ( error_callback : Callable [[ str , BaseException ], None ]) -> \"MultiAgentManager\" Add error callback to call on error raised.","title":"add_error_callback"},{"location":"aea/api/manager/manager/#start_manager","text":"| start_manager ( local : bool = False , remote : bool = False ) -> \"MultiAgentManager\" Start manager. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : local : whether or not to fetch from local registry. remote : whether or not to fetch from remote registry. Returns : the MultiAgentManager instance.","title":"start_manager"},{"location":"aea/api/manager/manager/#last_start_status","text":"| @property | last_start_status () -> Tuple [ | bool , Dict [ PublicId , List [ Dict ]], List [ Tuple [ PublicId , List [ Dict ], Exception ]], | ] Get status of the last agents start loading state.","title":"last_start_status"},{"location":"aea/api/manager/manager/#stop_manager","text":"| stop_manager ( cleanup : bool = True , save : bool = False ) -> \"MultiAgentManager\" Stop manager. Stops all running agents and stop agent. Arguments : cleanup : bool is cleanup on stop. save : bool is save state to file on stop. Returns : None","title":"stop_manager"},{"location":"aea/api/manager/manager/#add_project","text":"| add_project ( public_id : PublicId , local : bool = False , remote : bool = False , restore : bool = False ) -> \"MultiAgentManager\" Fetch agent project and all dependencies to working_dir. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : public_id : the public if of the agent project. local : whether or not to fetch from local registry. remote : whether or not to fetch from remote registry. restore : bool flag for restoring already fetched agent. Returns : self","title":"add_project"},{"location":"aea/api/manager/manager/#remove_project","text":"| remove_project ( public_id : PublicId , keep_files : bool = False ) -> \"MultiAgentManager\" Remove agent project.","title":"remove_project"},{"location":"aea/api/manager/manager/#list_projects","text":"| list_projects () -> List [ PublicId ] List all agents projects added. Returns : list of public ids of projects","title":"list_projects"},{"location":"aea/api/manager/manager/#add_agent","text":"| add_agent ( public_id : PublicId , agent_name : Optional [ str ] = None , agent_overrides : Optional [ dict ] = None , component_overrides : Optional [ List [ dict ]] = None , local : bool = False , remote : bool = False , restore : bool = False ) -> \"MultiAgentManager\" Create new agent configuration based on project with config overrides applied. Alias is stored in memory only! Arguments : public_id : base agent project public id agent_name : unique name for the agent agent_overrides : overrides for agent config. component_overrides : overrides for component section. local : whether or not to fetch from local registry. remote : whether or not to fetch from remote registry. restore : bool flag for restoring already fetched agent. Returns : self","title":"add_agent"},{"location":"aea/api/manager/manager/#add_agent_with_config","text":"| add_agent_with_config ( public_id : PublicId , config : List [ dict ], agent_name : Optional [ str ] = None ) -> \"MultiAgentManager\" Create new agent configuration based on project with config provided. Alias is stored in memory only! Arguments : public_id : base agent project public id agent_name : unique name for the agent config : agent config (used for agent re-creation). Returns : manager","title":"add_agent_with_config"},{"location":"aea/api/manager/manager/#get_agent_overridables","text":"| get_agent_overridables ( agent_name : str ) -> Tuple [ Dict , List [ Dict ]] Get agent config overridables. Arguments : agent_name : str Returns : Tuple of agent overridables dict and and list of component overridables dict.","title":"get_agent_overridables"},{"location":"aea/api/manager/manager/#set_agent_overrides","text":"| set_agent_overrides ( agent_name : str , agent_overides : Optional [ Dict ], components_overrides : Optional [ List [ Dict ]]) -> \"MultiAgentManager\" Set agent overrides. Arguments : agent_name : str agent_overides : optional dict of agent config overrides components_overrides : optional list of dict of components overrides Returns : self","title":"set_agent_overrides"},{"location":"aea/api/manager/manager/#list_agents_info","text":"| list_agents_info () -> List [ Dict [ str , Any ]] List agents detailed info. Returns : list of dicts that represents agent info: public_id, name, is_running.","title":"list_agents_info"},{"location":"aea/api/manager/manager/#list_agents","text":"| list_agents ( running_only : bool = False ) -> List [ str ] List all agents. Arguments : running_only : returns only running if set to True Returns : list of agents names","title":"list_agents"},{"location":"aea/api/manager/manager/#remove_agent","text":"| remove_agent ( agent_name : str , skip_project_auto_remove : bool = False ) -> \"MultiAgentManager\" Remove agent alias definition from registry. Arguments : agent_name : agent name to remove skip_project_auto_remove : disable auto project remove on last agent removed. Returns : None","title":"remove_agent"},{"location":"aea/api/manager/manager/#start_agent","text":"| start_agent ( agent_name : str ) -> \"MultiAgentManager\" Start selected agent. Arguments : agent_name : agent name to start Returns : None","title":"start_agent"},{"location":"aea/api/manager/manager/#start_all_agents","text":"| start_all_agents () -> \"MultiAgentManager\" Start all not started agents. Returns : None","title":"start_all_agents"},{"location":"aea/api/manager/manager/#stop_agent","text":"| stop_agent ( agent_name : str ) -> \"MultiAgentManager\" Stop running agent. Arguments : agent_name : agent name to stop Returns : self","title":"stop_agent"},{"location":"aea/api/manager/manager/#stop_all_agents","text":"| stop_all_agents () -> \"MultiAgentManager\" Stop all agents running. Returns : self","title":"stop_all_agents"},{"location":"aea/api/manager/manager/#stop_agents","text":"| stop_agents ( agent_names : List [ str ]) -> \"MultiAgentManager\" Stop specified agents. Arguments : agent_names : names of agents Returns : self","title":"stop_agents"},{"location":"aea/api/manager/manager/#start_agents","text":"| start_agents ( agent_names : List [ str ]) -> \"MultiAgentManager\" Stop specified agents. Arguments : agent_names : names of agents Returns : self","title":"start_agents"},{"location":"aea/api/manager/manager/#get_agent_alias","text":"| get_agent_alias ( agent_name : str ) -> AgentAlias Return details about agent alias definition. Arguments : agent_name : name of agent Returns : AgentAlias","title":"get_agent_alias"},{"location":"aea/api/manager/project/","text":"aea.manager.project This module contains the implementation of AEA agents project configuration. _ Base Objects class _Base () Base class to share some methods. builder | @property | builder () -> AEABuilder Get AEABuilder instance. install _ pypi _ dependencies | install_pypi_dependencies () -> None Install python dependencies for the project. Project Objects class Project ( _Base ) Agent project representation. __ init __ | __init__ ( public_id : PublicId , path : str ) -> None Init project with public_id and project's path. build | build () -> None Call all build entry points. load | @classmethod | load ( cls , working_dir : str , public_id : PublicId , is_local : bool = False , is_remote : bool = False , is_restore : bool = False , cli_verbosity : str = \"INFO\" , registry_path : str = DEFAULT_REGISTRY_NAME , skip_consistency_check : bool = False , skip_aea_validation : bool = False ) -> \"Project\" Load project with given public_id to working_dir. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : working_dir : the working directory public_id : the public id is_local : whether to fetch from local is_remote : whether to fetch from remote is_restore : whether to restore or not cli_verbosity : the logging verbosity of the CLI registry_path : the path to the registry locally skip_consistency_check : consistency checks flag skip_aea_validation : aea validation flag Returns : project remove | remove () -> None Remove project, do cleanup. agent _ config | @property | agent_config () -> AgentConfig Get the agent configuration. builder | @property | builder () -> AEABuilder Get builder instance. check | check () -> None Check we can still construct an AEA from the project with builder.build. AgentAlias Objects class AgentAlias ( _Base ) Agent alias representation. __ init __ | __init__ ( project : Project , agent_name : str , data_dir : str , password : Optional [ str ] = None ) Init agent alias with project, config, name, agent, builder. set _ agent _ config _ from _ data | set_agent_config_from_data ( json_data : List [ Dict ]) -> None Set agent config instance constructed from json data. Arguments : json_data : agent config json data builder | @property | builder () -> AEABuilder Get builder instance. agent _ config | @property | agent_config () -> AgentConfig Get agent config. remove _ from _ project | remove_from_project () -> None Remove agent alias from project. dict | @property | dict () -> Dict [ str , Any ] Convert AgentAlias to dict. config _ json | @property | config_json () -> List [ Dict ] Get agent config json data. get _ aea _ instance | get_aea_instance () -> AEA Build new aea instance. issue _ certificates | issue_certificates () -> None Issue the certificates for this agent. set _ overrides | set_overrides ( agent_overrides : Optional [ Dict ] = None , component_overrides : Optional [ List [ Dict ]] = None ) -> None Set override for this agent alias's config. agent _ config _ manager | @property | agent_config_manager () -> AgentConfigManager Get agent configuration manager instance for the config. get _ overridables | get_overridables () -> Tuple [ Dict , List [ Dict ]] Get all overridables for this agent alias's config. get _ addresses | get_addresses () -> Dict [ str , str ] Get addresses from private keys. Returns : dict with crypto id str as key and address str as value get _ connections _ addresses | get_connections_addresses () -> Dict [ str , str ] Get connections addresses from connections private keys. Returns : dict with crypto id str as key and address str as value","title":"Project"},{"location":"aea/api/manager/project/#aeamanagerproject","text":"This module contains the implementation of AEA agents project configuration.","title":"aea.manager.project"},{"location":"aea/api/manager/project/#_base-objects","text":"class _Base () Base class to share some methods.","title":"_Base Objects"},{"location":"aea/api/manager/project/#builder","text":"| @property | builder () -> AEABuilder Get AEABuilder instance.","title":"builder"},{"location":"aea/api/manager/project/#install_pypi_dependencies","text":"| install_pypi_dependencies () -> None Install python dependencies for the project.","title":"install_pypi_dependencies"},{"location":"aea/api/manager/project/#project-objects","text":"class Project ( _Base ) Agent project representation.","title":"Project Objects"},{"location":"aea/api/manager/project/#__init__","text":"| __init__ ( public_id : PublicId , path : str ) -> None Init project with public_id and project's path.","title":"__init__"},{"location":"aea/api/manager/project/#build","text":"| build () -> None Call all build entry points.","title":"build"},{"location":"aea/api/manager/project/#load","text":"| @classmethod | load ( cls , working_dir : str , public_id : PublicId , is_local : bool = False , is_remote : bool = False , is_restore : bool = False , cli_verbosity : str = \"INFO\" , registry_path : str = DEFAULT_REGISTRY_NAME , skip_consistency_check : bool = False , skip_aea_validation : bool = False ) -> \"Project\" Load project with given public_id to working_dir. If local = False and remote = False, then the packages are fetched in mixed mode (i.e. first try from local registry, and then from remote registry in case of failure). Arguments : working_dir : the working directory public_id : the public id is_local : whether to fetch from local is_remote : whether to fetch from remote is_restore : whether to restore or not cli_verbosity : the logging verbosity of the CLI registry_path : the path to the registry locally skip_consistency_check : consistency checks flag skip_aea_validation : aea validation flag Returns : project","title":"load"},{"location":"aea/api/manager/project/#remove","text":"| remove () -> None Remove project, do cleanup.","title":"remove"},{"location":"aea/api/manager/project/#agent_config","text":"| @property | agent_config () -> AgentConfig Get the agent configuration.","title":"agent_config"},{"location":"aea/api/manager/project/#builder_1","text":"| @property | builder () -> AEABuilder Get builder instance.","title":"builder"},{"location":"aea/api/manager/project/#check","text":"| check () -> None Check we can still construct an AEA from the project with builder.build.","title":"check"},{"location":"aea/api/manager/project/#agentalias-objects","text":"class AgentAlias ( _Base ) Agent alias representation.","title":"AgentAlias Objects"},{"location":"aea/api/manager/project/#__init___1","text":"| __init__ ( project : Project , agent_name : str , data_dir : str , password : Optional [ str ] = None ) Init agent alias with project, config, name, agent, builder.","title":"__init__"},{"location":"aea/api/manager/project/#set_agent_config_from_data","text":"| set_agent_config_from_data ( json_data : List [ Dict ]) -> None Set agent config instance constructed from json data. Arguments : json_data : agent config json data","title":"set_agent_config_from_data"},{"location":"aea/api/manager/project/#builder_2","text":"| @property | builder () -> AEABuilder Get builder instance.","title":"builder"},{"location":"aea/api/manager/project/#agent_config_1","text":"| @property | agent_config () -> AgentConfig Get agent config.","title":"agent_config"},{"location":"aea/api/manager/project/#remove_from_project","text":"| remove_from_project () -> None Remove agent alias from project.","title":"remove_from_project"},{"location":"aea/api/manager/project/#dict","text":"| @property | dict () -> Dict [ str , Any ] Convert AgentAlias to dict.","title":"dict"},{"location":"aea/api/manager/project/#config_json","text":"| @property | config_json () -> List [ Dict ] Get agent config json data.","title":"config_json"},{"location":"aea/api/manager/project/#get_aea_instance","text":"| get_aea_instance () -> AEA Build new aea instance.","title":"get_aea_instance"},{"location":"aea/api/manager/project/#issue_certificates","text":"| issue_certificates () -> None Issue the certificates for this agent.","title":"issue_certificates"},{"location":"aea/api/manager/project/#set_overrides","text":"| set_overrides ( agent_overrides : Optional [ Dict ] = None , component_overrides : Optional [ List [ Dict ]] = None ) -> None Set override for this agent alias's config.","title":"set_overrides"},{"location":"aea/api/manager/project/#agent_config_manager","text":"| @property | agent_config_manager () -> AgentConfigManager Get agent configuration manager instance for the config.","title":"agent_config_manager"},{"location":"aea/api/manager/project/#get_overridables","text":"| get_overridables () -> Tuple [ Dict , List [ Dict ]] Get all overridables for this agent alias's config.","title":"get_overridables"},{"location":"aea/api/manager/project/#get_addresses","text":"| get_addresses () -> Dict [ str , str ] Get addresses from private keys. Returns : dict with crypto id str as key and address str as value","title":"get_addresses"},{"location":"aea/api/manager/project/#get_connections_addresses","text":"| get_connections_addresses () -> Dict [ str , str ] Get connections addresses from connections private keys. Returns : dict with crypto id str as key and address str as value","title":"get_connections_addresses"},{"location":"aea/api/manager/utils/","text":"aea.manager.utils Multiagent manager utils. get _ lib _ path get_lib_path ( env_dir : str ) -> str Get librarty path for env dir. make _ venv make_venv ( env_dir : str , set_env : bool = False ) -> None Make venv and update variable to use it. Arguments : env_dir : str, path for new env dir set_env : bool. use evn within this python process (update, sys.executable and sys.path) project _ install _ and _ build project_install_and_build ( project : Project ) -> None Install project dependencies and build required components. get _ venv _ dir _ for _ project get_venv_dir_for_project ( project : Project ) -> str Get virtual env directory for project specified. project _ check project_check ( project : Project ) -> None Perform project loads well. run _ in _ venv run_in_venv ( env_dir : str , fn : Callable , timeout : float , * args : Any ) -> Any Run python function in a dedicated process with virtual env specified.","title":"Utils"},{"location":"aea/api/manager/utils/#aeamanagerutils","text":"Multiagent manager utils.","title":"aea.manager.utils"},{"location":"aea/api/manager/utils/#get_lib_path","text":"get_lib_path ( env_dir : str ) -> str Get librarty path for env dir.","title":"get_lib_path"},{"location":"aea/api/manager/utils/#make_venv","text":"make_venv ( env_dir : str , set_env : bool = False ) -> None Make venv and update variable to use it. Arguments : env_dir : str, path for new env dir set_env : bool. use evn within this python process (update, sys.executable and sys.path)","title":"make_venv"},{"location":"aea/api/manager/utils/#project_install_and_build","text":"project_install_and_build ( project : Project ) -> None Install project dependencies and build required components.","title":"project_install_and_build"},{"location":"aea/api/manager/utils/#get_venv_dir_for_project","text":"get_venv_dir_for_project ( project : Project ) -> str Get virtual env directory for project specified.","title":"get_venv_dir_for_project"},{"location":"aea/api/manager/utils/#project_check","text":"project_check ( project : Project ) -> None Perform project loads well.","title":"project_check"},{"location":"aea/api/manager/utils/#run_in_venv","text":"run_in_venv ( env_dir : str , fn : Callable , timeout : float , * args : Any ) -> Any Run python function in a dedicated process with virtual env specified.","title":"run_in_venv"},{"location":"aea/api/plugins/aea_cli_ipfs/core/","text":"plugins.aea-cli-ipfs.aea _ cli _ ipfs.core Core components for ipfs cli command . ipfs @click . group () @click . pass_context ipfs ( click_context : click . Context ) -> None IPFS Commands process _ result @ipfs . resultcallback () @click . pass_context process_result ( click_context : click . Context , * _ : Any ) -> None Tear down command group. add @ipfs . command () @click . argument ( \"dir_path\" , type = click . Path ( exists = True , dir_okay = True , file_okay = False , resolve_path = True , readable = True ), required = False , ) @click . option ( \"-p\" , \"--publish\" , is_flag = True ) @click . option ( \"--no-pin\" , is_flag = True ) @click . pass_context add ( click_context : click . Context , dir_path : Optional [ str ], publish : bool = False , no_pin : bool = False ) -> None Add directory to ipfs, if not directory specified the current one will be added. remove @ipfs . command () @click . argument ( \"hash_\" , metavar = \"hash\" , type = str , required = True , ) @click . pass_context remove ( click_context : click . Context , hash_ : str ) -> None Remove a directory from ipfs by it's hash. download @ipfs . command () @click . argument ( \"hash_\" , metavar = \"hash\" , type = str , required = True , ) @click . argument ( \"target_dir\" , type = click . Path ( dir_okay = True , file_okay = False , resolve_path = True ), required = False , ) @click . pass_context download ( click_context : click . Context , hash_ : str , target_dir : Optional [ str ]) -> None Download directory by it's hash, if not target directory specified will use current one.","title":"API"},{"location":"aea/api/plugins/aea_cli_ipfs/core/#pluginsaea-cli-ipfsaea_cli_ipfscore","text":"Core components for ipfs cli command .","title":"plugins.aea-cli-ipfs.aea_cli_ipfs.core"},{"location":"aea/api/plugins/aea_cli_ipfs/core/#ipfs","text":"@click . group () @click . pass_context ipfs ( click_context : click . Context ) -> None IPFS Commands","title":"ipfs"},{"location":"aea/api/plugins/aea_cli_ipfs/core/#process_result","text":"@ipfs . resultcallback () @click . pass_context process_result ( click_context : click . Context , * _ : Any ) -> None Tear down command group.","title":"process_result"},{"location":"aea/api/plugins/aea_cli_ipfs/core/#add","text":"@ipfs . command () @click . argument ( \"dir_path\" , type = click . Path ( exists = True , dir_okay = True , file_okay = False , resolve_path = True , readable = True ), required = False , ) @click . option ( \"-p\" , \"--publish\" , is_flag = True ) @click . option ( \"--no-pin\" , is_flag = True ) @click . pass_context add ( click_context : click . Context , dir_path : Optional [ str ], publish : bool = False , no_pin : bool = False ) -> None Add directory to ipfs, if not directory specified the current one will be added.","title":"add"},{"location":"aea/api/plugins/aea_cli_ipfs/core/#remove","text":"@ipfs . command () @click . argument ( \"hash_\" , metavar = \"hash\" , type = str , required = True , ) @click . pass_context remove ( click_context : click . Context , hash_ : str ) -> None Remove a directory from ipfs by it's hash.","title":"remove"},{"location":"aea/api/plugins/aea_cli_ipfs/core/#download","text":"@ipfs . command () @click . argument ( \"hash_\" , metavar = \"hash\" , type = str , required = True , ) @click . argument ( \"target_dir\" , type = click . Path ( dir_okay = True , file_okay = False , resolve_path = True ), required = False , ) @click . pass_context download ( click_context : click . Context , hash_ : str , target_dir : Optional [ str ]) -> None Download directory by it's hash, if not target directory specified will use current one.","title":"download"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/","text":"plugins.aea-cli-ipfs.aea _ cli _ ipfs.ipfs _ utils Ipfs utils for ipfs cli command . IPFSDaemon Objects class IPFSDaemon () Set up the IPFS daemon. Raises : Exception : if IPFS is not installed. __ init __ | __init__ () -> None Initialise IPFS daemon. is _ started | is_started () -> bool Check daemon was started. start | start () -> None Run the ipfs daemon. stop | stop () -> None Terminate the ipfs daemon. BaseIPFSToolException Objects class BaseIPFSToolException ( Exception ) Base ipfs tool exception. RemoveError Objects class RemoveError ( BaseIPFSToolException ) Exception on remove. PublishError Objects class PublishError ( BaseIPFSToolException ) Exception on publish. NodeError Objects class NodeError ( BaseIPFSToolException ) Exception for node connection check. DownloadError Objects class DownloadError ( BaseIPFSToolException ) Exception on download failed. IPFSTool Objects class IPFSTool () IPFS tool to add, publish, remove, download directories. __ init __ | __init__ ( client_options : Optional [ Dict ] = None ) Init tool. Arguments : client_options : dict, options for ipfshttpclient instance. add | add ( dir_path : str , pin : bool = True ) -> Tuple [ str , str , List ] Add directory to ipfs. It wraps into directory. Arguments : dir_path : str, path to dir to publish pin : bool, pin object or not Returns : dir name published, hash, list of items processed remove | remove ( hash_id : str ) -> Dict Remove dir added by it's hash. Arguments : hash_id : str. hash of dir to remove Returns : dict with unlinked items. download | download ( hash_id : str , target_dir : str , fix_path : bool = True ) -> None Download dir by it's hash. Arguments : hash_id : str. hash of file to download target_dir : str. directory to place downloaded fix_path : bool. default True. on download don't wrap result in to hash_id directory. publish | publish ( hash_id : str ) -> Dict Publish directory by it's hash id. Arguments : hash_id : hash of the directory to publish. Returns : dict of names it was publish for. chec _ ipfs _ node _ running | chec_ipfs_node_running () -> None Check ipfs node running.","title":"Utils"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#pluginsaea-cli-ipfsaea_cli_ipfsipfs_utils","text":"Ipfs utils for ipfs cli command .","title":"plugins.aea-cli-ipfs.aea_cli_ipfs.ipfs_utils"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#ipfsdaemon-objects","text":"class IPFSDaemon () Set up the IPFS daemon. Raises : Exception : if IPFS is not installed.","title":"IPFSDaemon Objects"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#__init__","text":"| __init__ () -> None Initialise IPFS daemon.","title":"__init__"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#is_started","text":"| is_started () -> bool Check daemon was started.","title":"is_started"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#start","text":"| start () -> None Run the ipfs daemon.","title":"start"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#stop","text":"| stop () -> None Terminate the ipfs daemon.","title":"stop"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#baseipfstoolexception-objects","text":"class BaseIPFSToolException ( Exception ) Base ipfs tool exception.","title":"BaseIPFSToolException Objects"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#removeerror-objects","text":"class RemoveError ( BaseIPFSToolException ) Exception on remove.","title":"RemoveError Objects"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#publisherror-objects","text":"class PublishError ( BaseIPFSToolException ) Exception on publish.","title":"PublishError Objects"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#nodeerror-objects","text":"class NodeError ( BaseIPFSToolException ) Exception for node connection check.","title":"NodeError Objects"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#downloaderror-objects","text":"class DownloadError ( BaseIPFSToolException ) Exception on download failed.","title":"DownloadError Objects"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#ipfstool-objects","text":"class IPFSTool () IPFS tool to add, publish, remove, download directories.","title":"IPFSTool Objects"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#__init___1","text":"| __init__ ( client_options : Optional [ Dict ] = None ) Init tool. Arguments : client_options : dict, options for ipfshttpclient instance.","title":"__init__"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#add","text":"| add ( dir_path : str , pin : bool = True ) -> Tuple [ str , str , List ] Add directory to ipfs. It wraps into directory. Arguments : dir_path : str, path to dir to publish pin : bool, pin object or not Returns : dir name published, hash, list of items processed","title":"add"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#remove","text":"| remove ( hash_id : str ) -> Dict Remove dir added by it's hash. Arguments : hash_id : str. hash of dir to remove Returns : dict with unlinked items.","title":"remove"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#download","text":"| download ( hash_id : str , target_dir : str , fix_path : bool = True ) -> None Download dir by it's hash. Arguments : hash_id : str. hash of file to download target_dir : str. directory to place downloaded fix_path : bool. default True. on download don't wrap result in to hash_id directory.","title":"download"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#publish","text":"| publish ( hash_id : str ) -> Dict Publish directory by it's hash id. Arguments : hash_id : hash of the directory to publish. Returns : dict of names it was publish for.","title":"publish"},{"location":"aea/api/plugins/aea_cli_ipfs/ipfs_utils/#chec_ipfs_node_running","text":"| chec_ipfs_node_running () -> None Check ipfs node running.","title":"chec_ipfs_node_running"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/","text":"plugins.aea-ledger-cosmos.aea _ ledger _ cosmos.cosmos Cosmos module wrapping the public and private key cryptography and ledger api. DataEncrypt Objects class DataEncrypt () Class to encrypt/decrypt data strings with password provided. encrypt | @classmethod | encrypt ( cls , data : bytes , password : str ) -> bytes Encrypt data with password. bytes _ encode | @staticmethod | bytes_encode ( data : bytes ) -> str Encode bytes to ascii friendly string. bytes _ decode | @staticmethod | bytes_decode ( data : str ) -> bytes Decode ascii friendly string to bytes. decrypt | @classmethod | decrypt ( cls , encrypted_data : bytes , password : str ) -> bytes Decrypt data with password provided. CosmosHelper Objects class CosmosHelper ( Helper ) Helper class usable as Mixin for CosmosApi or as standalone class. is _ transaction _ settled | @staticmethod | is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_receipt : the receipt of the transaction. Returns : True if the transaction has been settled, False o/w. get _ code _ id | @staticmethod | get_code_id ( tx_receipt : JSONLike ) -> Optional [ int ] Retrieve the code_id from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the code id, if present get _ contract _ address | @staticmethod | get_contract_address ( tx_receipt : JSONLike ) -> Optional [ str ] Retrieve the contract_address from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the contract address, if present is _ transaction _ valid | @staticmethod | is_transaction_valid ( tx : JSONLike , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input'] generate _ tx _ nonce | @staticmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish transactions with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. get _ address _ from _ public _ key | @classmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str recover _ message | @classmethod | recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses recover _ public _ keys _ from _ message | @classmethod | recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys get _ hash | @staticmethod | get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message. is _ valid _ address | @classmethod | is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate Returns : whether address is valid or not load _ contract _ interface | @classmethod | load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface CosmosCrypto Objects class CosmosCrypto ( Crypto [ SigningKey ]) Class wrapping the Account Generation from Ethereum ledger. __ init __ | __init__ ( private_key_path : Optional [ str ] = None , password : Optional [ str ] = None ) -> None Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent password : the password to encrypt/decrypt the private key. private _ key | @property | private_key () -> str Return a private key. Returns : a private key string public _ key | @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format address | @property | address () -> str Return the address for the key pair. Returns : a display_address str load _ private _ key _ from _ path | @classmethod | load_private_key_from_path ( cls , file_name : str , password : Optional [ str ] = None ) -> SigningKey Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. password : the password to encrypt/decrypt the private key. Returns : the Entity. sign _ message | sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form sign _ transaction | sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction generate _ private _ key | @classmethod | generate_private_key ( cls ) -> SigningKey Generate a key pair for cosmos network. encrypt | encrypt ( password : str ) -> str Encrypt the private key and return in json. Arguments : password : the password to decrypt. Returns : json string containing encrypted private key. decrypt | @classmethod | decrypt ( cls , keyfile_json : str , password : str ) -> str Decrypt the private key and return in raw form. Arguments : keyfile_json : json string containing encrypted private key. password : the password to decrypt. Returns : the raw private key. _ CosmosApi Objects class _CosmosApi ( LedgerApi ) Class to interact with the Cosmos SDK via a HTTP APIs. __ init __ | __init__ ( ** kwargs : Any ) -> None Initialize the Cosmos ledger APIs. api | @property | api () -> Any Get the underlying API object. get _ balance | get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. get _ state | get_state ( callable_name : str , * args : Any , ** kwargs : Any ) -> Optional [ JSONLike ] Call a specified function on the ledger API. Based on the cosmos REST API specification, which takes a path (strings separated by '/'). The convention here is to define the root of the path (txs, blocks, etc.) as the callable_name and the rest of the path as args. Arguments : callable_name : name of the callable args : positional arguments kwargs : keyword arguments Returns : the transaction dictionary get _ deploy _ transaction | get_deploy_transaction ( contract_interface : Dict [ str , str ], deployer_address : Address , ** kwargs : Any , ,) -> Optional [ JSONLike ] Get the transaction to deploy the smart contract. Dispatches to _get_storage_transaction and _get_init_transaction based on kwargs. Arguments : contract_interface : the contract interface. deployer_address : The address that will deploy the contract. kwargs : keyword arguments. Returns : the transaction dictionary. get _ handle _ transaction | get_handle_transaction ( sender_address : Address , contract_address : Address , handle_msg : Any , amount : int , tx_fee : int , denom : Optional [ str ] = None , gas : int = DEFAULT_GAS_AMOUNT , memo : str = \"\" , chain_id : Optional [ str ] = None , account_number : Optional [ int ] = None , sequence : Optional [ int ] = None , tx_fee_denom : Optional [ str ] = None ) -> Optional [ JSONLike ] Create a CosmWasm HandleMsg transaction. Arguments : sender_address : the sender address of the message initiator. contract_address : the address of the smart contract. handle_msg : HandleMsg in JSON format. amount : Funds amount sent with transaction. tx_fee : the tx fee accepted. denom : the name of the denomination of the contract funds gas : Maximum amount of gas to be used on executing command. memo : any string comment. chain_id : the Chain ID of the CosmWasm transaction. Default is 1 (i.e. mainnet). account_number : Account number sequence : Sequence tx_fee_denom : Denomination of tx_fee, identical with denom param when None Returns : the unsigned CosmWasm HandleMsg execute _ contract _ query | execute_contract_query ( contract_address : Address , query_msg : JSONLike ) -> Optional [ JSONLike ] Execute a CosmWasm QueryMsg. QueryMsg doesn't require signing. Arguments : contract_address : the address of the smart contract. query_msg : QueryMsg in JSON format. Returns : the message receipt get _ transfer _ transaction | get_transfer_transaction ( sender_address : Address , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , denom : Optional [ str ] = None , gas : int = DEFAULT_GAS_AMOUNT , memo : str = \"\" , chain_id : Optional [ str ] = None , account_number : Optional [ int ] = None , sequence : Optional [ int ] = None , tx_fee_denom : Optional [ str ] = None , ** kwargs : Any , ,) -> Optional [ JSONLike ] Submit a transfer transaction to the ledger. Arguments : sender_address : the sender address of the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx denom : the denomination of tx fee and amount gas : the gas used. memo : memo to include in tx. chain_id : the chain ID of the transaction. account_number : Account number sequence : Sequence tx_fee_denom : Denomination of tx_fee, identical with denom param when None kwargs : keyword arguments. Returns : the transfer transaction get _ packed _ exec _ msg | get_packed_exec_msg ( sender_address : Address , contract_address : str , msg : JSONLike , funds : int = 0 , denom : Optional [ str ] = None ) -> ProtoAny Create and pack MsgExecuteContract Arguments : sender_address : Address of sender contract_address : Address of contract msg : Paramaters to be passed to smart contract funds : Funds to be sent to smart contract denom : the denomination of funds Returns : Packed MsgExecuteContract get _ packed _ send _ msg | get_packed_send_msg ( from_address : Address , to_address : Address , amount : int , denom : Optional [ str ] = None ) -> ProtoAny Generate and pack MsgSend Arguments : from_address : Address of sender to_address : Address of recipient amount : amount of coins to be sent denom : the denomination of and amount Returns : packer ProtoAny type message get _ multi _ transaction | get_multi_transaction ( from_addresses : List [ str ], pub_keys : Optional [ List [ bytes ]], msgs : List [ ProtoAny ], gas : int , tx_fee : int = 0 , memo : str = \"\" , chain_id : Optional [ str ] = None , denom : Optional [ str ] = None , tx_fee_denom : Optional [ str ] = None ) -> JSONLike Generate transaction with multiple messages Arguments : from_addresses : Addresses of signers pub_keys : Public keys of signers msgs : Messages to be included in transaction gas : the gas used. tx_fee : the transaction fee. memo : memo to include in tx. chain_id : the chain ID of the transaction. denom : the denomination of tx fee tx_fee_denom : Denomination of tx_fee, identical with denom param when None :raises: RuntimeError if number of pubkeys is not equal to number of from_addresses Returns : the transaction send _ signed _ transaction | send_signed_transaction ( tx_signed : JSONLike ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction Returns : tx_digest, if present get _ transaction _ receipt | get_transaction_receipt ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction receipt for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present get _ transaction | get_transaction ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx, if present get _ contract _ instance | get_contract_instance ( contract_interface : Dict [ str , str ], contract_address : Optional [ str ] = None ) -> Any Get the instance of a contract. Arguments : contract_interface : the contract interface. contract_address : the contract address. Returns : the contract instance update _ with _ gas _ estimate | update_with_gas_estimate ( transaction : JSONLike ) -> JSONLike Attempts to update the transaction with a gas estimate Arguments : transaction : the transaction :raises: NotImplementedError CosmosApi Objects class CosmosApi ( _CosmosApi , CosmosHelper ) Class to interact with the Cosmos SDK via a HTTP APIs. CosmosFaucetApi Objects class CosmosFaucetApi ( FaucetApi ) Cosmos testnet faucet API. __ init __ | __init__ ( poll_interval : Optional [ float ] = None , final_wait_interval : Optional [ float ] = None ) Initialize CosmosFaucetApi. get _ wealth | get_wealth ( address : Address , url : Optional [ str ] = None ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. url : the url :raises: RuntimeError of explicit faucet failures","title":"API"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#pluginsaea-ledger-cosmosaea_ledger_cosmoscosmos","text":"Cosmos module wrapping the public and private key cryptography and ledger api.","title":"plugins.aea-ledger-cosmos.aea_ledger_cosmos.cosmos"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#dataencrypt-objects","text":"class DataEncrypt () Class to encrypt/decrypt data strings with password provided.","title":"DataEncrypt Objects"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#encrypt","text":"| @classmethod | encrypt ( cls , data : bytes , password : str ) -> bytes Encrypt data with password.","title":"encrypt"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#bytes_encode","text":"| @staticmethod | bytes_encode ( data : bytes ) -> str Encode bytes to ascii friendly string.","title":"bytes_encode"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#bytes_decode","text":"| @staticmethod | bytes_decode ( data : str ) -> bytes Decode ascii friendly string to bytes.","title":"bytes_decode"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#decrypt","text":"| @classmethod | decrypt ( cls , encrypted_data : bytes , password : str ) -> bytes Decrypt data with password provided.","title":"decrypt"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#cosmoshelper-objects","text":"class CosmosHelper ( Helper ) Helper class usable as Mixin for CosmosApi or as standalone class.","title":"CosmosHelper Objects"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#is_transaction_settled","text":"| @staticmethod | is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_receipt : the receipt of the transaction. Returns : True if the transaction has been settled, False o/w.","title":"is_transaction_settled"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#get_code_id","text":"| @staticmethod | get_code_id ( tx_receipt : JSONLike ) -> Optional [ int ] Retrieve the code_id from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the code id, if present","title":"get_code_id"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#get_contract_address","text":"| @staticmethod | get_contract_address ( tx_receipt : JSONLike ) -> Optional [ str ] Retrieve the contract_address from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the contract address, if present","title":"get_contract_address"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#is_transaction_valid","text":"| @staticmethod | is_transaction_valid ( tx : JSONLike , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input']","title":"is_transaction_valid"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#generate_tx_nonce","text":"| @staticmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish transactions with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#get_address_from_public_key","text":"| @classmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#recover_message","text":"| @classmethod | recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses","title":"recover_message"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#recover_public_keys_from_message","text":"| @classmethod | recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys","title":"recover_public_keys_from_message"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#get_hash","text":"| @staticmethod | get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message.","title":"get_hash"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#is_valid_address","text":"| @classmethod | is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate Returns : whether address is valid or not","title":"is_valid_address"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#load_contract_interface","text":"| @classmethod | load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface","title":"load_contract_interface"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#cosmoscrypto-objects","text":"class CosmosCrypto ( Crypto [ SigningKey ]) Class wrapping the Account Generation from Ethereum ledger.","title":"CosmosCrypto Objects"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#__init__","text":"| __init__ ( private_key_path : Optional [ str ] = None , password : Optional [ str ] = None ) -> None Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent password : the password to encrypt/decrypt the private key.","title":"__init__"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#private_key","text":"| @property | private_key () -> str Return a private key. Returns : a private key string","title":"private_key"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#public_key","text":"| @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format","title":"public_key"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#address","text":"| @property | address () -> str Return the address for the key pair. Returns : a display_address str","title":"address"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#load_private_key_from_path","text":"| @classmethod | load_private_key_from_path ( cls , file_name : str , password : Optional [ str ] = None ) -> SigningKey Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. password : the password to encrypt/decrypt the private key. Returns : the Entity.","title":"load_private_key_from_path"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#sign_message","text":"| sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form","title":"sign_message"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#sign_transaction","text":"| sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction","title":"sign_transaction"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#generate_private_key","text":"| @classmethod | generate_private_key ( cls ) -> SigningKey Generate a key pair for cosmos network.","title":"generate_private_key"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#encrypt_1","text":"| encrypt ( password : str ) -> str Encrypt the private key and return in json. Arguments : password : the password to decrypt. Returns : json string containing encrypted private key.","title":"encrypt"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#decrypt_1","text":"| @classmethod | decrypt ( cls , keyfile_json : str , password : str ) -> str Decrypt the private key and return in raw form. Arguments : keyfile_json : json string containing encrypted private key. password : the password to decrypt. Returns : the raw private key.","title":"decrypt"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#_cosmosapi-objects","text":"class _CosmosApi ( LedgerApi ) Class to interact with the Cosmos SDK via a HTTP APIs.","title":"_CosmosApi Objects"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#__init___1","text":"| __init__ ( ** kwargs : Any ) -> None Initialize the Cosmos ledger APIs.","title":"__init__"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#api","text":"| @property | api () -> Any Get the underlying API object.","title":"api"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#get_balance","text":"| get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account.","title":"get_balance"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#get_state","text":"| get_state ( callable_name : str , * args : Any , ** kwargs : Any ) -> Optional [ JSONLike ] Call a specified function on the ledger API. Based on the cosmos REST API specification, which takes a path (strings separated by '/'). The convention here is to define the root of the path (txs, blocks, etc.) as the callable_name and the rest of the path as args. Arguments : callable_name : name of the callable args : positional arguments kwargs : keyword arguments Returns : the transaction dictionary","title":"get_state"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#get_deploy_transaction","text":"| get_deploy_transaction ( contract_interface : Dict [ str , str ], deployer_address : Address , ** kwargs : Any , ,) -> Optional [ JSONLike ] Get the transaction to deploy the smart contract. Dispatches to _get_storage_transaction and _get_init_transaction based on kwargs. Arguments : contract_interface : the contract interface. deployer_address : The address that will deploy the contract. kwargs : keyword arguments. Returns : the transaction dictionary.","title":"get_deploy_transaction"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#get_handle_transaction","text":"| get_handle_transaction ( sender_address : Address , contract_address : Address , handle_msg : Any , amount : int , tx_fee : int , denom : Optional [ str ] = None , gas : int = DEFAULT_GAS_AMOUNT , memo : str = \"\" , chain_id : Optional [ str ] = None , account_number : Optional [ int ] = None , sequence : Optional [ int ] = None , tx_fee_denom : Optional [ str ] = None ) -> Optional [ JSONLike ] Create a CosmWasm HandleMsg transaction. Arguments : sender_address : the sender address of the message initiator. contract_address : the address of the smart contract. handle_msg : HandleMsg in JSON format. amount : Funds amount sent with transaction. tx_fee : the tx fee accepted. denom : the name of the denomination of the contract funds gas : Maximum amount of gas to be used on executing command. memo : any string comment. chain_id : the Chain ID of the CosmWasm transaction. Default is 1 (i.e. mainnet). account_number : Account number sequence : Sequence tx_fee_denom : Denomination of tx_fee, identical with denom param when None Returns : the unsigned CosmWasm HandleMsg","title":"get_handle_transaction"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#execute_contract_query","text":"| execute_contract_query ( contract_address : Address , query_msg : JSONLike ) -> Optional [ JSONLike ] Execute a CosmWasm QueryMsg. QueryMsg doesn't require signing. Arguments : contract_address : the address of the smart contract. query_msg : QueryMsg in JSON format. Returns : the message receipt","title":"execute_contract_query"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#get_transfer_transaction","text":"| get_transfer_transaction ( sender_address : Address , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , denom : Optional [ str ] = None , gas : int = DEFAULT_GAS_AMOUNT , memo : str = \"\" , chain_id : Optional [ str ] = None , account_number : Optional [ int ] = None , sequence : Optional [ int ] = None , tx_fee_denom : Optional [ str ] = None , ** kwargs : Any , ,) -> Optional [ JSONLike ] Submit a transfer transaction to the ledger. Arguments : sender_address : the sender address of the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx denom : the denomination of tx fee and amount gas : the gas used. memo : memo to include in tx. chain_id : the chain ID of the transaction. account_number : Account number sequence : Sequence tx_fee_denom : Denomination of tx_fee, identical with denom param when None kwargs : keyword arguments. Returns : the transfer transaction","title":"get_transfer_transaction"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#get_packed_exec_msg","text":"| get_packed_exec_msg ( sender_address : Address , contract_address : str , msg : JSONLike , funds : int = 0 , denom : Optional [ str ] = None ) -> ProtoAny Create and pack MsgExecuteContract Arguments : sender_address : Address of sender contract_address : Address of contract msg : Paramaters to be passed to smart contract funds : Funds to be sent to smart contract denom : the denomination of funds Returns : Packed MsgExecuteContract","title":"get_packed_exec_msg"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#get_packed_send_msg","text":"| get_packed_send_msg ( from_address : Address , to_address : Address , amount : int , denom : Optional [ str ] = None ) -> ProtoAny Generate and pack MsgSend Arguments : from_address : Address of sender to_address : Address of recipient amount : amount of coins to be sent denom : the denomination of and amount Returns : packer ProtoAny type message","title":"get_packed_send_msg"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#get_multi_transaction","text":"| get_multi_transaction ( from_addresses : List [ str ], pub_keys : Optional [ List [ bytes ]], msgs : List [ ProtoAny ], gas : int , tx_fee : int = 0 , memo : str = \"\" , chain_id : Optional [ str ] = None , denom : Optional [ str ] = None , tx_fee_denom : Optional [ str ] = None ) -> JSONLike Generate transaction with multiple messages Arguments : from_addresses : Addresses of signers pub_keys : Public keys of signers msgs : Messages to be included in transaction gas : the gas used. tx_fee : the transaction fee. memo : memo to include in tx. chain_id : the chain ID of the transaction. denom : the denomination of tx fee tx_fee_denom : Denomination of tx_fee, identical with denom param when None :raises: RuntimeError if number of pubkeys is not equal to number of from_addresses Returns : the transaction","title":"get_multi_transaction"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#send_signed_transaction","text":"| send_signed_transaction ( tx_signed : JSONLike ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction Returns : tx_digest, if present","title":"send_signed_transaction"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#get_transaction_receipt","text":"| get_transaction_receipt ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction receipt for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present","title":"get_transaction_receipt"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#get_transaction","text":"| get_transaction ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx, if present","title":"get_transaction"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#get_contract_instance","text":"| get_contract_instance ( contract_interface : Dict [ str , str ], contract_address : Optional [ str ] = None ) -> Any Get the instance of a contract. Arguments : contract_interface : the contract interface. contract_address : the contract address. Returns : the contract instance","title":"get_contract_instance"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#update_with_gas_estimate","text":"| update_with_gas_estimate ( transaction : JSONLike ) -> JSONLike Attempts to update the transaction with a gas estimate Arguments : transaction : the transaction :raises: NotImplementedError","title":"update_with_gas_estimate"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#cosmosapi-objects","text":"class CosmosApi ( _CosmosApi , CosmosHelper ) Class to interact with the Cosmos SDK via a HTTP APIs.","title":"CosmosApi Objects"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#cosmosfaucetapi-objects","text":"class CosmosFaucetApi ( FaucetApi ) Cosmos testnet faucet API.","title":"CosmosFaucetApi Objects"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#__init___2","text":"| __init__ ( poll_interval : Optional [ float ] = None , final_wait_interval : Optional [ float ] = None ) Initialize CosmosFaucetApi.","title":"__init__"},{"location":"aea/api/plugins/aea_ledger_cosmos/cosmos/#get_wealth","text":"| get_wealth ( address : Address , url : Optional [ str ] = None ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. url : the url :raises: RuntimeError of explicit faucet failures","title":"get_wealth"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/","text":"plugins.aea-ledger-ethereum.aea _ ledger _ ethereum.ethereum Ethereum module wrapping the public and private key cryptography and ledger api. get _ gas _ price _ strategy get_gas_price_strategy ( gas_price_strategy : Optional [ str ] = None , api_key : Optional [ str ] = None ) -> Callable [[ Web3 , TxParams ], Wei ] Get the gas price strategy. SignedTransactionTranslator Objects class SignedTransactionTranslator () Translator for SignedTransaction. to _ dict | @staticmethod | to_dict ( signed_transaction : SignedTransaction ) -> Dict [ str , Union [ str , int ]] Write SignedTransaction to dict. from _ dict | @staticmethod | from_dict ( signed_transaction_dict : JSONLike ) -> SignedTransaction Get SignedTransaction from dict. AttributeDictTranslator Objects class AttributeDictTranslator () Translator for AttributeDict. to _ dict | @classmethod | to_dict ( cls , attr_dict : Union [ AttributeDict , TxReceipt , TxData ]) -> JSONLike Simplify to dict. from _ dict | @classmethod | from_dict ( cls , di : JSONLike ) -> AttributeDict Get back attribute dict. EthereumCrypto Objects class EthereumCrypto ( Crypto [ Account ]) Class wrapping the Account Generation from Ethereum ledger. __ init __ | __init__ ( private_key_path : Optional [ str ] = None , password : Optional [ str ] = None ) -> None Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent password : the password to encrypt/decrypt the private key. private _ key | @property | private_key () -> str Return a private key. Returns : a private key string public _ key | @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format address | @property | address () -> str Return the address for the key pair. Returns : a display_address str load _ private _ key _ from _ path | @classmethod | load_private_key_from_path ( cls , file_name : str , password : Optional [ str ] = None ) -> Account Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. password : the password to encrypt/decrypt the private key. Returns : the Entity. sign _ message | sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form sign _ transaction | sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction generate _ private _ key | @classmethod | generate_private_key ( cls ) -> Account Generate a key pair for ethereum network. encrypt | encrypt ( password : str ) -> str Encrypt the private key and return in json. Arguments : password : the password to decrypt. Returns : json string containing encrypted private key. decrypt | @classmethod | decrypt ( cls , keyfile_json : str , password : str ) -> str Decrypt the private key and return in raw form. Arguments : keyfile_json : json str containing encrypted private key. password : the password to decrypt. Returns : the raw private key. EthereumHelper Objects class EthereumHelper ( Helper ) Helper class usable as Mixin for EthereumApi or as standalone class. is _ transaction _ settled | @staticmethod | is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_receipt : the receipt associated to the transaction. Returns : True if the transaction has been settled, False o/w. get _ contract _ address | @staticmethod | get_contract_address ( tx_receipt : JSONLike ) -> Optional [ str ] Retrieve the contract_address from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the contract address, if present is _ transaction _ valid | @staticmethod | is_transaction_valid ( tx : dict , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input'] generate _ tx _ nonce | @staticmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish transactions with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. get _ address _ from _ public _ key | @classmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str recover _ message | @classmethod | recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses recover _ public _ keys _ from _ message | @classmethod | recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys get _ hash | @staticmethod | get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message. load _ contract _ interface | @classmethod | load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface EthereumApi Objects class EthereumApi ( LedgerApi , EthereumHelper ) Class to interact with the Ethereum Web3 APIs. __ init __ | __init__ ( ** kwargs : Any ) Initialize the Ethereum ledger APIs. Arguments : kwargs : keyword arguments api | @property | api () -> Web3 Get the underlying API object. get _ balance | get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. get _ state | get_state ( callable_name : str , * args : Any , ** kwargs : Any ) -> Optional [ JSONLike ] Call a specified function on the ledger API. get _ transfer _ transaction | get_transfer_transaction ( sender_address : Address , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , chain_id : Optional [ int ] = None , gas_price : Optional [ str ] = None , gas_price_strategy : Optional [ str ] = None , ** kwargs : Any , ,) -> Optional [ JSONLike ] Submit a transfer transaction to the ledger. Arguments : sender_address : the sender address of the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred (in Wei). tx_fee : the transaction fee (gas) to be used (in Wei). tx_nonce : verifies the authenticity of the tx. chain_id : the Chain ID of the Ethereum transaction. gas_price : the gas price (in Wei) gas_price_strategy : the gas price strategy to be used. kwargs : keyword arguments Returns : the transfer transaction update _ with _ gas _ estimate | update_with_gas_estimate ( transaction : JSONLike ) -> JSONLike Attempts to update the transaction with a gas estimate Arguments : transaction : the transaction Returns : the updated transaction send _ signed _ transaction | send_signed_transaction ( tx_signed : JSONLike ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction Returns : tx_digest, if present get _ transaction _ receipt | get_transaction_receipt ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction receipt for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present get _ transaction | get_transaction ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx, if present get _ contract _ instance | get_contract_instance ( contract_interface : Dict [ str , str ], contract_address : Optional [ str ] = None ) -> Any Get the instance of a contract. Arguments : contract_interface : the contract interface. contract_address : the contract address. Returns : the contract instance get _ deploy _ transaction | get_deploy_transaction ( contract_interface : Dict [ str , str ], deployer_address : Address , value : int = 0 , gas : int = 0 , gas_price : Optional [ str ] = None , gas_price_strategy : Optional [ str ] = None , ** kwargs : Any , ,) -> Optional [ JSONLike ] Get the transaction to deploy the smart contract. Arguments : contract_interface : the contract interface. deployer_address : The address that will deploy the contract. value : value to send to contract (in Wei) gas : the gas to be used (in Wei) gas_price : the gas price (in Wei) gas_price_strategy : the gas price strategy to be used. kwargs : keyword arguments Returns : the transaction dictionary. is _ valid _ address | @classmethod | is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate Returns : whether the address is valid EthereumFaucetApi Objects class EthereumFaucetApi ( FaucetApi ) Ethereum testnet faucet API. get _ wealth | get_wealth ( address : Address , url : Optional [ str ] = None ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. url : the url LruLockWrapper Objects class LruLockWrapper () Wrapper for LRU with threading.Lock. __ init __ | __init__ ( lru : LRU ) -> None Init wrapper. __ getitem __ | __getitem__ ( * args : Any , ** kwargs : Any ) -> Any Get item __ setitem __ | __setitem__ ( * args : Any , ** kwargs : Any ) -> Any Set item. __ contains __ | __contains__ ( * args : Any , ** kwargs : Any ) -> Any Contain item. __ delitem __ | __delitem__ ( * args : Any , ** kwargs : Any ) -> Any Del item. set _ wrapper _ for _ web3py _ session _ cache set_wrapper_for_web3py_session_cache () -> None Wrap web3py session cache with threading.Lock.","title":"API"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#pluginsaea-ledger-ethereumaea_ledger_ethereumethereum","text":"Ethereum module wrapping the public and private key cryptography and ledger api.","title":"plugins.aea-ledger-ethereum.aea_ledger_ethereum.ethereum"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#get_gas_price_strategy","text":"get_gas_price_strategy ( gas_price_strategy : Optional [ str ] = None , api_key : Optional [ str ] = None ) -> Callable [[ Web3 , TxParams ], Wei ] Get the gas price strategy.","title":"get_gas_price_strategy"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#signedtransactiontranslator-objects","text":"class SignedTransactionTranslator () Translator for SignedTransaction.","title":"SignedTransactionTranslator Objects"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#to_dict","text":"| @staticmethod | to_dict ( signed_transaction : SignedTransaction ) -> Dict [ str , Union [ str , int ]] Write SignedTransaction to dict.","title":"to_dict"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#from_dict","text":"| @staticmethod | from_dict ( signed_transaction_dict : JSONLike ) -> SignedTransaction Get SignedTransaction from dict.","title":"from_dict"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#attributedicttranslator-objects","text":"class AttributeDictTranslator () Translator for AttributeDict.","title":"AttributeDictTranslator Objects"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#to_dict_1","text":"| @classmethod | to_dict ( cls , attr_dict : Union [ AttributeDict , TxReceipt , TxData ]) -> JSONLike Simplify to dict.","title":"to_dict"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#from_dict_1","text":"| @classmethod | from_dict ( cls , di : JSONLike ) -> AttributeDict Get back attribute dict.","title":"from_dict"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#ethereumcrypto-objects","text":"class EthereumCrypto ( Crypto [ Account ]) Class wrapping the Account Generation from Ethereum ledger.","title":"EthereumCrypto Objects"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#__init__","text":"| __init__ ( private_key_path : Optional [ str ] = None , password : Optional [ str ] = None ) -> None Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent password : the password to encrypt/decrypt the private key.","title":"__init__"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#private_key","text":"| @property | private_key () -> str Return a private key. Returns : a private key string","title":"private_key"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#public_key","text":"| @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format","title":"public_key"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#address","text":"| @property | address () -> str Return the address for the key pair. Returns : a display_address str","title":"address"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#load_private_key_from_path","text":"| @classmethod | load_private_key_from_path ( cls , file_name : str , password : Optional [ str ] = None ) -> Account Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. password : the password to encrypt/decrypt the private key. Returns : the Entity.","title":"load_private_key_from_path"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#sign_message","text":"| sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form","title":"sign_message"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#sign_transaction","text":"| sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction","title":"sign_transaction"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#generate_private_key","text":"| @classmethod | generate_private_key ( cls ) -> Account Generate a key pair for ethereum network.","title":"generate_private_key"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#encrypt","text":"| encrypt ( password : str ) -> str Encrypt the private key and return in json. Arguments : password : the password to decrypt. Returns : json string containing encrypted private key.","title":"encrypt"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#decrypt","text":"| @classmethod | decrypt ( cls , keyfile_json : str , password : str ) -> str Decrypt the private key and return in raw form. Arguments : keyfile_json : json str containing encrypted private key. password : the password to decrypt. Returns : the raw private key.","title":"decrypt"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#ethereumhelper-objects","text":"class EthereumHelper ( Helper ) Helper class usable as Mixin for EthereumApi or as standalone class.","title":"EthereumHelper Objects"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#is_transaction_settled","text":"| @staticmethod | is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_receipt : the receipt associated to the transaction. Returns : True if the transaction has been settled, False o/w.","title":"is_transaction_settled"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#get_contract_address","text":"| @staticmethod | get_contract_address ( tx_receipt : JSONLike ) -> Optional [ str ] Retrieve the contract_address from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the contract address, if present","title":"get_contract_address"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#is_transaction_valid","text":"| @staticmethod | is_transaction_valid ( tx : dict , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input']","title":"is_transaction_valid"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#generate_tx_nonce","text":"| @staticmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish transactions with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#get_address_from_public_key","text":"| @classmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#recover_message","text":"| @classmethod | recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses","title":"recover_message"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#recover_public_keys_from_message","text":"| @classmethod | recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys","title":"recover_public_keys_from_message"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#get_hash","text":"| @staticmethod | get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message.","title":"get_hash"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#load_contract_interface","text":"| @classmethod | load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface","title":"load_contract_interface"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#ethereumapi-objects","text":"class EthereumApi ( LedgerApi , EthereumHelper ) Class to interact with the Ethereum Web3 APIs.","title":"EthereumApi Objects"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#__init___1","text":"| __init__ ( ** kwargs : Any ) Initialize the Ethereum ledger APIs. Arguments : kwargs : keyword arguments","title":"__init__"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#api","text":"| @property | api () -> Web3 Get the underlying API object.","title":"api"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#get_balance","text":"| get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account.","title":"get_balance"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#get_state","text":"| get_state ( callable_name : str , * args : Any , ** kwargs : Any ) -> Optional [ JSONLike ] Call a specified function on the ledger API.","title":"get_state"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#get_transfer_transaction","text":"| get_transfer_transaction ( sender_address : Address , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , chain_id : Optional [ int ] = None , gas_price : Optional [ str ] = None , gas_price_strategy : Optional [ str ] = None , ** kwargs : Any , ,) -> Optional [ JSONLike ] Submit a transfer transaction to the ledger. Arguments : sender_address : the sender address of the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred (in Wei). tx_fee : the transaction fee (gas) to be used (in Wei). tx_nonce : verifies the authenticity of the tx. chain_id : the Chain ID of the Ethereum transaction. gas_price : the gas price (in Wei) gas_price_strategy : the gas price strategy to be used. kwargs : keyword arguments Returns : the transfer transaction","title":"get_transfer_transaction"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#update_with_gas_estimate","text":"| update_with_gas_estimate ( transaction : JSONLike ) -> JSONLike Attempts to update the transaction with a gas estimate Arguments : transaction : the transaction Returns : the updated transaction","title":"update_with_gas_estimate"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#send_signed_transaction","text":"| send_signed_transaction ( tx_signed : JSONLike ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction Returns : tx_digest, if present","title":"send_signed_transaction"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#get_transaction_receipt","text":"| get_transaction_receipt ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction receipt for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present","title":"get_transaction_receipt"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#get_transaction","text":"| get_transaction ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx, if present","title":"get_transaction"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#get_contract_instance","text":"| get_contract_instance ( contract_interface : Dict [ str , str ], contract_address : Optional [ str ] = None ) -> Any Get the instance of a contract. Arguments : contract_interface : the contract interface. contract_address : the contract address. Returns : the contract instance","title":"get_contract_instance"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#get_deploy_transaction","text":"| get_deploy_transaction ( contract_interface : Dict [ str , str ], deployer_address : Address , value : int = 0 , gas : int = 0 , gas_price : Optional [ str ] = None , gas_price_strategy : Optional [ str ] = None , ** kwargs : Any , ,) -> Optional [ JSONLike ] Get the transaction to deploy the smart contract. Arguments : contract_interface : the contract interface. deployer_address : The address that will deploy the contract. value : value to send to contract (in Wei) gas : the gas to be used (in Wei) gas_price : the gas price (in Wei) gas_price_strategy : the gas price strategy to be used. kwargs : keyword arguments Returns : the transaction dictionary.","title":"get_deploy_transaction"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#is_valid_address","text":"| @classmethod | is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate Returns : whether the address is valid","title":"is_valid_address"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#ethereumfaucetapi-objects","text":"class EthereumFaucetApi ( FaucetApi ) Ethereum testnet faucet API.","title":"EthereumFaucetApi Objects"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#get_wealth","text":"| get_wealth ( address : Address , url : Optional [ str ] = None ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. url : the url","title":"get_wealth"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#lrulockwrapper-objects","text":"class LruLockWrapper () Wrapper for LRU with threading.Lock.","title":"LruLockWrapper Objects"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#__init___2","text":"| __init__ ( lru : LRU ) -> None Init wrapper.","title":"__init__"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#__getitem__","text":"| __getitem__ ( * args : Any , ** kwargs : Any ) -> Any Get item","title":"__getitem__"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#__setitem__","text":"| __setitem__ ( * args : Any , ** kwargs : Any ) -> Any Set item.","title":"__setitem__"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#__contains__","text":"| __contains__ ( * args : Any , ** kwargs : Any ) -> Any Contain item.","title":"__contains__"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#__delitem__","text":"| __delitem__ ( * args : Any , ** kwargs : Any ) -> Any Del item.","title":"__delitem__"},{"location":"aea/api/plugins/aea_ledger_ethereum/ethereum/#set_wrapper_for_web3py_session_cache","text":"set_wrapper_for_web3py_session_cache () -> None Wrap web3py session cache with threading.Lock.","title":"set_wrapper_for_web3py_session_cache"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/","text":"plugins.aea-ledger-fetchai.aea _ ledger _ fetchai. _ cosmos Cosmos module wrapping the public and private key cryptography and ledger api. DataEncrypt Objects class DataEncrypt () Class to encrypt/decrypt data strings with password provided. encrypt | @classmethod | encrypt ( cls , data : bytes , password : str ) -> bytes Encrypt data with password. bytes _ encode | @staticmethod | bytes_encode ( data : bytes ) -> str Encode bytes to ascii friendly string. bytes _ decode | @staticmethod | bytes_decode ( data : str ) -> bytes Decode ascii friendly string to bytes. decrypt | @classmethod | decrypt ( cls , encrypted_data : bytes , password : str ) -> bytes Decrypt data with password provided. CosmosHelper Objects class CosmosHelper ( Helper ) Helper class usable as Mixin for CosmosApi or as standalone class. is _ transaction _ settled | @staticmethod | is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_receipt : the receipt of the transaction. Returns : True if the transaction has been settled, False o/w. get _ code _ id | @staticmethod | get_code_id ( tx_receipt : JSONLike ) -> Optional [ int ] Retrieve the code_id from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the code id, if present get _ contract _ address | @staticmethod | get_contract_address ( tx_receipt : JSONLike ) -> Optional [ str ] Retrieve the contract_address from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the contract address, if present is _ transaction _ valid | @staticmethod | is_transaction_valid ( tx : JSONLike , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input'] generate _ tx _ nonce | @staticmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish transactions with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex. get _ address _ from _ public _ key | @classmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str recover _ message | @classmethod | recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses recover _ public _ keys _ from _ message | @classmethod | recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys get _ hash | @staticmethod | get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message. is _ valid _ address | @classmethod | is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate Returns : whether address is valid or not load _ contract _ interface | @classmethod | load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface CosmosCrypto Objects class CosmosCrypto ( Crypto [ SigningKey ]) Class wrapping the Account Generation from Ethereum ledger. __ init __ | __init__ ( private_key_path : Optional [ str ] = None , password : Optional [ str ] = None ) -> None Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent password : the password to encrypt/decrypt the private key. private _ key | @property | private_key () -> str Return a private key. Returns : a private key string public _ key | @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format address | @property | address () -> str Return the address for the key pair. Returns : a display_address str load _ private _ key _ from _ path | @classmethod | load_private_key_from_path ( cls , file_name : str , password : Optional [ str ] = None ) -> SigningKey Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. password : the password to encrypt/decrypt the private key. Returns : the Entity. sign _ message | sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form sign _ transaction | sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction generate _ private _ key | @classmethod | generate_private_key ( cls ) -> SigningKey Generate a key pair for cosmos network. encrypt | encrypt ( password : str ) -> str Encrypt the private key and return in json. Arguments : password : the password to decrypt. Returns : json string containing encrypted private key. decrypt | @classmethod | decrypt ( cls , keyfile_json : str , password : str ) -> str Decrypt the private key and return in raw form. Arguments : keyfile_json : json string containing encrypted private key. password : the password to decrypt. Returns : the raw private key. _ CosmosApi Objects class _CosmosApi ( LedgerApi ) Class to interact with the Cosmos SDK via a HTTP APIs. __ init __ | __init__ ( ** kwargs : Any ) -> None Initialize the Cosmos ledger APIs. api | @property | api () -> Any Get the underlying API object. get _ balance | get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account. get _ state | get_state ( callable_name : str , * args : Any , ** kwargs : Any ) -> Optional [ JSONLike ] Call a specified function on the ledger API. Based on the cosmos REST API specification, which takes a path (strings separated by '/'). The convention here is to define the root of the path (txs, blocks, etc.) as the callable_name and the rest of the path as args. Arguments : callable_name : name of the callable args : positional arguments kwargs : keyword arguments Returns : the transaction dictionary get _ deploy _ transaction | get_deploy_transaction ( contract_interface : Dict [ str , str ], deployer_address : Address , ** kwargs : Any , ,) -> Optional [ JSONLike ] Get the transaction to deploy the smart contract. Dispatches to _get_storage_transaction and _get_init_transaction based on kwargs. Arguments : contract_interface : the contract interface. deployer_address : The address that will deploy the contract. kwargs : keyword arguments. Returns : the transaction dictionary. get _ handle _ transaction | get_handle_transaction ( sender_address : Address , contract_address : Address , handle_msg : Any , amount : int , tx_fee : int , denom : Optional [ str ] = None , gas : int = DEFAULT_GAS_AMOUNT , memo : str = \"\" , chain_id : Optional [ str ] = None , account_number : Optional [ int ] = None , sequence : Optional [ int ] = None , tx_fee_denom : Optional [ str ] = None ) -> Optional [ JSONLike ] Create a CosmWasm HandleMsg transaction. Arguments : sender_address : the sender address of the message initiator. contract_address : the address of the smart contract. handle_msg : HandleMsg in JSON format. amount : Funds amount sent with transaction. tx_fee : the tx fee accepted. denom : the name of the denomination of the contract funds gas : Maximum amount of gas to be used on executing command. memo : any string comment. chain_id : the Chain ID of the CosmWasm transaction. Default is 1 (i.e. mainnet). account_number : Account number sequence : Sequence tx_fee_denom : Denomination of tx_fee, identical with denom param when None Returns : the unsigned CosmWasm HandleMsg execute _ contract _ query | execute_contract_query ( contract_address : Address , query_msg : JSONLike ) -> Optional [ JSONLike ] Execute a CosmWasm QueryMsg. QueryMsg doesn't require signing. Arguments : contract_address : the address of the smart contract. query_msg : QueryMsg in JSON format. Returns : the message receipt get _ transfer _ transaction | get_transfer_transaction ( sender_address : Address , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , denom : Optional [ str ] = None , gas : int = DEFAULT_GAS_AMOUNT , memo : str = \"\" , chain_id : Optional [ str ] = None , account_number : Optional [ int ] = None , sequence : Optional [ int ] = None , tx_fee_denom : Optional [ str ] = None , ** kwargs : Any , ,) -> Optional [ JSONLike ] Submit a transfer transaction to the ledger. Arguments : sender_address : the sender address of the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx denom : the denomination of tx fee and amount gas : the gas used. memo : memo to include in tx. chain_id : the chain ID of the transaction. account_number : Account number sequence : Sequence tx_fee_denom : Denomination of tx_fee, identical with denom param when None kwargs : keyword arguments. Returns : the transfer transaction get _ packed _ exec _ msg | get_packed_exec_msg ( sender_address : Address , contract_address : str , msg : JSONLike , funds : int = 0 , denom : Optional [ str ] = None ) -> ProtoAny Create and pack MsgExecuteContract Arguments : sender_address : Address of sender contract_address : Address of contract msg : Paramaters to be passed to smart contract funds : Funds to be sent to smart contract denom : the denomination of funds Returns : Packed MsgExecuteContract get _ packed _ send _ msg | get_packed_send_msg ( from_address : Address , to_address : Address , amount : int , denom : Optional [ str ] = None ) -> ProtoAny Generate and pack MsgSend Arguments : from_address : Address of sender to_address : Address of recipient amount : amount of coins to be sent denom : the denomination of and amount Returns : packer ProtoAny type message get _ multi _ transaction | get_multi_transaction ( from_addresses : List [ str ], pub_keys : Optional [ List [ bytes ]], msgs : List [ ProtoAny ], gas : int , tx_fee : int = 0 , memo : str = \"\" , chain_id : Optional [ str ] = None , denom : Optional [ str ] = None , tx_fee_denom : Optional [ str ] = None ) -> JSONLike Generate transaction with multiple messages Arguments : from_addresses : Addresses of signers pub_keys : Public keys of signers msgs : Messages to be included in transaction gas : the gas used. tx_fee : the transaction fee. memo : memo to include in tx. chain_id : the chain ID of the transaction. denom : the denomination of tx fee tx_fee_denom : Denomination of tx_fee, identical with denom param when None :raises: RuntimeError if number of pubkeys is not equal to number of from_addresses Returns : the transaction send _ signed _ transaction | send_signed_transaction ( tx_signed : JSONLike ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction Returns : tx_digest, if present get _ transaction _ receipt | get_transaction_receipt ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction receipt for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present get _ transaction | get_transaction ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx, if present get _ contract _ instance | get_contract_instance ( contract_interface : Dict [ str , str ], contract_address : Optional [ str ] = None ) -> Any Get the instance of a contract. Arguments : contract_interface : the contract interface. contract_address : the contract address. Returns : the contract instance update _ with _ gas _ estimate | update_with_gas_estimate ( transaction : JSONLike ) -> JSONLike Attempts to update the transaction with a gas estimate Arguments : transaction : the transaction :raises: NotImplementedError CosmosApi Objects class CosmosApi ( _CosmosApi , CosmosHelper ) Class to interact with the Cosmos SDK via a HTTP APIs. CosmosFaucetApi Objects class CosmosFaucetApi ( FaucetApi ) Cosmos testnet faucet API. __ init __ | __init__ ( poll_interval : Optional [ float ] = None , final_wait_interval : Optional [ float ] = None ) Initialize CosmosFaucetApi. get _ wealth | get_wealth ( address : Address , url : Optional [ str ] = None ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. url : the url :raises: RuntimeError of explicit faucet failures","title":"Helper"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#pluginsaea-ledger-fetchaiaea_ledger_fetchai_cosmos","text":"Cosmos module wrapping the public and private key cryptography and ledger api.","title":"plugins.aea-ledger-fetchai.aea_ledger_fetchai._cosmos"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#dataencrypt-objects","text":"class DataEncrypt () Class to encrypt/decrypt data strings with password provided.","title":"DataEncrypt Objects"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#encrypt","text":"| @classmethod | encrypt ( cls , data : bytes , password : str ) -> bytes Encrypt data with password.","title":"encrypt"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#bytes_encode","text":"| @staticmethod | bytes_encode ( data : bytes ) -> str Encode bytes to ascii friendly string.","title":"bytes_encode"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#bytes_decode","text":"| @staticmethod | bytes_decode ( data : str ) -> bytes Decode ascii friendly string to bytes.","title":"bytes_decode"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#decrypt","text":"| @classmethod | decrypt ( cls , encrypted_data : bytes , password : str ) -> bytes Decrypt data with password provided.","title":"decrypt"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#cosmoshelper-objects","text":"class CosmosHelper ( Helper ) Helper class usable as Mixin for CosmosApi or as standalone class.","title":"CosmosHelper Objects"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#is_transaction_settled","text":"| @staticmethod | is_transaction_settled ( tx_receipt : JSONLike ) -> bool Check whether a transaction is settled or not. Arguments : tx_receipt : the receipt of the transaction. Returns : True if the transaction has been settled, False o/w.","title":"is_transaction_settled"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#get_code_id","text":"| @staticmethod | get_code_id ( tx_receipt : JSONLike ) -> Optional [ int ] Retrieve the code_id from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the code id, if present","title":"get_code_id"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#get_contract_address","text":"| @staticmethod | get_contract_address ( tx_receipt : JSONLike ) -> Optional [ str ] Retrieve the contract_address from a transaction receipt. Arguments : tx_receipt : the receipt of the transaction. Returns : the contract address, if present","title":"get_contract_address"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#is_transaction_valid","text":"| @staticmethod | is_transaction_valid ( tx : JSONLike , seller : Address , client : Address , tx_nonce : str , amount : int ) -> bool Check whether a transaction is valid or not. Arguments : tx : the transaction. seller : the address of the seller. client : the address of the client. tx_nonce : the transaction nonce. amount : the amount we expect to get from the transaction. Returns : True if the random_message is equals to tx['input']","title":"is_transaction_valid"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#generate_tx_nonce","text":"| @staticmethod | generate_tx_nonce ( seller : Address , client : Address ) -> str Generate a unique hash to distinguish transactions with the same terms. Arguments : seller : the address of the seller. client : the address of the client. Returns : return the hash in hex.","title":"generate_tx_nonce"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#get_address_from_public_key","text":"| @classmethod | get_address_from_public_key ( cls , public_key : str ) -> str Get the address from the public key. Arguments : public_key : the public key Returns : str","title":"get_address_from_public_key"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#recover_message","text":"| @classmethod | recover_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ Address , ... ] Recover the addresses from the hash. Arguments : message : the message we expect signature : the transaction signature is_deprecated_mode : if the deprecated signing was used Returns : the recovered addresses","title":"recover_message"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#recover_public_keys_from_message","text":"| @classmethod | recover_public_keys_from_message ( cls , message : bytes , signature : str , is_deprecated_mode : bool = False ) -> Tuple [ str , ... ] Get the public key used to produce the signature of the message Arguments : message : raw bytes used to produce signature signature : signature of the message is_deprecated_mode : if the deprecated signing was used Returns : the recovered public keys","title":"recover_public_keys_from_message"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#get_hash","text":"| @staticmethod | get_hash ( message : bytes ) -> str Get the hash of a message. Arguments : message : the message to be hashed. Returns : the hash of the message.","title":"get_hash"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#is_valid_address","text":"| @classmethod | is_valid_address ( cls , address : Address ) -> bool Check if the address is valid. Arguments : address : the address to validate Returns : whether address is valid or not","title":"is_valid_address"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#load_contract_interface","text":"| @classmethod | load_contract_interface ( cls , file_path : Path ) -> Dict [ str , str ] Load contract interface. Arguments : file_path : the file path to the interface Returns : the interface","title":"load_contract_interface"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#cosmoscrypto-objects","text":"class CosmosCrypto ( Crypto [ SigningKey ]) Class wrapping the Account Generation from Ethereum ledger.","title":"CosmosCrypto Objects"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#__init__","text":"| __init__ ( private_key_path : Optional [ str ] = None , password : Optional [ str ] = None ) -> None Instantiate an ethereum crypto object. Arguments : private_key_path : the private key path of the agent password : the password to encrypt/decrypt the private key.","title":"__init__"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#private_key","text":"| @property | private_key () -> str Return a private key. Returns : a private key string","title":"private_key"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#public_key","text":"| @property | public_key () -> str Return a public key in hex format. Returns : a public key string in hex format","title":"public_key"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#address","text":"| @property | address () -> str Return the address for the key pair. Returns : a display_address str","title":"address"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#load_private_key_from_path","text":"| @classmethod | load_private_key_from_path ( cls , file_name : str , password : Optional [ str ] = None ) -> SigningKey Load a private key in hex format from a file. Arguments : file_name : the path to the hex file. password : the password to encrypt/decrypt the private key. Returns : the Entity.","title":"load_private_key_from_path"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#sign_message","text":"| sign_message ( message : bytes , is_deprecated_mode : bool = False ) -> str Sign a message in bytes string form. Arguments : message : the message to be signed is_deprecated_mode : if the deprecated signing is used Returns : signature of the message in string form","title":"sign_message"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#sign_transaction","text":"| sign_transaction ( transaction : JSONLike ) -> JSONLike Sign a transaction in bytes string form. Arguments : transaction : the transaction to be signed Returns : signed transaction","title":"sign_transaction"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#generate_private_key","text":"| @classmethod | generate_private_key ( cls ) -> SigningKey Generate a key pair for cosmos network.","title":"generate_private_key"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#encrypt_1","text":"| encrypt ( password : str ) -> str Encrypt the private key and return in json. Arguments : password : the password to decrypt. Returns : json string containing encrypted private key.","title":"encrypt"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#decrypt_1","text":"| @classmethod | decrypt ( cls , keyfile_json : str , password : str ) -> str Decrypt the private key and return in raw form. Arguments : keyfile_json : json string containing encrypted private key. password : the password to decrypt. Returns : the raw private key.","title":"decrypt"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#_cosmosapi-objects","text":"class _CosmosApi ( LedgerApi ) Class to interact with the Cosmos SDK via a HTTP APIs.","title":"_CosmosApi Objects"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#__init___1","text":"| __init__ ( ** kwargs : Any ) -> None Initialize the Cosmos ledger APIs.","title":"__init__"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#api","text":"| @property | api () -> Any Get the underlying API object.","title":"api"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#get_balance","text":"| get_balance ( address : Address ) -> Optional [ int ] Get the balance of a given account.","title":"get_balance"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#get_state","text":"| get_state ( callable_name : str , * args : Any , ** kwargs : Any ) -> Optional [ JSONLike ] Call a specified function on the ledger API. Based on the cosmos REST API specification, which takes a path (strings separated by '/'). The convention here is to define the root of the path (txs, blocks, etc.) as the callable_name and the rest of the path as args. Arguments : callable_name : name of the callable args : positional arguments kwargs : keyword arguments Returns : the transaction dictionary","title":"get_state"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#get_deploy_transaction","text":"| get_deploy_transaction ( contract_interface : Dict [ str , str ], deployer_address : Address , ** kwargs : Any , ,) -> Optional [ JSONLike ] Get the transaction to deploy the smart contract. Dispatches to _get_storage_transaction and _get_init_transaction based on kwargs. Arguments : contract_interface : the contract interface. deployer_address : The address that will deploy the contract. kwargs : keyword arguments. Returns : the transaction dictionary.","title":"get_deploy_transaction"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#get_handle_transaction","text":"| get_handle_transaction ( sender_address : Address , contract_address : Address , handle_msg : Any , amount : int , tx_fee : int , denom : Optional [ str ] = None , gas : int = DEFAULT_GAS_AMOUNT , memo : str = \"\" , chain_id : Optional [ str ] = None , account_number : Optional [ int ] = None , sequence : Optional [ int ] = None , tx_fee_denom : Optional [ str ] = None ) -> Optional [ JSONLike ] Create a CosmWasm HandleMsg transaction. Arguments : sender_address : the sender address of the message initiator. contract_address : the address of the smart contract. handle_msg : HandleMsg in JSON format. amount : Funds amount sent with transaction. tx_fee : the tx fee accepted. denom : the name of the denomination of the contract funds gas : Maximum amount of gas to be used on executing command. memo : any string comment. chain_id : the Chain ID of the CosmWasm transaction. Default is 1 (i.e. mainnet). account_number : Account number sequence : Sequence tx_fee_denom : Denomination of tx_fee, identical with denom param when None Returns : the unsigned CosmWasm HandleMsg","title":"get_handle_transaction"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#execute_contract_query","text":"| execute_contract_query ( contract_address : Address , query_msg : JSONLike ) -> Optional [ JSONLike ] Execute a CosmWasm QueryMsg. QueryMsg doesn't require signing. Arguments : contract_address : the address of the smart contract. query_msg : QueryMsg in JSON format. Returns : the message receipt","title":"execute_contract_query"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#get_transfer_transaction","text":"| get_transfer_transaction ( sender_address : Address , destination_address : Address , amount : int , tx_fee : int , tx_nonce : str , denom : Optional [ str ] = None , gas : int = DEFAULT_GAS_AMOUNT , memo : str = \"\" , chain_id : Optional [ str ] = None , account_number : Optional [ int ] = None , sequence : Optional [ int ] = None , tx_fee_denom : Optional [ str ] = None , ** kwargs : Any , ,) -> Optional [ JSONLike ] Submit a transfer transaction to the ledger. Arguments : sender_address : the sender address of the payer. destination_address : the destination address of the payee. amount : the amount of wealth to be transferred. tx_fee : the transaction fee. tx_nonce : verifies the authenticity of the tx denom : the denomination of tx fee and amount gas : the gas used. memo : memo to include in tx. chain_id : the chain ID of the transaction. account_number : Account number sequence : Sequence tx_fee_denom : Denomination of tx_fee, identical with denom param when None kwargs : keyword arguments. Returns : the transfer transaction","title":"get_transfer_transaction"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#get_packed_exec_msg","text":"| get_packed_exec_msg ( sender_address : Address , contract_address : str , msg : JSONLike , funds : int = 0 , denom : Optional [ str ] = None ) -> ProtoAny Create and pack MsgExecuteContract Arguments : sender_address : Address of sender contract_address : Address of contract msg : Paramaters to be passed to smart contract funds : Funds to be sent to smart contract denom : the denomination of funds Returns : Packed MsgExecuteContract","title":"get_packed_exec_msg"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#get_packed_send_msg","text":"| get_packed_send_msg ( from_address : Address , to_address : Address , amount : int , denom : Optional [ str ] = None ) -> ProtoAny Generate and pack MsgSend Arguments : from_address : Address of sender to_address : Address of recipient amount : amount of coins to be sent denom : the denomination of and amount Returns : packer ProtoAny type message","title":"get_packed_send_msg"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#get_multi_transaction","text":"| get_multi_transaction ( from_addresses : List [ str ], pub_keys : Optional [ List [ bytes ]], msgs : List [ ProtoAny ], gas : int , tx_fee : int = 0 , memo : str = \"\" , chain_id : Optional [ str ] = None , denom : Optional [ str ] = None , tx_fee_denom : Optional [ str ] = None ) -> JSONLike Generate transaction with multiple messages Arguments : from_addresses : Addresses of signers pub_keys : Public keys of signers msgs : Messages to be included in transaction gas : the gas used. tx_fee : the transaction fee. memo : memo to include in tx. chain_id : the chain ID of the transaction. denom : the denomination of tx fee tx_fee_denom : Denomination of tx_fee, identical with denom param when None :raises: RuntimeError if number of pubkeys is not equal to number of from_addresses Returns : the transaction","title":"get_multi_transaction"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#send_signed_transaction","text":"| send_signed_transaction ( tx_signed : JSONLike ) -> Optional [ str ] Send a signed transaction and wait for confirmation. Arguments : tx_signed : the signed transaction Returns : tx_digest, if present","title":"send_signed_transaction"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#get_transaction_receipt","text":"| get_transaction_receipt ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction receipt for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx receipt, if present","title":"get_transaction_receipt"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#get_transaction","text":"| get_transaction ( tx_digest : str ) -> Optional [ JSONLike ] Get the transaction for a transaction digest. Arguments : tx_digest : the digest associated to the transaction. Returns : the tx, if present","title":"get_transaction"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#get_contract_instance","text":"| get_contract_instance ( contract_interface : Dict [ str , str ], contract_address : Optional [ str ] = None ) -> Any Get the instance of a contract. Arguments : contract_interface : the contract interface. contract_address : the contract address. Returns : the contract instance","title":"get_contract_instance"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#update_with_gas_estimate","text":"| update_with_gas_estimate ( transaction : JSONLike ) -> JSONLike Attempts to update the transaction with a gas estimate Arguments : transaction : the transaction :raises: NotImplementedError","title":"update_with_gas_estimate"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#cosmosapi-objects","text":"class CosmosApi ( _CosmosApi , CosmosHelper ) Class to interact with the Cosmos SDK via a HTTP APIs.","title":"CosmosApi Objects"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#cosmosfaucetapi-objects","text":"class CosmosFaucetApi ( FaucetApi ) Cosmos testnet faucet API.","title":"CosmosFaucetApi Objects"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#__init___2","text":"| __init__ ( poll_interval : Optional [ float ] = None , final_wait_interval : Optional [ float ] = None ) Initialize CosmosFaucetApi.","title":"__init__"},{"location":"aea/api/plugins/aea_ledger_fetchai/_cosmos/#get_wealth","text":"| get_wealth ( address : Address , url : Optional [ str ] = None ) -> None Get wealth from the faucet for the provided address. Arguments : address : the address. url : the url :raises: RuntimeError of explicit faucet failures","title":"get_wealth"},{"location":"aea/api/plugins/aea_ledger_fetchai/fetchai/","text":"plugins.aea-ledger-fetchai.aea _ ledger _ fetchai.fetchai Fetchai module wrapping the public and private key cryptography and ledger api. FetchAIHelper Objects class FetchAIHelper ( CosmosHelper ) Helper class usable as Mixin for FetchAIApi or as standalone class. FetchAICrypto Objects class FetchAICrypto ( CosmosCrypto ) Class wrapping the Entity Generation from Fetch.AI ledger. FetchAIApi Objects class FetchAIApi ( _CosmosApi , FetchAIHelper ) Class to interact with the Fetch ledger APIs. __ init __ | __init__ ( ** kwargs : Any ) -> None Initialize the Fetch.ai ledger APIs. FetchAIFaucetApi Objects class FetchAIFaucetApi ( CosmosFaucetApi ) Fetchai testnet faucet API.","title":"API"},{"location":"aea/api/plugins/aea_ledger_fetchai/fetchai/#pluginsaea-ledger-fetchaiaea_ledger_fetchaifetchai","text":"Fetchai module wrapping the public and private key cryptography and ledger api.","title":"plugins.aea-ledger-fetchai.aea_ledger_fetchai.fetchai"},{"location":"aea/api/plugins/aea_ledger_fetchai/fetchai/#fetchaihelper-objects","text":"class FetchAIHelper ( CosmosHelper ) Helper class usable as Mixin for FetchAIApi or as standalone class.","title":"FetchAIHelper Objects"},{"location":"aea/api/plugins/aea_ledger_fetchai/fetchai/#fetchaicrypto-objects","text":"class FetchAICrypto ( CosmosCrypto ) Class wrapping the Entity Generation from Fetch.AI ledger.","title":"FetchAICrypto Objects"},{"location":"aea/api/plugins/aea_ledger_fetchai/fetchai/#fetchaiapi-objects","text":"class FetchAIApi ( _CosmosApi , FetchAIHelper ) Class to interact with the Fetch ledger APIs.","title":"FetchAIApi Objects"},{"location":"aea/api/plugins/aea_ledger_fetchai/fetchai/#__init__","text":"| __init__ ( ** kwargs : Any ) -> None Initialize the Fetch.ai ledger APIs.","title":"__init__"},{"location":"aea/api/plugins/aea_ledger_fetchai/fetchai/#fetchaifaucetapi-objects","text":"class FetchAIFaucetApi ( CosmosFaucetApi ) Fetchai testnet faucet API.","title":"FetchAIFaucetApi Objects"},{"location":"aea/api/protocols/base/","text":"aea.protocols.base This module contains the base message and serialization definition. Message Objects class Message () This class implements a message. Performative Objects class Performative ( Enum ) Performatives for the base message. __ str __ | __str__ () -> str Get the string representation. __ init __ | __init__ ( _body : Optional [ Dict ] = None , ** kwargs : Any ) -> None Initialize a Message object. Arguments : _body : the dictionary of values to hold. kwargs : any additional value to add to the body. It will overwrite the body values. json | json () -> dict Get json friendly str representation of the message. from _ json | @classmethod | from_json ( cls , data : dict ) -> \"Message\" Construct message instance from json data. valid _ performatives | @property | valid_performatives () -> Set [ str ] Get valid performatives. has _ sender | @property | has_sender () -> bool Check if it has a sender. sender | @property | sender () -> Address Get the sender of the message in Address form. sender | @sender . setter | sender ( sender : Address ) -> None Set the sender of the message. has _ to | @property | has_to () -> bool Check if it has a sender. to | @property | to () -> Address Get address of receiver. to | @to . setter | to ( to : Address ) -> None Set address of receiver. dialogue _ reference | @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message. message _ id | @property | message_id () -> int Get the message_id of the message. performative | @property | performative () -> \"Performative\" Get the performative of the message. target | @property | target () -> int Get the target of the message. set | set ( key : str , value : Any ) -> None Set key and value pair. Arguments : key : the key. value : the value. get | get ( key : str ) -> Optional [ Any ] Get value for key. is _ set | is_set ( key : str ) -> bool Check value is set for key. __ eq __ | __eq__ ( other : Any ) -> bool Compare with another object. __ repr __ | __repr__ () -> str Get the representation of the message. __ str __ | __str__ () -> str Get the string representation of the message. Abbreviated to prevent spamming of logs. encode | encode () -> bytes Encode the message. decode | @classmethod | decode ( cls , data : bytes ) -> \"Message\" Decode the message. has _ dialogue _ info | @property | has_dialogue_info () -> bool Check whether a message has the dialogue fields populated. More precisely, it checks whether the fields 'message_id', 'target' and 'dialogue_reference' are set. Returns : True if the message has the dialogue fields set, False otherwise. Encoder Objects class Encoder ( ABC ) Encoder interface. encode | @staticmethod | @abstractmethod | encode ( msg : Message ) -> bytes Encode a message. Arguments : msg : the message to be encoded. Returns : the encoded message. Decoder Objects class Decoder ( ABC ) Decoder interface. decode | @staticmethod | @abstractmethod | decode ( obj : bytes ) -> Message Decode a message. Arguments : obj : the sequence of bytes to be decoded. Returns : the decoded message. Serializer Objects class Serializer ( Encoder , Decoder , ABC ) The implementations of this class defines a serialization layer for a protocol. Protocol Objects class Protocol ( Component ) This class implements a specifications for a protocol. It includes a serializer to encode/decode a message. __ init __ | __init__ ( configuration : ProtocolConfig , message_class : Type [ Message ], ** kwargs : Any ) -> None Initialize the protocol manager. Arguments : configuration : the protocol configurations. message_class : the message class. kwargs : the keyword arguments. serializer | @property | serializer () -> Type [ Serializer ] Get the serializer. from _ dir | @classmethod | from_dir ( cls , directory : str , ** kwargs : Any ) -> \"Protocol\" Load the protocol from a directory. Arguments : directory : the directory to the skill package. kwargs : the keyword arguments. Returns : the protocol object. from _ config | @classmethod | from_config ( cls , configuration : ProtocolConfig , ** kwargs : Any ) -> \"Protocol\" Load the protocol from configuration. Arguments : configuration : the protocol configuration. kwargs : the keyword arguments. Returns : the protocol object. protocol _ id | @property | protocol_id () -> PublicId Get protocol id. protocol _ specification _ id | @property | protocol_specification_id () -> PublicId Get protocol specification id. __ repr __ | __repr__ () -> str Get str representation of the protocol.","title":"Base"},{"location":"aea/api/protocols/base/#aeaprotocolsbase","text":"This module contains the base message and serialization definition.","title":"aea.protocols.base"},{"location":"aea/api/protocols/base/#message-objects","text":"class Message () This class implements a message.","title":"Message Objects"},{"location":"aea/api/protocols/base/#performative-objects","text":"class Performative ( Enum ) Performatives for the base message.","title":"Performative Objects"},{"location":"aea/api/protocols/base/#__str__","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/protocols/base/#__init__","text":"| __init__ ( _body : Optional [ Dict ] = None , ** kwargs : Any ) -> None Initialize a Message object. Arguments : _body : the dictionary of values to hold. kwargs : any additional value to add to the body. It will overwrite the body values.","title":"__init__"},{"location":"aea/api/protocols/base/#json","text":"| json () -> dict Get json friendly str representation of the message.","title":"json"},{"location":"aea/api/protocols/base/#from_json","text":"| @classmethod | from_json ( cls , data : dict ) -> \"Message\" Construct message instance from json data.","title":"from_json"},{"location":"aea/api/protocols/base/#valid_performatives","text":"| @property | valid_performatives () -> Set [ str ] Get valid performatives.","title":"valid_performatives"},{"location":"aea/api/protocols/base/#has_sender","text":"| @property | has_sender () -> bool Check if it has a sender.","title":"has_sender"},{"location":"aea/api/protocols/base/#sender","text":"| @property | sender () -> Address Get the sender of the message in Address form.","title":"sender"},{"location":"aea/api/protocols/base/#sender_1","text":"| @sender . setter | sender ( sender : Address ) -> None Set the sender of the message.","title":"sender"},{"location":"aea/api/protocols/base/#has_to","text":"| @property | has_to () -> bool Check if it has a sender.","title":"has_to"},{"location":"aea/api/protocols/base/#to","text":"| @property | to () -> Address Get address of receiver.","title":"to"},{"location":"aea/api/protocols/base/#to_1","text":"| @to . setter | to ( to : Address ) -> None Set address of receiver.","title":"to"},{"location":"aea/api/protocols/base/#dialogue_reference","text":"| @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message.","title":"dialogue_reference"},{"location":"aea/api/protocols/base/#message_id","text":"| @property | message_id () -> int Get the message_id of the message.","title":"message_id"},{"location":"aea/api/protocols/base/#performative","text":"| @property | performative () -> \"Performative\" Get the performative of the message.","title":"performative"},{"location":"aea/api/protocols/base/#target","text":"| @property | target () -> int Get the target of the message.","title":"target"},{"location":"aea/api/protocols/base/#set","text":"| set ( key : str , value : Any ) -> None Set key and value pair. Arguments : key : the key. value : the value.","title":"set"},{"location":"aea/api/protocols/base/#get","text":"| get ( key : str ) -> Optional [ Any ] Get value for key.","title":"get"},{"location":"aea/api/protocols/base/#is_set","text":"| is_set ( key : str ) -> bool Check value is set for key.","title":"is_set"},{"location":"aea/api/protocols/base/#__eq__","text":"| __eq__ ( other : Any ) -> bool Compare with another object.","title":"__eq__"},{"location":"aea/api/protocols/base/#__repr__","text":"| __repr__ () -> str Get the representation of the message.","title":"__repr__"},{"location":"aea/api/protocols/base/#__str___1","text":"| __str__ () -> str Get the string representation of the message. Abbreviated to prevent spamming of logs.","title":"__str__"},{"location":"aea/api/protocols/base/#encode","text":"| encode () -> bytes Encode the message.","title":"encode"},{"location":"aea/api/protocols/base/#decode","text":"| @classmethod | decode ( cls , data : bytes ) -> \"Message\" Decode the message.","title":"decode"},{"location":"aea/api/protocols/base/#has_dialogue_info","text":"| @property | has_dialogue_info () -> bool Check whether a message has the dialogue fields populated. More precisely, it checks whether the fields 'message_id', 'target' and 'dialogue_reference' are set. Returns : True if the message has the dialogue fields set, False otherwise.","title":"has_dialogue_info"},{"location":"aea/api/protocols/base/#encoder-objects","text":"class Encoder ( ABC ) Encoder interface.","title":"Encoder Objects"},{"location":"aea/api/protocols/base/#encode_1","text":"| @staticmethod | @abstractmethod | encode ( msg : Message ) -> bytes Encode a message. Arguments : msg : the message to be encoded. Returns : the encoded message.","title":"encode"},{"location":"aea/api/protocols/base/#decoder-objects","text":"class Decoder ( ABC ) Decoder interface.","title":"Decoder Objects"},{"location":"aea/api/protocols/base/#decode_1","text":"| @staticmethod | @abstractmethod | decode ( obj : bytes ) -> Message Decode a message. Arguments : obj : the sequence of bytes to be decoded. Returns : the decoded message.","title":"decode"},{"location":"aea/api/protocols/base/#serializer-objects","text":"class Serializer ( Encoder , Decoder , ABC ) The implementations of this class defines a serialization layer for a protocol.","title":"Serializer Objects"},{"location":"aea/api/protocols/base/#protocol-objects","text":"class Protocol ( Component ) This class implements a specifications for a protocol. It includes a serializer to encode/decode a message.","title":"Protocol Objects"},{"location":"aea/api/protocols/base/#__init___1","text":"| __init__ ( configuration : ProtocolConfig , message_class : Type [ Message ], ** kwargs : Any ) -> None Initialize the protocol manager. Arguments : configuration : the protocol configurations. message_class : the message class. kwargs : the keyword arguments.","title":"__init__"},{"location":"aea/api/protocols/base/#serializer","text":"| @property | serializer () -> Type [ Serializer ] Get the serializer.","title":"serializer"},{"location":"aea/api/protocols/base/#from_dir","text":"| @classmethod | from_dir ( cls , directory : str , ** kwargs : Any ) -> \"Protocol\" Load the protocol from a directory. Arguments : directory : the directory to the skill package. kwargs : the keyword arguments. Returns : the protocol object.","title":"from_dir"},{"location":"aea/api/protocols/base/#from_config","text":"| @classmethod | from_config ( cls , configuration : ProtocolConfig , ** kwargs : Any ) -> \"Protocol\" Load the protocol from configuration. Arguments : configuration : the protocol configuration. kwargs : the keyword arguments. Returns : the protocol object.","title":"from_config"},{"location":"aea/api/protocols/base/#protocol_id","text":"| @property | protocol_id () -> PublicId Get protocol id.","title":"protocol_id"},{"location":"aea/api/protocols/base/#protocol_specification_id","text":"| @property | protocol_specification_id () -> PublicId Get protocol specification id.","title":"protocol_specification_id"},{"location":"aea/api/protocols/base/#__repr___1","text":"| __repr__ () -> str Get str representation of the protocol.","title":"__repr__"},{"location":"aea/api/protocols/default/custom_types/","text":"packages.fetchai.protocols.default.custom _ types This module contains class representations corresponding to every custom type in the protocol specification. ErrorCode Objects class ErrorCode ( Enum ) This class represents an instance of ErrorCode. encode | @staticmethod | encode ( error_code_protobuf_object : Any , error_code_object : \"ErrorCode\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the error_code_protobuf_object argument is matched with the instance of this class in the 'error_code_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. error_code_object : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , error_code_protobuf_object : Any ) -> \"ErrorCode\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class is created that matches the protocol buffer object in the 'error_code_protobuf_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'error_code_protobuf_object' argument.","title":"Custom Types"},{"location":"aea/api/protocols/default/custom_types/#packagesfetchaiprotocolsdefaultcustom_types","text":"This module contains class representations corresponding to every custom type in the protocol specification.","title":"packages.fetchai.protocols.default.custom_types"},{"location":"aea/api/protocols/default/custom_types/#errorcode-objects","text":"class ErrorCode ( Enum ) This class represents an instance of ErrorCode.","title":"ErrorCode Objects"},{"location":"aea/api/protocols/default/custom_types/#encode","text":"| @staticmethod | encode ( error_code_protobuf_object : Any , error_code_object : \"ErrorCode\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the error_code_protobuf_object argument is matched with the instance of this class in the 'error_code_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. error_code_object : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/protocols/default/custom_types/#decode","text":"| @classmethod | decode ( cls , error_code_protobuf_object : Any ) -> \"ErrorCode\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class is created that matches the protocol buffer object in the 'error_code_protobuf_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'error_code_protobuf_object' argument.","title":"decode"},{"location":"aea/api/protocols/default/dialogues/","text":"packages.fetchai.protocols.default.dialogues This module contains the classes required for default dialogue management. DefaultDialogue: The dialogue class maintains state of a dialogue and manages it. DefaultDialogues: The dialogues class keeps track of all dialogues. DefaultDialogue Objects class DefaultDialogue ( Dialogue ) The default dialogue class maintains state of a dialogue and manages it. Role Objects class Role ( Dialogue . Role ) This class defines the agent's role in a default dialogue. EndState Objects class EndState ( Dialogue . EndState ) This class defines the end states of a default dialogue. __ init __ | __init__ ( dialogue_label : DialogueLabel , self_address : Address , role : Dialogue . Role , message_class : Type [ DefaultMessage ] = DefaultMessage ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for Returns : None DefaultDialogues Objects class DefaultDialogues ( Dialogues , ABC ) This class keeps track of all default dialogues. __ init __ | __init__ ( self_address : Address , role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], dialogue_class : Type [ DefaultDialogue ] = DefaultDialogue ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained Returns : None","title":"Dialogues"},{"location":"aea/api/protocols/default/dialogues/#packagesfetchaiprotocolsdefaultdialogues","text":"This module contains the classes required for default dialogue management. DefaultDialogue: The dialogue class maintains state of a dialogue and manages it. DefaultDialogues: The dialogues class keeps track of all dialogues.","title":"packages.fetchai.protocols.default.dialogues"},{"location":"aea/api/protocols/default/dialogues/#defaultdialogue-objects","text":"class DefaultDialogue ( Dialogue ) The default dialogue class maintains state of a dialogue and manages it.","title":"DefaultDialogue Objects"},{"location":"aea/api/protocols/default/dialogues/#role-objects","text":"class Role ( Dialogue . Role ) This class defines the agent's role in a default dialogue.","title":"Role Objects"},{"location":"aea/api/protocols/default/dialogues/#endstate-objects","text":"class EndState ( Dialogue . EndState ) This class defines the end states of a default dialogue.","title":"EndState Objects"},{"location":"aea/api/protocols/default/dialogues/#__init__","text":"| __init__ ( dialogue_label : DialogueLabel , self_address : Address , role : Dialogue . Role , message_class : Type [ DefaultMessage ] = DefaultMessage ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for Returns : None","title":"__init__"},{"location":"aea/api/protocols/default/dialogues/#defaultdialogues-objects","text":"class DefaultDialogues ( Dialogues , ABC ) This class keeps track of all default dialogues.","title":"DefaultDialogues Objects"},{"location":"aea/api/protocols/default/dialogues/#__init___1","text":"| __init__ ( self_address : Address , role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], dialogue_class : Type [ DefaultDialogue ] = DefaultDialogue ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained Returns : None","title":"__init__"},{"location":"aea/api/protocols/default/message/","text":"packages.fetchai.protocols.default.message This module contains default's message definition. DefaultMessage Objects class DefaultMessage ( Message ) A protocol for exchanging any bytes message. Performative Objects class Performative ( Message . Performative ) Performatives for the default protocol. __ str __ | __str__ () -> str Get the string representation. __ init __ | __init__ ( performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs : Any , ,) Initialise an instance of DefaultMessage. Arguments : message_id : the message id. dialogue_reference : the dialogue reference. target : the message target. performative : the message performative. valid _ performatives | @property | valid_performatives () -> Set [ str ] Get valid performatives. dialogue _ reference | @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message. message _ id | @property | message_id () -> int Get the message_id of the message. performative | @property | performative () -> Performative Get the performative of the message. target | @property | target () -> int Get the target of the message. content | @property | content () -> bytes Get the 'content' content from the message. error _ code | @property | error_code () -> CustomErrorCode Get the 'error_code' content from the message. error _ data | @property | error_data () -> Dict [ str , bytes ] Get the 'error_data' content from the message. error _ msg | @property | error_msg () -> str Get the 'error_msg' content from the message.","title":"Message"},{"location":"aea/api/protocols/default/message/#packagesfetchaiprotocolsdefaultmessage","text":"This module contains default's message definition.","title":"packages.fetchai.protocols.default.message"},{"location":"aea/api/protocols/default/message/#defaultmessage-objects","text":"class DefaultMessage ( Message ) A protocol for exchanging any bytes message.","title":"DefaultMessage Objects"},{"location":"aea/api/protocols/default/message/#performative-objects","text":"class Performative ( Message . Performative ) Performatives for the default protocol.","title":"Performative Objects"},{"location":"aea/api/protocols/default/message/#__str__","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/protocols/default/message/#__init__","text":"| __init__ ( performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs : Any , ,) Initialise an instance of DefaultMessage. Arguments : message_id : the message id. dialogue_reference : the dialogue reference. target : the message target. performative : the message performative.","title":"__init__"},{"location":"aea/api/protocols/default/message/#valid_performatives","text":"| @property | valid_performatives () -> Set [ str ] Get valid performatives.","title":"valid_performatives"},{"location":"aea/api/protocols/default/message/#dialogue_reference","text":"| @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message.","title":"dialogue_reference"},{"location":"aea/api/protocols/default/message/#message_id","text":"| @property | message_id () -> int Get the message_id of the message.","title":"message_id"},{"location":"aea/api/protocols/default/message/#performative","text":"| @property | performative () -> Performative Get the performative of the message.","title":"performative"},{"location":"aea/api/protocols/default/message/#target","text":"| @property | target () -> int Get the target of the message.","title":"target"},{"location":"aea/api/protocols/default/message/#content","text":"| @property | content () -> bytes Get the 'content' content from the message.","title":"content"},{"location":"aea/api/protocols/default/message/#error_code","text":"| @property | error_code () -> CustomErrorCode Get the 'error_code' content from the message.","title":"error_code"},{"location":"aea/api/protocols/default/message/#error_data","text":"| @property | error_data () -> Dict [ str , bytes ] Get the 'error_data' content from the message.","title":"error_data"},{"location":"aea/api/protocols/default/message/#error_msg","text":"| @property | error_msg () -> str Get the 'error_msg' content from the message.","title":"error_msg"},{"location":"aea/api/protocols/default/serialization/","text":"packages.fetchai.protocols.default.serialization Serialization module for default protocol. DefaultSerializer Objects class DefaultSerializer ( Serializer ) Serialization for the 'default' protocol. encode | @staticmethod | encode ( msg : Message ) -> bytes Encode a 'Default' message into bytes. Arguments : msg : the message object. Returns : the bytes. decode | @staticmethod | decode ( obj : bytes ) -> Message Decode bytes into a 'Default' message. Arguments : obj : the bytes object. Returns : the 'Default' message.","title":"Serialization"},{"location":"aea/api/protocols/default/serialization/#packagesfetchaiprotocolsdefaultserialization","text":"Serialization module for default protocol.","title":"packages.fetchai.protocols.default.serialization"},{"location":"aea/api/protocols/default/serialization/#defaultserializer-objects","text":"class DefaultSerializer ( Serializer ) Serialization for the 'default' protocol.","title":"DefaultSerializer Objects"},{"location":"aea/api/protocols/default/serialization/#encode","text":"| @staticmethod | encode ( msg : Message ) -> bytes Encode a 'Default' message into bytes. Arguments : msg : the message object. Returns : the bytes.","title":"encode"},{"location":"aea/api/protocols/default/serialization/#decode","text":"| @staticmethod | decode ( obj : bytes ) -> Message Decode bytes into a 'Default' message. Arguments : obj : the bytes object. Returns : the 'Default' message.","title":"decode"},{"location":"aea/api/protocols/dialogue/base/","text":"aea.protocols.dialogue.base This module contains the classes required for dialogue management. DialogueLabel: The dialogue label class acts as an identifier for dialogues. Dialogue: The dialogue class maintains state of a dialogue and manages it. Dialogues: The dialogues class keeps track of all dialogues. InvalidDialogueMessage Objects class InvalidDialogueMessage ( Exception ) Exception for adding invalid message to a dialogue. DialogueLabel Objects class DialogueLabel () The dialogue label class acts as an identifier for dialogues. __ init __ | __init__ ( dialogue_reference : Tuple [ str , str ], dialogue_opponent_addr : Address , dialogue_starter_addr : Address ) -> None Initialize a dialogue label. Arguments : dialogue_reference : the reference of the dialogue. dialogue_opponent_addr : the addr of the agent with which the dialogue is kept. dialogue_starter_addr : the addr of the agent which started the dialogue. dialogue _ reference | @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue reference. dialogue _ starter _ reference | @property | dialogue_starter_reference () -> str Get the dialogue starter reference. dialogue _ responder _ reference | @property | dialogue_responder_reference () -> str Get the dialogue responder reference. dialogue _ opponent _ addr | @property | dialogue_opponent_addr () -> str Get the address of the dialogue opponent. dialogue _ starter _ addr | @property | dialogue_starter_addr () -> str Get the address of the dialogue starter. __ eq __ | __eq__ ( other : Any ) -> bool Check for equality between two DialogueLabel objects. __ hash __ | __hash__ () -> int Turn object into hash. json | @property | json () -> Dict Return the JSON representation. from _ json | @classmethod | from_json ( cls , obj : Dict [ str , str ]) -> \"DialogueLabel\" Get dialogue label from json. get _ incomplete _ version | get_incomplete_version () -> \"DialogueLabel\" Get the incomplete version of the label. __ str __ | __str__ () -> str Get the string representation. from _ str | @classmethod | from_str ( cls , obj : str ) -> \"DialogueLabel\" Get the dialogue label from string representation. _ DialogueMeta Objects class _DialogueMeta ( type ) Metaclass for Dialogue. Creates class level Rules instance to share among instances __ new __ | __new__ ( cls , name : str , bases : Tuple [ Type ], dct : Dict ) -> \"_DialogueMeta\" Construct a new type. Dialogue Objects class Dialogue (, metaclass = _DialogueMeta ) The dialogue class maintains state of a dialogue and manages it. Rules Objects class Rules () This class defines the rules for the dialogue. __ init __ | __init__ ( initial_performatives : FrozenSet [ Message . Performative ], terminal_performatives : FrozenSet [ Message . Performative ], valid_replies : Dict [ Message . Performative , FrozenSet [ Message . Performative ]]) -> None Initialize a dialogue. Arguments : initial_performatives : the set of all initial performatives. terminal_performatives : the set of all terminal performatives. valid_replies : the reply structure of speech-acts. initial _ performatives | @property | initial_performatives () -> FrozenSet [ Message . Performative ] Get the performatives one of which the terminal message in the dialogue must have. Returns : the valid performatives of an terminal message terminal _ performatives | @property | terminal_performatives () -> FrozenSet [ Message . Performative ] Get the performatives one of which the terminal message in the dialogue must have. Returns : the valid performatives of an terminal message valid _ replies | @property | valid_replies () -> Dict [ Message . Performative , FrozenSet [ Message . Performative ]] Get all the valid performatives which are a valid replies to performatives. Returns : the full valid reply structure. get _ valid _ replies | get_valid_replies ( performative : Message . Performative ) -> FrozenSet [ Message . Performative ] Given a performative , return the list of performatives which are its valid replies in a dialogue. Arguments : performative : the performative in a message Returns : list of valid performative replies Role Objects class Role ( Enum ) This class defines the agent's role in a dialogue. __ str __ | __str__ () -> str Get the string representation. EndState Objects class EndState ( Enum ) This class defines the end states of a dialogue. __ str __ | __str__ () -> str Get the string representation. __ init __ | __init__ ( dialogue_label : DialogueLabel , message_class : Type [ Message ], self_address : Address , role : Role ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue message_class : the message class used self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for add _ terminal _ state _ callback | add_terminal_state_callback ( fn : Callable [[ \"Dialogue\" ], None ]) -> None Add callback to be called on dialogue reach terminal state. Arguments : fn : callable to be called with one argument: Dialogue __ eq __ | __eq__ ( other : Any ) -> bool Compare two dialogues. json | json () -> dict Get json representation of the dialogue. from _ json | @classmethod | from_json ( cls , message_class : Type [ Message ], data : dict ) -> \"Dialogue\" Create a dialogue instance with all messages from json data. Arguments : message_class : type of message used with this dialogue data : dict with data exported with Dialogue.to_json() method Returns : Dialogue instance dialogue _ label | @property | dialogue_label () -> DialogueLabel Get the dialogue label. Returns : The dialogue label incomplete _ dialogue _ label | @property | incomplete_dialogue_label () -> DialogueLabel Get the dialogue label. Returns : The incomplete dialogue label dialogue _ labels | @property | dialogue_labels () -> Set [ DialogueLabel ] Get the dialogue labels (incomplete and complete, if it exists). Returns : the dialogue labels self _ address | @property | self_address () -> Address Get the address of the entity for whom this dialogues is maintained. Returns : the address of this entity role | @property | role () -> \"Role\" Get the agent's role in the dialogue. Returns : the agent's role rules | @property | rules () -> \"Rules\" Get the dialogue rules. Returns : the rules message _ class | @property | message_class () -> Type [ Message ] Get the message class. Returns : the message class is _ self _ initiated | @property | is_self_initiated () -> bool Check whether the agent initiated the dialogue. Returns : True if the agent initiated the dialogue, False otherwise last _ incoming _ message | @property | last_incoming_message () -> Optional [ Message ] Get the last incoming message. Returns : the last incoming message if it exists, None otherwise last _ outgoing _ message | @property | last_outgoing_message () -> Optional [ Message ] Get the last outgoing message. Returns : the last outgoing message if it exists, None otherwise last _ message | @property | last_message () -> Optional [ Message ] Get the last message. Returns : the last message if it exists, None otherwise is _ empty | @property | is_empty () -> bool Check whether the dialogue is empty. Returns : True if empty, False otherwise reply | reply ( performative : Message . Performative , target_message : Optional [ Message ] = None , target : Optional [ int ] = None , ** kwargs : Any , ,) -> Message Reply to the 'target_message' in this dialogue with a message with 'performative', and contents from kwargs. Note if no target_message is provided, the last message in the dialogue will be replied to. Arguments : target_message : the message to reply to. target : the id of the message to reply to. performative : the performative of the reply message. kwargs : the content of the reply message. Returns : the reply message if it was successfully added as a reply, None otherwise. get _ message _ by _ id | get_message_by_id ( message_id : int ) -> Optional [ Message ] Get message by id, if not presents return None. get _ outgoing _ next _ message _ id | get_outgoing_next_message_id () -> int Get next outgoing message id. get _ incoming _ next _ message _ id | get_incoming_next_message_id () -> int Get next incoming message id. __ str __ | __str__ () -> str Get the string representation. Returns : The string representation of the dialogue DialogueStats Objects class DialogueStats () Class to handle statistics on default dialogues. __ init __ | __init__ ( end_states : FrozenSet [ Dialogue . EndState ]) -> None Initialize a StatsManager. Arguments : end_states : the list of dialogue endstates self _ initiated | @property | self_initiated () -> Dict [ Dialogue . EndState , int ] Get the stats dictionary on self initiated dialogues. other _ initiated | @property | other_initiated () -> Dict [ Dialogue . EndState , int ] Get the stats dictionary on other initiated dialogues. add _ dialogue _ endstate | add_dialogue_endstate ( end_state : Dialogue . EndState , is_self_initiated : bool ) -> None Add dialogue endstate stats. Arguments : end_state : the end state of the dialogue is_self_initiated : whether the dialogue is initiated by the agent or the opponent find _ caller _ object find_caller_object ( object_type : Type ) -> Any Find caller object of certain type in the call stack. BasicDialoguesStorage Objects class BasicDialoguesStorage () Dialogues state storage. __ init __ | __init__ ( dialogues : \"Dialogues\" ) -> None Init dialogues storage. dialogues _ in _ terminal _ state | @property | dialogues_in_terminal_state () -> List [ \"Dialogue\" ] Get all dialogues in terminal state. dialogues _ in _ active _ state | @property | dialogues_in_active_state () -> List [ \"Dialogue\" ] Get all dialogues in active state. is _ terminal _ dialogues _ kept | @property | is_terminal_dialogues_kept () -> bool Return True if dialogues should stay after terminal state. dialogue _ terminal _ state _ callback | dialogue_terminal_state_callback ( dialogue : \"Dialogue\" ) -> None Method to be called on dialogue terminal state reached. setup | setup () -> None Set up dialogue storage. teardown | teardown () -> None Tear down dialogue storage. add | add ( dialogue : Dialogue ) -> None Add dialogue to storage. Arguments : dialogue : dialogue to add. remove | remove ( dialogue_label : DialogueLabel ) -> None Remove dialogue from storage by it's label. Arguments : dialogue_label : label of the dialogue to remove get | get ( dialogue_label : DialogueLabel ) -> Optional [ Dialogue ] Get dialogue stored by it's label. Arguments : dialogue_label : label of the dialogue Returns : dialogue if presents or None get _ dialogues _ with _ counterparty | get_dialogues_with_counterparty ( counterparty : Address ) -> List [ Dialogue ] Get the dialogues by address. Arguments : counterparty : the counterparty Returns : The dialogues with the counterparty. is _ in _ incomplete | is_in_incomplete ( dialogue_label : DialogueLabel ) -> bool Check dialogue label presents in list of incomplete. set _ incomplete _ dialogue | set_incomplete_dialogue ( incomplete_dialogue_label : DialogueLabel , complete_dialogue_label : DialogueLabel ) -> None Set incomplete dialogue label. is _ dialogue _ present | is_dialogue_present ( dialogue_label : DialogueLabel ) -> bool Check dialogue with label specified presents in storage. get _ latest _ label | get_latest_label ( dialogue_label : DialogueLabel ) -> DialogueLabel Get latest label for dialogue. PersistDialoguesStorage Objects class PersistDialoguesStorage ( BasicDialoguesStorage ) Persist dialogues storage. Uses generic storage to load/save dialogues data on setup/teardown. __ init __ | __init__ ( dialogues : \"Dialogues\" ) -> None Init dialogues storage. get _ skill _ component | @staticmethod | get_skill_component () -> Optional [ SkillComponent ] Get skill component dialogues storage constructed for. setup | setup () -> None Set up dialogue storage. teardown | teardown () -> None Tear down dialogue storage. remove | remove ( dialogue_label : DialogueLabel ) -> None Remove dialogue from memory and persistent storage. PersistDialoguesStorageWithOffloading Objects class PersistDialoguesStorageWithOffloading ( PersistDialoguesStorage ) Dialogue Storage with dialogues offloading. dialogue _ terminal _ state _ callback | dialogue_terminal_state_callback ( dialogue : \"Dialogue\" ) -> None Call on dialogue reaches terminal state. get | get ( dialogue_label : DialogueLabel ) -> Optional [ Dialogue ] Try to get dialogue by label from memory or persists storage. get _ dialogues _ with _ counterparty | get_dialogues_with_counterparty ( counterparty : Address ) -> List [ Dialogue ] Get the dialogues by address. Arguments : counterparty : the counterparty Returns : The dialogues with the counterparty. dialogues _ in _ terminal _ state | @property | dialogues_in_terminal_state () -> List [ \"Dialogue\" ] Get all dialogues in terminal state. Dialogues Objects class Dialogues () The dialogues class keeps track of all dialogues for an agent. __ init __ | __init__ ( self_address : Address , end_states : FrozenSet [ Dialogue . EndState ], message_class : Type [ Message ], dialogue_class : Type [ Dialogue ], role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], keep_terminal_state_dialogues : Optional [ bool ] = None ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained end_states : the list of dialogue endstates message_class : the message class used dialogue_class : the dialogue class used role_from_first_message : the callable determining role from first message keep_terminal_state_dialogues : specify do dialogues in terminal state should stay or not is _ keep _ dialogues _ in _ terminal _ state | @property | is_keep_dialogues_in_terminal_state () -> bool Is required to keep dialogues in terminal state. self _ address | @property | self_address () -> Address Get the address of the agent for whom dialogues are maintained. dialogue _ stats | @property | dialogue_stats () -> DialogueStats Get the dialogue statistics. Returns : dialogue stats object message _ class | @property | message_class () -> Type [ Message ] Get the message class. Returns : the message class dialogue _ class | @property | dialogue_class () -> Type [ Dialogue ] Get the dialogue class. Returns : the dialogue class get _ dialogues _ with _ counterparty | get_dialogues_with_counterparty ( counterparty : Address ) -> List [ Dialogue ] Get the dialogues by address. Arguments : counterparty : the counterparty Returns : The dialogues with the counterparty. new _ self _ initiated _ dialogue _ reference | @classmethod | new_self_initiated_dialogue_reference ( cls ) -> Tuple [ str , str ] Return a dialogue label for a new self initiated dialogue. Returns : the next nonce create | create ( counterparty : Address , performative : Message . Performative , ** kwargs : Any , ,) -> Tuple [ Message , Dialogue ] Create a dialogue with 'counterparty', with an initial message whose performative is 'performative' and contents are from 'kwargs'. Arguments : counterparty : the counterparty of the dialogue. performative : the performative of the initial message. kwargs : the content of the initial message. Returns : the initial message and the dialogue. create _ with _ message | create_with_message ( counterparty : Address , initial_message : Message ) -> Dialogue Create a dialogue with 'counterparty', with an initial message provided. Arguments : counterparty : the counterparty of the dialogue. initial_message : the initial_message. Returns : the initial message and the dialogue. update | update ( message : Message ) -> Optional [ Dialogue ] Update the state of dialogues with a new incoming message. If the message is for a new dialogue, a new dialogue is created with 'message' as its first message, and returned. If the message is addressed to an existing dialogue, the dialogue is retrieved, extended with this message and returned. If there are any errors, e.g. the message dialogue reference does not exists or the message is invalid w.r.t. the dialogue, return None. Arguments : message : a new incoming message Returns : the new or existing dialogue the message is intended for, or None in case of any errors. get _ dialogue | get_dialogue ( message : Message ) -> Optional [ Dialogue ] Retrieve the dialogue 'message' belongs to. Arguments : message : a message Returns : the dialogue, or None in case such a dialogue does not exist get _ dialogue _ from _ label | get_dialogue_from_label ( dialogue_label : DialogueLabel ) -> Optional [ Dialogue ] Retrieve a dialogue based on its label. Arguments : dialogue_label : the dialogue label Returns : the dialogue if present setup | setup () -> None Set up. teardown | teardown () -> None Tear down.","title":"Base"},{"location":"aea/api/protocols/dialogue/base/#aeaprotocolsdialoguebase","text":"This module contains the classes required for dialogue management. DialogueLabel: The dialogue label class acts as an identifier for dialogues. Dialogue: The dialogue class maintains state of a dialogue and manages it. Dialogues: The dialogues class keeps track of all dialogues.","title":"aea.protocols.dialogue.base"},{"location":"aea/api/protocols/dialogue/base/#invaliddialoguemessage-objects","text":"class InvalidDialogueMessage ( Exception ) Exception for adding invalid message to a dialogue.","title":"InvalidDialogueMessage Objects"},{"location":"aea/api/protocols/dialogue/base/#dialoguelabel-objects","text":"class DialogueLabel () The dialogue label class acts as an identifier for dialogues.","title":"DialogueLabel Objects"},{"location":"aea/api/protocols/dialogue/base/#__init__","text":"| __init__ ( dialogue_reference : Tuple [ str , str ], dialogue_opponent_addr : Address , dialogue_starter_addr : Address ) -> None Initialize a dialogue label. Arguments : dialogue_reference : the reference of the dialogue. dialogue_opponent_addr : the addr of the agent with which the dialogue is kept. dialogue_starter_addr : the addr of the agent which started the dialogue.","title":"__init__"},{"location":"aea/api/protocols/dialogue/base/#dialogue_reference","text":"| @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue reference.","title":"dialogue_reference"},{"location":"aea/api/protocols/dialogue/base/#dialogue_starter_reference","text":"| @property | dialogue_starter_reference () -> str Get the dialogue starter reference.","title":"dialogue_starter_reference"},{"location":"aea/api/protocols/dialogue/base/#dialogue_responder_reference","text":"| @property | dialogue_responder_reference () -> str Get the dialogue responder reference.","title":"dialogue_responder_reference"},{"location":"aea/api/protocols/dialogue/base/#dialogue_opponent_addr","text":"| @property | dialogue_opponent_addr () -> str Get the address of the dialogue opponent.","title":"dialogue_opponent_addr"},{"location":"aea/api/protocols/dialogue/base/#dialogue_starter_addr","text":"| @property | dialogue_starter_addr () -> str Get the address of the dialogue starter.","title":"dialogue_starter_addr"},{"location":"aea/api/protocols/dialogue/base/#__eq__","text":"| __eq__ ( other : Any ) -> bool Check for equality between two DialogueLabel objects.","title":"__eq__"},{"location":"aea/api/protocols/dialogue/base/#__hash__","text":"| __hash__ () -> int Turn object into hash.","title":"__hash__"},{"location":"aea/api/protocols/dialogue/base/#json","text":"| @property | json () -> Dict Return the JSON representation.","title":"json"},{"location":"aea/api/protocols/dialogue/base/#from_json","text":"| @classmethod | from_json ( cls , obj : Dict [ str , str ]) -> \"DialogueLabel\" Get dialogue label from json.","title":"from_json"},{"location":"aea/api/protocols/dialogue/base/#get_incomplete_version","text":"| get_incomplete_version () -> \"DialogueLabel\" Get the incomplete version of the label.","title":"get_incomplete_version"},{"location":"aea/api/protocols/dialogue/base/#__str__","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/protocols/dialogue/base/#from_str","text":"| @classmethod | from_str ( cls , obj : str ) -> \"DialogueLabel\" Get the dialogue label from string representation.","title":"from_str"},{"location":"aea/api/protocols/dialogue/base/#_dialoguemeta-objects","text":"class _DialogueMeta ( type ) Metaclass for Dialogue. Creates class level Rules instance to share among instances","title":"_DialogueMeta Objects"},{"location":"aea/api/protocols/dialogue/base/#__new__","text":"| __new__ ( cls , name : str , bases : Tuple [ Type ], dct : Dict ) -> \"_DialogueMeta\" Construct a new type.","title":"__new__"},{"location":"aea/api/protocols/dialogue/base/#dialogue-objects","text":"class Dialogue (, metaclass = _DialogueMeta ) The dialogue class maintains state of a dialogue and manages it.","title":"Dialogue Objects"},{"location":"aea/api/protocols/dialogue/base/#rules-objects","text":"class Rules () This class defines the rules for the dialogue.","title":"Rules Objects"},{"location":"aea/api/protocols/dialogue/base/#__init___1","text":"| __init__ ( initial_performatives : FrozenSet [ Message . Performative ], terminal_performatives : FrozenSet [ Message . Performative ], valid_replies : Dict [ Message . Performative , FrozenSet [ Message . Performative ]]) -> None Initialize a dialogue. Arguments : initial_performatives : the set of all initial performatives. terminal_performatives : the set of all terminal performatives. valid_replies : the reply structure of speech-acts.","title":"__init__"},{"location":"aea/api/protocols/dialogue/base/#initial_performatives","text":"| @property | initial_performatives () -> FrozenSet [ Message . Performative ] Get the performatives one of which the terminal message in the dialogue must have. Returns : the valid performatives of an terminal message","title":"initial_performatives"},{"location":"aea/api/protocols/dialogue/base/#terminal_performatives","text":"| @property | terminal_performatives () -> FrozenSet [ Message . Performative ] Get the performatives one of which the terminal message in the dialogue must have. Returns : the valid performatives of an terminal message","title":"terminal_performatives"},{"location":"aea/api/protocols/dialogue/base/#valid_replies","text":"| @property | valid_replies () -> Dict [ Message . Performative , FrozenSet [ Message . Performative ]] Get all the valid performatives which are a valid replies to performatives. Returns : the full valid reply structure.","title":"valid_replies"},{"location":"aea/api/protocols/dialogue/base/#get_valid_replies","text":"| get_valid_replies ( performative : Message . Performative ) -> FrozenSet [ Message . Performative ] Given a performative , return the list of performatives which are its valid replies in a dialogue. Arguments : performative : the performative in a message Returns : list of valid performative replies","title":"get_valid_replies"},{"location":"aea/api/protocols/dialogue/base/#role-objects","text":"class Role ( Enum ) This class defines the agent's role in a dialogue.","title":"Role Objects"},{"location":"aea/api/protocols/dialogue/base/#__str___1","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/protocols/dialogue/base/#endstate-objects","text":"class EndState ( Enum ) This class defines the end states of a dialogue.","title":"EndState Objects"},{"location":"aea/api/protocols/dialogue/base/#__str___2","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/protocols/dialogue/base/#__init___2","text":"| __init__ ( dialogue_label : DialogueLabel , message_class : Type [ Message ], self_address : Address , role : Role ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue message_class : the message class used self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for","title":"__init__"},{"location":"aea/api/protocols/dialogue/base/#add_terminal_state_callback","text":"| add_terminal_state_callback ( fn : Callable [[ \"Dialogue\" ], None ]) -> None Add callback to be called on dialogue reach terminal state. Arguments : fn : callable to be called with one argument: Dialogue","title":"add_terminal_state_callback"},{"location":"aea/api/protocols/dialogue/base/#__eq___1","text":"| __eq__ ( other : Any ) -> bool Compare two dialogues.","title":"__eq__"},{"location":"aea/api/protocols/dialogue/base/#json_1","text":"| json () -> dict Get json representation of the dialogue.","title":"json"},{"location":"aea/api/protocols/dialogue/base/#from_json_1","text":"| @classmethod | from_json ( cls , message_class : Type [ Message ], data : dict ) -> \"Dialogue\" Create a dialogue instance with all messages from json data. Arguments : message_class : type of message used with this dialogue data : dict with data exported with Dialogue.to_json() method Returns : Dialogue instance","title":"from_json"},{"location":"aea/api/protocols/dialogue/base/#dialogue_label","text":"| @property | dialogue_label () -> DialogueLabel Get the dialogue label. Returns : The dialogue label","title":"dialogue_label"},{"location":"aea/api/protocols/dialogue/base/#incomplete_dialogue_label","text":"| @property | incomplete_dialogue_label () -> DialogueLabel Get the dialogue label. Returns : The incomplete dialogue label","title":"incomplete_dialogue_label"},{"location":"aea/api/protocols/dialogue/base/#dialogue_labels","text":"| @property | dialogue_labels () -> Set [ DialogueLabel ] Get the dialogue labels (incomplete and complete, if it exists). Returns : the dialogue labels","title":"dialogue_labels"},{"location":"aea/api/protocols/dialogue/base/#self_address","text":"| @property | self_address () -> Address Get the address of the entity for whom this dialogues is maintained. Returns : the address of this entity","title":"self_address"},{"location":"aea/api/protocols/dialogue/base/#role","text":"| @property | role () -> \"Role\" Get the agent's role in the dialogue. Returns : the agent's role","title":"role"},{"location":"aea/api/protocols/dialogue/base/#rules","text":"| @property | rules () -> \"Rules\" Get the dialogue rules. Returns : the rules","title":"rules"},{"location":"aea/api/protocols/dialogue/base/#message_class","text":"| @property | message_class () -> Type [ Message ] Get the message class. Returns : the message class","title":"message_class"},{"location":"aea/api/protocols/dialogue/base/#is_self_initiated","text":"| @property | is_self_initiated () -> bool Check whether the agent initiated the dialogue. Returns : True if the agent initiated the dialogue, False otherwise","title":"is_self_initiated"},{"location":"aea/api/protocols/dialogue/base/#last_incoming_message","text":"| @property | last_incoming_message () -> Optional [ Message ] Get the last incoming message. Returns : the last incoming message if it exists, None otherwise","title":"last_incoming_message"},{"location":"aea/api/protocols/dialogue/base/#last_outgoing_message","text":"| @property | last_outgoing_message () -> Optional [ Message ] Get the last outgoing message. Returns : the last outgoing message if it exists, None otherwise","title":"last_outgoing_message"},{"location":"aea/api/protocols/dialogue/base/#last_message","text":"| @property | last_message () -> Optional [ Message ] Get the last message. Returns : the last message if it exists, None otherwise","title":"last_message"},{"location":"aea/api/protocols/dialogue/base/#is_empty","text":"| @property | is_empty () -> bool Check whether the dialogue is empty. Returns : True if empty, False otherwise","title":"is_empty"},{"location":"aea/api/protocols/dialogue/base/#reply","text":"| reply ( performative : Message . Performative , target_message : Optional [ Message ] = None , target : Optional [ int ] = None , ** kwargs : Any , ,) -> Message Reply to the 'target_message' in this dialogue with a message with 'performative', and contents from kwargs. Note if no target_message is provided, the last message in the dialogue will be replied to. Arguments : target_message : the message to reply to. target : the id of the message to reply to. performative : the performative of the reply message. kwargs : the content of the reply message. Returns : the reply message if it was successfully added as a reply, None otherwise.","title":"reply"},{"location":"aea/api/protocols/dialogue/base/#get_message_by_id","text":"| get_message_by_id ( message_id : int ) -> Optional [ Message ] Get message by id, if not presents return None.","title":"get_message_by_id"},{"location":"aea/api/protocols/dialogue/base/#get_outgoing_next_message_id","text":"| get_outgoing_next_message_id () -> int Get next outgoing message id.","title":"get_outgoing_next_message_id"},{"location":"aea/api/protocols/dialogue/base/#get_incoming_next_message_id","text":"| get_incoming_next_message_id () -> int Get next incoming message id.","title":"get_incoming_next_message_id"},{"location":"aea/api/protocols/dialogue/base/#__str___3","text":"| __str__ () -> str Get the string representation. Returns : The string representation of the dialogue","title":"__str__"},{"location":"aea/api/protocols/dialogue/base/#dialoguestats-objects","text":"class DialogueStats () Class to handle statistics on default dialogues.","title":"DialogueStats Objects"},{"location":"aea/api/protocols/dialogue/base/#__init___3","text":"| __init__ ( end_states : FrozenSet [ Dialogue . EndState ]) -> None Initialize a StatsManager. Arguments : end_states : the list of dialogue endstates","title":"__init__"},{"location":"aea/api/protocols/dialogue/base/#self_initiated","text":"| @property | self_initiated () -> Dict [ Dialogue . EndState , int ] Get the stats dictionary on self initiated dialogues.","title":"self_initiated"},{"location":"aea/api/protocols/dialogue/base/#other_initiated","text":"| @property | other_initiated () -> Dict [ Dialogue . EndState , int ] Get the stats dictionary on other initiated dialogues.","title":"other_initiated"},{"location":"aea/api/protocols/dialogue/base/#add_dialogue_endstate","text":"| add_dialogue_endstate ( end_state : Dialogue . EndState , is_self_initiated : bool ) -> None Add dialogue endstate stats. Arguments : end_state : the end state of the dialogue is_self_initiated : whether the dialogue is initiated by the agent or the opponent","title":"add_dialogue_endstate"},{"location":"aea/api/protocols/dialogue/base/#find_caller_object","text":"find_caller_object ( object_type : Type ) -> Any Find caller object of certain type in the call stack.","title":"find_caller_object"},{"location":"aea/api/protocols/dialogue/base/#basicdialoguesstorage-objects","text":"class BasicDialoguesStorage () Dialogues state storage.","title":"BasicDialoguesStorage Objects"},{"location":"aea/api/protocols/dialogue/base/#__init___4","text":"| __init__ ( dialogues : \"Dialogues\" ) -> None Init dialogues storage.","title":"__init__"},{"location":"aea/api/protocols/dialogue/base/#dialogues_in_terminal_state","text":"| @property | dialogues_in_terminal_state () -> List [ \"Dialogue\" ] Get all dialogues in terminal state.","title":"dialogues_in_terminal_state"},{"location":"aea/api/protocols/dialogue/base/#dialogues_in_active_state","text":"| @property | dialogues_in_active_state () -> List [ \"Dialogue\" ] Get all dialogues in active state.","title":"dialogues_in_active_state"},{"location":"aea/api/protocols/dialogue/base/#is_terminal_dialogues_kept","text":"| @property | is_terminal_dialogues_kept () -> bool Return True if dialogues should stay after terminal state.","title":"is_terminal_dialogues_kept"},{"location":"aea/api/protocols/dialogue/base/#dialogue_terminal_state_callback","text":"| dialogue_terminal_state_callback ( dialogue : \"Dialogue\" ) -> None Method to be called on dialogue terminal state reached.","title":"dialogue_terminal_state_callback"},{"location":"aea/api/protocols/dialogue/base/#setup","text":"| setup () -> None Set up dialogue storage.","title":"setup"},{"location":"aea/api/protocols/dialogue/base/#teardown","text":"| teardown () -> None Tear down dialogue storage.","title":"teardown"},{"location":"aea/api/protocols/dialogue/base/#add","text":"| add ( dialogue : Dialogue ) -> None Add dialogue to storage. Arguments : dialogue : dialogue to add.","title":"add"},{"location":"aea/api/protocols/dialogue/base/#remove","text":"| remove ( dialogue_label : DialogueLabel ) -> None Remove dialogue from storage by it's label. Arguments : dialogue_label : label of the dialogue to remove","title":"remove"},{"location":"aea/api/protocols/dialogue/base/#get","text":"| get ( dialogue_label : DialogueLabel ) -> Optional [ Dialogue ] Get dialogue stored by it's label. Arguments : dialogue_label : label of the dialogue Returns : dialogue if presents or None","title":"get"},{"location":"aea/api/protocols/dialogue/base/#get_dialogues_with_counterparty","text":"| get_dialogues_with_counterparty ( counterparty : Address ) -> List [ Dialogue ] Get the dialogues by address. Arguments : counterparty : the counterparty Returns : The dialogues with the counterparty.","title":"get_dialogues_with_counterparty"},{"location":"aea/api/protocols/dialogue/base/#is_in_incomplete","text":"| is_in_incomplete ( dialogue_label : DialogueLabel ) -> bool Check dialogue label presents in list of incomplete.","title":"is_in_incomplete"},{"location":"aea/api/protocols/dialogue/base/#set_incomplete_dialogue","text":"| set_incomplete_dialogue ( incomplete_dialogue_label : DialogueLabel , complete_dialogue_label : DialogueLabel ) -> None Set incomplete dialogue label.","title":"set_incomplete_dialogue"},{"location":"aea/api/protocols/dialogue/base/#is_dialogue_present","text":"| is_dialogue_present ( dialogue_label : DialogueLabel ) -> bool Check dialogue with label specified presents in storage.","title":"is_dialogue_present"},{"location":"aea/api/protocols/dialogue/base/#get_latest_label","text":"| get_latest_label ( dialogue_label : DialogueLabel ) -> DialogueLabel Get latest label for dialogue.","title":"get_latest_label"},{"location":"aea/api/protocols/dialogue/base/#persistdialoguesstorage-objects","text":"class PersistDialoguesStorage ( BasicDialoguesStorage ) Persist dialogues storage. Uses generic storage to load/save dialogues data on setup/teardown.","title":"PersistDialoguesStorage Objects"},{"location":"aea/api/protocols/dialogue/base/#__init___5","text":"| __init__ ( dialogues : \"Dialogues\" ) -> None Init dialogues storage.","title":"__init__"},{"location":"aea/api/protocols/dialogue/base/#get_skill_component","text":"| @staticmethod | get_skill_component () -> Optional [ SkillComponent ] Get skill component dialogues storage constructed for.","title":"get_skill_component"},{"location":"aea/api/protocols/dialogue/base/#setup_1","text":"| setup () -> None Set up dialogue storage.","title":"setup"},{"location":"aea/api/protocols/dialogue/base/#teardown_1","text":"| teardown () -> None Tear down dialogue storage.","title":"teardown"},{"location":"aea/api/protocols/dialogue/base/#remove_1","text":"| remove ( dialogue_label : DialogueLabel ) -> None Remove dialogue from memory and persistent storage.","title":"remove"},{"location":"aea/api/protocols/dialogue/base/#persistdialoguesstoragewithoffloading-objects","text":"class PersistDialoguesStorageWithOffloading ( PersistDialoguesStorage ) Dialogue Storage with dialogues offloading.","title":"PersistDialoguesStorageWithOffloading Objects"},{"location":"aea/api/protocols/dialogue/base/#dialogue_terminal_state_callback_1","text":"| dialogue_terminal_state_callback ( dialogue : \"Dialogue\" ) -> None Call on dialogue reaches terminal state.","title":"dialogue_terminal_state_callback"},{"location":"aea/api/protocols/dialogue/base/#get_1","text":"| get ( dialogue_label : DialogueLabel ) -> Optional [ Dialogue ] Try to get dialogue by label from memory or persists storage.","title":"get"},{"location":"aea/api/protocols/dialogue/base/#get_dialogues_with_counterparty_1","text":"| get_dialogues_with_counterparty ( counterparty : Address ) -> List [ Dialogue ] Get the dialogues by address. Arguments : counterparty : the counterparty Returns : The dialogues with the counterparty.","title":"get_dialogues_with_counterparty"},{"location":"aea/api/protocols/dialogue/base/#dialogues_in_terminal_state_1","text":"| @property | dialogues_in_terminal_state () -> List [ \"Dialogue\" ] Get all dialogues in terminal state.","title":"dialogues_in_terminal_state"},{"location":"aea/api/protocols/dialogue/base/#dialogues-objects","text":"class Dialogues () The dialogues class keeps track of all dialogues for an agent.","title":"Dialogues Objects"},{"location":"aea/api/protocols/dialogue/base/#__init___6","text":"| __init__ ( self_address : Address , end_states : FrozenSet [ Dialogue . EndState ], message_class : Type [ Message ], dialogue_class : Type [ Dialogue ], role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], keep_terminal_state_dialogues : Optional [ bool ] = None ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained end_states : the list of dialogue endstates message_class : the message class used dialogue_class : the dialogue class used role_from_first_message : the callable determining role from first message keep_terminal_state_dialogues : specify do dialogues in terminal state should stay or not","title":"__init__"},{"location":"aea/api/protocols/dialogue/base/#is_keep_dialogues_in_terminal_state","text":"| @property | is_keep_dialogues_in_terminal_state () -> bool Is required to keep dialogues in terminal state.","title":"is_keep_dialogues_in_terminal_state"},{"location":"aea/api/protocols/dialogue/base/#self_address_1","text":"| @property | self_address () -> Address Get the address of the agent for whom dialogues are maintained.","title":"self_address"},{"location":"aea/api/protocols/dialogue/base/#dialogue_stats","text":"| @property | dialogue_stats () -> DialogueStats Get the dialogue statistics. Returns : dialogue stats object","title":"dialogue_stats"},{"location":"aea/api/protocols/dialogue/base/#message_class_1","text":"| @property | message_class () -> Type [ Message ] Get the message class. Returns : the message class","title":"message_class"},{"location":"aea/api/protocols/dialogue/base/#dialogue_class","text":"| @property | dialogue_class () -> Type [ Dialogue ] Get the dialogue class. Returns : the dialogue class","title":"dialogue_class"},{"location":"aea/api/protocols/dialogue/base/#get_dialogues_with_counterparty_2","text":"| get_dialogues_with_counterparty ( counterparty : Address ) -> List [ Dialogue ] Get the dialogues by address. Arguments : counterparty : the counterparty Returns : The dialogues with the counterparty.","title":"get_dialogues_with_counterparty"},{"location":"aea/api/protocols/dialogue/base/#new_self_initiated_dialogue_reference","text":"| @classmethod | new_self_initiated_dialogue_reference ( cls ) -> Tuple [ str , str ] Return a dialogue label for a new self initiated dialogue. Returns : the next nonce","title":"new_self_initiated_dialogue_reference"},{"location":"aea/api/protocols/dialogue/base/#create","text":"| create ( counterparty : Address , performative : Message . Performative , ** kwargs : Any , ,) -> Tuple [ Message , Dialogue ] Create a dialogue with 'counterparty', with an initial message whose performative is 'performative' and contents are from 'kwargs'. Arguments : counterparty : the counterparty of the dialogue. performative : the performative of the initial message. kwargs : the content of the initial message. Returns : the initial message and the dialogue.","title":"create"},{"location":"aea/api/protocols/dialogue/base/#create_with_message","text":"| create_with_message ( counterparty : Address , initial_message : Message ) -> Dialogue Create a dialogue with 'counterparty', with an initial message provided. Arguments : counterparty : the counterparty of the dialogue. initial_message : the initial_message. Returns : the initial message and the dialogue.","title":"create_with_message"},{"location":"aea/api/protocols/dialogue/base/#update","text":"| update ( message : Message ) -> Optional [ Dialogue ] Update the state of dialogues with a new incoming message. If the message is for a new dialogue, a new dialogue is created with 'message' as its first message, and returned. If the message is addressed to an existing dialogue, the dialogue is retrieved, extended with this message and returned. If there are any errors, e.g. the message dialogue reference does not exists or the message is invalid w.r.t. the dialogue, return None. Arguments : message : a new incoming message Returns : the new or existing dialogue the message is intended for, or None in case of any errors.","title":"update"},{"location":"aea/api/protocols/dialogue/base/#get_dialogue","text":"| get_dialogue ( message : Message ) -> Optional [ Dialogue ] Retrieve the dialogue 'message' belongs to. Arguments : message : a message Returns : the dialogue, or None in case such a dialogue does not exist","title":"get_dialogue"},{"location":"aea/api/protocols/dialogue/base/#get_dialogue_from_label","text":"| get_dialogue_from_label ( dialogue_label : DialogueLabel ) -> Optional [ Dialogue ] Retrieve a dialogue based on its label. Arguments : dialogue_label : the dialogue label Returns : the dialogue if present","title":"get_dialogue_from_label"},{"location":"aea/api/protocols/dialogue/base/#setup_2","text":"| setup () -> None Set up.","title":"setup"},{"location":"aea/api/protocols/dialogue/base/#teardown_2","text":"| teardown () -> None Tear down.","title":"teardown"},{"location":"aea/api/protocols/generator/base/","text":"aea.protocols.generator.base This module contains the protocol generator. ProtocolGenerator Objects class ProtocolGenerator () This class generates a protocol_verification package from a ProtocolTemplate object. __ init __ | __init__ ( path_to_protocol_specification : str , output_path : str = \".\" , dotted_path_to_protocol_package : Optional [ str ] = None ) -> None Instantiate a protocol generator. Arguments : path_to_protocol_specification : path to protocol specification file output_path : the path to the location in which the protocol module is to be generated. dotted_path_to_protocol_package : the path to the protocol package :raises FileNotFoundError if any prerequisite application is not installed :raises yaml.YAMLError if yaml parser encounters an error condition :raises ProtocolSpecificationParseError if specification fails generator's validation generate _ protobuf _ only _ mode | generate_protobuf_only_mode ( language : str = PROTOCOL_LANGUAGE_PYTHON , run_protolint : bool = True ) -> Optional [ str ] Run the generator in \"protobuf only\" mode: a) validate the protocol specification. b) create the protocol buffer schema file. c) create the protocol buffer implementation file via 'protoc'. Arguments : language : the target language in which to generate the package. run_protolint : whether to run protolint or not. Returns : None generate _ full _ mode | generate_full_mode ( language : str ) -> Optional [ str ] Run the generator in \"full\" mode: Runs the generator in protobuf only mode: a) validate the protocol specification. b) create the protocol buffer schema file. c) create the protocol buffer implementation file via 'protoc'. Additionally: d) generates python modules. e) applies black formatting f) applies isort formatting Arguments : language : the language for which to create protobuf files Returns : optional warning message generate | generate ( protobuf_only : bool = False , language : str = PROTOCOL_LANGUAGE_PYTHON ) -> Optional [ str ] Run the generator either in \"full\" or \"protobuf only\" mode. Arguments : protobuf_only : mode of running the generator. language : the target language in which to generate the protocol package. Returns : optional warning message. public _ id _ to _ package _ name public_id_to_package_name ( public_id : PublicId ) -> str Make package name string from public_id provided.","title":"Base"},{"location":"aea/api/protocols/generator/base/#aeaprotocolsgeneratorbase","text":"This module contains the protocol generator.","title":"aea.protocols.generator.base"},{"location":"aea/api/protocols/generator/base/#protocolgenerator-objects","text":"class ProtocolGenerator () This class generates a protocol_verification package from a ProtocolTemplate object.","title":"ProtocolGenerator Objects"},{"location":"aea/api/protocols/generator/base/#__init__","text":"| __init__ ( path_to_protocol_specification : str , output_path : str = \".\" , dotted_path_to_protocol_package : Optional [ str ] = None ) -> None Instantiate a protocol generator. Arguments : path_to_protocol_specification : path to protocol specification file output_path : the path to the location in which the protocol module is to be generated. dotted_path_to_protocol_package : the path to the protocol package :raises FileNotFoundError if any prerequisite application is not installed :raises yaml.YAMLError if yaml parser encounters an error condition :raises ProtocolSpecificationParseError if specification fails generator's validation","title":"__init__"},{"location":"aea/api/protocols/generator/base/#generate_protobuf_only_mode","text":"| generate_protobuf_only_mode ( language : str = PROTOCOL_LANGUAGE_PYTHON , run_protolint : bool = True ) -> Optional [ str ] Run the generator in \"protobuf only\" mode: a) validate the protocol specification. b) create the protocol buffer schema file. c) create the protocol buffer implementation file via 'protoc'. Arguments : language : the target language in which to generate the package. run_protolint : whether to run protolint or not. Returns : None","title":"generate_protobuf_only_mode"},{"location":"aea/api/protocols/generator/base/#generate_full_mode","text":"| generate_full_mode ( language : str ) -> Optional [ str ] Run the generator in \"full\" mode: Runs the generator in protobuf only mode: a) validate the protocol specification. b) create the protocol buffer schema file. c) create the protocol buffer implementation file via 'protoc'. Additionally: d) generates python modules. e) applies black formatting f) applies isort formatting Arguments : language : the language for which to create protobuf files Returns : optional warning message","title":"generate_full_mode"},{"location":"aea/api/protocols/generator/base/#generate","text":"| generate ( protobuf_only : bool = False , language : str = PROTOCOL_LANGUAGE_PYTHON ) -> Optional [ str ] Run the generator either in \"full\" or \"protobuf only\" mode. Arguments : protobuf_only : mode of running the generator. language : the target language in which to generate the protocol package. Returns : optional warning message.","title":"generate"},{"location":"aea/api/protocols/generator/base/#public_id_to_package_name","text":"public_id_to_package_name ( public_id : PublicId ) -> str Make package name string from public_id provided.","title":"public_id_to_package_name"},{"location":"aea/api/protocols/generator/common/","text":"aea.protocols.generator.common This module contains utility code for generator modules. is _ installed is_installed ( programme : str ) -> bool Check whether a programme is installed on the system. Arguments : programme : the name of the programme. Returns : True if installed, False otherwise base _ protolint _ command base_protolint_command () -> str Return the base protolint command. Returns : The base protolint command check _ prerequisites check_prerequisites () -> None Check whether a programme is installed on the system. get _ protoc _ version get_protoc_version () -> str Get the protoc version used. load _ protocol _ specification load_protocol_specification ( specification_path : str ) -> ProtocolSpecification Load a protocol specification. Arguments : specification_path : path to the protocol specification yaml file. Returns : A ProtocolSpecification object try _ run _ black _ formatting try_run_black_formatting ( path_to_protocol_package : str ) -> None Run Black code formatting via subprocess. Arguments : path_to_protocol_package : a path where formatting should be applied. try _ run _ isort _ formatting try_run_isort_formatting ( path_to_protocol_package : str ) -> None Run Isort code formatting via subprocess. Arguments : path_to_protocol_package : a path where formatting should be applied. try _ run _ protoc try_run_protoc ( path_to_generated_protocol_package : str , name : str , language : str = PROTOCOL_LANGUAGE_PYTHON ) -> None Run 'protoc' protocol buffer compiler via subprocess. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. language : the target language in which to compile the protobuf schema file try _ run _ protolint try_run_protolint ( path_to_generated_protocol_package : str , name : str ) -> None Run 'protolint' linter via subprocess. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. check _ protobuf _ using _ protoc check_protobuf_using_protoc ( path_to_generated_protocol_package : str , name : str ) -> Tuple [ bool , str ] Check whether a protocol buffer schema file is valid. Validation is via trying to compile the schema file. If successfully compiled it is valid, otherwise invalid. If valid, return True and a 'protobuf file is valid' message, otherwise return False and the error thrown by the compiler. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. Returns : Boolean result and an accompanying message compile _ protobuf _ using _ protoc compile_protobuf_using_protoc ( path_to_generated_protocol_package : str , name : str , language : str ) -> Tuple [ bool , str ] Compile a protocol buffer schema file using protoc. If successfully compiled, return True and a success message, otherwise return False and the error thrown by the compiler. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. language : the target language in which to compile the protobuf schema file Returns : Boolean result and an accompanying message apply _ protolint apply_protolint ( path_to_proto_file : str , name : str ) -> Tuple [ bool , str ] Apply protolint linter to a protocol buffer schema file. If no output, return True and a success message, otherwise return False and the output shown by the linter (minus the indentation suggestions which are automatically fixed by protolint). Arguments : path_to_proto_file : path to the protocol buffer schema file. name : name of the protocol buffer schema file. Returns : Boolean result and an accompanying message","title":"Common"},{"location":"aea/api/protocols/generator/common/#aeaprotocolsgeneratorcommon","text":"This module contains utility code for generator modules.","title":"aea.protocols.generator.common"},{"location":"aea/api/protocols/generator/common/#is_installed","text":"is_installed ( programme : str ) -> bool Check whether a programme is installed on the system. Arguments : programme : the name of the programme. Returns : True if installed, False otherwise","title":"is_installed"},{"location":"aea/api/protocols/generator/common/#base_protolint_command","text":"base_protolint_command () -> str Return the base protolint command. Returns : The base protolint command","title":"base_protolint_command"},{"location":"aea/api/protocols/generator/common/#check_prerequisites","text":"check_prerequisites () -> None Check whether a programme is installed on the system.","title":"check_prerequisites"},{"location":"aea/api/protocols/generator/common/#get_protoc_version","text":"get_protoc_version () -> str Get the protoc version used.","title":"get_protoc_version"},{"location":"aea/api/protocols/generator/common/#load_protocol_specification","text":"load_protocol_specification ( specification_path : str ) -> ProtocolSpecification Load a protocol specification. Arguments : specification_path : path to the protocol specification yaml file. Returns : A ProtocolSpecification object","title":"load_protocol_specification"},{"location":"aea/api/protocols/generator/common/#try_run_black_formatting","text":"try_run_black_formatting ( path_to_protocol_package : str ) -> None Run Black code formatting via subprocess. Arguments : path_to_protocol_package : a path where formatting should be applied.","title":"try_run_black_formatting"},{"location":"aea/api/protocols/generator/common/#try_run_isort_formatting","text":"try_run_isort_formatting ( path_to_protocol_package : str ) -> None Run Isort code formatting via subprocess. Arguments : path_to_protocol_package : a path where formatting should be applied.","title":"try_run_isort_formatting"},{"location":"aea/api/protocols/generator/common/#try_run_protoc","text":"try_run_protoc ( path_to_generated_protocol_package : str , name : str , language : str = PROTOCOL_LANGUAGE_PYTHON ) -> None Run 'protoc' protocol buffer compiler via subprocess. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. language : the target language in which to compile the protobuf schema file","title":"try_run_protoc"},{"location":"aea/api/protocols/generator/common/#try_run_protolint","text":"try_run_protolint ( path_to_generated_protocol_package : str , name : str ) -> None Run 'protolint' linter via subprocess. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file.","title":"try_run_protolint"},{"location":"aea/api/protocols/generator/common/#check_protobuf_using_protoc","text":"check_protobuf_using_protoc ( path_to_generated_protocol_package : str , name : str ) -> Tuple [ bool , str ] Check whether a protocol buffer schema file is valid. Validation is via trying to compile the schema file. If successfully compiled it is valid, otherwise invalid. If valid, return True and a 'protobuf file is valid' message, otherwise return False and the error thrown by the compiler. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. Returns : Boolean result and an accompanying message","title":"check_protobuf_using_protoc"},{"location":"aea/api/protocols/generator/common/#compile_protobuf_using_protoc","text":"compile_protobuf_using_protoc ( path_to_generated_protocol_package : str , name : str , language : str ) -> Tuple [ bool , str ] Compile a protocol buffer schema file using protoc. If successfully compiled, return True and a success message, otherwise return False and the error thrown by the compiler. Arguments : path_to_generated_protocol_package : path to the protocol buffer schema file. name : name of the protocol buffer schema file. language : the target language in which to compile the protobuf schema file Returns : Boolean result and an accompanying message","title":"compile_protobuf_using_protoc"},{"location":"aea/api/protocols/generator/common/#apply_protolint","text":"apply_protolint ( path_to_proto_file : str , name : str ) -> Tuple [ bool , str ] Apply protolint linter to a protocol buffer schema file. If no output, return True and a success message, otherwise return False and the output shown by the linter (minus the indentation suggestions which are automatically fixed by protolint). Arguments : path_to_proto_file : path to the protocol buffer schema file. name : name of the protocol buffer schema file. Returns : Boolean result and an accompanying message","title":"apply_protolint"},{"location":"aea/api/protocols/generator/extract_specification/","text":"aea.protocols.generator.extract _ specification This module extracts a valid protocol specification into pythonic objects. PythonicProtocolSpecification Objects class PythonicProtocolSpecification () This class represents a protocol specification in python. __ init __ | __init__ () -> None Instantiate a Pythonic protocol specification. extract extract ( protocol_specification : ProtocolSpecification ) -> PythonicProtocolSpecification Converts a protocol specification into a Pythonic protocol specification. Arguments : protocol_specification : a protocol specification Returns : a Pythonic protocol specification","title":"Extract Specification"},{"location":"aea/api/protocols/generator/extract_specification/#aeaprotocolsgeneratorextract_specification","text":"This module extracts a valid protocol specification into pythonic objects.","title":"aea.protocols.generator.extract_specification"},{"location":"aea/api/protocols/generator/extract_specification/#pythonicprotocolspecification-objects","text":"class PythonicProtocolSpecification () This class represents a protocol specification in python.","title":"PythonicProtocolSpecification Objects"},{"location":"aea/api/protocols/generator/extract_specification/#__init__","text":"| __init__ () -> None Instantiate a Pythonic protocol specification.","title":"__init__"},{"location":"aea/api/protocols/generator/extract_specification/#extract","text":"extract ( protocol_specification : ProtocolSpecification ) -> PythonicProtocolSpecification Converts a protocol specification into a Pythonic protocol specification. Arguments : protocol_specification : a protocol specification Returns : a Pythonic protocol specification","title":"extract"},{"location":"aea/api/protocols/generator/validate/","text":"aea.protocols.generator.validate This module validates a protocol specification. validate validate ( protocol_specification : ProtocolSpecification ) -> Tuple [ bool , str ] Evaluate whether a protocol specification is valid. Arguments : protocol_specification : a protocol specification. Returns : Boolean result, and associated message.","title":"Validate"},{"location":"aea/api/protocols/generator/validate/#aeaprotocolsgeneratorvalidate","text":"This module validates a protocol specification.","title":"aea.protocols.generator.validate"},{"location":"aea/api/protocols/generator/validate/#validate","text":"validate ( protocol_specification : ProtocolSpecification ) -> Tuple [ bool , str ] Evaluate whether a protocol specification is valid. Arguments : protocol_specification : a protocol specification. Returns : Boolean result, and associated message.","title":"validate"},{"location":"aea/api/protocols/signing/custom_types/","text":"packages.fetchai.protocols.signing.custom _ types This module contains class representations corresponding to every custom type in the protocol specification. ErrorCode Objects class ErrorCode ( Enum ) This class represents an instance of ErrorCode. encode | @staticmethod | encode ( error_code_protobuf_object : Any , error_code_object : \"ErrorCode\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the error_code_protobuf_object argument is matched with the instance of this class in the 'error_code_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. error_code_object : an instance of this class to be encoded in the protocol buffer object. Returns : None decode | @classmethod | decode ( cls , error_code_protobuf_object : Any ) -> \"ErrorCode\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class is created that matches the protocol buffer object in the 'error_code_protobuf_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'error_code_protobuf_object' argument.","title":"Custom Types"},{"location":"aea/api/protocols/signing/custom_types/#packagesfetchaiprotocolssigningcustom_types","text":"This module contains class representations corresponding to every custom type in the protocol specification.","title":"packages.fetchai.protocols.signing.custom_types"},{"location":"aea/api/protocols/signing/custom_types/#errorcode-objects","text":"class ErrorCode ( Enum ) This class represents an instance of ErrorCode.","title":"ErrorCode Objects"},{"location":"aea/api/protocols/signing/custom_types/#encode","text":"| @staticmethod | encode ( error_code_protobuf_object : Any , error_code_object : \"ErrorCode\" ) -> None Encode an instance of this class into the protocol buffer object. The protocol buffer object in the error_code_protobuf_object argument is matched with the instance of this class in the 'error_code_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. error_code_object : an instance of this class to be encoded in the protocol buffer object. Returns : None","title":"encode"},{"location":"aea/api/protocols/signing/custom_types/#decode","text":"| @classmethod | decode ( cls , error_code_protobuf_object : Any ) -> \"ErrorCode\" Decode a protocol buffer object that corresponds with this class into an instance of this class. A new instance of this class is created that matches the protocol buffer object in the 'error_code_protobuf_object' argument. Arguments : error_code_protobuf_object : the protocol buffer object whose type corresponds with this class. Returns : A new instance of this class that matches the protocol buffer object in the 'error_code_protobuf_object' argument.","title":"decode"},{"location":"aea/api/protocols/signing/dialogues/","text":"packages.fetchai.protocols.signing.dialogues This module contains the classes required for signing dialogue management. SigningDialogue: The dialogue class maintains state of a dialogue and manages it. SigningDialogues: The dialogues class keeps track of all dialogues. SigningDialogue Objects class SigningDialogue ( Dialogue ) The signing dialogue class maintains state of a dialogue and manages it. Role Objects class Role ( Dialogue . Role ) This class defines the agent's role in a signing dialogue. EndState Objects class EndState ( Dialogue . EndState ) This class defines the end states of a signing dialogue. __ init __ | __init__ ( dialogue_label : DialogueLabel , self_address : Address , role : Dialogue . Role , message_class : Type [ SigningMessage ] = SigningMessage ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for Returns : None SigningDialogues Objects class SigningDialogues ( Dialogues , ABC ) This class keeps track of all signing dialogues. __ init __ | __init__ ( self_address : Address , role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], dialogue_class : Type [ SigningDialogue ] = SigningDialogue ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained Returns : None","title":"Dialogues"},{"location":"aea/api/protocols/signing/dialogues/#packagesfetchaiprotocolssigningdialogues","text":"This module contains the classes required for signing dialogue management. SigningDialogue: The dialogue class maintains state of a dialogue and manages it. SigningDialogues: The dialogues class keeps track of all dialogues.","title":"packages.fetchai.protocols.signing.dialogues"},{"location":"aea/api/protocols/signing/dialogues/#signingdialogue-objects","text":"class SigningDialogue ( Dialogue ) The signing dialogue class maintains state of a dialogue and manages it.","title":"SigningDialogue Objects"},{"location":"aea/api/protocols/signing/dialogues/#role-objects","text":"class Role ( Dialogue . Role ) This class defines the agent's role in a signing dialogue.","title":"Role Objects"},{"location":"aea/api/protocols/signing/dialogues/#endstate-objects","text":"class EndState ( Dialogue . EndState ) This class defines the end states of a signing dialogue.","title":"EndState Objects"},{"location":"aea/api/protocols/signing/dialogues/#__init__","text":"| __init__ ( dialogue_label : DialogueLabel , self_address : Address , role : Dialogue . Role , message_class : Type [ SigningMessage ] = SigningMessage ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for Returns : None","title":"__init__"},{"location":"aea/api/protocols/signing/dialogues/#signingdialogues-objects","text":"class SigningDialogues ( Dialogues , ABC ) This class keeps track of all signing dialogues.","title":"SigningDialogues Objects"},{"location":"aea/api/protocols/signing/dialogues/#__init___1","text":"| __init__ ( self_address : Address , role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], dialogue_class : Type [ SigningDialogue ] = SigningDialogue ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained Returns : None","title":"__init__"},{"location":"aea/api/protocols/signing/message/","text":"packages.fetchai.protocols.signing.message This module contains signing's message definition. SigningMessage Objects class SigningMessage ( Message ) A protocol for communication between skills and decision maker. Performative Objects class Performative ( Message . Performative ) Performatives for the signing protocol. __ str __ | __str__ () -> str Get the string representation. __ init __ | __init__ ( performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs : Any , ,) Initialise an instance of SigningMessage. Arguments : message_id : the message id. dialogue_reference : the dialogue reference. target : the message target. performative : the message performative. valid _ performatives | @property | valid_performatives () -> Set [ str ] Get valid performatives. dialogue _ reference | @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message. message _ id | @property | message_id () -> int Get the message_id of the message. performative | @property | performative () -> Performative Get the performative of the message. target | @property | target () -> int Get the target of the message. error _ code | @property | error_code () -> CustomErrorCode Get the 'error_code' content from the message. raw _ message | @property | raw_message () -> CustomRawMessage Get the 'raw_message' content from the message. raw _ transaction | @property | raw_transaction () -> CustomRawTransaction Get the 'raw_transaction' content from the message. signed _ message | @property | signed_message () -> CustomSignedMessage Get the 'signed_message' content from the message. signed _ transaction | @property | signed_transaction () -> CustomSignedTransaction Get the 'signed_transaction' content from the message. terms | @property | terms () -> CustomTerms Get the 'terms' content from the message.","title":"Message"},{"location":"aea/api/protocols/signing/message/#packagesfetchaiprotocolssigningmessage","text":"This module contains signing's message definition.","title":"packages.fetchai.protocols.signing.message"},{"location":"aea/api/protocols/signing/message/#signingmessage-objects","text":"class SigningMessage ( Message ) A protocol for communication between skills and decision maker.","title":"SigningMessage Objects"},{"location":"aea/api/protocols/signing/message/#performative-objects","text":"class Performative ( Message . Performative ) Performatives for the signing protocol.","title":"Performative Objects"},{"location":"aea/api/protocols/signing/message/#__str__","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/protocols/signing/message/#__init__","text":"| __init__ ( performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs : Any , ,) Initialise an instance of SigningMessage. Arguments : message_id : the message id. dialogue_reference : the dialogue reference. target : the message target. performative : the message performative.","title":"__init__"},{"location":"aea/api/protocols/signing/message/#valid_performatives","text":"| @property | valid_performatives () -> Set [ str ] Get valid performatives.","title":"valid_performatives"},{"location":"aea/api/protocols/signing/message/#dialogue_reference","text":"| @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message.","title":"dialogue_reference"},{"location":"aea/api/protocols/signing/message/#message_id","text":"| @property | message_id () -> int Get the message_id of the message.","title":"message_id"},{"location":"aea/api/protocols/signing/message/#performative","text":"| @property | performative () -> Performative Get the performative of the message.","title":"performative"},{"location":"aea/api/protocols/signing/message/#target","text":"| @property | target () -> int Get the target of the message.","title":"target"},{"location":"aea/api/protocols/signing/message/#error_code","text":"| @property | error_code () -> CustomErrorCode Get the 'error_code' content from the message.","title":"error_code"},{"location":"aea/api/protocols/signing/message/#raw_message","text":"| @property | raw_message () -> CustomRawMessage Get the 'raw_message' content from the message.","title":"raw_message"},{"location":"aea/api/protocols/signing/message/#raw_transaction","text":"| @property | raw_transaction () -> CustomRawTransaction Get the 'raw_transaction' content from the message.","title":"raw_transaction"},{"location":"aea/api/protocols/signing/message/#signed_message","text":"| @property | signed_message () -> CustomSignedMessage Get the 'signed_message' content from the message.","title":"signed_message"},{"location":"aea/api/protocols/signing/message/#signed_transaction","text":"| @property | signed_transaction () -> CustomSignedTransaction Get the 'signed_transaction' content from the message.","title":"signed_transaction"},{"location":"aea/api/protocols/signing/message/#terms","text":"| @property | terms () -> CustomTerms Get the 'terms' content from the message.","title":"terms"},{"location":"aea/api/protocols/signing/serialization/","text":"packages.fetchai.protocols.signing.serialization Serialization module for signing protocol. SigningSerializer Objects class SigningSerializer ( Serializer ) Serialization for the 'signing' protocol. encode | @staticmethod | encode ( msg : Message ) -> bytes Encode a 'Signing' message into bytes. Arguments : msg : the message object. Returns : the bytes. decode | @staticmethod | decode ( obj : bytes ) -> Message Decode bytes into a 'Signing' message. Arguments : obj : the bytes object. Returns : the 'Signing' message.","title":"Serialization"},{"location":"aea/api/protocols/signing/serialization/#packagesfetchaiprotocolssigningserialization","text":"Serialization module for signing protocol.","title":"packages.fetchai.protocols.signing.serialization"},{"location":"aea/api/protocols/signing/serialization/#signingserializer-objects","text":"class SigningSerializer ( Serializer ) Serialization for the 'signing' protocol.","title":"SigningSerializer Objects"},{"location":"aea/api/protocols/signing/serialization/#encode","text":"| @staticmethod | encode ( msg : Message ) -> bytes Encode a 'Signing' message into bytes. Arguments : msg : the message object. Returns : the bytes.","title":"encode"},{"location":"aea/api/protocols/signing/serialization/#decode","text":"| @staticmethod | decode ( obj : bytes ) -> Message Decode bytes into a 'Signing' message. Arguments : obj : the bytes object. Returns : the 'Signing' message.","title":"decode"},{"location":"aea/api/protocols/state_update/dialogues/","text":"packages.fetchai.protocols.state _ update.dialogues This module contains the classes required for state_update dialogue management. StateUpdateDialogue: The dialogue class maintains state of a dialogue and manages it. StateUpdateDialogues: The dialogues class keeps track of all dialogues. StateUpdateDialogue Objects class StateUpdateDialogue ( Dialogue ) The state_update dialogue class maintains state of a dialogue and manages it. Role Objects class Role ( Dialogue . Role ) This class defines the agent's role in a state_update dialogue. EndState Objects class EndState ( Dialogue . EndState ) This class defines the end states of a state_update dialogue. __ init __ | __init__ ( dialogue_label : DialogueLabel , self_address : Address , role : Dialogue . Role , message_class : Type [ StateUpdateMessage ] = StateUpdateMessage ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for Returns : None StateUpdateDialogues Objects class StateUpdateDialogues ( Dialogues , ABC ) This class keeps track of all state_update dialogues. __ init __ | __init__ ( self_address : Address , role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], dialogue_class : Type [ StateUpdateDialogue ] = StateUpdateDialogue ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained Returns : None","title":"Dialogues"},{"location":"aea/api/protocols/state_update/dialogues/#packagesfetchaiprotocolsstate_updatedialogues","text":"This module contains the classes required for state_update dialogue management. StateUpdateDialogue: The dialogue class maintains state of a dialogue and manages it. StateUpdateDialogues: The dialogues class keeps track of all dialogues.","title":"packages.fetchai.protocols.state_update.dialogues"},{"location":"aea/api/protocols/state_update/dialogues/#stateupdatedialogue-objects","text":"class StateUpdateDialogue ( Dialogue ) The state_update dialogue class maintains state of a dialogue and manages it.","title":"StateUpdateDialogue Objects"},{"location":"aea/api/protocols/state_update/dialogues/#role-objects","text":"class Role ( Dialogue . Role ) This class defines the agent's role in a state_update dialogue.","title":"Role Objects"},{"location":"aea/api/protocols/state_update/dialogues/#endstate-objects","text":"class EndState ( Dialogue . EndState ) This class defines the end states of a state_update dialogue.","title":"EndState Objects"},{"location":"aea/api/protocols/state_update/dialogues/#__init__","text":"| __init__ ( dialogue_label : DialogueLabel , self_address : Address , role : Dialogue . Role , message_class : Type [ StateUpdateMessage ] = StateUpdateMessage ) -> None Initialize a dialogue. Arguments : dialogue_label : the identifier of the dialogue self_address : the address of the entity for whom this dialogue is maintained role : the role of the agent this dialogue is maintained for Returns : None","title":"__init__"},{"location":"aea/api/protocols/state_update/dialogues/#stateupdatedialogues-objects","text":"class StateUpdateDialogues ( Dialogues , ABC ) This class keeps track of all state_update dialogues.","title":"StateUpdateDialogues Objects"},{"location":"aea/api/protocols/state_update/dialogues/#__init___1","text":"| __init__ ( self_address : Address , role_from_first_message : Callable [[ Message , Address ], Dialogue . Role ], dialogue_class : Type [ StateUpdateDialogue ] = StateUpdateDialogue ) -> None Initialize dialogues. Arguments : self_address : the address of the entity for whom dialogues are maintained Returns : None","title":"__init__"},{"location":"aea/api/protocols/state_update/message/","text":"packages.fetchai.protocols.state _ update.message This module contains state_update's message definition. StateUpdateMessage Objects class StateUpdateMessage ( Message ) A protocol for state updates to the decision maker state. Performative Objects class Performative ( Message . Performative ) Performatives for the state_update protocol. __ str __ | __str__ () -> str Get the string representation. __ init __ | __init__ ( performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs : Any , ,) Initialise an instance of StateUpdateMessage. Arguments : message_id : the message id. dialogue_reference : the dialogue reference. target : the message target. performative : the message performative. valid _ performatives | @property | valid_performatives () -> Set [ str ] Get valid performatives. dialogue _ reference | @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message. message _ id | @property | message_id () -> int Get the message_id of the message. performative | @property | performative () -> Performative Get the performative of the message. target | @property | target () -> int Get the target of the message. amount _ by _ currency _ id | @property | amount_by_currency_id () -> Dict [ str , int ] Get the 'amount_by_currency_id' content from the message. exchange _ params _ by _ currency _ id | @property | exchange_params_by_currency_id () -> Dict [ str , float ] Get the 'exchange_params_by_currency_id' content from the message. quantities _ by _ good _ id | @property | quantities_by_good_id () -> Dict [ str , int ] Get the 'quantities_by_good_id' content from the message. utility _ params _ by _ good _ id | @property | utility_params_by_good_id () -> Dict [ str , float ] Get the 'utility_params_by_good_id' content from the message.","title":"Message"},{"location":"aea/api/protocols/state_update/message/#packagesfetchaiprotocolsstate_updatemessage","text":"This module contains state_update's message definition.","title":"packages.fetchai.protocols.state_update.message"},{"location":"aea/api/protocols/state_update/message/#stateupdatemessage-objects","text":"class StateUpdateMessage ( Message ) A protocol for state updates to the decision maker state.","title":"StateUpdateMessage Objects"},{"location":"aea/api/protocols/state_update/message/#performative-objects","text":"class Performative ( Message . Performative ) Performatives for the state_update protocol.","title":"Performative Objects"},{"location":"aea/api/protocols/state_update/message/#__str__","text":"| __str__ () -> str Get the string representation.","title":"__str__"},{"location":"aea/api/protocols/state_update/message/#__init__","text":"| __init__ ( performative : Performative , dialogue_reference : Tuple [ str , str ] = ( \"\" , \"\" ), message_id : int = 1 , target : int = 0 , ** kwargs : Any , ,) Initialise an instance of StateUpdateMessage. Arguments : message_id : the message id. dialogue_reference : the dialogue reference. target : the message target. performative : the message performative.","title":"__init__"},{"location":"aea/api/protocols/state_update/message/#valid_performatives","text":"| @property | valid_performatives () -> Set [ str ] Get valid performatives.","title":"valid_performatives"},{"location":"aea/api/protocols/state_update/message/#dialogue_reference","text":"| @property | dialogue_reference () -> Tuple [ str , str ] Get the dialogue_reference of the message.","title":"dialogue_reference"},{"location":"aea/api/protocols/state_update/message/#message_id","text":"| @property | message_id () -> int Get the message_id of the message.","title":"message_id"},{"location":"aea/api/protocols/state_update/message/#performative","text":"| @property | performative () -> Performative Get the performative of the message.","title":"performative"},{"location":"aea/api/protocols/state_update/message/#target","text":"| @property | target () -> int Get the target of the message.","title":"target"},{"location":"aea/api/protocols/state_update/message/#amount_by_currency_id","text":"| @property | amount_by_currency_id () -> Dict [ str , int ] Get the 'amount_by_currency_id' content from the message.","title":"amount_by_currency_id"},{"location":"aea/api/protocols/state_update/message/#exchange_params_by_currency_id","text":"| @property | exchange_params_by_currency_id () -> Dict [ str , float ] Get the 'exchange_params_by_currency_id' content from the message.","title":"exchange_params_by_currency_id"},{"location":"aea/api/protocols/state_update/message/#quantities_by_good_id","text":"| @property | quantities_by_good_id () -> Dict [ str , int ] Get the 'quantities_by_good_id' content from the message.","title":"quantities_by_good_id"},{"location":"aea/api/protocols/state_update/message/#utility_params_by_good_id","text":"| @property | utility_params_by_good_id () -> Dict [ str , float ] Get the 'utility_params_by_good_id' content from the message.","title":"utility_params_by_good_id"},{"location":"aea/api/protocols/state_update/serialization/","text":"packages.fetchai.protocols.state _ update.serialization Serialization module for state_update protocol. StateUpdateSerializer Objects class StateUpdateSerializer ( Serializer ) Serialization for the 'state_update' protocol. encode | @staticmethod | encode ( msg : Message ) -> bytes Encode a 'StateUpdate' message into bytes. Arguments : msg : the message object. Returns : the bytes. decode | @staticmethod | decode ( obj : bytes ) -> Message Decode bytes into a 'StateUpdate' message. Arguments : obj : the bytes object. Returns : the 'StateUpdate' message.","title":"Serialization"},{"location":"aea/api/protocols/state_update/serialization/#packagesfetchaiprotocolsstate_updateserialization","text":"Serialization module for state_update protocol.","title":"packages.fetchai.protocols.state_update.serialization"},{"location":"aea/api/protocols/state_update/serialization/#stateupdateserializer-objects","text":"class StateUpdateSerializer ( Serializer ) Serialization for the 'state_update' protocol.","title":"StateUpdateSerializer Objects"},{"location":"aea/api/protocols/state_update/serialization/#encode","text":"| @staticmethod | encode ( msg : Message ) -> bytes Encode a 'StateUpdate' message into bytes. Arguments : msg : the message object. Returns : the bytes.","title":"encode"},{"location":"aea/api/protocols/state_update/serialization/#decode","text":"| @staticmethod | decode ( obj : bytes ) -> Message Decode bytes into a 'StateUpdate' message. Arguments : obj : the bytes object. Returns : the 'StateUpdate' message.","title":"decode"},{"location":"aea/api/registries/base/","text":"aea.registries.base This module contains registries. Registry Objects class Registry ( Generic [ ItemId , Item ], WithLogger , ABC ) This class implements an abstract registry. __ init __ | __init__ ( agent_name : str = \"standalone\" ) -> None Initialize the registry. Arguments : agent_name : the name of the agent register | @abstractmethod | register ( item_id : ItemId , item : Item , is_dynamically_added : bool = False ) -> None Register an item. Arguments : item_id : the public id of the item. item : the item. is_dynamically_added : whether or not the item is dynamically added. Returns : None :raises: ValueError if an item is already registered with that item id. unregister | @abstractmethod | unregister ( item_id : ItemId ) -> Optional [ Item ] Unregister an item. Arguments : item_id : the public id of the item. Returns : the item :raises: ValueError if no item registered with that item id. fetch | @abstractmethod | fetch ( item_id : ItemId ) -> Optional [ Item ] Fetch an item. Arguments : item_id : the public id of the item. Returns : the Item fetch _ all | @abstractmethod | fetch_all () -> List [ Item ] Fetch all the items. Returns : the list of items. ids | @abstractmethod | ids () -> Set [ ItemId ] Return the set of all the used item ids. Returns : the set of item ids. setup | @abstractmethod | setup () -> None Set up registry. Returns : None teardown | @abstractmethod | teardown () -> None Teardown the registry. Returns : None PublicIdRegistry Objects class PublicIdRegistry ( Generic [ Item ], Registry [ PublicId , Item ]) This class implement a registry whose keys are public ids. In particular, it is able to handle the case when the public id points to the 'latest' version of a package. __ init __ | __init__ () -> None Initialize the registry. register | register ( public_id : PublicId , item : Item , is_dynamically_added : bool = False ) -> None Register an item. unregister | unregister ( public_id : PublicId ) -> Item Unregister an item. fetch | fetch ( public_id : PublicId ) -> Optional [ Item ] Fetch an item associated with a public id. Arguments : public_id : the public id. Returns : an item, or None if the key is not present. fetch _ all | fetch_all () -> List [ Item ] Fetch all the items. ids | ids () -> Set [ PublicId ] Get all the item ids. setup | setup () -> None Set up the items. teardown | teardown () -> None Tear down the items. AgentComponentRegistry Objects class AgentComponentRegistry ( Registry [ ComponentId , Component ]) This class implements a simple dictionary-based registry for agent components. __ init __ | __init__ ( ** kwargs : Any ) -> None Instantiate the registry. Arguments : kwargs : kwargs register | register ( component_id : ComponentId , component : Component , is_dynamically_added : bool = False ) -> None Register a component. Arguments : component_id : the id of the component. component : the component object. is_dynamically_added : whether or not the item is dynamically added. unregister | unregister ( component_id : ComponentId ) -> Optional [ Component ] Unregister a component. Arguments : component_id : the ComponentId Returns : the item fetch | fetch ( component_id : ComponentId ) -> Optional [ Component ] Fetch the component by id. Arguments : component_id : the contract id Returns : the component or None if the component is not registered fetch _ all | fetch_all () -> List [ Component ] Fetch all the components. Returns : the list of registered components. fetch _ by _ type | fetch_by_type ( component_type : ComponentType ) -> List [ Component ] Fetch all the components by a given type.. Arguments : component_type : a component type Returns : the list of registered components of a given type. ids | ids () -> Set [ ComponentId ] Get the item ids. setup | setup () -> None Set up the registry. teardown | teardown () -> None Teardown the registry. ComponentRegistry Objects class ComponentRegistry ( Registry [ Tuple [ PublicId , str ], SkillComponentType ], Generic [ SkillComponentType ]) This class implements a generic registry for skill components. __ init __ | __init__ ( ** kwargs : Any ) -> None Instantiate the registry. Arguments : kwargs : kwargs register | register ( item_id : Tuple [ PublicId , str ], item : SkillComponentType , is_dynamically_added : bool = False ) -> None Register a item. Arguments : item_id : a pair (skill id, item name). item : the item to register. is_dynamically_added : whether or not the item is dynamically added. :raises: ValueError if an item is already registered with that item id. unregister | unregister ( item_id : Tuple [ PublicId , str ]) -> Optional [ SkillComponentType ] Unregister a item. Arguments : item_id : a pair (skill id, item name). Returns : skill component :raises: ValueError if no item registered with that item id. fetch | fetch ( item_id : Tuple [ PublicId , str ]) -> Optional [ SkillComponentType ] Fetch an item. Arguments : item_id : the public id of the item. Returns : the Item fetch _ by _ skill | fetch_by_skill ( skill_id : PublicId ) -> List [ SkillComponentType ] Fetch all the items of a given skill. fetch _ all | fetch_all () -> List [ SkillComponentType ] Fetch all the items. unregister _ by _ skill | unregister_by_skill ( skill_id : PublicId ) -> None Unregister all the components by skill. ids | ids () -> Set [ Tuple [ PublicId , str ]] Get the item ids. setup | setup () -> None Set up the items in the registry. teardown | teardown () -> None Teardown the registry. HandlerRegistry Objects class HandlerRegistry ( ComponentRegistry [ Handler ]) This class implements the handlers registry. __ init __ | __init__ ( ** kwargs : Any ) -> None Instantiate the registry. Arguments : kwargs : kwargs register | register ( item_id : Tuple [ PublicId , str ], item : Handler , is_dynamically_added : bool = False ) -> None Register a handler. Arguments : item_id : the item id. item : the handler. is_dynamically_added : whether or not the item is dynamically added. Raises : ValueError : if the protocol is None, or an item with pair (skill_id, protocol_id_ already exists. unregister | unregister ( item_id : Tuple [ PublicId , str ]) -> Handler Unregister a item. Arguments : item_id : a pair (skill id, item name). Returns : the unregistered handler :raises: ValueError if no item is registered with that item id. unregister _ by _ skill | unregister_by_skill ( skill_id : PublicId ) -> None Unregister all the components by skill. fetch _ by _ protocol | fetch_by_protocol ( protocol_id : PublicId ) -> List [ Handler ] Fetch the handler by the pair protocol id and skill id. Arguments : protocol_id : the protocol id Returns : the handlers registered for the protocol_id and skill_id fetch _ by _ protocol _ and _ skill | fetch_by_protocol_and_skill ( protocol_id : PublicId , skill_id : PublicId ) -> Optional [ Handler ] Fetch the handler by the pair protocol id and skill id. Arguments : protocol_id : the protocol id skill_id : the skill id. Returns : the handlers registered for the protocol_id and skill_id","title":"Base"},{"location":"aea/api/registries/base/#aearegistriesbase","text":"This module contains registries.","title":"aea.registries.base"},{"location":"aea/api/registries/base/#registry-objects","text":"class Registry ( Generic [ ItemId , Item ], WithLogger , ABC ) This class implements an abstract registry.","title":"Registry Objects"},{"location":"aea/api/registries/base/#__init__","text":"| __init__ ( agent_name : str = \"standalone\" ) -> None Initialize the registry. Arguments : agent_name : the name of the agent","title":"__init__"},{"location":"aea/api/registries/base/#register","text":"| @abstractmethod | register ( item_id : ItemId , item : Item , is_dynamically_added : bool = False ) -> None Register an item. Arguments : item_id : the public id of the item. item : the item. is_dynamically_added : whether or not the item is dynamically added. Returns : None :raises: ValueError if an item is already registered with that item id.","title":"register"},{"location":"aea/api/registries/base/#unregister","text":"| @abstractmethod | unregister ( item_id : ItemId ) -> Optional [ Item ] Unregister an item. Arguments : item_id : the public id of the item. Returns : the item :raises: ValueError if no item registered with that item id.","title":"unregister"},{"location":"aea/api/registries/base/#fetch","text":"| @abstractmethod | fetch ( item_id : ItemId ) -> Optional [ Item ] Fetch an item. Arguments : item_id : the public id of the item. Returns : the Item","title":"fetch"},{"location":"aea/api/registries/base/#fetch_all","text":"| @abstractmethod | fetch_all () -> List [ Item ] Fetch all the items. Returns : the list of items.","title":"fetch_all"},{"location":"aea/api/registries/base/#ids","text":"| @abstractmethod | ids () -> Set [ ItemId ] Return the set of all the used item ids. Returns : the set of item ids.","title":"ids"},{"location":"aea/api/registries/base/#setup","text":"| @abstractmethod | setup () -> None Set up registry. Returns : None","title":"setup"},{"location":"aea/api/registries/base/#teardown","text":"| @abstractmethod | teardown () -> None Teardown the registry. Returns : None","title":"teardown"},{"location":"aea/api/registries/base/#publicidregistry-objects","text":"class PublicIdRegistry ( Generic [ Item ], Registry [ PublicId , Item ]) This class implement a registry whose keys are public ids. In particular, it is able to handle the case when the public id points to the 'latest' version of a package.","title":"PublicIdRegistry Objects"},{"location":"aea/api/registries/base/#__init___1","text":"| __init__ () -> None Initialize the registry.","title":"__init__"},{"location":"aea/api/registries/base/#register_1","text":"| register ( public_id : PublicId , item : Item , is_dynamically_added : bool = False ) -> None Register an item.","title":"register"},{"location":"aea/api/registries/base/#unregister_1","text":"| unregister ( public_id : PublicId ) -> Item Unregister an item.","title":"unregister"},{"location":"aea/api/registries/base/#fetch_1","text":"| fetch ( public_id : PublicId ) -> Optional [ Item ] Fetch an item associated with a public id. Arguments : public_id : the public id. Returns : an item, or None if the key is not present.","title":"fetch"},{"location":"aea/api/registries/base/#fetch_all_1","text":"| fetch_all () -> List [ Item ] Fetch all the items.","title":"fetch_all"},{"location":"aea/api/registries/base/#ids_1","text":"| ids () -> Set [ PublicId ] Get all the item ids.","title":"ids"},{"location":"aea/api/registries/base/#setup_1","text":"| setup () -> None Set up the items.","title":"setup"},{"location":"aea/api/registries/base/#teardown_1","text":"| teardown () -> None Tear down the items.","title":"teardown"},{"location":"aea/api/registries/base/#agentcomponentregistry-objects","text":"class AgentComponentRegistry ( Registry [ ComponentId , Component ]) This class implements a simple dictionary-based registry for agent components.","title":"AgentComponentRegistry Objects"},{"location":"aea/api/registries/base/#__init___2","text":"| __init__ ( ** kwargs : Any ) -> None Instantiate the registry. Arguments : kwargs : kwargs","title":"__init__"},{"location":"aea/api/registries/base/#register_2","text":"| register ( component_id : ComponentId , component : Component , is_dynamically_added : bool = False ) -> None Register a component. Arguments : component_id : the id of the component. component : the component object. is_dynamically_added : whether or not the item is dynamically added.","title":"register"},{"location":"aea/api/registries/base/#unregister_2","text":"| unregister ( component_id : ComponentId ) -> Optional [ Component ] Unregister a component. Arguments : component_id : the ComponentId Returns : the item","title":"unregister"},{"location":"aea/api/registries/base/#fetch_2","text":"| fetch ( component_id : ComponentId ) -> Optional [ Component ] Fetch the component by id. Arguments : component_id : the contract id Returns : the component or None if the component is not registered","title":"fetch"},{"location":"aea/api/registries/base/#fetch_all_2","text":"| fetch_all () -> List [ Component ] Fetch all the components. Returns : the list of registered components.","title":"fetch_all"},{"location":"aea/api/registries/base/#fetch_by_type","text":"| fetch_by_type ( component_type : ComponentType ) -> List [ Component ] Fetch all the components by a given type.. Arguments : component_type : a component type Returns : the list of registered components of a given type.","title":"fetch_by_type"},{"location":"aea/api/registries/base/#ids_2","text":"| ids () -> Set [ ComponentId ] Get the item ids.","title":"ids"},{"location":"aea/api/registries/base/#setup_2","text":"| setup () -> None Set up the registry.","title":"setup"},{"location":"aea/api/registries/base/#teardown_2","text":"| teardown () -> None Teardown the registry.","title":"teardown"},{"location":"aea/api/registries/base/#componentregistry-objects","text":"class ComponentRegistry ( Registry [ Tuple [ PublicId , str ], SkillComponentType ], Generic [ SkillComponentType ]) This class implements a generic registry for skill components.","title":"ComponentRegistry Objects"},{"location":"aea/api/registries/base/#__init___3","text":"| __init__ ( ** kwargs : Any ) -> None Instantiate the registry. Arguments : kwargs : kwargs","title":"__init__"},{"location":"aea/api/registries/base/#register_3","text":"| register ( item_id : Tuple [ PublicId , str ], item : SkillComponentType , is_dynamically_added : bool = False ) -> None Register a item. Arguments : item_id : a pair (skill id, item name). item : the item to register. is_dynamically_added : whether or not the item is dynamically added. :raises: ValueError if an item is already registered with that item id.","title":"register"},{"location":"aea/api/registries/base/#unregister_3","text":"| unregister ( item_id : Tuple [ PublicId , str ]) -> Optional [ SkillComponentType ] Unregister a item. Arguments : item_id : a pair (skill id, item name). Returns : skill component :raises: ValueError if no item registered with that item id.","title":"unregister"},{"location":"aea/api/registries/base/#fetch_3","text":"| fetch ( item_id : Tuple [ PublicId , str ]) -> Optional [ SkillComponentType ] Fetch an item. Arguments : item_id : the public id of the item. Returns : the Item","title":"fetch"},{"location":"aea/api/registries/base/#fetch_by_skill","text":"| fetch_by_skill ( skill_id : PublicId ) -> List [ SkillComponentType ] Fetch all the items of a given skill.","title":"fetch_by_skill"},{"location":"aea/api/registries/base/#fetch_all_3","text":"| fetch_all () -> List [ SkillComponentType ] Fetch all the items.","title":"fetch_all"},{"location":"aea/api/registries/base/#unregister_by_skill","text":"| unregister_by_skill ( skill_id : PublicId ) -> None Unregister all the components by skill.","title":"unregister_by_skill"},{"location":"aea/api/registries/base/#ids_3","text":"| ids () -> Set [ Tuple [ PublicId , str ]] Get the item ids.","title":"ids"},{"location":"aea/api/registries/base/#setup_3","text":"| setup () -> None Set up the items in the registry.","title":"setup"},{"location":"aea/api/registries/base/#teardown_3","text":"| teardown () -> None Teardown the registry.","title":"teardown"},{"location":"aea/api/registries/base/#handlerregistry-objects","text":"class HandlerRegistry ( ComponentRegistry [ Handler ]) This class implements the handlers registry.","title":"HandlerRegistry Objects"},{"location":"aea/api/registries/base/#__init___4","text":"| __init__ ( ** kwargs : Any ) -> None Instantiate the registry. Arguments : kwargs : kwargs","title":"__init__"},{"location":"aea/api/registries/base/#register_4","text":"| register ( item_id : Tuple [ PublicId , str ], item : Handler , is_dynamically_added : bool = False ) -> None Register a handler. Arguments : item_id : the item id. item : the handler. is_dynamically_added : whether or not the item is dynamically added. Raises : ValueError : if the protocol is None, or an item with pair (skill_id, protocol_id_ already exists.","title":"register"},{"location":"aea/api/registries/base/#unregister_4","text":"| unregister ( item_id : Tuple [ PublicId , str ]) -> Handler Unregister a item. Arguments : item_id : a pair (skill id, item name). Returns : the unregistered handler :raises: ValueError if no item is registered with that item id.","title":"unregister"},{"location":"aea/api/registries/base/#unregister_by_skill_1","text":"| unregister_by_skill ( skill_id : PublicId ) -> None Unregister all the components by skill.","title":"unregister_by_skill"},{"location":"aea/api/registries/base/#fetch_by_protocol","text":"| fetch_by_protocol ( protocol_id : PublicId ) -> List [ Handler ] Fetch the handler by the pair protocol id and skill id. Arguments : protocol_id : the protocol id Returns : the handlers registered for the protocol_id and skill_id","title":"fetch_by_protocol"},{"location":"aea/api/registries/base/#fetch_by_protocol_and_skill","text":"| fetch_by_protocol_and_skill ( protocol_id : PublicId , skill_id : PublicId ) -> Optional [ Handler ] Fetch the handler by the pair protocol id and skill id. Arguments : protocol_id : the protocol id skill_id : the skill id. Returns : the handlers registered for the protocol_id and skill_id","title":"fetch_by_protocol_and_skill"},{"location":"aea/api/registries/filter/","text":"aea.registries.filter This module contains registries. Filter Objects class Filter ( WithLogger ) This class implements the filter of an AEA. __ init __ | __init__ ( resources : Resources , decision_maker_out_queue : AsyncFriendlyQueue ) -> None Instantiate the filter. Arguments : resources : the resources decision_maker_out_queue : the decision maker queue resources | @property | resources () -> Resources Get resources. decision _ maker _ out _ queue | @property | decision_maker_out_queue () -> AsyncFriendlyQueue Get decision maker (out) queue. get _ active _ handlers | get_active_handlers ( protocol_id : PublicId , skill_id : Optional [ PublicId ] = None ) -> List [ Handler ] Get active handlers based on protocol id and optional skill id. Arguments : protocol_id : the protocol id skill_id : the skill id Returns : the list of handlers currently active get _ active _ behaviours | get_active_behaviours () -> List [ Behaviour ] Get the active behaviours. Returns : the list of behaviours currently active handle _ new _ handlers _ and _ behaviours | handle_new_handlers_and_behaviours () -> None Handle the messages from the decision maker. get _ internal _ message | async get_internal_message () -> Optional [ Message ] Get a message from decision_maker_out_queue. handle _ internal _ message | handle_internal_message ( internal_message : Optional [ Message ]) -> None Handle internal message.","title":"Filter"},{"location":"aea/api/registries/filter/#aearegistriesfilter","text":"This module contains registries.","title":"aea.registries.filter"},{"location":"aea/api/registries/filter/#filter-objects","text":"class Filter ( WithLogger ) This class implements the filter of an AEA.","title":"Filter Objects"},{"location":"aea/api/registries/filter/#__init__","text":"| __init__ ( resources : Resources , decision_maker_out_queue : AsyncFriendlyQueue ) -> None Instantiate the filter. Arguments : resources : the resources decision_maker_out_queue : the decision maker queue","title":"__init__"},{"location":"aea/api/registries/filter/#resources","text":"| @property | resources () -> Resources Get resources.","title":"resources"},{"location":"aea/api/registries/filter/#decision_maker_out_queue","text":"| @property | decision_maker_out_queue () -> AsyncFriendlyQueue Get decision maker (out) queue.","title":"decision_maker_out_queue"},{"location":"aea/api/registries/filter/#get_active_handlers","text":"| get_active_handlers ( protocol_id : PublicId , skill_id : Optional [ PublicId ] = None ) -> List [ Handler ] Get active handlers based on protocol id and optional skill id. Arguments : protocol_id : the protocol id skill_id : the skill id Returns : the list of handlers currently active","title":"get_active_handlers"},{"location":"aea/api/registries/filter/#get_active_behaviours","text":"| get_active_behaviours () -> List [ Behaviour ] Get the active behaviours. Returns : the list of behaviours currently active","title":"get_active_behaviours"},{"location":"aea/api/registries/filter/#handle_new_handlers_and_behaviours","text":"| handle_new_handlers_and_behaviours () -> None Handle the messages from the decision maker.","title":"handle_new_handlers_and_behaviours"},{"location":"aea/api/registries/filter/#get_internal_message","text":"| async get_internal_message () -> Optional [ Message ] Get a message from decision_maker_out_queue.","title":"get_internal_message"},{"location":"aea/api/registries/filter/#handle_internal_message","text":"| handle_internal_message ( internal_message : Optional [ Message ]) -> None Handle internal message.","title":"handle_internal_message"},{"location":"aea/api/registries/resources/","text":"aea.registries.resources This module contains the resources class. Resources Objects class Resources () This class implements the object that holds the resources of an AEA. __ init __ | __init__ ( agent_name : str = \"standalone\" ) -> None Instantiate the resources. Arguments : agent_name : the name of the agent agent _ name | @property | agent_name () -> str Get the agent name. component _ registry | @property | component_registry () -> AgentComponentRegistry Get the agent component registry. behaviour _ registry | @property | behaviour_registry () -> ComponentRegistry [ Behaviour ] Get the behaviour registry. handler _ registry | @property | handler_registry () -> HandlerRegistry Get the handler registry. model _ registry | @property | model_registry () -> ComponentRegistry [ Model ] Get the model registry. add _ component | add_component ( component : Component ) -> None Add a component to resources. add _ protocol | add_protocol ( protocol : Protocol ) -> None Add a protocol to the set of resources. Arguments : protocol : a protocol get _ protocol | get_protocol ( protocol_id : PublicId ) -> Optional [ Protocol ] Get protocol for given protocol id. Arguments : protocol_id : the protocol id Returns : a matching protocol, if present, else None get _ protocol _ by _ specification _ id | get_protocol_by_specification_id ( protocol_specification_id : PublicId ) -> Optional [ Protocol ] Get protocol for given protocol_specification_id. Arguments : protocol_specification_id : the protocol id Returns : a matching protocol, if present, else None get _ all _ protocols | get_all_protocols () -> List [ Protocol ] Get the list of all the protocols. Returns : the list of protocols. remove _ protocol | remove_protocol ( protocol_id : PublicId ) -> None Remove a protocol from the set of resources. Arguments : protocol_id : the protocol id for the protocol to be removed. add _ contract | add_contract ( contract : Contract ) -> None Add a contract to the set of resources. Arguments : contract : a contract get _ contract | get_contract ( contract_id : PublicId ) -> Optional [ Contract ] Get contract for given contract id. Arguments : contract_id : the contract id Returns : a matching contract, if present, else None get _ all _ contracts | get_all_contracts () -> List [ Contract ] Get the list of all the contracts. Returns : the list of contracts. remove _ contract | remove_contract ( contract_id : PublicId ) -> None Remove a contract from the set of resources. Arguments : contract_id : the contract id for the contract to be removed. add _ connection | add_connection ( connection : Connection ) -> None Add a connection to the set of resources. Arguments : connection : a connection get _ connection | get_connection ( connection_id : PublicId ) -> Optional [ Connection ] Get connection for given connection id. Arguments : connection_id : the connection id Returns : a matching connection, if present, else None get _ all _ connections | get_all_connections () -> List [ Connection ] Get the list of all the connections. Returns : the list of connections. remove _ connection | remove_connection ( connection_id : PublicId ) -> None Remove a connection from the set of resources. Arguments : connection_id : the connection id for the connection to be removed. add _ skill | add_skill ( skill : Skill ) -> None Add a skill to the set of resources. Arguments : skill : a skill get _ skill | get_skill ( skill_id : PublicId ) -> Optional [ Skill ] Get the skill for a given skill id. Arguments : skill_id : the skill id Returns : a matching skill, if present, else None get _ all _ skills | get_all_skills () -> List [ Skill ] Get the list of all the skills. Returns : the list of skills. remove _ skill | remove_skill ( skill_id : PublicId ) -> None Remove a skill from the set of resources. Arguments : skill_id : the skill id for the skill to be removed. get _ handler | get_handler ( protocol_id : PublicId , skill_id : PublicId ) -> Optional [ Handler ] Get a specific handler. Arguments : protocol_id : the protocol id the handler is handling skill_id : the skill id of the handler's skill Returns : the handler get _ handlers | get_handlers ( protocol_id : PublicId ) -> List [ Handler ] Get all handlers for a given protocol. Arguments : protocol_id : the protocol id the handler is handling Returns : the list of handlers matching the protocol get _ all _ handlers | get_all_handlers () -> List [ Handler ] Get all handlers from all skills. Returns : the list of handlers get _ behaviour | get_behaviour ( skill_id : PublicId , behaviour_name : str ) -> Optional [ Behaviour ] Get a specific behaviours for a given skill. Arguments : skill_id : the skill id behaviour_name : the behaviour name Returns : the behaviour, if it is present, else None get _ behaviours | get_behaviours ( skill_id : PublicId ) -> List [ Behaviour ] Get all behaviours for a given skill. Arguments : skill_id : the skill id Returns : the list of behaviours of the skill get _ all _ behaviours | get_all_behaviours () -> List [ Behaviour ] Get all behaviours from all skills. Returns : the list of all behaviours setup | setup () -> None Set up the resources. Calls setup on all resources. teardown | teardown () -> None Teardown the resources. Calls teardown on all resources.","title":"Resources"},{"location":"aea/api/registries/resources/#aearegistriesresources","text":"This module contains the resources class.","title":"aea.registries.resources"},{"location":"aea/api/registries/resources/#resources-objects","text":"class Resources () This class implements the object that holds the resources of an AEA.","title":"Resources Objects"},{"location":"aea/api/registries/resources/#__init__","text":"| __init__ ( agent_name : str = \"standalone\" ) -> None Instantiate the resources. Arguments : agent_name : the name of the agent","title":"__init__"},{"location":"aea/api/registries/resources/#agent_name","text":"| @property | agent_name () -> str Get the agent name.","title":"agent_name"},{"location":"aea/api/registries/resources/#component_registry","text":"| @property | component_registry () -> AgentComponentRegistry Get the agent component registry.","title":"component_registry"},{"location":"aea/api/registries/resources/#behaviour_registry","text":"| @property | behaviour_registry () -> ComponentRegistry [ Behaviour ] Get the behaviour registry.","title":"behaviour_registry"},{"location":"aea/api/registries/resources/#handler_registry","text":"| @property | handler_registry () -> HandlerRegistry Get the handler registry.","title":"handler_registry"},{"location":"aea/api/registries/resources/#model_registry","text":"| @property | model_registry () -> ComponentRegistry [ Model ] Get the model registry.","title":"model_registry"},{"location":"aea/api/registries/resources/#add_component","text":"| add_component ( component : Component ) -> None Add a component to resources.","title":"add_component"},{"location":"aea/api/registries/resources/#add_protocol","text":"| add_protocol ( protocol : Protocol ) -> None Add a protocol to the set of resources. Arguments : protocol : a protocol","title":"add_protocol"},{"location":"aea/api/registries/resources/#get_protocol","text":"| get_protocol ( protocol_id : PublicId ) -> Optional [ Protocol ] Get protocol for given protocol id. Arguments : protocol_id : the protocol id Returns : a matching protocol, if present, else None","title":"get_protocol"},{"location":"aea/api/registries/resources/#get_protocol_by_specification_id","text":"| get_protocol_by_specification_id ( protocol_specification_id : PublicId ) -> Optional [ Protocol ] Get protocol for given protocol_specification_id. Arguments : protocol_specification_id : the protocol id Returns : a matching protocol, if present, else None","title":"get_protocol_by_specification_id"},{"location":"aea/api/registries/resources/#get_all_protocols","text":"| get_all_protocols () -> List [ Protocol ] Get the list of all the protocols. Returns : the list of protocols.","title":"get_all_protocols"},{"location":"aea/api/registries/resources/#remove_protocol","text":"| remove_protocol ( protocol_id : PublicId ) -> None Remove a protocol from the set of resources. Arguments : protocol_id : the protocol id for the protocol to be removed.","title":"remove_protocol"},{"location":"aea/api/registries/resources/#add_contract","text":"| add_contract ( contract : Contract ) -> None Add a contract to the set of resources. Arguments : contract : a contract","title":"add_contract"},{"location":"aea/api/registries/resources/#get_contract","text":"| get_contract ( contract_id : PublicId ) -> Optional [ Contract ] Get contract for given contract id. Arguments : contract_id : the contract id Returns : a matching contract, if present, else None","title":"get_contract"},{"location":"aea/api/registries/resources/#get_all_contracts","text":"| get_all_contracts () -> List [ Contract ] Get the list of all the contracts. Returns : the list of contracts.","title":"get_all_contracts"},{"location":"aea/api/registries/resources/#remove_contract","text":"| remove_contract ( contract_id : PublicId ) -> None Remove a contract from the set of resources. Arguments : contract_id : the contract id for the contract to be removed.","title":"remove_contract"},{"location":"aea/api/registries/resources/#add_connection","text":"| add_connection ( connection : Connection ) -> None Add a connection to the set of resources. Arguments : connection : a connection","title":"add_connection"},{"location":"aea/api/registries/resources/#get_connection","text":"| get_connection ( connection_id : PublicId ) -> Optional [ Connection ] Get connection for given connection id. Arguments : connection_id : the connection id Returns : a matching connection, if present, else None","title":"get_connection"},{"location":"aea/api/registries/resources/#get_all_connections","text":"| get_all_connections () -> List [ Connection ] Get the list of all the connections. Returns : the list of connections.","title":"get_all_connections"},{"location":"aea/api/registries/resources/#remove_connection","text":"| remove_connection ( connection_id : PublicId ) -> None Remove a connection from the set of resources. Arguments : connection_id : the connection id for the connection to be removed.","title":"remove_connection"},{"location":"aea/api/registries/resources/#add_skill","text":"| add_skill ( skill : Skill ) -> None Add a skill to the set of resources. Arguments : skill : a skill","title":"add_skill"},{"location":"aea/api/registries/resources/#get_skill","text":"| get_skill ( skill_id : PublicId ) -> Optional [ Skill ] Get the skill for a given skill id. Arguments : skill_id : the skill id Returns : a matching skill, if present, else None","title":"get_skill"},{"location":"aea/api/registries/resources/#get_all_skills","text":"| get_all_skills () -> List [ Skill ] Get the list of all the skills. Returns : the list of skills.","title":"get_all_skills"},{"location":"aea/api/registries/resources/#remove_skill","text":"| remove_skill ( skill_id : PublicId ) -> None Remove a skill from the set of resources. Arguments : skill_id : the skill id for the skill to be removed.","title":"remove_skill"},{"location":"aea/api/registries/resources/#get_handler","text":"| get_handler ( protocol_id : PublicId , skill_id : PublicId ) -> Optional [ Handler ] Get a specific handler. Arguments : protocol_id : the protocol id the handler is handling skill_id : the skill id of the handler's skill Returns : the handler","title":"get_handler"},{"location":"aea/api/registries/resources/#get_handlers","text":"| get_handlers ( protocol_id : PublicId ) -> List [ Handler ] Get all handlers for a given protocol. Arguments : protocol_id : the protocol id the handler is handling Returns : the list of handlers matching the protocol","title":"get_handlers"},{"location":"aea/api/registries/resources/#get_all_handlers","text":"| get_all_handlers () -> List [ Handler ] Get all handlers from all skills. Returns : the list of handlers","title":"get_all_handlers"},{"location":"aea/api/registries/resources/#get_behaviour","text":"| get_behaviour ( skill_id : PublicId , behaviour_name : str ) -> Optional [ Behaviour ] Get a specific behaviours for a given skill. Arguments : skill_id : the skill id behaviour_name : the behaviour name Returns : the behaviour, if it is present, else None","title":"get_behaviour"},{"location":"aea/api/registries/resources/#get_behaviours","text":"| get_behaviours ( skill_id : PublicId ) -> List [ Behaviour ] Get all behaviours for a given skill. Arguments : skill_id : the skill id Returns : the list of behaviours of the skill","title":"get_behaviours"},{"location":"aea/api/registries/resources/#get_all_behaviours","text":"| get_all_behaviours () -> List [ Behaviour ] Get all behaviours from all skills. Returns : the list of all behaviours","title":"get_all_behaviours"},{"location":"aea/api/registries/resources/#setup","text":"| setup () -> None Set up the resources. Calls setup on all resources.","title":"setup"},{"location":"aea/api/registries/resources/#teardown","text":"| teardown () -> None Teardown the resources. Calls teardown on all resources.","title":"teardown"},{"location":"aea/api/skills/base/","text":"aea.skills.base This module contains the base classes for the skills. SkillContext Objects class SkillContext () This class implements the context of a skill. __ init __ | __init__ ( agent_context : Optional [ AgentContext ] = None , skill : Optional [ \"Skill\" ] = None ) -> None Initialize a skill context. Arguments : agent_context : the agent context. skill : the skill. logger | @property | logger () -> Logger Get the logger. logger | @logger . setter | logger ( logger_ : Logger ) -> None Set the logger. set _ agent _ context | set_agent_context ( agent_context : AgentContext ) -> None Set the agent context. shared _ state | @property | shared_state () -> Dict [ str , Any ] Get the shared state dictionary. agent _ name | @property | agent_name () -> str Get agent name. skill _ id | @property | skill_id () -> PublicId Get the skill id of the skill context. is _ active | @property | is_active () -> bool Get the status of the skill (active/not active). is _ active | @is_active . setter | is_active ( value : bool ) -> None Set the status of the skill (active/not active). new _ behaviours | @property | new_behaviours () -> \"Queue[Behaviour]\" Queue for the new behaviours. This queue can be used to send messages to the framework to request the registration of a behaviour. Returns : the queue of new behaviours. new _ handlers | @property | new_handlers () -> \"Queue[Handler]\" Queue for the new handlers. This queue can be used to send messages to the framework to request the registration of a handler. Returns : the queue of new handlers. agent _ addresses | @property | agent_addresses () -> Dict [ str , str ] Get addresses. agent _ address | @property | agent_address () -> str Get address. public _ key | @property | public_key () -> str Get public key. public _ keys | @property | public_keys () -> Dict [ str , str ] Get public keys. connection _ status | @property | connection_status () -> MultiplexerStatus Get connection status. outbox | @property | outbox () -> OutBox Get outbox. storage | @property | storage () -> Optional [ Storage ] Get optional storage for agent. message _ in _ queue | @property | message_in_queue () -> Queue Get message in queue. decision _ maker _ message _ queue | @property | decision_maker_message_queue () -> Queue Get message queue of decision maker. decision _ maker _ handler _ context | @property | decision_maker_handler_context () -> SimpleNamespace Get decision maker handler context. task _ manager | @property | task_manager () -> TaskManager Get behaviours of the skill. default _ ledger _ id | @property | default_ledger_id () -> str Get the default ledger id. currency _ denominations | @property | currency_denominations () -> Dict [ str , str ] Get a dictionary mapping ledger ids to currency denominations. search _ service _ address | @property | search_service_address () -> Address Get the address of the search service. decision _ maker _ address | @property | decision_maker_address () -> Address Get the address of the decision maker. handlers | @property | handlers () -> SimpleNamespace Get handlers of the skill. behaviours | @property | behaviours () -> SimpleNamespace Get behaviours of the skill. namespace | @property | namespace () -> SimpleNamespace Get the agent context namespace. __ getattr __ | __getattr__ ( item : Any ) -> Any Get attribute. send _ to _ skill | send_to_skill ( message_or_envelope : Union [ Message , Envelope ], context : Optional [ EnvelopeContext ] = None ) -> None Send message or envelope to another skill. If message passed it will be wrapped into envelope with optional envelope context. Arguments : message_or_envelope : envelope to send to another skill. context : the optional envelope context SkillComponent Objects class SkillComponent ( ABC ) This class defines an abstract interface for skill component classes. __ init __ | __init__ ( name : str , skill_context : SkillContext , configuration : Optional [ SkillComponentConfiguration ] = None , ** kwargs : Any , ,) -> None Initialize a skill component. Arguments : name : the name of the component. configuration : the configuration for the component. skill_context : the skill context. kwargs : the keyword arguments. name | @property | name () -> str Get the name of the skill component. context | @property | context () -> SkillContext Get the context of the skill component. skill _ id | @property | skill_id () -> PublicId Get the skill id of the skill component. configuration | @property | configuration () -> SkillComponentConfiguration Get the skill component configuration. config | @property | config () -> Dict [ Any , Any ] Get the config of the skill component. setup | @abstractmethod | setup () -> None Implement the setup. teardown | @abstractmethod | teardown () -> None Implement the teardown. parse _ module | @classmethod | @abstractmethod | parse_module ( cls , path : str , configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> dict Parse the component module. AbstractBehaviour Objects class AbstractBehaviour ( SkillComponent , ABC ) Abstract behaviour for periodical calls. tick_interval: float, interval to call behaviour's act. start_at: optional datetime, when to start periodical calls. tick _ interval | @property | tick_interval () -> float Get the tick_interval in seconds. start _ at | @property | start_at () -> Optional [ datetime . datetime ] Get the start time of the behaviour. Behaviour Objects class Behaviour ( AbstractBehaviour , ABC ) This class implements an abstract behaviour. In a subclass of Behaviour, the flag 'is_programmatically_defined' can be used by the developer to signal to the framework that the class is meant to be used programmatically; hence, in case the class is not declared in the configuration file but it is present in a skill module, the framework will just ignore this class instead of printing a warning message. act | @abstractmethod | act () -> None Implement the behaviour. Returns : None is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. act _ wrapper | act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. parse _ module | @classmethod | parse_module ( cls , path : str , behaviour_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Behaviour\" ] Parse the behaviours module. Arguments : path : path to the Python module containing the Behaviour classes. behaviour_configs : a list of behaviour configurations. skill_context : the skill context Returns : a list of Behaviour. Handler Objects class Handler ( SkillComponent , ABC ) This class implements an abstract behaviour. In a subclass of Handler, the flag 'is_programmatically_defined' can be used by the developer to signal to the framework that the component is meant to be used programmatically; hence, in case the class is not declared in the configuration file but it is present in a skill module, the framework will just ignore this class instead of printing a warning message. SUPPORTED_PROTOCOL is read by the framework when the handlers are loaded to register them as 'listeners' to the protocol identified by the specified public id. Whenever a message of protocol 'SUPPORTED_PROTOCOL' is sent to the agent, the framework will call the 'handle' method. handle | @abstractmethod | handle ( message : Message ) -> None Implement the reaction to a message. Arguments : message : the message Returns : None handle _ wrapper | handle_wrapper ( message : Message ) -> None Wrap the call of the handler. This method must be called only by the framework. parse _ module | @classmethod | parse_module ( cls , path : str , handler_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Handler\" ] Parse the handler module. Arguments : path : path to the Python module containing the Handler class. handler_configs : the list of handler configurations. skill_context : the skill context Returns : an handler, or None if the parsing fails. Model Objects class Model ( SkillComponent , ABC ) This class implements an abstract model. __ init __ | __init__ ( name : str , skill_context : SkillContext , configuration : Optional [ SkillComponentConfiguration ] = None , keep_terminal_state_dialogues : Optional [ bool ] = None , ** kwargs : Any , ,) -> None Initialize a model. Arguments : name : the name of the component. configuration : the configuration for the component. skill_context : the skill context. keep_terminal_state_dialogues : specify do dialogues in terminal state should stay or not kwargs : the keyword arguments. setup | setup () -> None Set the class up. teardown | teardown () -> None Tear the class down. parse _ module | @classmethod | parse_module ( cls , path : str , model_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Model\" ] Parse the model module. Arguments : path : path to the Python skill module. model_configs : a list of model configurations. skill_context : the skill context Returns : a list of Model. Skill Objects class Skill ( Component ) This class implements a skill. __ init __ | __init__ ( configuration : SkillConfig , skill_context : Optional [ SkillContext ] = None , handlers : Optional [ Dict [ str , Handler ]] = None , behaviours : Optional [ Dict [ str , Behaviour ]] = None , models : Optional [ Dict [ str , Model ]] = None , ** kwargs : Any , ,) Initialize a skill. Arguments : configuration : the skill configuration. skill_context : the skill context. handlers : dictionary of handlers. behaviours : dictionary of behaviours. models : dictionary of models. kwargs : the keyword arguments. skill _ context | @property | skill_context () -> SkillContext Get the skill context. handlers | @property | handlers () -> Dict [ str , Handler ] Get the handlers. behaviours | @property | behaviours () -> Dict [ str , Behaviour ] Get the handlers. models | @property | models () -> Dict [ str , Model ] Get the handlers. from _ dir | @classmethod | from_dir ( cls , directory : str , agent_context : AgentContext , ** kwargs : Any ) -> \"Skill\" Load the skill from a directory. Arguments : directory : the directory to the skill package. agent_context : the skill context. kwargs : the keyword arguments. Returns : the skill object. logger | @property | logger () -> Logger Get the logger. In the case of a skill, return the logger provided by the skill context. Returns : the logger logger | @logger . setter | logger ( * args : str ) -> None Set the logger. from _ config | @classmethod | from_config ( cls , configuration : SkillConfig , agent_context : AgentContext , ** kwargs : Any ) -> \"Skill\" Load the skill from configuration. Arguments : configuration : a skill configuration. Must be associated with a directory. agent_context : the agent context. kwargs : the keyword arguments. Returns : the skill. _ SkillComponentLoadingItem Objects class _SkillComponentLoadingItem () Class to represent a triple (component name, component configuration, component class). __ init __ | __init__ ( name : str , config : SkillComponentConfiguration , class_ : Type [ SkillComponent ], type_ : _SKILL_COMPONENT_TYPES ) Initialize the item. _ SkillComponentLoader Objects class _SkillComponentLoader () This class implements the loading policy for skill components. __ init __ | __init__ ( configuration : SkillConfig , skill_context : SkillContext , ** kwargs : Any ) Initialize the helper class. load _ skill | load_skill () -> Skill Load the skill.","title":"Base"},{"location":"aea/api/skills/base/#aeaskillsbase","text":"This module contains the base classes for the skills.","title":"aea.skills.base"},{"location":"aea/api/skills/base/#skillcontext-objects","text":"class SkillContext () This class implements the context of a skill.","title":"SkillContext Objects"},{"location":"aea/api/skills/base/#__init__","text":"| __init__ ( agent_context : Optional [ AgentContext ] = None , skill : Optional [ \"Skill\" ] = None ) -> None Initialize a skill context. Arguments : agent_context : the agent context. skill : the skill.","title":"__init__"},{"location":"aea/api/skills/base/#logger","text":"| @property | logger () -> Logger Get the logger.","title":"logger"},{"location":"aea/api/skills/base/#logger_1","text":"| @logger . setter | logger ( logger_ : Logger ) -> None Set the logger.","title":"logger"},{"location":"aea/api/skills/base/#set_agent_context","text":"| set_agent_context ( agent_context : AgentContext ) -> None Set the agent context.","title":"set_agent_context"},{"location":"aea/api/skills/base/#shared_state","text":"| @property | shared_state () -> Dict [ str , Any ] Get the shared state dictionary.","title":"shared_state"},{"location":"aea/api/skills/base/#agent_name","text":"| @property | agent_name () -> str Get agent name.","title":"agent_name"},{"location":"aea/api/skills/base/#skill_id","text":"| @property | skill_id () -> PublicId Get the skill id of the skill context.","title":"skill_id"},{"location":"aea/api/skills/base/#is_active","text":"| @property | is_active () -> bool Get the status of the skill (active/not active).","title":"is_active"},{"location":"aea/api/skills/base/#is_active_1","text":"| @is_active . setter | is_active ( value : bool ) -> None Set the status of the skill (active/not active).","title":"is_active"},{"location":"aea/api/skills/base/#new_behaviours","text":"| @property | new_behaviours () -> \"Queue[Behaviour]\" Queue for the new behaviours. This queue can be used to send messages to the framework to request the registration of a behaviour. Returns : the queue of new behaviours.","title":"new_behaviours"},{"location":"aea/api/skills/base/#new_handlers","text":"| @property | new_handlers () -> \"Queue[Handler]\" Queue for the new handlers. This queue can be used to send messages to the framework to request the registration of a handler. Returns : the queue of new handlers.","title":"new_handlers"},{"location":"aea/api/skills/base/#agent_addresses","text":"| @property | agent_addresses () -> Dict [ str , str ] Get addresses.","title":"agent_addresses"},{"location":"aea/api/skills/base/#agent_address","text":"| @property | agent_address () -> str Get address.","title":"agent_address"},{"location":"aea/api/skills/base/#public_key","text":"| @property | public_key () -> str Get public key.","title":"public_key"},{"location":"aea/api/skills/base/#public_keys","text":"| @property | public_keys () -> Dict [ str , str ] Get public keys.","title":"public_keys"},{"location":"aea/api/skills/base/#connection_status","text":"| @property | connection_status () -> MultiplexerStatus Get connection status.","title":"connection_status"},{"location":"aea/api/skills/base/#outbox","text":"| @property | outbox () -> OutBox Get outbox.","title":"outbox"},{"location":"aea/api/skills/base/#storage","text":"| @property | storage () -> Optional [ Storage ] Get optional storage for agent.","title":"storage"},{"location":"aea/api/skills/base/#message_in_queue","text":"| @property | message_in_queue () -> Queue Get message in queue.","title":"message_in_queue"},{"location":"aea/api/skills/base/#decision_maker_message_queue","text":"| @property | decision_maker_message_queue () -> Queue Get message queue of decision maker.","title":"decision_maker_message_queue"},{"location":"aea/api/skills/base/#decision_maker_handler_context","text":"| @property | decision_maker_handler_context () -> SimpleNamespace Get decision maker handler context.","title":"decision_maker_handler_context"},{"location":"aea/api/skills/base/#task_manager","text":"| @property | task_manager () -> TaskManager Get behaviours of the skill.","title":"task_manager"},{"location":"aea/api/skills/base/#default_ledger_id","text":"| @property | default_ledger_id () -> str Get the default ledger id.","title":"default_ledger_id"},{"location":"aea/api/skills/base/#currency_denominations","text":"| @property | currency_denominations () -> Dict [ str , str ] Get a dictionary mapping ledger ids to currency denominations.","title":"currency_denominations"},{"location":"aea/api/skills/base/#search_service_address","text":"| @property | search_service_address () -> Address Get the address of the search service.","title":"search_service_address"},{"location":"aea/api/skills/base/#decision_maker_address","text":"| @property | decision_maker_address () -> Address Get the address of the decision maker.","title":"decision_maker_address"},{"location":"aea/api/skills/base/#handlers","text":"| @property | handlers () -> SimpleNamespace Get handlers of the skill.","title":"handlers"},{"location":"aea/api/skills/base/#behaviours","text":"| @property | behaviours () -> SimpleNamespace Get behaviours of the skill.","title":"behaviours"},{"location":"aea/api/skills/base/#namespace","text":"| @property | namespace () -> SimpleNamespace Get the agent context namespace.","title":"namespace"},{"location":"aea/api/skills/base/#__getattr__","text":"| __getattr__ ( item : Any ) -> Any Get attribute.","title":"__getattr__"},{"location":"aea/api/skills/base/#send_to_skill","text":"| send_to_skill ( message_or_envelope : Union [ Message , Envelope ], context : Optional [ EnvelopeContext ] = None ) -> None Send message or envelope to another skill. If message passed it will be wrapped into envelope with optional envelope context. Arguments : message_or_envelope : envelope to send to another skill. context : the optional envelope context","title":"send_to_skill"},{"location":"aea/api/skills/base/#skillcomponent-objects","text":"class SkillComponent ( ABC ) This class defines an abstract interface for skill component classes.","title":"SkillComponent Objects"},{"location":"aea/api/skills/base/#__init___1","text":"| __init__ ( name : str , skill_context : SkillContext , configuration : Optional [ SkillComponentConfiguration ] = None , ** kwargs : Any , ,) -> None Initialize a skill component. Arguments : name : the name of the component. configuration : the configuration for the component. skill_context : the skill context. kwargs : the keyword arguments.","title":"__init__"},{"location":"aea/api/skills/base/#name","text":"| @property | name () -> str Get the name of the skill component.","title":"name"},{"location":"aea/api/skills/base/#context","text":"| @property | context () -> SkillContext Get the context of the skill component.","title":"context"},{"location":"aea/api/skills/base/#skill_id_1","text":"| @property | skill_id () -> PublicId Get the skill id of the skill component.","title":"skill_id"},{"location":"aea/api/skills/base/#configuration","text":"| @property | configuration () -> SkillComponentConfiguration Get the skill component configuration.","title":"configuration"},{"location":"aea/api/skills/base/#config","text":"| @property | config () -> Dict [ Any , Any ] Get the config of the skill component.","title":"config"},{"location":"aea/api/skills/base/#setup","text":"| @abstractmethod | setup () -> None Implement the setup.","title":"setup"},{"location":"aea/api/skills/base/#teardown","text":"| @abstractmethod | teardown () -> None Implement the teardown.","title":"teardown"},{"location":"aea/api/skills/base/#parse_module","text":"| @classmethod | @abstractmethod | parse_module ( cls , path : str , configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> dict Parse the component module.","title":"parse_module"},{"location":"aea/api/skills/base/#abstractbehaviour-objects","text":"class AbstractBehaviour ( SkillComponent , ABC ) Abstract behaviour for periodical calls. tick_interval: float, interval to call behaviour's act. start_at: optional datetime, when to start periodical calls.","title":"AbstractBehaviour Objects"},{"location":"aea/api/skills/base/#tick_interval","text":"| @property | tick_interval () -> float Get the tick_interval in seconds.","title":"tick_interval"},{"location":"aea/api/skills/base/#start_at","text":"| @property | start_at () -> Optional [ datetime . datetime ] Get the start time of the behaviour.","title":"start_at"},{"location":"aea/api/skills/base/#behaviour-objects","text":"class Behaviour ( AbstractBehaviour , ABC ) This class implements an abstract behaviour. In a subclass of Behaviour, the flag 'is_programmatically_defined' can be used by the developer to signal to the framework that the class is meant to be used programmatically; hence, in case the class is not declared in the configuration file but it is present in a skill module, the framework will just ignore this class instead of printing a warning message.","title":"Behaviour Objects"},{"location":"aea/api/skills/base/#act","text":"| @abstractmethod | act () -> None Implement the behaviour. Returns : None","title":"act"},{"location":"aea/api/skills/base/#is_done","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/base/#act_wrapper","text":"| act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"aea/api/skills/base/#parse_module_1","text":"| @classmethod | parse_module ( cls , path : str , behaviour_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Behaviour\" ] Parse the behaviours module. Arguments : path : path to the Python module containing the Behaviour classes. behaviour_configs : a list of behaviour configurations. skill_context : the skill context Returns : a list of Behaviour.","title":"parse_module"},{"location":"aea/api/skills/base/#handler-objects","text":"class Handler ( SkillComponent , ABC ) This class implements an abstract behaviour. In a subclass of Handler, the flag 'is_programmatically_defined' can be used by the developer to signal to the framework that the component is meant to be used programmatically; hence, in case the class is not declared in the configuration file but it is present in a skill module, the framework will just ignore this class instead of printing a warning message. SUPPORTED_PROTOCOL is read by the framework when the handlers are loaded to register them as 'listeners' to the protocol identified by the specified public id. Whenever a message of protocol 'SUPPORTED_PROTOCOL' is sent to the agent, the framework will call the 'handle' method.","title":"Handler Objects"},{"location":"aea/api/skills/base/#handle","text":"| @abstractmethod | handle ( message : Message ) -> None Implement the reaction to a message. Arguments : message : the message Returns : None","title":"handle"},{"location":"aea/api/skills/base/#handle_wrapper","text":"| handle_wrapper ( message : Message ) -> None Wrap the call of the handler. This method must be called only by the framework.","title":"handle_wrapper"},{"location":"aea/api/skills/base/#parse_module_2","text":"| @classmethod | parse_module ( cls , path : str , handler_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Handler\" ] Parse the handler module. Arguments : path : path to the Python module containing the Handler class. handler_configs : the list of handler configurations. skill_context : the skill context Returns : an handler, or None if the parsing fails.","title":"parse_module"},{"location":"aea/api/skills/base/#model-objects","text":"class Model ( SkillComponent , ABC ) This class implements an abstract model.","title":"Model Objects"},{"location":"aea/api/skills/base/#__init___2","text":"| __init__ ( name : str , skill_context : SkillContext , configuration : Optional [ SkillComponentConfiguration ] = None , keep_terminal_state_dialogues : Optional [ bool ] = None , ** kwargs : Any , ,) -> None Initialize a model. Arguments : name : the name of the component. configuration : the configuration for the component. skill_context : the skill context. keep_terminal_state_dialogues : specify do dialogues in terminal state should stay or not kwargs : the keyword arguments.","title":"__init__"},{"location":"aea/api/skills/base/#setup_1","text":"| setup () -> None Set the class up.","title":"setup"},{"location":"aea/api/skills/base/#teardown_1","text":"| teardown () -> None Tear the class down.","title":"teardown"},{"location":"aea/api/skills/base/#parse_module_3","text":"| @classmethod | parse_module ( cls , path : str , model_configs : Dict [ str , SkillComponentConfiguration ], skill_context : SkillContext ) -> Dict [ str , \"Model\" ] Parse the model module. Arguments : path : path to the Python skill module. model_configs : a list of model configurations. skill_context : the skill context Returns : a list of Model.","title":"parse_module"},{"location":"aea/api/skills/base/#skill-objects","text":"class Skill ( Component ) This class implements a skill.","title":"Skill Objects"},{"location":"aea/api/skills/base/#__init___3","text":"| __init__ ( configuration : SkillConfig , skill_context : Optional [ SkillContext ] = None , handlers : Optional [ Dict [ str , Handler ]] = None , behaviours : Optional [ Dict [ str , Behaviour ]] = None , models : Optional [ Dict [ str , Model ]] = None , ** kwargs : Any , ,) Initialize a skill. Arguments : configuration : the skill configuration. skill_context : the skill context. handlers : dictionary of handlers. behaviours : dictionary of behaviours. models : dictionary of models. kwargs : the keyword arguments.","title":"__init__"},{"location":"aea/api/skills/base/#skill_context","text":"| @property | skill_context () -> SkillContext Get the skill context.","title":"skill_context"},{"location":"aea/api/skills/base/#handlers_1","text":"| @property | handlers () -> Dict [ str , Handler ] Get the handlers.","title":"handlers"},{"location":"aea/api/skills/base/#behaviours_1","text":"| @property | behaviours () -> Dict [ str , Behaviour ] Get the handlers.","title":"behaviours"},{"location":"aea/api/skills/base/#models","text":"| @property | models () -> Dict [ str , Model ] Get the handlers.","title":"models"},{"location":"aea/api/skills/base/#from_dir","text":"| @classmethod | from_dir ( cls , directory : str , agent_context : AgentContext , ** kwargs : Any ) -> \"Skill\" Load the skill from a directory. Arguments : directory : the directory to the skill package. agent_context : the skill context. kwargs : the keyword arguments. Returns : the skill object.","title":"from_dir"},{"location":"aea/api/skills/base/#logger_2","text":"| @property | logger () -> Logger Get the logger. In the case of a skill, return the logger provided by the skill context. Returns : the logger","title":"logger"},{"location":"aea/api/skills/base/#logger_3","text":"| @logger . setter | logger ( * args : str ) -> None Set the logger.","title":"logger"},{"location":"aea/api/skills/base/#from_config","text":"| @classmethod | from_config ( cls , configuration : SkillConfig , agent_context : AgentContext , ** kwargs : Any ) -> \"Skill\" Load the skill from configuration. Arguments : configuration : a skill configuration. Must be associated with a directory. agent_context : the agent context. kwargs : the keyword arguments. Returns : the skill.","title":"from_config"},{"location":"aea/api/skills/base/#_skillcomponentloadingitem-objects","text":"class _SkillComponentLoadingItem () Class to represent a triple (component name, component configuration, component class).","title":"_SkillComponentLoadingItem Objects"},{"location":"aea/api/skills/base/#__init___4","text":"| __init__ ( name : str , config : SkillComponentConfiguration , class_ : Type [ SkillComponent ], type_ : _SKILL_COMPONENT_TYPES ) Initialize the item.","title":"__init__"},{"location":"aea/api/skills/base/#_skillcomponentloader-objects","text":"class _SkillComponentLoader () This class implements the loading policy for skill components.","title":"_SkillComponentLoader Objects"},{"location":"aea/api/skills/base/#__init___5","text":"| __init__ ( configuration : SkillConfig , skill_context : SkillContext , ** kwargs : Any ) Initialize the helper class.","title":"__init__"},{"location":"aea/api/skills/base/#load_skill","text":"| load_skill () -> Skill Load the skill.","title":"load_skill"},{"location":"aea/api/skills/behaviours/","text":"aea.skills.behaviours This module contains the classes for specific behaviours. SimpleBehaviour Objects class SimpleBehaviour ( Behaviour , ABC ) This class implements a simple behaviour. __ init __ | __init__ ( act : Optional [ Callable [[], None ]] = None , ** kwargs : Any ) -> None Initialize a simple behaviour. Arguments : act : the act callable. kwargs : the keyword arguments to be passed to the parent class. setup | setup () -> None Set the behaviour up. act | act () -> None Do the action. teardown | teardown () -> None Tear the behaviour down. CompositeBehaviour Objects class CompositeBehaviour ( Behaviour , ABC ) This class implements a composite behaviour. CyclicBehaviour Objects class CyclicBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed until the agent is stopped. __ init __ | __init__ ( ** kwargs : Any ) -> None Initialize the cyclic behaviour. number _ of _ executions | @property | number_of_executions () -> int Get the number of executions. act _ wrapper | act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. The user should implement it properly to determine the stopping condition. Returns : bool indicating status OneShotBehaviour Objects class OneShotBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed only once. __ init __ | __init__ ( ** kwargs : Any ) -> None Initialize the cyclic behaviour. is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. act _ wrapper | act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. TickerBehaviour Objects class TickerBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed periodically with an interval. __ init __ | __init__ ( tick_interval : float = 1.0 , start_at : Optional [ datetime . datetime ] = None , ** kwargs : Any ) -> None Initialize the ticker behaviour. Arguments : tick_interval : interval of the behaviour in seconds. start_at : whether to start the behaviour with an offset. kwargs : the keyword arguments. tick _ interval | @property | tick_interval () -> float Get the tick_interval in seconds. start _ at | @property | start_at () -> datetime . datetime Get the start time. last _ act _ time | @property | last_act_time () -> datetime . datetime Get the last time the act method has been called. act _ wrapper | act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework. is _ time _ to _ act | is_time_to_act () -> bool Check whether it is time to act, according to the tick_interval constraint and the 'start at' constraint. Returns : True if it is time to act, false otherwise. SequenceBehaviour Objects class SequenceBehaviour ( CompositeBehaviour , ABC ) This behaviour executes sub-behaviour serially. __ init __ | __init__ ( behaviour_sequence : List [ Behaviour ], ** kwargs : Any ) -> None Initialize the sequence behaviour. Arguments : behaviour_sequence : the sequence of behaviour. kwargs : the keyword arguments current _ behaviour | @property | current_behaviour () -> Optional [ Behaviour ] Get the current behaviour. If None, the sequence behaviour can be considered done. Returns : current behaviour or None act | act () -> None Implement the behaviour. is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. State Objects class State ( SimpleBehaviour , ABC ) A state of a FSMBehaviour. A State behaviour is a simple behaviour with a special property 'event' that is opportunely set by the implementer. The event is read by the framework when the behaviour is done in order to pick the transition to trigger. __ init __ | __init__ ( ** kwargs : Any ) -> None Initialize a state of the state machine. event | @property | event () -> Optional [ str ] Get the event to be triggered at the end of the behaviour. is _ done | @abstractmethod | is_done () -> bool Return True if the behaviour is terminated, False otherwise. reset | reset () -> None Reset initial conditions. FSMBehaviour Objects class FSMBehaviour ( CompositeBehaviour , ABC ) This class implements a finite-state machine behaviour. __ init __ | __init__ ( ** kwargs : Any ) -> None Initialize the finite-state machine behaviour. is _ started | @property | is_started () -> bool Check if the behaviour is started. register _ state | register_state ( name : str , state : State , initial : bool = False ) -> None Register a state. Arguments : name : the name of the state. state : the behaviour in that state. initial : whether the state is an initial state. Raises : ValueError : if a state with the provided name already exists. register _ final _ state | register_final_state ( name : str , state : State ) -> None Register a final state. Arguments : name : the name of the state. state : the state. Raises : ValueError : if a state with the provided name already exists. unregister _ state | unregister_state ( name : str ) -> None Unregister a state. Arguments : name : the state name to unregister. Raises : ValueError : if the state is not registered. states | @property | states () -> Set [ str ] Get all the state names. initial _ state | @property | initial_state () -> Optional [ str ] Get the initial state name. initial _ state | @initial_state . setter | initial_state ( name : str ) -> None Set the initial state. final _ states | @property | final_states () -> Set [ str ] Get the final state names. get _ state | get_state ( name : str ) -> Optional [ State ] Get a state from its name. act | act () -> None Implement the behaviour. is _ done | is_done () -> bool Return True if the behaviour is terminated, False otherwise. register _ transition | register_transition ( source : str , destination : str , event : Optional [ str ] = None ) -> None Register a transition. No sanity check is done. Arguments : source : the source state name. destination : the destination state name. event : the event. Raises : ValueError : if a transition from source with event is already present. unregister _ transition | unregister_transition ( source : str , destination : str , event : Optional [ str ] = None ) -> None Unregister a transition. Arguments : source : the source state name. destination : the destination state name. event : the event. Raises : ValueError : if a transition from source with event is not present.","title":"Behaviors"},{"location":"aea/api/skills/behaviours/#aeaskillsbehaviours","text":"This module contains the classes for specific behaviours.","title":"aea.skills.behaviours"},{"location":"aea/api/skills/behaviours/#simplebehaviour-objects","text":"class SimpleBehaviour ( Behaviour , ABC ) This class implements a simple behaviour.","title":"SimpleBehaviour Objects"},{"location":"aea/api/skills/behaviours/#__init__","text":"| __init__ ( act : Optional [ Callable [[], None ]] = None , ** kwargs : Any ) -> None Initialize a simple behaviour. Arguments : act : the act callable. kwargs : the keyword arguments to be passed to the parent class.","title":"__init__"},{"location":"aea/api/skills/behaviours/#setup","text":"| setup () -> None Set the behaviour up.","title":"setup"},{"location":"aea/api/skills/behaviours/#act","text":"| act () -> None Do the action.","title":"act"},{"location":"aea/api/skills/behaviours/#teardown","text":"| teardown () -> None Tear the behaviour down.","title":"teardown"},{"location":"aea/api/skills/behaviours/#compositebehaviour-objects","text":"class CompositeBehaviour ( Behaviour , ABC ) This class implements a composite behaviour.","title":"CompositeBehaviour Objects"},{"location":"aea/api/skills/behaviours/#cyclicbehaviour-objects","text":"class CyclicBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed until the agent is stopped.","title":"CyclicBehaviour Objects"},{"location":"aea/api/skills/behaviours/#__init___1","text":"| __init__ ( ** kwargs : Any ) -> None Initialize the cyclic behaviour.","title":"__init__"},{"location":"aea/api/skills/behaviours/#number_of_executions","text":"| @property | number_of_executions () -> int Get the number of executions.","title":"number_of_executions"},{"location":"aea/api/skills/behaviours/#act_wrapper","text":"| act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"aea/api/skills/behaviours/#is_done","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise. The user should implement it properly to determine the stopping condition. Returns : bool indicating status","title":"is_done"},{"location":"aea/api/skills/behaviours/#oneshotbehaviour-objects","text":"class OneShotBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed only once.","title":"OneShotBehaviour Objects"},{"location":"aea/api/skills/behaviours/#__init___2","text":"| __init__ ( ** kwargs : Any ) -> None Initialize the cyclic behaviour.","title":"__init__"},{"location":"aea/api/skills/behaviours/#is_done_1","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/behaviours/#act_wrapper_1","text":"| act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"aea/api/skills/behaviours/#tickerbehaviour-objects","text":"class TickerBehaviour ( SimpleBehaviour , ABC ) This behaviour is executed periodically with an interval.","title":"TickerBehaviour Objects"},{"location":"aea/api/skills/behaviours/#__init___3","text":"| __init__ ( tick_interval : float = 1.0 , start_at : Optional [ datetime . datetime ] = None , ** kwargs : Any ) -> None Initialize the ticker behaviour. Arguments : tick_interval : interval of the behaviour in seconds. start_at : whether to start the behaviour with an offset. kwargs : the keyword arguments.","title":"__init__"},{"location":"aea/api/skills/behaviours/#tick_interval","text":"| @property | tick_interval () -> float Get the tick_interval in seconds.","title":"tick_interval"},{"location":"aea/api/skills/behaviours/#start_at","text":"| @property | start_at () -> datetime . datetime Get the start time.","title":"start_at"},{"location":"aea/api/skills/behaviours/#last_act_time","text":"| @property | last_act_time () -> datetime . datetime Get the last time the act method has been called.","title":"last_act_time"},{"location":"aea/api/skills/behaviours/#act_wrapper_2","text":"| act_wrapper () -> None Wrap the call of the action. This method must be called only by the framework.","title":"act_wrapper"},{"location":"aea/api/skills/behaviours/#is_time_to_act","text":"| is_time_to_act () -> bool Check whether it is time to act, according to the tick_interval constraint and the 'start at' constraint. Returns : True if it is time to act, false otherwise.","title":"is_time_to_act"},{"location":"aea/api/skills/behaviours/#sequencebehaviour-objects","text":"class SequenceBehaviour ( CompositeBehaviour , ABC ) This behaviour executes sub-behaviour serially.","title":"SequenceBehaviour Objects"},{"location":"aea/api/skills/behaviours/#__init___4","text":"| __init__ ( behaviour_sequence : List [ Behaviour ], ** kwargs : Any ) -> None Initialize the sequence behaviour. Arguments : behaviour_sequence : the sequence of behaviour. kwargs : the keyword arguments","title":"__init__"},{"location":"aea/api/skills/behaviours/#current_behaviour","text":"| @property | current_behaviour () -> Optional [ Behaviour ] Get the current behaviour. If None, the sequence behaviour can be considered done. Returns : current behaviour or None","title":"current_behaviour"},{"location":"aea/api/skills/behaviours/#act_1","text":"| act () -> None Implement the behaviour.","title":"act"},{"location":"aea/api/skills/behaviours/#is_done_2","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/behaviours/#state-objects","text":"class State ( SimpleBehaviour , ABC ) A state of a FSMBehaviour. A State behaviour is a simple behaviour with a special property 'event' that is opportunely set by the implementer. The event is read by the framework when the behaviour is done in order to pick the transition to trigger.","title":"State Objects"},{"location":"aea/api/skills/behaviours/#__init___5","text":"| __init__ ( ** kwargs : Any ) -> None Initialize a state of the state machine.","title":"__init__"},{"location":"aea/api/skills/behaviours/#event","text":"| @property | event () -> Optional [ str ] Get the event to be triggered at the end of the behaviour.","title":"event"},{"location":"aea/api/skills/behaviours/#is_done_3","text":"| @abstractmethod | is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/behaviours/#reset","text":"| reset () -> None Reset initial conditions.","title":"reset"},{"location":"aea/api/skills/behaviours/#fsmbehaviour-objects","text":"class FSMBehaviour ( CompositeBehaviour , ABC ) This class implements a finite-state machine behaviour.","title":"FSMBehaviour Objects"},{"location":"aea/api/skills/behaviours/#__init___6","text":"| __init__ ( ** kwargs : Any ) -> None Initialize the finite-state machine behaviour.","title":"__init__"},{"location":"aea/api/skills/behaviours/#is_started","text":"| @property | is_started () -> bool Check if the behaviour is started.","title":"is_started"},{"location":"aea/api/skills/behaviours/#register_state","text":"| register_state ( name : str , state : State , initial : bool = False ) -> None Register a state. Arguments : name : the name of the state. state : the behaviour in that state. initial : whether the state is an initial state. Raises : ValueError : if a state with the provided name already exists.","title":"register_state"},{"location":"aea/api/skills/behaviours/#register_final_state","text":"| register_final_state ( name : str , state : State ) -> None Register a final state. Arguments : name : the name of the state. state : the state. Raises : ValueError : if a state with the provided name already exists.","title":"register_final_state"},{"location":"aea/api/skills/behaviours/#unregister_state","text":"| unregister_state ( name : str ) -> None Unregister a state. Arguments : name : the state name to unregister. Raises : ValueError : if the state is not registered.","title":"unregister_state"},{"location":"aea/api/skills/behaviours/#states","text":"| @property | states () -> Set [ str ] Get all the state names.","title":"states"},{"location":"aea/api/skills/behaviours/#initial_state","text":"| @property | initial_state () -> Optional [ str ] Get the initial state name.","title":"initial_state"},{"location":"aea/api/skills/behaviours/#initial_state_1","text":"| @initial_state . setter | initial_state ( name : str ) -> None Set the initial state.","title":"initial_state"},{"location":"aea/api/skills/behaviours/#final_states","text":"| @property | final_states () -> Set [ str ] Get the final state names.","title":"final_states"},{"location":"aea/api/skills/behaviours/#get_state","text":"| get_state ( name : str ) -> Optional [ State ] Get a state from its name.","title":"get_state"},{"location":"aea/api/skills/behaviours/#act_2","text":"| act () -> None Implement the behaviour.","title":"act"},{"location":"aea/api/skills/behaviours/#is_done_4","text":"| is_done () -> bool Return True if the behaviour is terminated, False otherwise.","title":"is_done"},{"location":"aea/api/skills/behaviours/#register_transition","text":"| register_transition ( source : str , destination : str , event : Optional [ str ] = None ) -> None Register a transition. No sanity check is done. Arguments : source : the source state name. destination : the destination state name. event : the event. Raises : ValueError : if a transition from source with event is already present.","title":"register_transition"},{"location":"aea/api/skills/behaviours/#unregister_transition","text":"| unregister_transition ( source : str , destination : str , event : Optional [ str ] = None ) -> None Unregister a transition. Arguments : source : the source state name. destination : the destination state name. event : the event. Raises : ValueError : if a transition from source with event is not present.","title":"unregister_transition"},{"location":"aea/api/skills/tasks/","text":"aea.skills.tasks This module contains the classes for tasks. Task Objects class Task ( WithLogger ) This class implements an abstract task. __ init __ | __init__ ( ** kwargs : Any ) -> None Initialize a task. __ call __ | __call__ ( * args : Any , ** kwargs : Any ) -> Any Execute the task. Arguments : args : positional arguments forwarded to the 'execute' method. kwargs : keyword arguments forwarded to the 'execute' method. Returns : the task instance Raises : ValueError : if the task has already been executed. is _ executed | @property | is_executed () -> bool Check if the task has already been executed. result | @property | result () -> Any Get the result. Returns : the result from the execute method. Raises : ValueError : if the task has not been executed yet. setup | setup () -> None Implement the task setup. execute | @abstractmethod | execute ( * args : Any , ** kwargs : Any ) -> Any Run the task logic. Arguments : args : the positional arguments kwargs : the keyword arguments Returns : any teardown | teardown () -> None Implement the task teardown. init _ worker init_worker () -> None Initialize a worker. Disable the SIGINT handler of process pool is using. Related to a well-known bug: https://bugs.python.org/issue8296 TaskManager Objects class TaskManager ( WithLogger ) A Task manager. __ init __ | __init__ ( nb_workers : int = DEFAULT_WORKERS_AMOUNT , is_lazy_pool_start : bool = True , logger : Optional [ logging . Logger ] = None , pool_mode : str = THREAD_POOL_MODE ) -> None Initialize the task manager. Arguments : nb_workers : the number of worker processes. is_lazy_pool_start : option to postpone pool creation till the first enqueue_task called. logger : the logger. pool_mode : str. multithread or multiprocess is _ started | @property | is_started () -> bool Get started status of TaskManager. Returns : bool nb _ workers | @property | nb_workers () -> int Get the number of workers. Returns : int enqueue _ task | enqueue_task ( func : Callable , args : Sequence = (), kwargs : Optional [ Dict [ str , Any ]] = None ) -> int Enqueue a task with the executor. Arguments : func : the callable instance to be enqueued args : the positional arguments to be passed to the function. kwargs : the keyword arguments to be passed to the function. Returns : the task id to get the the result. Raises : ValueError : if the task manager is not running. get _ task _ result | get_task_result ( task_id : int ) -> AsyncResult Get the result from a task. Arguments : task_id : the task id Returns : async result for task_id start | start () -> None Start the task manager. stop | stop () -> None Stop the task manager. ThreadedTaskManager Objects class ThreadedTaskManager ( TaskManager ) A threaded task manager. __ init __ | __init__ ( nb_workers : int = DEFAULT_WORKERS_AMOUNT , is_lazy_pool_start : bool = True , logger : Optional [ logging . Logger ] = None ) -> None Initialize the task manager. Arguments : nb_workers : the number of worker processes. is_lazy_pool_start : option to postpone pool creation till the first enqueue_task called. logger : the logger. ProcessTaskManager Objects class ProcessTaskManager ( TaskManager ) A multiprocess task manager. __ init __ | __init__ ( nb_workers : int = DEFAULT_WORKERS_AMOUNT , is_lazy_pool_start : bool = True , logger : Optional [ logging . Logger ] = None ) -> None Initialize the task manager. Arguments : nb_workers : the number of worker processes. is_lazy_pool_start : option to postpone pool creation till the first enqueue_task called. logger : the logger.","title":"Task"},{"location":"aea/api/skills/tasks/#aeaskillstasks","text":"This module contains the classes for tasks.","title":"aea.skills.tasks"},{"location":"aea/api/skills/tasks/#task-objects","text":"class Task ( WithLogger ) This class implements an abstract task.","title":"Task Objects"},{"location":"aea/api/skills/tasks/#__init__","text":"| __init__ ( ** kwargs : Any ) -> None Initialize a task.","title":"__init__"},{"location":"aea/api/skills/tasks/#__call__","text":"| __call__ ( * args : Any , ** kwargs : Any ) -> Any Execute the task. Arguments : args : positional arguments forwarded to the 'execute' method. kwargs : keyword arguments forwarded to the 'execute' method. Returns : the task instance Raises : ValueError : if the task has already been executed.","title":"__call__"},{"location":"aea/api/skills/tasks/#is_executed","text":"| @property | is_executed () -> bool Check if the task has already been executed.","title":"is_executed"},{"location":"aea/api/skills/tasks/#result","text":"| @property | result () -> Any Get the result. Returns : the result from the execute method. Raises : ValueError : if the task has not been executed yet.","title":"result"},{"location":"aea/api/skills/tasks/#setup","text":"| setup () -> None Implement the task setup.","title":"setup"},{"location":"aea/api/skills/tasks/#execute","text":"| @abstractmethod | execute ( * args : Any , ** kwargs : Any ) -> Any Run the task logic. Arguments : args : the positional arguments kwargs : the keyword arguments Returns : any","title":"execute"},{"location":"aea/api/skills/tasks/#teardown","text":"| teardown () -> None Implement the task teardown.","title":"teardown"},{"location":"aea/api/skills/tasks/#init_worker","text":"init_worker () -> None Initialize a worker. Disable the SIGINT handler of process pool is using. Related to a well-known bug: https://bugs.python.org/issue8296","title":"init_worker"},{"location":"aea/api/skills/tasks/#taskmanager-objects","text":"class TaskManager ( WithLogger ) A Task manager.","title":"TaskManager Objects"},{"location":"aea/api/skills/tasks/#__init___1","text":"| __init__ ( nb_workers : int = DEFAULT_WORKERS_AMOUNT , is_lazy_pool_start : bool = True , logger : Optional [ logging . Logger ] = None , pool_mode : str = THREAD_POOL_MODE ) -> None Initialize the task manager. Arguments : nb_workers : the number of worker processes. is_lazy_pool_start : option to postpone pool creation till the first enqueue_task called. logger : the logger. pool_mode : str. multithread or multiprocess","title":"__init__"},{"location":"aea/api/skills/tasks/#is_started","text":"| @property | is_started () -> bool Get started status of TaskManager. Returns : bool","title":"is_started"},{"location":"aea/api/skills/tasks/#nb_workers","text":"| @property | nb_workers () -> int Get the number of workers. Returns : int","title":"nb_workers"},{"location":"aea/api/skills/tasks/#enqueue_task","text":"| enqueue_task ( func : Callable , args : Sequence = (), kwargs : Optional [ Dict [ str , Any ]] = None ) -> int Enqueue a task with the executor. Arguments : func : the callable instance to be enqueued args : the positional arguments to be passed to the function. kwargs : the keyword arguments to be passed to the function. Returns : the task id to get the the result. Raises : ValueError : if the task manager is not running.","title":"enqueue_task"},{"location":"aea/api/skills/tasks/#get_task_result","text":"| get_task_result ( task_id : int ) -> AsyncResult Get the result from a task. Arguments : task_id : the task id Returns : async result for task_id","title":"get_task_result"},{"location":"aea/api/skills/tasks/#start","text":"| start () -> None Start the task manager.","title":"start"},{"location":"aea/api/skills/tasks/#stop","text":"| stop () -> None Stop the task manager.","title":"stop"},{"location":"aea/api/skills/tasks/#threadedtaskmanager-objects","text":"class ThreadedTaskManager ( TaskManager ) A threaded task manager.","title":"ThreadedTaskManager Objects"},{"location":"aea/api/skills/tasks/#__init___2","text":"| __init__ ( nb_workers : int = DEFAULT_WORKERS_AMOUNT , is_lazy_pool_start : bool = True , logger : Optional [ logging . Logger ] = None ) -> None Initialize the task manager. Arguments : nb_workers : the number of worker processes. is_lazy_pool_start : option to postpone pool creation till the first enqueue_task called. logger : the logger.","title":"__init__"},{"location":"aea/api/skills/tasks/#processtaskmanager-objects","text":"class ProcessTaskManager ( TaskManager ) A multiprocess task manager.","title":"ProcessTaskManager Objects"},{"location":"aea/api/skills/tasks/#__init___3","text":"| __init__ ( nb_workers : int = DEFAULT_WORKERS_AMOUNT , is_lazy_pool_start : bool = True , logger : Optional [ logging . Logger ] = None ) -> None Initialize the task manager. Arguments : nb_workers : the number of worker processes. is_lazy_pool_start : option to postpone pool creation till the first enqueue_task called. logger : the logger.","title":"__init__"},{"location":"aea/api/test_tools/constants/","text":"aea.test _ tools.constants This is a module with constants for test tools.","title":"Constants"},{"location":"aea/api/test_tools/constants/#aeatest_toolsconstants","text":"This is a module with constants for test tools.","title":"aea.test_tools.constants"},{"location":"aea/api/test_tools/exceptions/","text":"aea.test _ tools.exceptions Module with AEA testing exceptions. AEATestingException Objects class AEATestingException ( Exception ) An exception to be raised on incorrect testing tools usage.","title":"Exceptions"},{"location":"aea/api/test_tools/exceptions/#aeatest_toolsexceptions","text":"Module with AEA testing exceptions.","title":"aea.test_tools.exceptions"},{"location":"aea/api/test_tools/exceptions/#aeatestingexception-objects","text":"class AEATestingException ( Exception ) An exception to be raised on incorrect testing tools usage.","title":"AEATestingException Objects"},{"location":"aea/api/test_tools/generic/","text":"aea.test _ tools.generic This module contains generic tools for AEA end-to-end testing. write _ envelope _ to _ file write_envelope_to_file ( envelope : Envelope , file_path : str ) -> None Write an envelope to a file. Arguments : envelope : Envelope. file_path : the file path read _ envelope _ from _ file read_envelope_from_file ( file_path : str ) -> Envelope Read an envelope from a file. Arguments : file_path : the file path. Returns : envelope nested _ set _ config nested_set_config ( dotted_path : str , value : Any , author : str = DEFAULT_AUTHOR ) -> None Set an AEA config with nested values. Run from agent's directory. Allowed dotted_path: 'agent.an_attribute_name' 'protocols.my_protocol.an_attribute_name' 'connections.my_connection.an_attribute_name' 'contracts.my_contract.an_attribute_name' 'skills.my_skill.an_attribute_name' 'vendor.author.[protocols|connections|skills].package_name.attribute_name Arguments : dotted_path : dotted path to a setting. value : a value to assign. Must be of yaml serializable type. author : the author name, used to parse the dotted path.","title":"Generic"},{"location":"aea/api/test_tools/generic/#aeatest_toolsgeneric","text":"This module contains generic tools for AEA end-to-end testing.","title":"aea.test_tools.generic"},{"location":"aea/api/test_tools/generic/#write_envelope_to_file","text":"write_envelope_to_file ( envelope : Envelope , file_path : str ) -> None Write an envelope to a file. Arguments : envelope : Envelope. file_path : the file path","title":"write_envelope_to_file"},{"location":"aea/api/test_tools/generic/#read_envelope_from_file","text":"read_envelope_from_file ( file_path : str ) -> Envelope Read an envelope from a file. Arguments : file_path : the file path. Returns : envelope","title":"read_envelope_from_file"},{"location":"aea/api/test_tools/generic/#nested_set_config","text":"nested_set_config ( dotted_path : str , value : Any , author : str = DEFAULT_AUTHOR ) -> None Set an AEA config with nested values. Run from agent's directory. Allowed dotted_path: 'agent.an_attribute_name' 'protocols.my_protocol.an_attribute_name' 'connections.my_connection.an_attribute_name' 'contracts.my_contract.an_attribute_name' 'skills.my_skill.an_attribute_name' 'vendor.author.[protocols|connections|skills].package_name.attribute_name Arguments : dotted_path : dotted path to a setting. value : a value to assign. Must be of yaml serializable type. author : the author name, used to parse the dotted path.","title":"nested_set_config"},{"location":"aea/api/test_tools/test_cases/","text":"aea.test _ tools.test _ cases This module contains test case classes based on pytest for AEA end-to-end testing. BaseAEATestCase Objects class BaseAEATestCase ( ABC ) Base class for AEA test cases. set _ agent _ context | @classmethod | set_agent_context ( cls , agent_name : str ) -> None Set the current agent context. unset _ agent _ context | @classmethod | unset_agent_context ( cls ) -> None Unset the current agent context. set _ config | @classmethod | set_config ( cls , dotted_path : str , value : Any , type_ : Optional [ str ] = None ) -> Result Set a config. Run from agent's directory. Arguments : dotted_path : str dotted path to config param. value : a new value to set. type_ : the type Returns : Result nested _ set _ config | @classmethod | nested_set_config ( cls , dotted_path : str , value : Any ) -> None Force set config. disable _ aea _ logging | @classmethod | disable_aea_logging ( cls ) -> None Disable AEA logging of specific agent. Run from agent's directory. run _ cli _ command | @classmethod | run_cli_command ( cls , * args : str , * , cwd : str = \".\" , ** kwargs : str ) -> Result Run AEA CLI command. Arguments : args : CLI args cwd : the working directory from where to run the command. kwargs : other keyword arguments to click.CliRunner.invoke. Raises : AEATestingException : if command fails. Returns : Result start _ subprocess | @classmethod | start_subprocess ( cls , * args : str , * , cwd : str = \".\" ) -> subprocess . Popen Run python with args as subprocess. Arguments : args : CLI args cwd : the current working directory Returns : subprocess object. start _ thread | @classmethod | start_thread ( cls , target : Callable , ** kwargs : subprocess . Popen ) -> Thread Start python Thread. Arguments : target : target method. kwargs : thread keyword arguments Returns : thread create _ agents | @classmethod | create_agents ( cls , * agents_names : str , * , is_local : bool = True , is_empty : bool = False ) -> None Create agents in current working directory. Arguments : agents_names : str agent names. is_local : a flag for local folder add True by default. is_empty : optional boolean flag for skip adding default dependencies. fetch _ agent | @classmethod | fetch_agent ( cls , public_id : str , agent_name : str , is_local : bool = True ) -> None Create agents in current working directory. Arguments : public_id : str public id agent_name : str agent name. is_local : a flag for local folder add True by default. difference _ to _ fetched _ agent | @classmethod | difference_to_fetched_agent ( cls , public_id : str , agent_name : str ) -> List [ str ] Compare agent against the one fetched from public id. Arguments : public_id : str public id agent_name : str agent name. Returns : list of files differing in the projects delete _ agents | @classmethod | delete_agents ( cls , * agents_names : str ) -> None Delete agents in current working directory. Arguments : agents_names : str agent names. run _ agent | @classmethod | run_agent ( cls , * args : str ) -> subprocess . Popen Run agent as subprocess. Run from agent's directory. Arguments : args : CLI args Returns : subprocess object. run _ interaction | @classmethod | run_interaction ( cls ) -> subprocess . Popen Run interaction as subprocess. Run from agent's directory. Returns : subprocess object. terminate _ agents | @classmethod | terminate_agents ( cls , * subprocesses : subprocess . Popen , * , timeout : int = 20 ) -> None Terminate agent subprocesses. Run from agent's directory. Arguments : subprocesses : the subprocesses running the agents timeout : the timeout for interruption is _ successfully _ terminated | @classmethod | is_successfully_terminated ( cls , * subprocesses : subprocess . Popen ) -> bool Check if all subprocesses terminated successfully. initialize _ aea | @classmethod | initialize_aea ( cls , author : str ) -> None Initialize AEA locally with author name. add _ item | @classmethod | add_item ( cls , item_type : str , public_id : str , local : bool = True ) -> Result Add an item to the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. local : a flag for local folder add True by default. Returns : Result remove _ item | @classmethod | remove_item ( cls , item_type : str , public_id : str ) -> Result Remove an item from the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : Result scaffold _ item | @classmethod | scaffold_item ( cls , item_type : str , name : str , skip_consistency_check : bool = False ) -> Result Scaffold an item for the agent. Run from agent's directory. Arguments : item_type : str item type. name : name of the item. skip_consistency_check : if True, skip consistency check. Returns : Result fingerprint _ item | @classmethod | fingerprint_item ( cls , item_type : str , public_id : str ) -> Result Fingerprint an item for the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : Result eject _ item | @classmethod | eject_item ( cls , item_type : str , public_id : str ) -> Result Eject an item in the agent in quiet mode (i.e. no interaction). Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : None run _ install | @classmethod | run_install ( cls ) -> Result Execute AEA CLI install command. Run from agent's directory. Returns : Result generate _ private _ key | @classmethod | generate_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , private_key_file : Optional [ str ] = None , password : Optional [ str ] = None ) -> Result Generate AEA private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. private_key_file : the private key file. password : the password. Returns : Result add _ private _ key | @classmethod | add_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , private_key_filepath : str = DEFAULT_PRIVATE_KEY_FILE , connection : bool = False , password : Optional [ str ] = None ) -> Result Add private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. private_key_filepath : private key filepath. connection : whether or not the private key filepath is for a connection. password : the password to encrypt private keys. Returns : Result remove _ private _ key | @classmethod | remove_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , connection : bool = False ) -> Result Remove private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. connection : whether or not the private key filepath is for a connection. Returns : Result replace _ private _ key _ in _ file | @classmethod | replace_private_key_in_file ( cls , private_key : str , private_key_filepath : str = DEFAULT_PRIVATE_KEY_FILE ) -> None Replace the private key in the provided file with the provided key. Arguments : private_key : the private key private_key_filepath : the filepath to the private key file :raises: exception if file does not exist generate _ wealth | @classmethod | generate_wealth ( cls , ledger_api_id : str = DEFAULT_LEDGER , password : Optional [ str ] = None ) -> Result Generate wealth with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. password : the password. Returns : Result get _ wealth | @classmethod | get_wealth ( cls , ledger_api_id : str = DEFAULT_LEDGER , password : Optional [ str ] = None ) -> str Get wealth with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. password : the password to encrypt/decrypt private keys. Returns : command line output get _ address | @classmethod | get_address ( cls , ledger_api_id : str = DEFAULT_LEDGER , password : Optional [ str ] = None ) -> str Get address with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. password : the password to encrypt/decrypt private keys. Returns : command line output replace _ file _ content | @classmethod | replace_file_content ( cls , src : Path , dest : Path ) -> None Replace the content of the source file to the destination file. Arguments : src : the source file. dest : the destination file. change _ directory | @classmethod | change_directory ( cls , path : Path ) -> None Change current working directory. Arguments : path : path to the new working directory. send _ envelope _ to _ agent | @classmethod | send_envelope_to_agent ( cls , envelope : Envelope , agent : str ) -> None Send an envelope to an agent, using the stub connection. read _ envelope _ from _ agent | @classmethod | read_envelope_from_agent ( cls , agent : str ) -> Envelope Read an envelope from an agent, using the stub connection. missing _ from _ output | @classmethod | missing_from_output ( cls , process : subprocess . Popen , strings : Sequence [ str ], timeout : int = DEFAULT_PROCESS_TIMEOUT , period : int = 1 , is_terminating : bool = True ) -> List [ str ] Check if strings are present in process output. Read process stdout in thread and terminate when all strings are present or timeout expired. Arguments : process : agent subprocess. strings : tuple of strings expected to appear in output. timeout : int amount of seconds before stopping check. period : int period of checking. is_terminating : whether or not the agents are terminated Returns : list of missed strings. is _ running | @classmethod | is_running ( cls , process : subprocess . Popen , timeout : int = DEFAULT_LAUNCH_TIMEOUT ) -> bool Check if the AEA is launched and running (ready to process messages). Arguments : process : agent subprocess. timeout : the timeout to wait for launch to complete Returns : bool indicating status invoke | @classmethod | invoke ( cls , * args : str ) -> Result Call the cli command. load _ agent _ config | @classmethod | load_agent_config ( cls , agent_name : str ) -> AgentConfig Load agent configuration. setup _ class | @classmethod | setup_class ( cls ) -> None Set up the test class. teardown _ class | @classmethod | teardown_class ( cls ) -> None Teardown the test. AEATestCaseEmpty Objects class AEATestCaseEmpty ( BaseAEATestCase ) Test case for a default AEA project. This test case will create a default AEA project. setup _ class | @classmethod | setup_class ( cls ) -> None Set up the test class. teardown _ class | @classmethod | teardown_class ( cls ) -> None Teardown the test class. AEATestCaseEmptyFlaky Objects class AEATestCaseEmptyFlaky ( AEATestCaseEmpty ) Test case for a default AEA project. This test case will create a default AEA project. Use for flaky tests with the flaky decorator. setup _ class | @classmethod | setup_class ( cls ) -> None Set up the test class. teardown _ class | @classmethod | teardown_class ( cls ) -> None Teardown the test class. AEATestCaseMany Objects class AEATestCaseMany ( BaseAEATestCase ) Test case for many AEA projects. setup _ class | @classmethod | setup_class ( cls ) -> None Set up the test class. teardown _ class | @classmethod | teardown_class ( cls ) -> None Teardown the test class. AEATestCaseManyFlaky Objects class AEATestCaseManyFlaky ( AEATestCaseMany ) Test case for many AEA projects which are flaky. Use for flaky tests with the flaky decorator. setup _ class | @classmethod | setup_class ( cls ) -> None Set up the test class. teardown _ class | @classmethod | teardown_class ( cls ) -> None Teardown the test class. AEATestCase Objects class AEATestCase ( BaseAEATestCase ) Test case from an existing AEA project. Subclass this class and set path_to_aea properly. By default, it is assumed the project is inside the current working directory. setup _ class | @classmethod | setup_class ( cls ) -> None Set up the test class. teardown _ class | @classmethod | teardown_class ( cls ) -> None Teardown the test class.","title":"Test Cases"},{"location":"aea/api/test_tools/test_cases/#aeatest_toolstest_cases","text":"This module contains test case classes based on pytest for AEA end-to-end testing.","title":"aea.test_tools.test_cases"},{"location":"aea/api/test_tools/test_cases/#baseaeatestcase-objects","text":"class BaseAEATestCase ( ABC ) Base class for AEA test cases.","title":"BaseAEATestCase Objects"},{"location":"aea/api/test_tools/test_cases/#set_agent_context","text":"| @classmethod | set_agent_context ( cls , agent_name : str ) -> None Set the current agent context.","title":"set_agent_context"},{"location":"aea/api/test_tools/test_cases/#unset_agent_context","text":"| @classmethod | unset_agent_context ( cls ) -> None Unset the current agent context.","title":"unset_agent_context"},{"location":"aea/api/test_tools/test_cases/#set_config","text":"| @classmethod | set_config ( cls , dotted_path : str , value : Any , type_ : Optional [ str ] = None ) -> Result Set a config. Run from agent's directory. Arguments : dotted_path : str dotted path to config param. value : a new value to set. type_ : the type Returns : Result","title":"set_config"},{"location":"aea/api/test_tools/test_cases/#nested_set_config","text":"| @classmethod | nested_set_config ( cls , dotted_path : str , value : Any ) -> None Force set config.","title":"nested_set_config"},{"location":"aea/api/test_tools/test_cases/#disable_aea_logging","text":"| @classmethod | disable_aea_logging ( cls ) -> None Disable AEA logging of specific agent. Run from agent's directory.","title":"disable_aea_logging"},{"location":"aea/api/test_tools/test_cases/#run_cli_command","text":"| @classmethod | run_cli_command ( cls , * args : str , * , cwd : str = \".\" , ** kwargs : str ) -> Result Run AEA CLI command. Arguments : args : CLI args cwd : the working directory from where to run the command. kwargs : other keyword arguments to click.CliRunner.invoke. Raises : AEATestingException : if command fails. Returns : Result","title":"run_cli_command"},{"location":"aea/api/test_tools/test_cases/#start_subprocess","text":"| @classmethod | start_subprocess ( cls , * args : str , * , cwd : str = \".\" ) -> subprocess . Popen Run python with args as subprocess. Arguments : args : CLI args cwd : the current working directory Returns : subprocess object.","title":"start_subprocess"},{"location":"aea/api/test_tools/test_cases/#start_thread","text":"| @classmethod | start_thread ( cls , target : Callable , ** kwargs : subprocess . Popen ) -> Thread Start python Thread. Arguments : target : target method. kwargs : thread keyword arguments Returns : thread","title":"start_thread"},{"location":"aea/api/test_tools/test_cases/#create_agents","text":"| @classmethod | create_agents ( cls , * agents_names : str , * , is_local : bool = True , is_empty : bool = False ) -> None Create agents in current working directory. Arguments : agents_names : str agent names. is_local : a flag for local folder add True by default. is_empty : optional boolean flag for skip adding default dependencies.","title":"create_agents"},{"location":"aea/api/test_tools/test_cases/#fetch_agent","text":"| @classmethod | fetch_agent ( cls , public_id : str , agent_name : str , is_local : bool = True ) -> None Create agents in current working directory. Arguments : public_id : str public id agent_name : str agent name. is_local : a flag for local folder add True by default.","title":"fetch_agent"},{"location":"aea/api/test_tools/test_cases/#difference_to_fetched_agent","text":"| @classmethod | difference_to_fetched_agent ( cls , public_id : str , agent_name : str ) -> List [ str ] Compare agent against the one fetched from public id. Arguments : public_id : str public id agent_name : str agent name. Returns : list of files differing in the projects","title":"difference_to_fetched_agent"},{"location":"aea/api/test_tools/test_cases/#delete_agents","text":"| @classmethod | delete_agents ( cls , * agents_names : str ) -> None Delete agents in current working directory. Arguments : agents_names : str agent names.","title":"delete_agents"},{"location":"aea/api/test_tools/test_cases/#run_agent","text":"| @classmethod | run_agent ( cls , * args : str ) -> subprocess . Popen Run agent as subprocess. Run from agent's directory. Arguments : args : CLI args Returns : subprocess object.","title":"run_agent"},{"location":"aea/api/test_tools/test_cases/#run_interaction","text":"| @classmethod | run_interaction ( cls ) -> subprocess . Popen Run interaction as subprocess. Run from agent's directory. Returns : subprocess object.","title":"run_interaction"},{"location":"aea/api/test_tools/test_cases/#terminate_agents","text":"| @classmethod | terminate_agents ( cls , * subprocesses : subprocess . Popen , * , timeout : int = 20 ) -> None Terminate agent subprocesses. Run from agent's directory. Arguments : subprocesses : the subprocesses running the agents timeout : the timeout for interruption","title":"terminate_agents"},{"location":"aea/api/test_tools/test_cases/#is_successfully_terminated","text":"| @classmethod | is_successfully_terminated ( cls , * subprocesses : subprocess . Popen ) -> bool Check if all subprocesses terminated successfully.","title":"is_successfully_terminated"},{"location":"aea/api/test_tools/test_cases/#initialize_aea","text":"| @classmethod | initialize_aea ( cls , author : str ) -> None Initialize AEA locally with author name.","title":"initialize_aea"},{"location":"aea/api/test_tools/test_cases/#add_item","text":"| @classmethod | add_item ( cls , item_type : str , public_id : str , local : bool = True ) -> Result Add an item to the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. local : a flag for local folder add True by default. Returns : Result","title":"add_item"},{"location":"aea/api/test_tools/test_cases/#remove_item","text":"| @classmethod | remove_item ( cls , item_type : str , public_id : str ) -> Result Remove an item from the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : Result","title":"remove_item"},{"location":"aea/api/test_tools/test_cases/#scaffold_item","text":"| @classmethod | scaffold_item ( cls , item_type : str , name : str , skip_consistency_check : bool = False ) -> Result Scaffold an item for the agent. Run from agent's directory. Arguments : item_type : str item type. name : name of the item. skip_consistency_check : if True, skip consistency check. Returns : Result","title":"scaffold_item"},{"location":"aea/api/test_tools/test_cases/#fingerprint_item","text":"| @classmethod | fingerprint_item ( cls , item_type : str , public_id : str ) -> Result Fingerprint an item for the agent. Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : Result","title":"fingerprint_item"},{"location":"aea/api/test_tools/test_cases/#eject_item","text":"| @classmethod | eject_item ( cls , item_type : str , public_id : str ) -> Result Eject an item in the agent in quiet mode (i.e. no interaction). Run from agent's directory. Arguments : item_type : str item type. public_id : public id of the item. Returns : None","title":"eject_item"},{"location":"aea/api/test_tools/test_cases/#run_install","text":"| @classmethod | run_install ( cls ) -> Result Execute AEA CLI install command. Run from agent's directory. Returns : Result","title":"run_install"},{"location":"aea/api/test_tools/test_cases/#generate_private_key","text":"| @classmethod | generate_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , private_key_file : Optional [ str ] = None , password : Optional [ str ] = None ) -> Result Generate AEA private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. private_key_file : the private key file. password : the password. Returns : Result","title":"generate_private_key"},{"location":"aea/api/test_tools/test_cases/#add_private_key","text":"| @classmethod | add_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , private_key_filepath : str = DEFAULT_PRIVATE_KEY_FILE , connection : bool = False , password : Optional [ str ] = None ) -> Result Add private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. private_key_filepath : private key filepath. connection : whether or not the private key filepath is for a connection. password : the password to encrypt private keys. Returns : Result","title":"add_private_key"},{"location":"aea/api/test_tools/test_cases/#remove_private_key","text":"| @classmethod | remove_private_key ( cls , ledger_api_id : str = DEFAULT_LEDGER , connection : bool = False ) -> Result Remove private key with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. connection : whether or not the private key filepath is for a connection. Returns : Result","title":"remove_private_key"},{"location":"aea/api/test_tools/test_cases/#replace_private_key_in_file","text":"| @classmethod | replace_private_key_in_file ( cls , private_key : str , private_key_filepath : str = DEFAULT_PRIVATE_KEY_FILE ) -> None Replace the private key in the provided file with the provided key. Arguments : private_key : the private key private_key_filepath : the filepath to the private key file :raises: exception if file does not exist","title":"replace_private_key_in_file"},{"location":"aea/api/test_tools/test_cases/#generate_wealth","text":"| @classmethod | generate_wealth ( cls , ledger_api_id : str = DEFAULT_LEDGER , password : Optional [ str ] = None ) -> Result Generate wealth with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. password : the password. Returns : Result","title":"generate_wealth"},{"location":"aea/api/test_tools/test_cases/#get_wealth","text":"| @classmethod | get_wealth ( cls , ledger_api_id : str = DEFAULT_LEDGER , password : Optional [ str ] = None ) -> str Get wealth with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. password : the password to encrypt/decrypt private keys. Returns : command line output","title":"get_wealth"},{"location":"aea/api/test_tools/test_cases/#get_address","text":"| @classmethod | get_address ( cls , ledger_api_id : str = DEFAULT_LEDGER , password : Optional [ str ] = None ) -> str Get address with CLI command. Run from agent's directory. Arguments : ledger_api_id : ledger API ID. password : the password to encrypt/decrypt private keys. Returns : command line output","title":"get_address"},{"location":"aea/api/test_tools/test_cases/#replace_file_content","text":"| @classmethod | replace_file_content ( cls , src : Path , dest : Path ) -> None Replace the content of the source file to the destination file. Arguments : src : the source file. dest : the destination file.","title":"replace_file_content"},{"location":"aea/api/test_tools/test_cases/#change_directory","text":"| @classmethod | change_directory ( cls , path : Path ) -> None Change current working directory. Arguments : path : path to the new working directory.","title":"change_directory"},{"location":"aea/api/test_tools/test_cases/#send_envelope_to_agent","text":"| @classmethod | send_envelope_to_agent ( cls , envelope : Envelope , agent : str ) -> None Send an envelope to an agent, using the stub connection.","title":"send_envelope_to_agent"},{"location":"aea/api/test_tools/test_cases/#read_envelope_from_agent","text":"| @classmethod | read_envelope_from_agent ( cls , agent : str ) -> Envelope Read an envelope from an agent, using the stub connection.","title":"read_envelope_from_agent"},{"location":"aea/api/test_tools/test_cases/#missing_from_output","text":"| @classmethod | missing_from_output ( cls , process : subprocess . Popen , strings : Sequence [ str ], timeout : int = DEFAULT_PROCESS_TIMEOUT , period : int = 1 , is_terminating : bool = True ) -> List [ str ] Check if strings are present in process output. Read process stdout in thread and terminate when all strings are present or timeout expired. Arguments : process : agent subprocess. strings : tuple of strings expected to appear in output. timeout : int amount of seconds before stopping check. period : int period of checking. is_terminating : whether or not the agents are terminated Returns : list of missed strings.","title":"missing_from_output"},{"location":"aea/api/test_tools/test_cases/#is_running","text":"| @classmethod | is_running ( cls , process : subprocess . Popen , timeout : int = DEFAULT_LAUNCH_TIMEOUT ) -> bool Check if the AEA is launched and running (ready to process messages). Arguments : process : agent subprocess. timeout : the timeout to wait for launch to complete Returns : bool indicating status","title":"is_running"},{"location":"aea/api/test_tools/test_cases/#invoke","text":"| @classmethod | invoke ( cls , * args : str ) -> Result Call the cli command.","title":"invoke"},{"location":"aea/api/test_tools/test_cases/#load_agent_config","text":"| @classmethod | load_agent_config ( cls , agent_name : str ) -> AgentConfig Load agent configuration.","title":"load_agent_config"},{"location":"aea/api/test_tools/test_cases/#setup_class","text":"| @classmethod | setup_class ( cls ) -> None Set up the test class.","title":"setup_class"},{"location":"aea/api/test_tools/test_cases/#teardown_class","text":"| @classmethod | teardown_class ( cls ) -> None Teardown the test.","title":"teardown_class"},{"location":"aea/api/test_tools/test_cases/#aeatestcaseempty-objects","text":"class AEATestCaseEmpty ( BaseAEATestCase ) Test case for a default AEA project. This test case will create a default AEA project.","title":"AEATestCaseEmpty Objects"},{"location":"aea/api/test_tools/test_cases/#setup_class_1","text":"| @classmethod | setup_class ( cls ) -> None Set up the test class.","title":"setup_class"},{"location":"aea/api/test_tools/test_cases/#teardown_class_1","text":"| @classmethod | teardown_class ( cls ) -> None Teardown the test class.","title":"teardown_class"},{"location":"aea/api/test_tools/test_cases/#aeatestcaseemptyflaky-objects","text":"class AEATestCaseEmptyFlaky ( AEATestCaseEmpty ) Test case for a default AEA project. This test case will create a default AEA project. Use for flaky tests with the flaky decorator.","title":"AEATestCaseEmptyFlaky Objects"},{"location":"aea/api/test_tools/test_cases/#setup_class_2","text":"| @classmethod | setup_class ( cls ) -> None Set up the test class.","title":"setup_class"},{"location":"aea/api/test_tools/test_cases/#teardown_class_2","text":"| @classmethod | teardown_class ( cls ) -> None Teardown the test class.","title":"teardown_class"},{"location":"aea/api/test_tools/test_cases/#aeatestcasemany-objects","text":"class AEATestCaseMany ( BaseAEATestCase ) Test case for many AEA projects.","title":"AEATestCaseMany Objects"},{"location":"aea/api/test_tools/test_cases/#setup_class_3","text":"| @classmethod | setup_class ( cls ) -> None Set up the test class.","title":"setup_class"},{"location":"aea/api/test_tools/test_cases/#teardown_class_3","text":"| @classmethod | teardown_class ( cls ) -> None Teardown the test class.","title":"teardown_class"},{"location":"aea/api/test_tools/test_cases/#aeatestcasemanyflaky-objects","text":"class AEATestCaseManyFlaky ( AEATestCaseMany ) Test case for many AEA projects which are flaky. Use for flaky tests with the flaky decorator.","title":"AEATestCaseManyFlaky Objects"},{"location":"aea/api/test_tools/test_cases/#setup_class_4","text":"| @classmethod | setup_class ( cls ) -> None Set up the test class.","title":"setup_class"},{"location":"aea/api/test_tools/test_cases/#teardown_class_4","text":"| @classmethod | teardown_class ( cls ) -> None Teardown the test class.","title":"teardown_class"},{"location":"aea/api/test_tools/test_cases/#aeatestcase-objects","text":"class AEATestCase ( BaseAEATestCase ) Test case from an existing AEA project. Subclass this class and set path_to_aea properly. By default, it is assumed the project is inside the current working directory.","title":"AEATestCase Objects"},{"location":"aea/api/test_tools/test_cases/#setup_class_5","text":"| @classmethod | setup_class ( cls ) -> None Set up the test class.","title":"setup_class"},{"location":"aea/api/test_tools/test_cases/#teardown_class_5","text":"| @classmethod | teardown_class ( cls ) -> None Teardown the test class.","title":"teardown_class"},{"location":"aea/api/test_tools/test_contract/","text":"aea.test _ tools.test _ contract This module contains test case classes based on pytest for AEA contract testing. BaseContractTestCase Objects class BaseContractTestCase ( ABC ) A class to test a contract. contract | @property | contract () -> Contract Get the contract. setup | @classmethod | setup ( cls , ** kwargs : Any ) -> None Set up the contract test case. finish _ contract _ deployment | @classmethod | @abstractmethod | finish_contract_deployment ( cls ) -> str Finish deploying contract. Returns : contract address refill _ from _ faucet | @staticmethod | refill_from_faucet ( ledger_api : LedgerApi , faucet_api : FaucetApi , address : str ) -> None Refill from faucet. sign _ send _ confirm _ receipt _ multisig _ transaction | @staticmethod | sign_send_confirm_receipt_multisig_transaction ( tx : JSONLike , ledger_api : LedgerApi , cryptos : List [ Crypto ], sleep_time : float = 2.0 ) -> JSONLike Sign, send and confirm settlement of a transaction with multiple signatures. Arguments : tx : the transaction ledger_api : the ledger api cryptos : Cryptos to sign transaction with sleep_time : the time to sleep between transaction submission and receipt request Returns : The transaction receipt sign _ send _ confirm _ receipt _ transaction | @classmethod | sign_send_confirm_receipt_transaction ( cls , tx : JSONLike , ledger_api : LedgerApi , crypto : Crypto , sleep_time : float = 2.0 ) -> JSONLike Sign, send and confirm settlement of a transaction with multiple signatures. Arguments : tx : the transaction ledger_api : the ledger api crypto : Crypto to sign transaction with sleep_time : the time to sleep between transaction submission and receipt request Returns : The transaction receipt","title":"Test Contract"},{"location":"aea/api/test_tools/test_contract/#aeatest_toolstest_contract","text":"This module contains test case classes based on pytest for AEA contract testing.","title":"aea.test_tools.test_contract"},{"location":"aea/api/test_tools/test_contract/#basecontracttestcase-objects","text":"class BaseContractTestCase ( ABC ) A class to test a contract.","title":"BaseContractTestCase Objects"},{"location":"aea/api/test_tools/test_contract/#contract","text":"| @property | contract () -> Contract Get the contract.","title":"contract"},{"location":"aea/api/test_tools/test_contract/#setup","text":"| @classmethod | setup ( cls , ** kwargs : Any ) -> None Set up the contract test case.","title":"setup"},{"location":"aea/api/test_tools/test_contract/#finish_contract_deployment","text":"| @classmethod | @abstractmethod | finish_contract_deployment ( cls ) -> str Finish deploying contract. Returns : contract address","title":"finish_contract_deployment"},{"location":"aea/api/test_tools/test_contract/#refill_from_faucet","text":"| @staticmethod | refill_from_faucet ( ledger_api : LedgerApi , faucet_api : FaucetApi , address : str ) -> None Refill from faucet.","title":"refill_from_faucet"},{"location":"aea/api/test_tools/test_contract/#sign_send_confirm_receipt_multisig_transaction","text":"| @staticmethod | sign_send_confirm_receipt_multisig_transaction ( tx : JSONLike , ledger_api : LedgerApi , cryptos : List [ Crypto ], sleep_time : float = 2.0 ) -> JSONLike Sign, send and confirm settlement of a transaction with multiple signatures. Arguments : tx : the transaction ledger_api : the ledger api cryptos : Cryptos to sign transaction with sleep_time : the time to sleep between transaction submission and receipt request Returns : The transaction receipt","title":"sign_send_confirm_receipt_multisig_transaction"},{"location":"aea/api/test_tools/test_contract/#sign_send_confirm_receipt_transaction","text":"| @classmethod | sign_send_confirm_receipt_transaction ( cls , tx : JSONLike , ledger_api : LedgerApi , crypto : Crypto , sleep_time : float = 2.0 ) -> JSONLike Sign, send and confirm settlement of a transaction with multiple signatures. Arguments : tx : the transaction ledger_api : the ledger api crypto : Crypto to sign transaction with sleep_time : the time to sleep between transaction submission and receipt request Returns : The transaction receipt","title":"sign_send_confirm_receipt_transaction"},{"location":"aea/api/test_tools/test_skill/","text":"aea.test _ tools.test _ skill This module contains test case classes based on pytest for AEA skill testing. BaseSkillTestCase Objects class BaseSkillTestCase () A class to test a skill. skill | @property | skill () -> Skill Get the skill. get _ quantity _ in _ outbox | get_quantity_in_outbox () -> int Get the quantity of envelopes in the outbox. get _ message _ from _ outbox | get_message_from_outbox () -> Optional [ Message ] Get message from outbox. drop _ messages _ from _ outbox | drop_messages_from_outbox ( number : int = 1 ) -> None Dismiss the first 'number' number of message from outbox. get _ quantity _ in _ decision _ maker _ inbox | get_quantity_in_decision_maker_inbox () -> int Get the quantity of messages in the decision maker inbox. get _ message _ from _ decision _ maker _ inbox | get_message_from_decision_maker_inbox () -> Optional [ Message ] Get message from decision maker inbox. drop _ messages _ from _ decision _ maker _ inbox | drop_messages_from_decision_maker_inbox ( number : int = 1 ) -> None Dismiss the first 'number' number of message from decision maker inbox. assert _ quantity _ in _ outbox | assert_quantity_in_outbox ( expected_quantity : int ) -> None Assert the quantity of messages in the outbox. assert _ quantity _ in _ decision _ making _ queue | assert_quantity_in_decision_making_queue ( expected_quantity : int ) -> None Assert the quantity of messages in the decision maker queue. message _ has _ attributes | @staticmethod | message_has_attributes ( actual_message : Message , message_type : Type [ Message ], ** kwargs : Any , ,) -> Tuple [ bool , str ] Evaluates whether a message's attributes match the expected attributes provided. Arguments : actual_message : the actual message message_type : the expected message type kwargs : other expected message attributes Returns : boolean result of the evaluation and accompanied message build _ incoming _ message | build_incoming_message ( message_type : Type [ Message ], performative : Message . Performative , dialogue_reference : Optional [ Tuple [ str , str ]] = None , message_id : Optional [ int ] = None , target : Optional [ int ] = None , to : Optional [ Address ] = None , sender : Optional [ Address ] = None , is_agent_to_agent_messages : Optional [ bool ] = None , ** kwargs : Any , ,) -> Message Quickly create an incoming message with the provided attributes. For any attribute not provided, the corresponding default value in message is used. Arguments : message_type : the type of the message dialogue_reference : the dialogue_reference message_id : the message_id target : the target performative : the performative to : the 'to' address sender : the 'sender' address is_agent_to_agent_messages : whether the dialogue is between agents or components kwargs : other attributes Returns : the created incoming message build _ incoming _ message _ for _ skill _ dialogue | build_incoming_message_for_skill_dialogue ( dialogue : Dialogue , performative : Message . Performative , message_type : Optional [ Type [ Message ]] = None , dialogue_reference : Optional [ Tuple [ str , str ]] = None , message_id : Optional [ int ] = None , target : Optional [ int ] = None , to : Optional [ Address ] = None , sender : Optional [ Address ] = None , ** kwargs : Any , ,) -> Message Quickly create an incoming message with the provided attributes for a dialogue. For any attribute not provided, a value based on the dialogue is used. These values are shown in parentheses in the list of parameters below. NOTE: This method must be used with care. The dialogue provided is part of the skill which is being tested. Because for any unspecified attribute, a \"correct\" value is used, the test will be, by design, insured to pass on these values. Arguments : dialogue : the dialogue to which the incoming message is intended performative : the performative of the message message_type : (the message_class of the provided dialogue) the type of the message dialogue_reference : (the dialogue_reference of the provided dialogue) the dialogue reference of the message message_id : (the id of the last message in the provided dialogue + 1) the id of the message target : (the id of the last message in the provided dialogue) the target of the message to : (the agent address associated with this skill) the receiver of the message sender : (the counterparty in the provided dialogue) the sender of the message kwargs : other attributes Returns : the created incoming message prepare _ skill _ dialogue | prepare_skill_dialogue ( dialogues : Dialogues , messages : Tuple [ DialogueMessage , ... ], counterparty : Optional [ Address ] = None , is_agent_to_agent_messages : Optional [ bool ] = None ) -> Dialogue Quickly create a dialogue. The 'messages' argument is a tuple of DialogueMessages. For every DialogueMessage (performative, contents, is_incoming, target): - if 'is_incoming' is not provided: for the first message it is assumed False (outgoing), for any other message, it is the opposite of the one preceding it. - if 'target' is not provided: for the first message it is assumed 0, for any other message, it is the index of the message before it in the tuple of messages + 1. Arguments : dialogues : a dialogues class counterparty : the message_id messages : the dialogue_reference is_agent_to_agent_messages : whether the dialogue is between agents or components Returns : the created incoming message setup | @classmethod | setup ( cls , ** kwargs : Any ) -> None Set up the skill test case.","title":"Test Skill"},{"location":"aea/api/test_tools/test_skill/#aeatest_toolstest_skill","text":"This module contains test case classes based on pytest for AEA skill testing.","title":"aea.test_tools.test_skill"},{"location":"aea/api/test_tools/test_skill/#baseskilltestcase-objects","text":"class BaseSkillTestCase () A class to test a skill.","title":"BaseSkillTestCase Objects"},{"location":"aea/api/test_tools/test_skill/#skill","text":"| @property | skill () -> Skill Get the skill.","title":"skill"},{"location":"aea/api/test_tools/test_skill/#get_quantity_in_outbox","text":"| get_quantity_in_outbox () -> int Get the quantity of envelopes in the outbox.","title":"get_quantity_in_outbox"},{"location":"aea/api/test_tools/test_skill/#get_message_from_outbox","text":"| get_message_from_outbox () -> Optional [ Message ] Get message from outbox.","title":"get_message_from_outbox"},{"location":"aea/api/test_tools/test_skill/#drop_messages_from_outbox","text":"| drop_messages_from_outbox ( number : int = 1 ) -> None Dismiss the first 'number' number of message from outbox.","title":"drop_messages_from_outbox"},{"location":"aea/api/test_tools/test_skill/#get_quantity_in_decision_maker_inbox","text":"| get_quantity_in_decision_maker_inbox () -> int Get the quantity of messages in the decision maker inbox.","title":"get_quantity_in_decision_maker_inbox"},{"location":"aea/api/test_tools/test_skill/#get_message_from_decision_maker_inbox","text":"| get_message_from_decision_maker_inbox () -> Optional [ Message ] Get message from decision maker inbox.","title":"get_message_from_decision_maker_inbox"},{"location":"aea/api/test_tools/test_skill/#drop_messages_from_decision_maker_inbox","text":"| drop_messages_from_decision_maker_inbox ( number : int = 1 ) -> None Dismiss the first 'number' number of message from decision maker inbox.","title":"drop_messages_from_decision_maker_inbox"},{"location":"aea/api/test_tools/test_skill/#assert_quantity_in_outbox","text":"| assert_quantity_in_outbox ( expected_quantity : int ) -> None Assert the quantity of messages in the outbox.","title":"assert_quantity_in_outbox"},{"location":"aea/api/test_tools/test_skill/#assert_quantity_in_decision_making_queue","text":"| assert_quantity_in_decision_making_queue ( expected_quantity : int ) -> None Assert the quantity of messages in the decision maker queue.","title":"assert_quantity_in_decision_making_queue"},{"location":"aea/api/test_tools/test_skill/#message_has_attributes","text":"| @staticmethod | message_has_attributes ( actual_message : Message , message_type : Type [ Message ], ** kwargs : Any , ,) -> Tuple [ bool , str ] Evaluates whether a message's attributes match the expected attributes provided. Arguments : actual_message : the actual message message_type : the expected message type kwargs : other expected message attributes Returns : boolean result of the evaluation and accompanied message","title":"message_has_attributes"},{"location":"aea/api/test_tools/test_skill/#build_incoming_message","text":"| build_incoming_message ( message_type : Type [ Message ], performative : Message . Performative , dialogue_reference : Optional [ Tuple [ str , str ]] = None , message_id : Optional [ int ] = None , target : Optional [ int ] = None , to : Optional [ Address ] = None , sender : Optional [ Address ] = None , is_agent_to_agent_messages : Optional [ bool ] = None , ** kwargs : Any , ,) -> Message Quickly create an incoming message with the provided attributes. For any attribute not provided, the corresponding default value in message is used. Arguments : message_type : the type of the message dialogue_reference : the dialogue_reference message_id : the message_id target : the target performative : the performative to : the 'to' address sender : the 'sender' address is_agent_to_agent_messages : whether the dialogue is between agents or components kwargs : other attributes Returns : the created incoming message","title":"build_incoming_message"},{"location":"aea/api/test_tools/test_skill/#build_incoming_message_for_skill_dialogue","text":"| build_incoming_message_for_skill_dialogue ( dialogue : Dialogue , performative : Message . Performative , message_type : Optional [ Type [ Message ]] = None , dialogue_reference : Optional [ Tuple [ str , str ]] = None , message_id : Optional [ int ] = None , target : Optional [ int ] = None , to : Optional [ Address ] = None , sender : Optional [ Address ] = None , ** kwargs : Any , ,) -> Message Quickly create an incoming message with the provided attributes for a dialogue. For any attribute not provided, a value based on the dialogue is used. These values are shown in parentheses in the list of parameters below. NOTE: This method must be used with care. The dialogue provided is part of the skill which is being tested. Because for any unspecified attribute, a \"correct\" value is used, the test will be, by design, insured to pass on these values. Arguments : dialogue : the dialogue to which the incoming message is intended performative : the performative of the message message_type : (the message_class of the provided dialogue) the type of the message dialogue_reference : (the dialogue_reference of the provided dialogue) the dialogue reference of the message message_id : (the id of the last message in the provided dialogue + 1) the id of the message target : (the id of the last message in the provided dialogue) the target of the message to : (the agent address associated with this skill) the receiver of the message sender : (the counterparty in the provided dialogue) the sender of the message kwargs : other attributes Returns : the created incoming message","title":"build_incoming_message_for_skill_dialogue"},{"location":"aea/api/test_tools/test_skill/#prepare_skill_dialogue","text":"| prepare_skill_dialogue ( dialogues : Dialogues , messages : Tuple [ DialogueMessage , ... ], counterparty : Optional [ Address ] = None , is_agent_to_agent_messages : Optional [ bool ] = None ) -> Dialogue Quickly create a dialogue. The 'messages' argument is a tuple of DialogueMessages. For every DialogueMessage (performative, contents, is_incoming, target): - if 'is_incoming' is not provided: for the first message it is assumed False (outgoing), for any other message, it is the opposite of the one preceding it. - if 'target' is not provided: for the first message it is assumed 0, for any other message, it is the index of the message before it in the tuple of messages + 1. Arguments : dialogues : a dialogues class counterparty : the message_id messages : the dialogue_reference is_agent_to_agent_messages : whether the dialogue is between agents or components Returns : the created incoming message","title":"prepare_skill_dialogue"},{"location":"aea/api/test_tools/test_skill/#setup","text":"| @classmethod | setup ( cls , ** kwargs : Any ) -> None Set up the skill test case.","title":"setup"},{"location":"bounty/aea-docs-bounty/","text":"Fetch.ai is running a 1 week (19th November - 26th November 2020) documentation bounty programme for https://docs.fetch.ai/aea . The following rewards are on offer: Type of issue FET reward Cap (max # of rewards issued) Unable to run a demo as specified on a page in the demo section of the documentation (Agent Framework > Demos) 200 20 Unable to import, instantiate or run code as specified on a page in the development section of the documentation (Agent Framework > Development) 100 20 The problem must be recorded on GitHub as an issue with the label documentation . Related problems on a single page count as one issue and should be reported as such. The issue must be reproducible by a developer at Fetch.ai to qualify for rewards. Ambiguous language or spelling and grammar erros in the documentation do not qualify for a bounty but we will happily fix it if reported. If the same problem is recorded twice, only the first reported issue qualifies for rewards. Once the caps are reached, no further issues reported receive any rewards (except our gratitude for helping make the docs better for all agent BUIDLers!).","title":"Aea docs bounty"},{"location":"colearn/","text":"Welcome to the Fetch.ai Collective Learning Library Colearn is a library that enables privacy-preserving decentralized machine learning tasks on the FET network. This blockchain-mediated collective learning system enables multiple stakeholders to build a shared machine learning model without needing to rely on a central authority, and without revealing their dataset to the other stakeholders. This library is currently in development. How collective learning works A group of learners comes together, each of whom have their own datasets and want to collaborate on training a machine learning model over a set number of rounds. We refer to this as an 'experiment'. In each round of collective learning: One learner is selected to train the model and propose a new set of model weights. The other learners vote on whether the weights are an improvement. If the majority vote that the new weights are better than the old ones then the new weights are accepted by all the learners. Otherwise the new weights are discarded. The next round begins. For more information on the Collective Learning Protocol see here . Current Version We have released v.0.2.6 of the Colearn Machine Learning Interface, the first version of an interface that allows developers to define their own model architectures that can then be used in collective learning. Together with the interface we provide a simple backend for local experiments. This is a prototype backend with upcoming blockchain ledger based backends to follow. Future releases will use similar interfaces so that learners built with the current system will work on a different backend that integrates a distributed ledger and provides other improvements. The current framework will then be used mainly for model development and debugging. We invite all users to experiment with the framework, develop their own models, and provide feedback! Getting Started To use the latest stable release we recommend installing the package from PyPi To install with support for Keras and Pytorch: pip install colearn [ all ] To install with just support for Keras or Pytorch: pip install colearn [ keras ] pip install colearn [ pytorch ] For more installation options or get the latest (development) version see Installation Then run the standalone demo: python -m colearn_examples.ml_interface.run_demo For plenty of other examples see the Examples . Writing your own models We encourage users to try out the system by writing their own models. Models need to implement the collective learning interface, which provides functions for training and voting on updates. More instructions can be found in the Getting Started section.","title":"Colearn"},{"location":"colearn/#welcome-to-the-fetchai-collective-learning-library","text":"Colearn is a library that enables privacy-preserving decentralized machine learning tasks on the FET network. This blockchain-mediated collective learning system enables multiple stakeholders to build a shared machine learning model without needing to rely on a central authority, and without revealing their dataset to the other stakeholders. This library is currently in development.","title":"Welcome to the Fetch.ai Collective Learning Library"},{"location":"colearn/#how-collective-learning-works","text":"A group of learners comes together, each of whom have their own datasets and want to collaborate on training a machine learning model over a set number of rounds. We refer to this as an 'experiment'. In each round of collective learning: One learner is selected to train the model and propose a new set of model weights. The other learners vote on whether the weights are an improvement. If the majority vote that the new weights are better than the old ones then the new weights are accepted by all the learners. Otherwise the new weights are discarded. The next round begins. For more information on the Collective Learning Protocol see here .","title":"How collective learning works"},{"location":"colearn/#current-version","text":"We have released v.0.2.6 of the Colearn Machine Learning Interface, the first version of an interface that allows developers to define their own model architectures that can then be used in collective learning. Together with the interface we provide a simple backend for local experiments. This is a prototype backend with upcoming blockchain ledger based backends to follow. Future releases will use similar interfaces so that learners built with the current system will work on a different backend that integrates a distributed ledger and provides other improvements. The current framework will then be used mainly for model development and debugging. We invite all users to experiment with the framework, develop their own models, and provide feedback!","title":"Current Version"},{"location":"colearn/#getting-started","text":"To use the latest stable release we recommend installing the package from PyPi To install with support for Keras and Pytorch: pip install colearn [ all ] To install with just support for Keras or Pytorch: pip install colearn [ keras ] pip install colearn [ pytorch ] For more installation options or get the latest (development) version see Installation Then run the standalone demo: python -m colearn_examples.ml_interface.run_demo For plenty of other examples see the Examples .","title":"Getting Started"},{"location":"colearn/#writing-your-own-models","text":"We encourage users to try out the system by writing their own models. Models need to implement the collective learning interface, which provides functions for training and voting on updates. More instructions can be found in the Getting Started section.","title":"Writing your own models"},{"location":"colearn/about/","text":"How collective learning works A Colearn experiment begins when a group of entities, referred to as learners , decide on a model architecture and begin learning. Together they will train a single global model. The goal is to train a model that performs better than any of the learners can produce by training on their private data set. How Training Works Training occurs in rounds; during each round the learners attempt to improve the performance of the global shared model. To do so each round an update of the global model (for example new set of weights in a neural network) is proposed. The learners then validate the update and decide if the new model is better than the current global model. If enough learners approve the update then the global model is updated. After an update is approved or rejected a new round begins. The detailed steps of a round updating a global model M are as follows: One of the learners is selected and proposes a new updated model M' The rest of the learners validate M' If M' has better performance than M against their private data set then the learner votes to approve If not, the learner votes to reject The total votes are tallied If more than some threshold (typically 50%) of learners approve then M' becomes the new global model. If not, M continues to be the global model A new round begins. By using a decentralized ledger (a blockchain) this learning process can be run in a completely decentralized, secure and auditable way. Further security can be provided by using differential privacy to avoid exposing your private data set when generating an update. Learning algorithms that work for collective learning Collective learning is not just for neural networks; any learning algorithm that can be trained on subsets of the data and which can use the results of previous training rounds as the basis for subsequent rounds can be used. Neural networks fit both these constraints: training can be done on mini-batches of data and each training step uses the weights of the previous training step as its starting point. More generally, any model that is trained using mini-batch stochastic gradient descent is fine. Other algorithms can be made to work with collective learning as well. For example, a random forest can be trained iteratively by having each learner add new trees (see example in mli_random_forest_iris.py ). For more discussion, see here . The driver The driver implements the voting protocol, so it handles selecting a learner to train, sending the update out for voting, calculating the vote and accepting or declining the update. Here we have a very minimal driver that doesn't use networking or a blockchain. Eventually the driver will be a smart contract. This is the code that implements one round of voting: def run_one_round ( round_index : int , learners : Sequence [ MachineLearningInterface ], vote_threshold = 0.5 ): proposer = round_index % len ( learners ) new_weights = learners [ proposer ] . mli_propose_weights () prop_weights_list = [ ln . mli_test_weights ( new_weights ) for ln in learners ] approves = sum ( 1 if v . vote else 0 for v in prop_weights_list ) vote = False if approves >= len ( learners ) * vote_threshold : vote = True for j , learner in enumerate ( learners ): learner . mli_accept_weights ( prop_weights_list [ j ]) return prop_weights_list , vote The driver has a list of learners, and each round it selects one learner to be the proposer. The proposer does some training and proposes an updated set of weights. The driver then sends the proposed weights to each of the learners, and they each vote on whether this is an improvement. If the number of approving votes is greater than the vote threshold the proposed weights are accepted, and if not they're rejected. The Machine Learning Interface # ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ import abc from typing import Any from pydantic import BaseModel class Weights ( BaseModel ): weights : Any class ProposedWeights ( BaseModel ): weights : Weights vote_score : float test_score : float vote : bool class MachineLearningInterface ( abc . ABC ): @abc . abstractmethod def mli_propose_weights ( self ) -> Weights : \"\"\" Trains the model. Returns new weights. Does not change the current weights of the model. \"\"\" pass @abc . abstractmethod def mli_test_weights ( self , weights : Weights ) -> ProposedWeights : \"\"\" Tests the proposed weights and fills in the rest of the fields \"\"\" @abc . abstractmethod def mli_accept_weights ( self , weights : Weights ): \"\"\" Updates the model with the proposed set of weights :param weights: The new weights \"\"\" pass @abc . abstractmethod def mli_get_current_weights ( self ) -> Weights : \"\"\" Returns the current weights of the model \"\"\" pass There are four methods that need to be implemented: propose_weights causes the model to do some training and then return a new set of weights that are proposed to the other learners. This method shouldn't change the current weights of the model - that only happens when accept_weights is called. test_weights - the models takes some new weights and returns a vote on whether the new weights are an improvement. As with propose_weights, this shouldn't change the current weights of the model - that only happens when accept_weights is called. accept_weights - the models accepts some weights that have been voted on and approved by the set of learners. The old weighs of the model are discarded and replaced by the new weights. current_weights should return the current weights of the model. For more details about directly implementing the machine learning interface see the tutorial here","title":"Collective Learning Protocol"},{"location":"colearn/about/#how-collective-learning-works","text":"A Colearn experiment begins when a group of entities, referred to as learners , decide on a model architecture and begin learning. Together they will train a single global model. The goal is to train a model that performs better than any of the learners can produce by training on their private data set.","title":"How collective learning works"},{"location":"colearn/about/#how-training-works","text":"Training occurs in rounds; during each round the learners attempt to improve the performance of the global shared model. To do so each round an update of the global model (for example new set of weights in a neural network) is proposed. The learners then validate the update and decide if the new model is better than the current global model. If enough learners approve the update then the global model is updated. After an update is approved or rejected a new round begins. The detailed steps of a round updating a global model M are as follows: One of the learners is selected and proposes a new updated model M' The rest of the learners validate M' If M' has better performance than M against their private data set then the learner votes to approve If not, the learner votes to reject The total votes are tallied If more than some threshold (typically 50%) of learners approve then M' becomes the new global model. If not, M continues to be the global model A new round begins. By using a decentralized ledger (a blockchain) this learning process can be run in a completely decentralized, secure and auditable way. Further security can be provided by using differential privacy to avoid exposing your private data set when generating an update.","title":"How Training Works"},{"location":"colearn/about/#learning-algorithms-that-work-for-collective-learning","text":"Collective learning is not just for neural networks; any learning algorithm that can be trained on subsets of the data and which can use the results of previous training rounds as the basis for subsequent rounds can be used. Neural networks fit both these constraints: training can be done on mini-batches of data and each training step uses the weights of the previous training step as its starting point. More generally, any model that is trained using mini-batch stochastic gradient descent is fine. Other algorithms can be made to work with collective learning as well. For example, a random forest can be trained iteratively by having each learner add new trees (see example in mli_random_forest_iris.py ). For more discussion, see here .","title":"Learning algorithms that work for collective learning"},{"location":"colearn/about/#the-driver","text":"The driver implements the voting protocol, so it handles selecting a learner to train, sending the update out for voting, calculating the vote and accepting or declining the update. Here we have a very minimal driver that doesn't use networking or a blockchain. Eventually the driver will be a smart contract. This is the code that implements one round of voting: def run_one_round ( round_index : int , learners : Sequence [ MachineLearningInterface ], vote_threshold = 0.5 ): proposer = round_index % len ( learners ) new_weights = learners [ proposer ] . mli_propose_weights () prop_weights_list = [ ln . mli_test_weights ( new_weights ) for ln in learners ] approves = sum ( 1 if v . vote else 0 for v in prop_weights_list ) vote = False if approves >= len ( learners ) * vote_threshold : vote = True for j , learner in enumerate ( learners ): learner . mli_accept_weights ( prop_weights_list [ j ]) return prop_weights_list , vote The driver has a list of learners, and each round it selects one learner to be the proposer. The proposer does some training and proposes an updated set of weights. The driver then sends the proposed weights to each of the learners, and they each vote on whether this is an improvement. If the number of approving votes is greater than the vote threshold the proposed weights are accepted, and if not they're rejected.","title":"The driver"},{"location":"colearn/about/#the-machine-learning-interface","text":"# ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ import abc from typing import Any from pydantic import BaseModel class Weights ( BaseModel ): weights : Any class ProposedWeights ( BaseModel ): weights : Weights vote_score : float test_score : float vote : bool class MachineLearningInterface ( abc . ABC ): @abc . abstractmethod def mli_propose_weights ( self ) -> Weights : \"\"\" Trains the model. Returns new weights. Does not change the current weights of the model. \"\"\" pass @abc . abstractmethod def mli_test_weights ( self , weights : Weights ) -> ProposedWeights : \"\"\" Tests the proposed weights and fills in the rest of the fields \"\"\" @abc . abstractmethod def mli_accept_weights ( self , weights : Weights ): \"\"\" Updates the model with the proposed set of weights :param weights: The new weights \"\"\" pass @abc . abstractmethod def mli_get_current_weights ( self ) -> Weights : \"\"\" Returns the current weights of the model \"\"\" pass There are four methods that need to be implemented: propose_weights causes the model to do some training and then return a new set of weights that are proposed to the other learners. This method shouldn't change the current weights of the model - that only happens when accept_weights is called. test_weights - the models takes some new weights and returns a vote on whether the new weights are an improvement. As with propose_weights, this shouldn't change the current weights of the model - that only happens when accept_weights is called. accept_weights - the models accepts some weights that have been voted on and approved by the set of learners. The old weighs of the model are discarded and replaced by the new weights. current_weights should return the current weights of the model. For more details about directly implementing the machine learning interface see the tutorial here","title":"The Machine Learning Interface"},{"location":"colearn/demo/","text":"How to run the demo You can try collective learning for yourself using the simple demo in run_demo . This demo creates n learners for one of six learning tasks and co-ordinates the collective learning between them. There are six potential models for the demo KERAS_MNIST is the Tensorflow implementation of a small model for the standard handwritten digits recognition dataset KERAS_MNIST_RESNET is the Tensorflow implementation of a Resnet model for the standard handwritten digits recognition dataset KERAS_CIFAR10 is the Tensorflow implementation of the classical image recognition dataset PYTORCH_XRAY is Pytorch implementation of a binary classification task that requires predicting pneumonia from images of chest X-rays. The data need to be downloaded from Kaggle PYTORCH_COVID_XRAY is Pytorch implementation of a 3 class classification task that requires predicting no finding, covid or pneumonia from images of chest X-rays. This dataset is not currently publicly available. FRAUD The fraud dataset consists of information about credit card transactions, and the task is to predict whether transactions are fraudulent or not. The data need to be downloaded from Kaggle Use the -h flag to see the options: python -m colearn_examples.ml_interface.run_demo -h Arguments to run the demo: --data_dir: Directory containing training data, not required for MNIST and CIFAR10 --test_dir: Optional directory containing test data. A fraction of the training set will be used as a test set when not specified --model: Model to train, options are KERAS_MNIST KERAS_MNIST_RESNET KERAS_CIFAR10 PYTORCH_XRAY PYTORCH_COVID_XRAY FRAUD --n_learners: Number of individual learners --n_rounds: Number of training rounds --vote_threshold: Minimum fraction of positive votes to accept the new model --train_ratio: Fraction of training dataset to be used as test-set when no test-set is specified --seed: Seed for initialising model and shuffling datasets --learning_rate: Learning rate for optimiser --batch_size: Size of training batch Running MNIST The simplest task to run is MNIST because the data are downloaded automatically from tensorflow_datasets . The command below runs the MNIST task with five learners for 15 rounds. python -m colearn_examples.ml_interface.run_demo --model KERAS_MNIST --n_learners 5 --n_rounds 15 You should see a graph of the vote score and the test score (the score used here is categorical accuracy). The new model is accepted if the fraction of positive votes (green colour) is higher than 0.5. The new model is rejected if the fraction of negative votes (red color) is lower than 0.5. As you can see, there are five learners, and initially they perform poorly. In round one, learner 0 is selected to propose a new set of weights. Other datasets To run the CIFAR10 dataset: python -m colearn_examples.ml_interface.run_demo --model KERAS_CIFAR10 --n_learners 5 --n_rounds 15 The Fraud and X-ray datasets need to be downloaded from kaggle (this requires a kaggle account). To run the fraud dataset: python -m colearn_examples.ml_interface.run_demo --model FRAUD --n_learners 5 --n_rounds 15 --data_dir ./data/fraud To run the X-ray dataset: python -m colearn_examples.ml_interface.run_demo --model PYTORCH_XRAY --n_learners 5 --n_rounds 15 --data_dir ./data/xray","title":"Demo"},{"location":"colearn/demo/#how-to-run-the-demo","text":"You can try collective learning for yourself using the simple demo in run_demo . This demo creates n learners for one of six learning tasks and co-ordinates the collective learning between them. There are six potential models for the demo KERAS_MNIST is the Tensorflow implementation of a small model for the standard handwritten digits recognition dataset KERAS_MNIST_RESNET is the Tensorflow implementation of a Resnet model for the standard handwritten digits recognition dataset KERAS_CIFAR10 is the Tensorflow implementation of the classical image recognition dataset PYTORCH_XRAY is Pytorch implementation of a binary classification task that requires predicting pneumonia from images of chest X-rays. The data need to be downloaded from Kaggle PYTORCH_COVID_XRAY is Pytorch implementation of a 3 class classification task that requires predicting no finding, covid or pneumonia from images of chest X-rays. This dataset is not currently publicly available. FRAUD The fraud dataset consists of information about credit card transactions, and the task is to predict whether transactions are fraudulent or not. The data need to be downloaded from Kaggle Use the -h flag to see the options: python -m colearn_examples.ml_interface.run_demo -h Arguments to run the demo: --data_dir: Directory containing training data, not required for MNIST and CIFAR10 --test_dir: Optional directory containing test data. A fraction of the training set will be used as a test set when not specified --model: Model to train, options are KERAS_MNIST KERAS_MNIST_RESNET KERAS_CIFAR10 PYTORCH_XRAY PYTORCH_COVID_XRAY FRAUD --n_learners: Number of individual learners --n_rounds: Number of training rounds --vote_threshold: Minimum fraction of positive votes to accept the new model --train_ratio: Fraction of training dataset to be used as test-set when no test-set is specified --seed: Seed for initialising model and shuffling datasets --learning_rate: Learning rate for optimiser --batch_size: Size of training batch","title":"How to run the demo"},{"location":"colearn/demo/#running-mnist","text":"The simplest task to run is MNIST because the data are downloaded automatically from tensorflow_datasets . The command below runs the MNIST task with five learners for 15 rounds. python -m colearn_examples.ml_interface.run_demo --model KERAS_MNIST --n_learners 5 --n_rounds 15 You should see a graph of the vote score and the test score (the score used here is categorical accuracy). The new model is accepted if the fraction of positive votes (green colour) is higher than 0.5. The new model is rejected if the fraction of negative votes (red color) is lower than 0.5. As you can see, there are five learners, and initially they perform poorly. In round one, learner 0 is selected to propose a new set of weights.","title":"Running MNIST"},{"location":"colearn/demo/#other-datasets","text":"To run the CIFAR10 dataset: python -m colearn_examples.ml_interface.run_demo --model KERAS_CIFAR10 --n_learners 5 --n_rounds 15 The Fraud and X-ray datasets need to be downloaded from kaggle (this requires a kaggle account). To run the fraud dataset: python -m colearn_examples.ml_interface.run_demo --model FRAUD --n_learners 5 --n_rounds 15 --data_dir ./data/fraud To run the X-ray dataset: python -m colearn_examples.ml_interface.run_demo --model PYTORCH_XRAY --n_learners 5 --n_rounds 15 --data_dir ./data/xray","title":"Other datasets"},{"location":"colearn/dev_notes/","text":"Developer Notes These are some notes for developers working on the colearn code repo Google Cloud Storage To have access to the google cloud storage you need to set up your google authentication and have the $GOOGLE_APPLICATION_CREDENTIALS set up correctly. For more details ask or see the contract-learn documentation Build image To build ML server image and push to google cloud use the following command: cd docker python3 ./build.py --publish --allow_dirty # Check this worked correctly docker images","title":"Developer Notes"},{"location":"colearn/dev_notes/#developer-notes","text":"These are some notes for developers working on the colearn code repo","title":"Developer Notes"},{"location":"colearn/dev_notes/#google-cloud-storage","text":"To have access to the google cloud storage you need to set up your google authentication and have the $GOOGLE_APPLICATION_CREDENTIALS set up correctly. For more details ask or see the contract-learn documentation","title":"Google Cloud Storage"},{"location":"colearn/dev_notes/#build-image","text":"To build ML server image and push to google cloud use the following command: cd docker python3 ./build.py --publish --allow_dirty # Check this worked correctly docker images","title":"Build image"},{"location":"colearn/differential_privacy/","text":"What is differential privacy? To make a machine learning system that protects privacy we first need to have a definition of what privacy is. Differential privacy (DP) is one such definition. First we need to have three concepts: the database is a collection of data about individuals (for example, their medical records), and we want to make a query about that data (for example \"How much does smoking increase someone's risk of cancer?\"). DP says that privacy is preserved if the result of the query cannot be used to determine if any particular individual is present in the database. So if person A has their medical data in a database, and the query that we want to make on that database is \"How much does smoking increase someone's risk of cancer\" then the result of that query shouldn't disclose whether or not person A's details are in the database. From this comes the idea of sensitivity of a query. The sensitivity of a query determines how much the result of the query depends on an individual's data. For example, the query \"How much does smoking increase the risk of cancer for adults in the UK?\" is less sensitive than the query \"How much does smoking increase the risk of cancer for men aged 50-55 in Cambridge?\" because the second query uses a smaller set of individuals. Epsilon-differential privacy EDP is a scheme for preserving differential privacy. In EDP all queries have random noise added to them, so they are no longer deterministic. So if the query was \"What fraction of people in the database are male\", and the true result is 0.5 then the results of calling this query three times might be 0.53, 0.49 and 0.51. This makes it harder to tell if an individual's data is in the database, because the effect of adding a person can't be distinguished from the effect of the random noise. Intuitively this is a bit like blurring an image: adding noise obscures personal information. The amount of personal information that is revealed isn't zero, but it is guaranteed to be below a certain threshold. The level of privacy that is provided is controlled by the parameter epsilon; the greater epsilon is the more noise is added and the more privacy is preserved. Queries that are more sensitive have more noise added, because they reveal more information about individuals. It is important to add as little noise as possible, because adding more noise obscures the patterns that you want to extract from the data. Differential privacy when training neural networks Each training step for a neural network can be though of as a complicated query on a database of training data. Differential privacy mechanisms tell you how much noise you need to add to guarantee a certain level of privacy. The opacus and tensorflow-privacy libraries implement epsilon-differential privacy for training neural networks for pytorch and keras respectively. How to use differential privacy with colearn By using opacus and tensorflow-privacy we can make collective learning use differential privacy. The learner that is proposing weights does so using a DP-enabled optimiser. To see an example of using this see dp_pytorch and dp_keras .","title":"Differential Privacy"},{"location":"colearn/differential_privacy/#what-is-differential-privacy","text":"To make a machine learning system that protects privacy we first need to have a definition of what privacy is. Differential privacy (DP) is one such definition. First we need to have three concepts: the database is a collection of data about individuals (for example, their medical records), and we want to make a query about that data (for example \"How much does smoking increase someone's risk of cancer?\"). DP says that privacy is preserved if the result of the query cannot be used to determine if any particular individual is present in the database. So if person A has their medical data in a database, and the query that we want to make on that database is \"How much does smoking increase someone's risk of cancer\" then the result of that query shouldn't disclose whether or not person A's details are in the database. From this comes the idea of sensitivity of a query. The sensitivity of a query determines how much the result of the query depends on an individual's data. For example, the query \"How much does smoking increase the risk of cancer for adults in the UK?\" is less sensitive than the query \"How much does smoking increase the risk of cancer for men aged 50-55 in Cambridge?\" because the second query uses a smaller set of individuals.","title":"What is differential privacy?"},{"location":"colearn/differential_privacy/#epsilon-differential-privacy","text":"EDP is a scheme for preserving differential privacy. In EDP all queries have random noise added to them, so they are no longer deterministic. So if the query was \"What fraction of people in the database are male\", and the true result is 0.5 then the results of calling this query three times might be 0.53, 0.49 and 0.51. This makes it harder to tell if an individual's data is in the database, because the effect of adding a person can't be distinguished from the effect of the random noise. Intuitively this is a bit like blurring an image: adding noise obscures personal information. The amount of personal information that is revealed isn't zero, but it is guaranteed to be below a certain threshold. The level of privacy that is provided is controlled by the parameter epsilon; the greater epsilon is the more noise is added and the more privacy is preserved. Queries that are more sensitive have more noise added, because they reveal more information about individuals. It is important to add as little noise as possible, because adding more noise obscures the patterns that you want to extract from the data.","title":"Epsilon-differential privacy"},{"location":"colearn/differential_privacy/#differential-privacy-when-training-neural-networks","text":"Each training step for a neural network can be though of as a complicated query on a database of training data. Differential privacy mechanisms tell you how much noise you need to add to guarantee a certain level of privacy. The opacus and tensorflow-privacy libraries implement epsilon-differential privacy for training neural networks for pytorch and keras respectively.","title":"Differential privacy when training neural networks"},{"location":"colearn/differential_privacy/#how-to-use-differential-privacy-with-colearn","text":"By using opacus and tensorflow-privacy we can make collective learning use differential privacy. The learner that is proposing weights does so using a DP-enabled optimiser. To see an example of using this see dp_pytorch and dp_keras .","title":"How to use differential privacy with colearn"},{"location":"colearn/examples/","text":"Examples that use Collective Learning This is a list of examples that we've implemented to show you how to use Collective Learning locally. See and example of the gRPC server for the next step towards decentralized Colearn. Mnist Uses the standard Mnist database of handwritten images mnist_keras . Uses the KerasLearner helper class. Discussed in more detail here . mnist_pytorch . Uses the PytorchLearner helper class. Discussed in more detail here . Fraud The fraud dataset consists of information about credit card transactions. The task is to predict whether transactions are fraudulent or not. The data needs to be downloaded from Kaggle , and the data directory passed in with the flag --data_dir . fraud_mli . Uses the MachineLearningInterface directly and detects fraud in bank transactions. fraud_keras . Loads data from numpy arrays and uses KerasLearner . Cifar10 Uses the standard Cifar10 database of images cifar_keras . Uses the KerasLearner helper class. cifar_pytorch . Uses the PytorchLearner helper class. Xray A binary classification task that requires predicting pneumonia from images of chest X-rays. The data need to be downloaded from Kaggle , and the data directory passed in with the flag --data_dir xray_keras . Uses the KerasLearner helper class. xray_pytorch . Uses the PytorchLearner helper class. Iris Uses the standard Iris dataset. The aim of this task is to classify examples into one of three iris species based on measurements of the flower. iris_random_forest . Uses the MachineLearningInterface directly and a random forest for classification.","title":"Standalone examples"},{"location":"colearn/examples/#examples-that-use-collective-learning","text":"This is a list of examples that we've implemented to show you how to use Collective Learning locally. See and example of the gRPC server for the next step towards decentralized Colearn.","title":"Examples that use Collective Learning"},{"location":"colearn/examples/#mnist","text":"Uses the standard Mnist database of handwritten images mnist_keras . Uses the KerasLearner helper class. Discussed in more detail here . mnist_pytorch . Uses the PytorchLearner helper class. Discussed in more detail here .","title":"Mnist"},{"location":"colearn/examples/#fraud","text":"The fraud dataset consists of information about credit card transactions. The task is to predict whether transactions are fraudulent or not. The data needs to be downloaded from Kaggle , and the data directory passed in with the flag --data_dir . fraud_mli . Uses the MachineLearningInterface directly and detects fraud in bank transactions. fraud_keras . Loads data from numpy arrays and uses KerasLearner .","title":"Fraud"},{"location":"colearn/examples/#cifar10","text":"Uses the standard Cifar10 database of images cifar_keras . Uses the KerasLearner helper class. cifar_pytorch . Uses the PytorchLearner helper class.","title":"Cifar10"},{"location":"colearn/examples/#xray","text":"A binary classification task that requires predicting pneumonia from images of chest X-rays. The data need to be downloaded from Kaggle , and the data directory passed in with the flag --data_dir xray_keras . Uses the KerasLearner helper class. xray_pytorch . Uses the PytorchLearner helper class.","title":"Xray"},{"location":"colearn/examples/#iris","text":"Uses the standard Iris dataset. The aim of this task is to classify examples into one of three iris species based on measurements of the flower. iris_random_forest . Uses the MachineLearningInterface directly and a random forest for classification.","title":"Iris"},{"location":"colearn/grpc_examples/","text":"Mnist gRPC Example To run the Keras Mnist gRPC example run: python -m colearn_examples.grpc.run_grpc_demo --n_learners 5 --dataloader_tag KERAS_MNIST --model_tag KERAS_MNIST \\ --data_locations /tmp/mnist/0,/tmp/mnist/1,/tmp/mnist/2,/tmp/mnist/3,/tmp/mnist/4 Note This requires colearn[keras] You can verify that the example is working correctly by running the probe: python -m colearn_grpc.scripts.probe_grpc_server --port 9995 For more about the gRPC components of Colearn see the gRPC Tutorial","title":"gRPC example"},{"location":"colearn/grpc_examples/#mnist-grpc-example","text":"To run the Keras Mnist gRPC example run: python -m colearn_examples.grpc.run_grpc_demo --n_learners 5 --dataloader_tag KERAS_MNIST --model_tag KERAS_MNIST \\ --data_locations /tmp/mnist/0,/tmp/mnist/1,/tmp/mnist/2,/tmp/mnist/3,/tmp/mnist/4 Note This requires colearn[keras] You can verify that the example is working correctly by running the probe: python -m colearn_grpc.scripts.probe_grpc_server --port 9995 For more about the gRPC components of Colearn see the gRPC Tutorial","title":"Mnist gRPC Example"},{"location":"colearn/grpc_tutorial/","text":"gRPC tutorial This tutorial explains how to set up the gRPC learner server. It assumes that you can already run colearn locally, and that you have already defined your own models and dataloaders (if you're going to do so). If you haven't done this then see the tutorials in the Getting Started section. Architecture of colearn There are two main parts to a collective learning system: the learner and the backend. The backend controls the learner, and manages the smart contracts and IPFS, and acts as a control hub for all the associated learners. The learner is the part that executes machine learning code. This consists of proposing, evaluating and accepting new weights as detailed in the Machine Learning Interface. The learner and the backend communicate via gRPC ; the learner runs a gRPC server, and the backend runs a gRPC client that makes requests of the learner. This separation means that the learner can run on specialised hardware (e.g. a compute server) and does not need to be co-located with the backend. Architecture of gRPC server The gRPC interface is defined in colearn_grpc/proto/interface.proto . This defines the functions that the gRPC server exposes and the format for messages between the server and the client. As we covered in the earlier tutorials, the machine learning part of colearn is contained inside the MachineLearningInterface (MLI). To recap: the MLI provides methods for proposing, evaluating and accepting weights. If you want to use your own models with colearn then you need to write an object that implements the MLI (for example, an instance of a python class that inherits from MachineLearningInterface ). For more about the MLI see the MLI tutorial . The gRPC server has an MLI factory, and it uses its MLI factory to make objects that implement the MachineLearningInterface . The MLI factory needs to implement the MLI factory interface. You could write your own MLI factory, but it's easier to use the one we provide. Below we will discuss the MLI factory interface and then talk about how to use the example factory. MLI Factory interface The MLI Factory (as the name suggests) is a factory class for creating objects that implement the machine learning interface: # ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ import abc from typing import Dict , Set , Any from colearn.ml_interface import MachineLearningInterface class MliFactory ( abc . ABC ): \"\"\" Interface a class must implement to be used as a factory by the GRPC Server \"\"\" @abc . abstractmethod def get_models ( self ) -> Dict [ str , Dict [ str , Any ]]: \"\"\" Returns the models this factory produces. The key is the name of the model and the values are their default parameters \"\"\" pass @abc . abstractmethod def get_dataloaders ( self ) -> Dict [ str , Dict [ str , Any ]]: \"\"\" Returns the dataloaders this factory produces. The key is the name of the dataloader and the values are their default parameters \"\"\" pass @abc . abstractmethod def get_compatibilities ( self ) -> Dict [ str , Set [ str ]]: \"\"\" A model is compatible with a dataloader if they can be used together to construct a MachineLearningInterface with the get_MLI function. Returns a dictionary that defines which model is compatible with which dataloader. \"\"\" pass @abc . abstractmethod def get_mli ( self , model_name : str , model_params : str , dataloader_name : str , dataset_params : str ) -> MachineLearningInterface : \"\"\" @param model_name: name of a model, must be in the set return by get_models @param model_params: user defined parameters for the model @param dataloader_name: name of a dataloader to be used: - must be in the set returned by get_dataloaders - must be compatible with model_name as defined by get_compatibilities @param dataset_params: user defined parameters for the dataset @return: Instance of MachineLearningInterface Constructs an object that implements MachineLearningInterface whose underlying model is model_name and dataset is loaded by dataloader_name. \"\"\" pass The MLI Factory stores the constructors for dataloaders and models and also a list of the dataloaders that are compatible with each model. Each constructor is stored under a specific name. For example, \"KERAS_MNIST_MODEL\" is the model for keras mnist. The gRPC server uses the MLI factory to construct MLI objects. The MLI Factory needs to implement four methods: get_models - returns the names of the models that are registered with the factory and their parameters. get_dataloaders - returns the names of the dataloaders that are registered with the factory and their parameters. get_compatibilities - returns a list of dataloaders for each model that can be used with that model. get_mli - takes the name and parameters for the model and dataloader and constructs the MLI object. Returns the MLI object. Using the example MLI Factory The example MLI factory is defined in colearn_grpc/example_mli_factory.py . It stores the models and dataloaders that it knows about in factoryRegistry.py To add a new model and dataloader to the factory you need to do the following things: Define a function that loads the dataset given the location of the dataset. Define a function that takes in the dataset and loads the MLI model. Register both these functions with the factory registry. Registering a dataloader looks like this: @FactoryRegistry . register_dataloader ( dataloader_tag ) def prepare_data_loaders ( location : str , train_ratio : float = 0.9 , batch_size : int = 32 ) -> Tuple [ PrefetchDataset , PrefetchDataset ]: Registering a model is similar, but you additionally have to specify the dataloaders that this model is compatible with. @FactoryRegistry . register_model_architecture ( model_tag , [ dataloader_tag ]) def prepare_learner ( data_loaders : Tuple [ PrefetchDataset , PrefetchDataset ], steps_per_epoch : int = 100 , vote_batches : int = 10 , learning_rate : float = 0.001 ) -> KerasLearner : You can see an example of how to do this in colearn_examples/grpc/mnist_grpc.py . The FactoryRegistry decorators get evaluated when the functions are imported, so ensure that the functions are imported before constructing the gRPC server (more on that later). Constraints on the dataloader function: The first parameter should be a mandatory parameter called \"location\" which stores the location of the dataset. The subsequent parameters should have default arguments. The return type should be specified with a type annotation, and this should be the same type that is expected by the model functions that use this dataloader. The arguments that you pass to the dataloader function must be JSON-encodable . Native python types are fine (e.g. str, dict, list, float). Constraints on the model function: The first parameter should be a mandatory parameter called \"data_loaders\". This must have the same type as the return type of the compatible dataloaders. The subsequent parameters should have default arguments. The return type of model_function should be MachineLearningInterface or a subclass of it (e.g. KerasLearner ). The dataloaders listed as being compatible with the model should already be registered with FactoryRegistry before the model is registered. The arguments that you pass to the model function must be JSON-encodable . Native python types are fine (e.g. str, dict, list, float). Making it all work together It can be challenging to ensure that all the parts talk to each other, so we have provided some examples and helper scripts. It is recommended to first make an all-in-one script following the example of colearn_examples/grpc/mnist_grpc.py . Once this is working you can run colearn_grpc/scripts/run_n_servers.py or colearn_grpc/scripts/run_grpc_server.py to run the server(s). The script colearn_grpc/scripts/probe_grpc_server.py will connect to a gRPC server and print the dataloaders and models that are registered on it (pass in the address as a parameter). The client side of the gRPC communication can then be run using colearn_examples/grpc/run_grpc_demo.py . More details are given below. A note about running tensorflow in multiple processes: on a system with a GPU, tensorflow will try to get all the GPU memory when it starts up. This means that running tensorflow in multiple processes on the same machine will fail. To prevent this happening, tensorflow should be told to use only the CPU by setting the environment variable CUDA_VISIBLE_DEVIES to -1 . This can be done in a python script (before importing tensorflow) by using: import os os . environ [ \"CUDA_VISIBLE_DEVICES\" ] = \"-1\" Testing locally with an all-in-one script You can test this locally by following the example in colearn_examples/grpc/mnist_grpc.py . Define your dataloader and model functions as specified above, and register them with the factory. Then create n_learners gRPC servers: n_learners = 5 first_server_port = 9995 # make n servers for i in range ( n_learners ): port = first_server_port + i server = GRPCServer ( mli_factory = ExampleMliFactory (), port = port ) server_process = Process ( target = server . run ) server_process . start () And then create n_learners gRPC clients: all_learner_models = [] for i in range ( n_learners ): port = first_server_port + i ml_system = ExampleGRPCLearnerClient ( f \"client { i } \" , f \"127.0.0.1: { port } \" ) ml_system . start () dataloader_params = { \"location\" : data_folders [ i ]} ml_system . setup_ml ( dataset_loader_name = dataloader_tag , dataset_loader_parameters = json . dumps ( dataloader_params ), model_arch_name = model_tag , model_parameters = json . dumps ({})) all_learner_models . append ( ml_system ) ExampleGRPCLearnerClient inherits from the MachineLearningInterface so you can use it with the training functions as before: for round_index in range ( n_rounds ): results . data . append ( collective_learning_round ( all_learner_models , vote_threshold , round_index ) ) Testing remotely We expect that the gRPC learner part will often be on a compute cluster and be separate from the gRPC client side. To test the gRPC in a setup like this you can start the servers on the computer side and the client part separately. For one gRPC server: python3 ./colearn_grpc/scripts/run_grpc_server.py --port 9995 --metrics_port 9091 For multiple gRPC servers: python3 ./colearn_grpc/scrips/run_n_grpc_servers.py --n_learners 5 --port 9995 --metrics_port 9091 The servers by default will start on port 9995 and use subsequent ports from there, so if three servers are required they will run on ports 9995, 9996 and 9997. If you have written your own dataloaders and models then you need to make sure that those functions are defined or imported before the server is created. These are the imports of the default dataloaders and models in colearn_grpc/scripts/run_grpc_server.py : # These are imported so that they are registered in the FactoryRegistry import colearn_keras.keras_mnist import colearn_keras.keras_cifar10 import colearn_pytorch.pytorch_xray import colearn_pytorch.pytorch_covid_xray import colearn_other.fraud_dataset Once the gRPC server(s) are running, set up whatever networking and port forwarding is required. You can check that the gRPC server is accessible by using the probe script: python3 ./colearn_grpc/scripts/probe_grpc_server.py --port 9995 If the connection is successful this will print a list of the models and datasets registered on the server. These are the defaults that are registered: info: Attempt number 0 to connect to 127.0.0.1:9995 info: Successfully connected to 127.0.0.1:9995! {'compatibilities': {'FRAUD': ['FRAUD'], 'KERAS_CIFAR10': ['KERAS_CIFAR10'], 'KERAS_MNIST': ['KERAS_MNIST'], 'KERAS_MNIST_RESNET': ['KERAS_MNIST'], 'PYTORCH_COVID_XRAY': ['PYTORCH_COVID_XRAY'], 'PYTORCH_XRAY': ['PYTORCH_XRAY']}, 'data_loaders': {'FRAUD': '{\"train_ratio\": 0.8}', 'KERAS_CIFAR10': '{\"train_ratio\": 0.9, \"batch_size\": 32}', 'KERAS_MNIST': '{\"train_ratio\": 0.9, \"batch_size\": 32}', 'PYTORCH_COVID_XRAY': '{\"train_ratio\": 0.8, \"batch_size\": 8, ' '\"no_cuda\": false}', 'PYTORCH_XRAY': '{\"test_location\": null, \"train_ratio\": 0.96, ' '\"batch_size\": 8, \"no_cuda\": false}'}, 'model_architectures': {'FRAUD': '{}', 'KERAS_CIFAR10': '{\"steps_per_epoch\": 100, ' '\"vote_batches\": 10, ' '\"learning_rate\": 0.001}', 'KERAS_MNIST': '{\"steps_per_epoch\": 100, ' '\"vote_batches\": 10, \"learning_rate\": ' '0.001}', 'KERAS_MNIST_RESNET': '{\"steps_per_epoch\": 100, ' '\"vote_batches\": 10, ' '\"learning_rate\": 0.001}', 'PYTORCH_COVID_XRAY': '{\"learning_rate\": 0.001, ' '\"steps_per_epoch\": 40, ' '\"vote_batches\": 10, \"no_cuda\": ' 'false, \"vote_on_accuracy\": ' 'true}', 'PYTORCH_XRAY': '{\"learning_rate\": 0.001, ' '\"steps_per_epoch\": 40, ' '\"vote_batches\": 10, \"no_cuda\": ' 'false, \"vote_on_accuracy\": true}'}} Then run python -m colearn_examples.grpc.run_grpc_demo on the other side to run the usual demo. The script takes as arguments the model name and dataset name that should be run, along with the number of learners and the data location for each learner. python -m colearn_examples.grpc.run_grpc_demo --n_learners 5 --dataloader_tag KERAS_MNIST --model_tag KERAS_MNIST \\ --data_locations /tmp/mnist/0,/tmp/mnist/1,/tmp/mnist/2,/tmp/mnist/3,/tmp/mnist/4 Using the MLI Factory interface An alternative method of using your own dataloaders and models with the gRPC server is to use the MLI Factory interface. This is defined in colearn_grpc/mli_factory_interface.py . An example is given in colearn_examples/grpc/mlifactory_grpc_mnist.py . The MLI Factory is implemented as shown: dataloader_tag = \"KERAS_MNIST_EXAMPLE_DATALOADER\" model_tag = \"KERAS_MNIST_EXAMPLE_MODEL\" class SimpleFactory ( MliFactory ): def get_dataloaders ( self ) -> Dict [ str , Dict [ str , Any ]]: return { dataloader_tag : dict ( train_ratio = 0.9 , batch_size = 32 )} def get_models ( self ) -> Dict [ str , Dict [ str , Any ]]: return { model_tag : dict ( steps_per_epoch = 100 , vote_batches = 10 , learning_rate = 0.001 )} def get_compatibilities ( self ) -> Dict [ str , Set [ str ]]: return { model_tag : { dataloader_tag }} def get_mli ( self , model_name : str , model_params : str , dataloader_name : str , dataset_params : str ) -> MachineLearningInterface : dataloader_params = json . loads ( dataset_params ) data_loaders = prepare_data_loaders ( ** dataloader_params ) model_params = json . loads ( model_params ) mli_model = prepare_learner ( data_loaders = data_loaders , ** model_params ) return mli_model An instance of the SimpleFactory class needs to be passed to the gRPC server on creation: n_learners = 5 first_server_port = 9995 # make n servers server_processes = [] for i in range ( n_learners ): port = first_server_port + i server = GRPCServer ( mli_factory = SimpleFactory (), port = port ) server_process = Process ( target = server . run ) print ( \"starting server\" , i ) server_process . start () server_processes . append ( server_process ) The rest of the example follows the grpc_mnist.py example.","title":"gRPC server"},{"location":"colearn/grpc_tutorial/#grpc-tutorial","text":"This tutorial explains how to set up the gRPC learner server. It assumes that you can already run colearn locally, and that you have already defined your own models and dataloaders (if you're going to do so). If you haven't done this then see the tutorials in the Getting Started section.","title":"gRPC tutorial"},{"location":"colearn/grpc_tutorial/#architecture-of-colearn","text":"There are two main parts to a collective learning system: the learner and the backend. The backend controls the learner, and manages the smart contracts and IPFS, and acts as a control hub for all the associated learners. The learner is the part that executes machine learning code. This consists of proposing, evaluating and accepting new weights as detailed in the Machine Learning Interface. The learner and the backend communicate via gRPC ; the learner runs a gRPC server, and the backend runs a gRPC client that makes requests of the learner. This separation means that the learner can run on specialised hardware (e.g. a compute server) and does not need to be co-located with the backend.","title":"Architecture of colearn"},{"location":"colearn/grpc_tutorial/#architecture-of-grpc-server","text":"The gRPC interface is defined in colearn_grpc/proto/interface.proto . This defines the functions that the gRPC server exposes and the format for messages between the server and the client. As we covered in the earlier tutorials, the machine learning part of colearn is contained inside the MachineLearningInterface (MLI). To recap: the MLI provides methods for proposing, evaluating and accepting weights. If you want to use your own models with colearn then you need to write an object that implements the MLI (for example, an instance of a python class that inherits from MachineLearningInterface ). For more about the MLI see the MLI tutorial . The gRPC server has an MLI factory, and it uses its MLI factory to make objects that implement the MachineLearningInterface . The MLI factory needs to implement the MLI factory interface. You could write your own MLI factory, but it's easier to use the one we provide. Below we will discuss the MLI factory interface and then talk about how to use the example factory.","title":"Architecture of gRPC server"},{"location":"colearn/grpc_tutorial/#mli-factory-interface","text":"The MLI Factory (as the name suggests) is a factory class for creating objects that implement the machine learning interface: # ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ import abc from typing import Dict , Set , Any from colearn.ml_interface import MachineLearningInterface class MliFactory ( abc . ABC ): \"\"\" Interface a class must implement to be used as a factory by the GRPC Server \"\"\" @abc . abstractmethod def get_models ( self ) -> Dict [ str , Dict [ str , Any ]]: \"\"\" Returns the models this factory produces. The key is the name of the model and the values are their default parameters \"\"\" pass @abc . abstractmethod def get_dataloaders ( self ) -> Dict [ str , Dict [ str , Any ]]: \"\"\" Returns the dataloaders this factory produces. The key is the name of the dataloader and the values are their default parameters \"\"\" pass @abc . abstractmethod def get_compatibilities ( self ) -> Dict [ str , Set [ str ]]: \"\"\" A model is compatible with a dataloader if they can be used together to construct a MachineLearningInterface with the get_MLI function. Returns a dictionary that defines which model is compatible with which dataloader. \"\"\" pass @abc . abstractmethod def get_mli ( self , model_name : str , model_params : str , dataloader_name : str , dataset_params : str ) -> MachineLearningInterface : \"\"\" @param model_name: name of a model, must be in the set return by get_models @param model_params: user defined parameters for the model @param dataloader_name: name of a dataloader to be used: - must be in the set returned by get_dataloaders - must be compatible with model_name as defined by get_compatibilities @param dataset_params: user defined parameters for the dataset @return: Instance of MachineLearningInterface Constructs an object that implements MachineLearningInterface whose underlying model is model_name and dataset is loaded by dataloader_name. \"\"\" pass The MLI Factory stores the constructors for dataloaders and models and also a list of the dataloaders that are compatible with each model. Each constructor is stored under a specific name. For example, \"KERAS_MNIST_MODEL\" is the model for keras mnist. The gRPC server uses the MLI factory to construct MLI objects. The MLI Factory needs to implement four methods: get_models - returns the names of the models that are registered with the factory and their parameters. get_dataloaders - returns the names of the dataloaders that are registered with the factory and their parameters. get_compatibilities - returns a list of dataloaders for each model that can be used with that model. get_mli - takes the name and parameters for the model and dataloader and constructs the MLI object. Returns the MLI object.","title":"MLI Factory interface"},{"location":"colearn/grpc_tutorial/#using-the-example-mli-factory","text":"The example MLI factory is defined in colearn_grpc/example_mli_factory.py . It stores the models and dataloaders that it knows about in factoryRegistry.py To add a new model and dataloader to the factory you need to do the following things: Define a function that loads the dataset given the location of the dataset. Define a function that takes in the dataset and loads the MLI model. Register both these functions with the factory registry. Registering a dataloader looks like this: @FactoryRegistry . register_dataloader ( dataloader_tag ) def prepare_data_loaders ( location : str , train_ratio : float = 0.9 , batch_size : int = 32 ) -> Tuple [ PrefetchDataset , PrefetchDataset ]: Registering a model is similar, but you additionally have to specify the dataloaders that this model is compatible with. @FactoryRegistry . register_model_architecture ( model_tag , [ dataloader_tag ]) def prepare_learner ( data_loaders : Tuple [ PrefetchDataset , PrefetchDataset ], steps_per_epoch : int = 100 , vote_batches : int = 10 , learning_rate : float = 0.001 ) -> KerasLearner : You can see an example of how to do this in colearn_examples/grpc/mnist_grpc.py . The FactoryRegistry decorators get evaluated when the functions are imported, so ensure that the functions are imported before constructing the gRPC server (more on that later). Constraints on the dataloader function: The first parameter should be a mandatory parameter called \"location\" which stores the location of the dataset. The subsequent parameters should have default arguments. The return type should be specified with a type annotation, and this should be the same type that is expected by the model functions that use this dataloader. The arguments that you pass to the dataloader function must be JSON-encodable . Native python types are fine (e.g. str, dict, list, float). Constraints on the model function: The first parameter should be a mandatory parameter called \"data_loaders\". This must have the same type as the return type of the compatible dataloaders. The subsequent parameters should have default arguments. The return type of model_function should be MachineLearningInterface or a subclass of it (e.g. KerasLearner ). The dataloaders listed as being compatible with the model should already be registered with FactoryRegistry before the model is registered. The arguments that you pass to the model function must be JSON-encodable . Native python types are fine (e.g. str, dict, list, float).","title":"Using the example MLI Factory"},{"location":"colearn/grpc_tutorial/#making-it-all-work-together","text":"It can be challenging to ensure that all the parts talk to each other, so we have provided some examples and helper scripts. It is recommended to first make an all-in-one script following the example of colearn_examples/grpc/mnist_grpc.py . Once this is working you can run colearn_grpc/scripts/run_n_servers.py or colearn_grpc/scripts/run_grpc_server.py to run the server(s). The script colearn_grpc/scripts/probe_grpc_server.py will connect to a gRPC server and print the dataloaders and models that are registered on it (pass in the address as a parameter). The client side of the gRPC communication can then be run using colearn_examples/grpc/run_grpc_demo.py . More details are given below. A note about running tensorflow in multiple processes: on a system with a GPU, tensorflow will try to get all the GPU memory when it starts up. This means that running tensorflow in multiple processes on the same machine will fail. To prevent this happening, tensorflow should be told to use only the CPU by setting the environment variable CUDA_VISIBLE_DEVIES to -1 . This can be done in a python script (before importing tensorflow) by using: import os os . environ [ \"CUDA_VISIBLE_DEVICES\" ] = \"-1\"","title":"Making it all work together"},{"location":"colearn/grpc_tutorial/#testing-locally-with-an-all-in-one-script","text":"You can test this locally by following the example in colearn_examples/grpc/mnist_grpc.py . Define your dataloader and model functions as specified above, and register them with the factory. Then create n_learners gRPC servers: n_learners = 5 first_server_port = 9995 # make n servers for i in range ( n_learners ): port = first_server_port + i server = GRPCServer ( mli_factory = ExampleMliFactory (), port = port ) server_process = Process ( target = server . run ) server_process . start () And then create n_learners gRPC clients: all_learner_models = [] for i in range ( n_learners ): port = first_server_port + i ml_system = ExampleGRPCLearnerClient ( f \"client { i } \" , f \"127.0.0.1: { port } \" ) ml_system . start () dataloader_params = { \"location\" : data_folders [ i ]} ml_system . setup_ml ( dataset_loader_name = dataloader_tag , dataset_loader_parameters = json . dumps ( dataloader_params ), model_arch_name = model_tag , model_parameters = json . dumps ({})) all_learner_models . append ( ml_system ) ExampleGRPCLearnerClient inherits from the MachineLearningInterface so you can use it with the training functions as before: for round_index in range ( n_rounds ): results . data . append ( collective_learning_round ( all_learner_models , vote_threshold , round_index ) )","title":"Testing locally with an all-in-one script"},{"location":"colearn/grpc_tutorial/#testing-remotely","text":"We expect that the gRPC learner part will often be on a compute cluster and be separate from the gRPC client side. To test the gRPC in a setup like this you can start the servers on the computer side and the client part separately. For one gRPC server: python3 ./colearn_grpc/scripts/run_grpc_server.py --port 9995 --metrics_port 9091 For multiple gRPC servers: python3 ./colearn_grpc/scrips/run_n_grpc_servers.py --n_learners 5 --port 9995 --metrics_port 9091 The servers by default will start on port 9995 and use subsequent ports from there, so if three servers are required they will run on ports 9995, 9996 and 9997. If you have written your own dataloaders and models then you need to make sure that those functions are defined or imported before the server is created. These are the imports of the default dataloaders and models in colearn_grpc/scripts/run_grpc_server.py : # These are imported so that they are registered in the FactoryRegistry import colearn_keras.keras_mnist import colearn_keras.keras_cifar10 import colearn_pytorch.pytorch_xray import colearn_pytorch.pytorch_covid_xray import colearn_other.fraud_dataset Once the gRPC server(s) are running, set up whatever networking and port forwarding is required. You can check that the gRPC server is accessible by using the probe script: python3 ./colearn_grpc/scripts/probe_grpc_server.py --port 9995 If the connection is successful this will print a list of the models and datasets registered on the server. These are the defaults that are registered: info: Attempt number 0 to connect to 127.0.0.1:9995 info: Successfully connected to 127.0.0.1:9995! {'compatibilities': {'FRAUD': ['FRAUD'], 'KERAS_CIFAR10': ['KERAS_CIFAR10'], 'KERAS_MNIST': ['KERAS_MNIST'], 'KERAS_MNIST_RESNET': ['KERAS_MNIST'], 'PYTORCH_COVID_XRAY': ['PYTORCH_COVID_XRAY'], 'PYTORCH_XRAY': ['PYTORCH_XRAY']}, 'data_loaders': {'FRAUD': '{\"train_ratio\": 0.8}', 'KERAS_CIFAR10': '{\"train_ratio\": 0.9, \"batch_size\": 32}', 'KERAS_MNIST': '{\"train_ratio\": 0.9, \"batch_size\": 32}', 'PYTORCH_COVID_XRAY': '{\"train_ratio\": 0.8, \"batch_size\": 8, ' '\"no_cuda\": false}', 'PYTORCH_XRAY': '{\"test_location\": null, \"train_ratio\": 0.96, ' '\"batch_size\": 8, \"no_cuda\": false}'}, 'model_architectures': {'FRAUD': '{}', 'KERAS_CIFAR10': '{\"steps_per_epoch\": 100, ' '\"vote_batches\": 10, ' '\"learning_rate\": 0.001}', 'KERAS_MNIST': '{\"steps_per_epoch\": 100, ' '\"vote_batches\": 10, \"learning_rate\": ' '0.001}', 'KERAS_MNIST_RESNET': '{\"steps_per_epoch\": 100, ' '\"vote_batches\": 10, ' '\"learning_rate\": 0.001}', 'PYTORCH_COVID_XRAY': '{\"learning_rate\": 0.001, ' '\"steps_per_epoch\": 40, ' '\"vote_batches\": 10, \"no_cuda\": ' 'false, \"vote_on_accuracy\": ' 'true}', 'PYTORCH_XRAY': '{\"learning_rate\": 0.001, ' '\"steps_per_epoch\": 40, ' '\"vote_batches\": 10, \"no_cuda\": ' 'false, \"vote_on_accuracy\": true}'}} Then run python -m colearn_examples.grpc.run_grpc_demo on the other side to run the usual demo. The script takes as arguments the model name and dataset name that should be run, along with the number of learners and the data location for each learner. python -m colearn_examples.grpc.run_grpc_demo --n_learners 5 --dataloader_tag KERAS_MNIST --model_tag KERAS_MNIST \\ --data_locations /tmp/mnist/0,/tmp/mnist/1,/tmp/mnist/2,/tmp/mnist/3,/tmp/mnist/4","title":"Testing remotely"},{"location":"colearn/grpc_tutorial/#using-the-mli-factory-interface","text":"An alternative method of using your own dataloaders and models with the gRPC server is to use the MLI Factory interface. This is defined in colearn_grpc/mli_factory_interface.py . An example is given in colearn_examples/grpc/mlifactory_grpc_mnist.py . The MLI Factory is implemented as shown: dataloader_tag = \"KERAS_MNIST_EXAMPLE_DATALOADER\" model_tag = \"KERAS_MNIST_EXAMPLE_MODEL\" class SimpleFactory ( MliFactory ): def get_dataloaders ( self ) -> Dict [ str , Dict [ str , Any ]]: return { dataloader_tag : dict ( train_ratio = 0.9 , batch_size = 32 )} def get_models ( self ) -> Dict [ str , Dict [ str , Any ]]: return { model_tag : dict ( steps_per_epoch = 100 , vote_batches = 10 , learning_rate = 0.001 )} def get_compatibilities ( self ) -> Dict [ str , Set [ str ]]: return { model_tag : { dataloader_tag }} def get_mli ( self , model_name : str , model_params : str , dataloader_name : str , dataset_params : str ) -> MachineLearningInterface : dataloader_params = json . loads ( dataset_params ) data_loaders = prepare_data_loaders ( ** dataloader_params ) model_params = json . loads ( model_params ) mli_model = prepare_learner ( data_loaders = data_loaders , ** model_params ) return mli_model An instance of the SimpleFactory class needs to be passed to the gRPC server on creation: n_learners = 5 first_server_port = 9995 # make n servers server_processes = [] for i in range ( n_learners ): port = first_server_port + i server = GRPCServer ( mli_factory = SimpleFactory (), port = port ) server_process = Process ( target = server . run ) print ( \"starting server\" , i ) server_process . start () server_processes . append ( server_process ) The rest of the example follows the grpc_mnist.py example.","title":"Using the MLI Factory interface"},{"location":"colearn/installation/","text":"Installation The core package, colearn , contains only the MachineLearningInterface and a simple driver that implements the Collective Learning Protocol. To install only the core package: pip install colearn To make collective learning easier to use we have defined extra packages with helpers for model development in Keras and Pytorch. To install with Keras/Pytorch extras: pip install colearn[keras] pip install colearn[pytorch] To install both the Keras and Pytorch extras use: pip install colearn[all] To run stand-alone examples: python -m colearn_examples.ml_interface.run_demo For more examples see the Examples Page Installing From Source Alternatively, to install the latest code from the repo: Download the source code from github: git clone https://github.com/fetchai/colearn.git && cd colearn Create and launch a clean virtual environment with Python 3.7. (This library has currently only been tested with Python 3.7). pipenv --python 3 .7 && pipenv shell Install the package from source: pip install -e . [ all ] Run one of the examples: python colearn_examples/ml_interface/pytorch_mnist.py If you are developing the colearn library then install it in editable mode so that new changes are effective immediately: pip install -e .[all] Running the tests Tests can be run with: tox Documentation To run the documentation, first install mkdocs and plugins: pip install . [ docs ] Then run: mkdocs serve","title":"Installation"},{"location":"colearn/installation/#installation","text":"The core package, colearn , contains only the MachineLearningInterface and a simple driver that implements the Collective Learning Protocol. To install only the core package: pip install colearn To make collective learning easier to use we have defined extra packages with helpers for model development in Keras and Pytorch. To install with Keras/Pytorch extras: pip install colearn[keras] pip install colearn[pytorch] To install both the Keras and Pytorch extras use: pip install colearn[all] To run stand-alone examples: python -m colearn_examples.ml_interface.run_demo For more examples see the Examples Page","title":"Installation"},{"location":"colearn/installation/#installing-from-source","text":"Alternatively, to install the latest code from the repo: Download the source code from github: git clone https://github.com/fetchai/colearn.git && cd colearn Create and launch a clean virtual environment with Python 3.7. (This library has currently only been tested with Python 3.7). pipenv --python 3 .7 && pipenv shell Install the package from source: pip install -e . [ all ] Run one of the examples: python colearn_examples/ml_interface/pytorch_mnist.py If you are developing the colearn library then install it in editable mode so that new changes are effective immediately: pip install -e .[all]","title":"Installing From Source"},{"location":"colearn/installation/#running-the-tests","text":"Tests can be run with: tox","title":"Running the tests"},{"location":"colearn/installation/#documentation","text":"To run the documentation, first install mkdocs and plugins: pip install . [ docs ] Then run: mkdocs serve","title":"Documentation"},{"location":"colearn/intro_tutorial_keras/","text":"Using collective learning with keras This tutorial is a simple guide to trying out the collective learning protocol with your own machine learning code. Everything runs locally. The most flexible way to use the collective learning backends is to make a class that implements the Collective Learning MachineLearningInterface defined in ml_interface.py . For more details on how to use the MachineLearningInterface see here However, the simpler way is to use one of the helper classes that we have provided that implement most of the interface for popular ML libraries. In this tutorial we are going to walk through using the KerasLearner . First we are going to define the model architecture, then we are going to load the data and configure the model, and then we will run Collective Learning. A standard script for machine learning with Keras looks like the one below # ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ import tensorflow as tf import tensorflow_datasets as tfds from colearn_keras.utils import normalize_img n_rounds = 20 width = 28 height = 28 n_classes = 10 l_rate = 0.001 batch_size = 64 # Load the data train_dataset , info = tfds . load ( 'mnist' , split = 'train' , as_supervised = True , with_info = True ) n_train = info . splits [ 'train' ] . num_examples test_dataset = tfds . load ( 'mnist' , split = 'test' , as_supervised = True ) train_dataset = train_dataset . map ( normalize_img , num_parallel_calls = tf . data . experimental . AUTOTUNE ) train_dataset = train_dataset . shuffle ( n_train ) train_dataset = train_dataset . batch ( batch_size ) test_dataset = test_dataset . map ( normalize_img , num_parallel_calls = tf . data . experimental . AUTOTUNE ) test_dataset = test_dataset . batch ( batch_size ) # Define the model input_img = tf . keras . Input ( shape = ( width , height , 1 ), name = \"Input\" ) x = tf . keras . layers . Conv2D ( 64 , ( 3 , 3 ), activation = \"relu\" , padding = \"same\" , name = \"Conv1_1\" )( input_img ) x = tf . keras . layers . BatchNormalization ( name = \"bn1\" )( x ) x = tf . keras . layers . MaxPooling2D (( 2 , 2 ), name = \"pool1\" )( x ) x = tf . keras . layers . Conv2D ( 128 , ( 3 , 3 ), activation = \"relu\" , padding = \"same\" , name = \"Conv2_1\" )( x ) x = tf . keras . layers . BatchNormalization ( name = \"bn4\" )( x ) x = tf . keras . layers . MaxPooling2D (( 2 , 2 ), name = \"pool2\" )( x ) x = tf . keras . layers . Flatten ( name = \"flatten\" )( x ) x = tf . keras . layers . Dense ( n_classes , activation = \"softmax\" , name = \"fc1\" )( x ) model = tf . keras . Model ( inputs = input_img , outputs = x ) opt = tf . keras . optimizers . Adam ( lr = l_rate ) model . compile ( loss = \"sparse_categorical_crossentropy\" , metrics = [ tf . keras . metrics . SparseCategoricalAccuracy ()], optimizer = opt ) # Train and evaluate model for round in range ( n_rounds ): model . fit ( train_dataset , steps_per_epoch = 40 ) result = model . evaluate ( x = test_dataset , return_dict = True , steps = 10 ) print ( f \"Performance at round { round } is { result } \" ) There are three steps: Load the data Define the model Train the model In this tutorial we are going to see how to modify each step to use collective learning. We'll end up with code like this: # ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ import os import tensorflow as tf import tensorflow_datasets as tfds from colearn.training import initial_result , collective_learning_round , set_equal_weights from colearn.utils.plot import ColearnPlot from colearn.utils.results import Results , print_results from colearn_keras.keras_learner import KerasLearner from colearn_keras.utils import normalize_img \"\"\" MNIST training example using Keras Used dataset: - MNIST is set of 60 000 black and white hand written digits images of size 28x28x1 in 10 classes What script does: - Loads MNIST dataset from Keras - Sets up a Keras learner - Randomly splits dataset between multiple learners - Does multiple rounds of learning process and displays plot with results \"\"\" n_learners = 5 vote_threshold = 0.5 vote_batches = 2 testing_mode = bool ( os . getenv ( \"COLEARN_EXAMPLES_TEST\" , \"\" )) # for testing n_rounds = 20 if not testing_mode else 1 width = 28 height = 28 n_classes = 10 l_rate = 0.001 batch_size = 64 # Load data for each learner train_dataset , info = tfds . load ( 'mnist' , split = 'train' , as_supervised = True , with_info = True ) n_datapoints = info . splits [ 'train' ] . num_examples train_datasets = [ train_dataset . shard ( num_shards = n_learners , index = i ) for i in range ( n_learners )] test_dataset = tfds . load ( 'mnist' , split = 'test' , as_supervised = True ) test_datasets = [ test_dataset . shard ( num_shards = n_learners , index = i ) for i in range ( n_learners )] for i in range ( n_learners ): train_datasets [ i ] = train_datasets [ i ] . map ( normalize_img , num_parallel_calls = tf . data . experimental . AUTOTUNE ) train_datasets [ i ] = train_datasets [ i ] . shuffle ( n_datapoints // n_learners ) train_datasets [ i ] = train_datasets [ i ] . batch ( batch_size ) test_datasets [ i ] = test_datasets [ i ] . map ( normalize_img , num_parallel_calls = tf . data . experimental . AUTOTUNE ) test_datasets [ i ] = test_datasets [ i ] . batch ( batch_size ) # Define model def get_model (): input_img = tf . keras . Input ( shape = ( width , height , 1 ), name = \"Input\" ) x = tf . keras . layers . Conv2D ( 64 , ( 3 , 3 ), activation = \"relu\" , padding = \"same\" , name = \"Conv1_1\" )( input_img ) x = tf . keras . layers . BatchNormalization ( name = \"bn1\" )( x ) x = tf . keras . layers . MaxPooling2D (( 2 , 2 ), name = \"pool1\" )( x ) x = tf . keras . layers . Conv2D ( 128 , ( 3 , 3 ), activation = \"relu\" , padding = \"same\" , name = \"Conv2_1\" )( x ) x = tf . keras . layers . BatchNormalization ( name = \"bn4\" )( x ) x = tf . keras . layers . MaxPooling2D (( 2 , 2 ), name = \"pool2\" )( x ) x = tf . keras . layers . Flatten ( name = \"flatten\" )( x ) x = tf . keras . layers . Dense ( n_classes , activation = \"softmax\" , name = \"fc1\" )( x ) model = tf . keras . Model ( inputs = input_img , outputs = x ) opt = tf . keras . optimizers . Adam ( lr = l_rate ) model . compile ( loss = \"sparse_categorical_crossentropy\" , metrics = [ tf . keras . metrics . SparseCategoricalAccuracy ()], optimizer = opt ) return model all_learner_models = [] for i in range ( n_learners ): all_learner_models . append ( KerasLearner ( model = get_model (), train_loader = train_datasets [ i ], test_loader = test_datasets [ i ], criterion = \"sparse_categorical_accuracy\" , minimise_criterion = False , model_evaluate_kwargs = { \"steps\" : vote_batches }, )) set_equal_weights ( all_learner_models ) # Train the model using Collective Learning results = Results () results . data . append ( initial_result ( all_learner_models )) plot = ColearnPlot ( score_name = all_learner_models [ 0 ] . criterion ) for round_index in range ( n_rounds ): results . data . append ( collective_learning_round ( all_learner_models , vote_threshold , round_index ) ) print_results ( results ) plot . plot_results_and_votes ( results ) plot . block () print ( \"Colearn Example Finished!\" ) The first thing is to modify the data loading code. Each learner needs to have their own training and testing set from the data. This is easy to do with keras: train_datasets = [ train_dataset . shard ( num_shards = n_learners , index = i ) for i in range ( n_learners )] The model definition is very similar too, except that each learner will need its own copy of the model, so we've moved it into a function. To use collective learning, we need to create an object that implements the MachineLearningInterface. To make it easier to use the MachineLearningInterface with keras, we've defined KerasLearner . KerasLearner implements standard training and evaluation routines as well as the MachineLearningInterface methods. # ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ from inspect import signature from typing import Optional try : import tensorflow as tf except ImportError : raise Exception ( \"Tensorflow is not installed. To use the tensorflow/keras \" \"add-ons please install colearn with `pip install colearn[keras]`.\" ) from tensorflow import keras from colearn.ml_interface import MachineLearningInterface , Weights , ProposedWeights class KerasLearner ( MachineLearningInterface ): \"\"\" Tensorflow Keras learner implementation of machine learning interface \"\"\" def __init__ ( self , model : keras . Model , train_loader : tf . data . Dataset , test_loader : Optional [ tf . data . Dataset ] = None , minimise_criterion : bool = True , criterion : str = 'loss' , model_fit_kwargs : Optional [ dict ] = None , model_evaluate_kwargs : Optional [ dict ] = None ): \"\"\" :param model: Keras model used for training :param train_loader: Training dataset :param test_loader: Optional test set. Subset of training set will be used if not specified. :param minimise_criterion: Boolean - True to minimise value of criterion, False to maximise :param criterion: Function to measure model performance :param model_fit_kwargs: Arguments to be passed on model.fit function call :param model_evaluate_kwargs: Arguments to be passed on model.evaluate function call \"\"\" self . model : keras . Model = model self . train_loader : tf . data . Dataset = train_loader self . test_loader : Optional [ tf . data . Dataset ] = test_loader self . minimise_criterion : bool = minimise_criterion self . criterion = criterion self . model_fit_kwargs = model_fit_kwargs or {} if model_fit_kwargs : # check that these are valid kwargs for model fit sig = signature ( self . model . fit ) try : sig . bind_partial ( ** self . model_fit_kwargs ) except TypeError : raise Exception ( \"Invalid arguments for model.fit\" ) self . model_evaluate_kwargs = model_evaluate_kwargs or {} if model_evaluate_kwargs : # check that these are valid kwargs for model evaluate sig = signature ( self . model . evaluate ) try : sig . bind_partial ( ** self . model_evaluate_kwargs ) except TypeError : raise Exception ( \"Invalid arguments for model.evaluate\" ) self . vote_score : float = self . test ( self . train_loader ) def mli_propose_weights ( self ) -> Weights : \"\"\" Trains model on training set and returns new weights after training - Current model is reverted to original state after training :return: Weights after training \"\"\" current_weights = self . mli_get_current_weights () self . train () new_weights = self . mli_get_current_weights () self . set_weights ( current_weights ) return new_weights def mli_test_weights ( self , weights : Weights ) -> ProposedWeights : \"\"\" Tests given weights on training and test set and returns weights with score values :param weights: Weights to be tested :return: ProposedWeights - Weights with vote and test score \"\"\" current_weights = self . mli_get_current_weights () self . set_weights ( weights ) vote_score = self . test ( self . train_loader ) if self . test_loader : test_score = self . test ( self . test_loader ) else : test_score = 0 vote = self . vote ( vote_score ) self . set_weights ( current_weights ) return ProposedWeights ( weights = weights , vote_score = vote_score , test_score = test_score , vote = vote ) def vote ( self , new_score ) -> bool : \"\"\" Compares current model score with proposed model score and returns vote :param new_score: Proposed score :return: bool positive or negative vote \"\"\" if self . minimise_criterion : return new_score < self . vote_score else : return new_score > self . vote_score def mli_accept_weights ( self , weights : Weights ): \"\"\" Updates the model with the proposed set of weights :param weights: The new weights \"\"\" self . set_weights ( weights ) self . vote_score = self . test ( self . train_loader ) def mli_get_current_weights ( self ) -> Weights : \"\"\" :return: The current weights of the model \"\"\" return Weights ( weights = self . model . get_weights ()) def set_weights ( self , weights : Weights ): \"\"\" Rewrites weight of current model :param weights: Weights to be stored \"\"\" self . model . set_weights ( weights . weights ) def train ( self ): \"\"\" Trains the model on the training dataset \"\"\" self . model . fit ( self . train_loader , ** self . model_fit_kwargs ) def test ( self , loader : tf . data . Dataset ) -> float : \"\"\" Tests performance of the model on specified dataset :param loader: Dataset for testing :return: Value of performance metric \"\"\" result = self . model . evaluate ( x = loader , return_dict = True , ** self . model_evaluate_kwargs ) return result [ self . criterion ] We create a set of KerasLearners by passing in the model and the datasets: all_learner_models = [] for i in range ( n_learners ): all_learner_models . append ( KerasLearner ( model = get_model (), train_loader = train_datasets [ i ], test_loader = test_datasets [ i ], criterion = \"sparse_categorical_accuracy\" , minimise_criterion = False , model_evaluate_kwargs = { \"steps\" : vote_batches }, )) Then we give all the models the same weights to start off with: set_equal_weights ( all_learner_models ) And then we can move on to the final stage, which is training with Collective Learning. The function collective_learning_round performs one round of collective learning. One learner is selected to train and propose an update. The other learners vote on the update, and if the vote passes then the update is accepted. Then a new round begins. # Train the model using Collective Learning results = Results () results . data . append ( initial_result ( all_learner_models )) for round in range ( n_rounds ): results . data . append ( collective_learning_round ( all_learner_models , vote_threshold , round ) ) plot_results ( results , n_learners , block = False , score_name = all_learner_models [ 0 ] . criterion ) plot_votes ( results , block = False ) plot_results ( results , n_learners , block = False , score_name = all_learner_models [ 0 ] . criterion ) plot_votes ( results , block = True )","title":"Keras"},{"location":"colearn/intro_tutorial_keras/#using-collective-learning-with-keras","text":"This tutorial is a simple guide to trying out the collective learning protocol with your own machine learning code. Everything runs locally. The most flexible way to use the collective learning backends is to make a class that implements the Collective Learning MachineLearningInterface defined in ml_interface.py . For more details on how to use the MachineLearningInterface see here However, the simpler way is to use one of the helper classes that we have provided that implement most of the interface for popular ML libraries. In this tutorial we are going to walk through using the KerasLearner . First we are going to define the model architecture, then we are going to load the data and configure the model, and then we will run Collective Learning. A standard script for machine learning with Keras looks like the one below # ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ import tensorflow as tf import tensorflow_datasets as tfds from colearn_keras.utils import normalize_img n_rounds = 20 width = 28 height = 28 n_classes = 10 l_rate = 0.001 batch_size = 64 # Load the data train_dataset , info = tfds . load ( 'mnist' , split = 'train' , as_supervised = True , with_info = True ) n_train = info . splits [ 'train' ] . num_examples test_dataset = tfds . load ( 'mnist' , split = 'test' , as_supervised = True ) train_dataset = train_dataset . map ( normalize_img , num_parallel_calls = tf . data . experimental . AUTOTUNE ) train_dataset = train_dataset . shuffle ( n_train ) train_dataset = train_dataset . batch ( batch_size ) test_dataset = test_dataset . map ( normalize_img , num_parallel_calls = tf . data . experimental . AUTOTUNE ) test_dataset = test_dataset . batch ( batch_size ) # Define the model input_img = tf . keras . Input ( shape = ( width , height , 1 ), name = \"Input\" ) x = tf . keras . layers . Conv2D ( 64 , ( 3 , 3 ), activation = \"relu\" , padding = \"same\" , name = \"Conv1_1\" )( input_img ) x = tf . keras . layers . BatchNormalization ( name = \"bn1\" )( x ) x = tf . keras . layers . MaxPooling2D (( 2 , 2 ), name = \"pool1\" )( x ) x = tf . keras . layers . Conv2D ( 128 , ( 3 , 3 ), activation = \"relu\" , padding = \"same\" , name = \"Conv2_1\" )( x ) x = tf . keras . layers . BatchNormalization ( name = \"bn4\" )( x ) x = tf . keras . layers . MaxPooling2D (( 2 , 2 ), name = \"pool2\" )( x ) x = tf . keras . layers . Flatten ( name = \"flatten\" )( x ) x = tf . keras . layers . Dense ( n_classes , activation = \"softmax\" , name = \"fc1\" )( x ) model = tf . keras . Model ( inputs = input_img , outputs = x ) opt = tf . keras . optimizers . Adam ( lr = l_rate ) model . compile ( loss = \"sparse_categorical_crossentropy\" , metrics = [ tf . keras . metrics . SparseCategoricalAccuracy ()], optimizer = opt ) # Train and evaluate model for round in range ( n_rounds ): model . fit ( train_dataset , steps_per_epoch = 40 ) result = model . evaluate ( x = test_dataset , return_dict = True , steps = 10 ) print ( f \"Performance at round { round } is { result } \" ) There are three steps: Load the data Define the model Train the model In this tutorial we are going to see how to modify each step to use collective learning. We'll end up with code like this: # ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ import os import tensorflow as tf import tensorflow_datasets as tfds from colearn.training import initial_result , collective_learning_round , set_equal_weights from colearn.utils.plot import ColearnPlot from colearn.utils.results import Results , print_results from colearn_keras.keras_learner import KerasLearner from colearn_keras.utils import normalize_img \"\"\" MNIST training example using Keras Used dataset: - MNIST is set of 60 000 black and white hand written digits images of size 28x28x1 in 10 classes What script does: - Loads MNIST dataset from Keras - Sets up a Keras learner - Randomly splits dataset between multiple learners - Does multiple rounds of learning process and displays plot with results \"\"\" n_learners = 5 vote_threshold = 0.5 vote_batches = 2 testing_mode = bool ( os . getenv ( \"COLEARN_EXAMPLES_TEST\" , \"\" )) # for testing n_rounds = 20 if not testing_mode else 1 width = 28 height = 28 n_classes = 10 l_rate = 0.001 batch_size = 64 # Load data for each learner train_dataset , info = tfds . load ( 'mnist' , split = 'train' , as_supervised = True , with_info = True ) n_datapoints = info . splits [ 'train' ] . num_examples train_datasets = [ train_dataset . shard ( num_shards = n_learners , index = i ) for i in range ( n_learners )] test_dataset = tfds . load ( 'mnist' , split = 'test' , as_supervised = True ) test_datasets = [ test_dataset . shard ( num_shards = n_learners , index = i ) for i in range ( n_learners )] for i in range ( n_learners ): train_datasets [ i ] = train_datasets [ i ] . map ( normalize_img , num_parallel_calls = tf . data . experimental . AUTOTUNE ) train_datasets [ i ] = train_datasets [ i ] . shuffle ( n_datapoints // n_learners ) train_datasets [ i ] = train_datasets [ i ] . batch ( batch_size ) test_datasets [ i ] = test_datasets [ i ] . map ( normalize_img , num_parallel_calls = tf . data . experimental . AUTOTUNE ) test_datasets [ i ] = test_datasets [ i ] . batch ( batch_size ) # Define model def get_model (): input_img = tf . keras . Input ( shape = ( width , height , 1 ), name = \"Input\" ) x = tf . keras . layers . Conv2D ( 64 , ( 3 , 3 ), activation = \"relu\" , padding = \"same\" , name = \"Conv1_1\" )( input_img ) x = tf . keras . layers . BatchNormalization ( name = \"bn1\" )( x ) x = tf . keras . layers . MaxPooling2D (( 2 , 2 ), name = \"pool1\" )( x ) x = tf . keras . layers . Conv2D ( 128 , ( 3 , 3 ), activation = \"relu\" , padding = \"same\" , name = \"Conv2_1\" )( x ) x = tf . keras . layers . BatchNormalization ( name = \"bn4\" )( x ) x = tf . keras . layers . MaxPooling2D (( 2 , 2 ), name = \"pool2\" )( x ) x = tf . keras . layers . Flatten ( name = \"flatten\" )( x ) x = tf . keras . layers . Dense ( n_classes , activation = \"softmax\" , name = \"fc1\" )( x ) model = tf . keras . Model ( inputs = input_img , outputs = x ) opt = tf . keras . optimizers . Adam ( lr = l_rate ) model . compile ( loss = \"sparse_categorical_crossentropy\" , metrics = [ tf . keras . metrics . SparseCategoricalAccuracy ()], optimizer = opt ) return model all_learner_models = [] for i in range ( n_learners ): all_learner_models . append ( KerasLearner ( model = get_model (), train_loader = train_datasets [ i ], test_loader = test_datasets [ i ], criterion = \"sparse_categorical_accuracy\" , minimise_criterion = False , model_evaluate_kwargs = { \"steps\" : vote_batches }, )) set_equal_weights ( all_learner_models ) # Train the model using Collective Learning results = Results () results . data . append ( initial_result ( all_learner_models )) plot = ColearnPlot ( score_name = all_learner_models [ 0 ] . criterion ) for round_index in range ( n_rounds ): results . data . append ( collective_learning_round ( all_learner_models , vote_threshold , round_index ) ) print_results ( results ) plot . plot_results_and_votes ( results ) plot . block () print ( \"Colearn Example Finished!\" ) The first thing is to modify the data loading code. Each learner needs to have their own training and testing set from the data. This is easy to do with keras: train_datasets = [ train_dataset . shard ( num_shards = n_learners , index = i ) for i in range ( n_learners )] The model definition is very similar too, except that each learner will need its own copy of the model, so we've moved it into a function. To use collective learning, we need to create an object that implements the MachineLearningInterface. To make it easier to use the MachineLearningInterface with keras, we've defined KerasLearner . KerasLearner implements standard training and evaluation routines as well as the MachineLearningInterface methods. # ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ from inspect import signature from typing import Optional try : import tensorflow as tf except ImportError : raise Exception ( \"Tensorflow is not installed. To use the tensorflow/keras \" \"add-ons please install colearn with `pip install colearn[keras]`.\" ) from tensorflow import keras from colearn.ml_interface import MachineLearningInterface , Weights , ProposedWeights class KerasLearner ( MachineLearningInterface ): \"\"\" Tensorflow Keras learner implementation of machine learning interface \"\"\" def __init__ ( self , model : keras . Model , train_loader : tf . data . Dataset , test_loader : Optional [ tf . data . Dataset ] = None , minimise_criterion : bool = True , criterion : str = 'loss' , model_fit_kwargs : Optional [ dict ] = None , model_evaluate_kwargs : Optional [ dict ] = None ): \"\"\" :param model: Keras model used for training :param train_loader: Training dataset :param test_loader: Optional test set. Subset of training set will be used if not specified. :param minimise_criterion: Boolean - True to minimise value of criterion, False to maximise :param criterion: Function to measure model performance :param model_fit_kwargs: Arguments to be passed on model.fit function call :param model_evaluate_kwargs: Arguments to be passed on model.evaluate function call \"\"\" self . model : keras . Model = model self . train_loader : tf . data . Dataset = train_loader self . test_loader : Optional [ tf . data . Dataset ] = test_loader self . minimise_criterion : bool = minimise_criterion self . criterion = criterion self . model_fit_kwargs = model_fit_kwargs or {} if model_fit_kwargs : # check that these are valid kwargs for model fit sig = signature ( self . model . fit ) try : sig . bind_partial ( ** self . model_fit_kwargs ) except TypeError : raise Exception ( \"Invalid arguments for model.fit\" ) self . model_evaluate_kwargs = model_evaluate_kwargs or {} if model_evaluate_kwargs : # check that these are valid kwargs for model evaluate sig = signature ( self . model . evaluate ) try : sig . bind_partial ( ** self . model_evaluate_kwargs ) except TypeError : raise Exception ( \"Invalid arguments for model.evaluate\" ) self . vote_score : float = self . test ( self . train_loader ) def mli_propose_weights ( self ) -> Weights : \"\"\" Trains model on training set and returns new weights after training - Current model is reverted to original state after training :return: Weights after training \"\"\" current_weights = self . mli_get_current_weights () self . train () new_weights = self . mli_get_current_weights () self . set_weights ( current_weights ) return new_weights def mli_test_weights ( self , weights : Weights ) -> ProposedWeights : \"\"\" Tests given weights on training and test set and returns weights with score values :param weights: Weights to be tested :return: ProposedWeights - Weights with vote and test score \"\"\" current_weights = self . mli_get_current_weights () self . set_weights ( weights ) vote_score = self . test ( self . train_loader ) if self . test_loader : test_score = self . test ( self . test_loader ) else : test_score = 0 vote = self . vote ( vote_score ) self . set_weights ( current_weights ) return ProposedWeights ( weights = weights , vote_score = vote_score , test_score = test_score , vote = vote ) def vote ( self , new_score ) -> bool : \"\"\" Compares current model score with proposed model score and returns vote :param new_score: Proposed score :return: bool positive or negative vote \"\"\" if self . minimise_criterion : return new_score < self . vote_score else : return new_score > self . vote_score def mli_accept_weights ( self , weights : Weights ): \"\"\" Updates the model with the proposed set of weights :param weights: The new weights \"\"\" self . set_weights ( weights ) self . vote_score = self . test ( self . train_loader ) def mli_get_current_weights ( self ) -> Weights : \"\"\" :return: The current weights of the model \"\"\" return Weights ( weights = self . model . get_weights ()) def set_weights ( self , weights : Weights ): \"\"\" Rewrites weight of current model :param weights: Weights to be stored \"\"\" self . model . set_weights ( weights . weights ) def train ( self ): \"\"\" Trains the model on the training dataset \"\"\" self . model . fit ( self . train_loader , ** self . model_fit_kwargs ) def test ( self , loader : tf . data . Dataset ) -> float : \"\"\" Tests performance of the model on specified dataset :param loader: Dataset for testing :return: Value of performance metric \"\"\" result = self . model . evaluate ( x = loader , return_dict = True , ** self . model_evaluate_kwargs ) return result [ self . criterion ] We create a set of KerasLearners by passing in the model and the datasets: all_learner_models = [] for i in range ( n_learners ): all_learner_models . append ( KerasLearner ( model = get_model (), train_loader = train_datasets [ i ], test_loader = test_datasets [ i ], criterion = \"sparse_categorical_accuracy\" , minimise_criterion = False , model_evaluate_kwargs = { \"steps\" : vote_batches }, )) Then we give all the models the same weights to start off with: set_equal_weights ( all_learner_models ) And then we can move on to the final stage, which is training with Collective Learning. The function collective_learning_round performs one round of collective learning. One learner is selected to train and propose an update. The other learners vote on the update, and if the vote passes then the update is accepted. Then a new round begins. # Train the model using Collective Learning results = Results () results . data . append ( initial_result ( all_learner_models )) for round in range ( n_rounds ): results . data . append ( collective_learning_round ( all_learner_models , vote_threshold , round ) ) plot_results ( results , n_learners , block = False , score_name = all_learner_models [ 0 ] . criterion ) plot_votes ( results , block = False ) plot_results ( results , n_learners , block = False , score_name = all_learner_models [ 0 ] . criterion ) plot_votes ( results , block = True )","title":"Using collective learning with keras"},{"location":"colearn/intro_tutorial_mli/","text":"Using collective learning This tutorial is a simple guide to trying out the collective learning protocol with your own machine learning code. Everything runs locally. The most flexible way to use the collective learning backends is to make a class that implements the Collective Learning MachineLearningInterface defined in ml_interface.py . This tutorial will walk through implementing the MachineLearningInterface . If you're already using keras or pytorch you might find it easier to use the KerasLearner or Pytorchlearner classes. See the other tutorials for details of how to do that. The MachineLearningInterface # ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ import abc from typing import Any from pydantic import BaseModel class Weights ( BaseModel ): weights : Any class ProposedWeights ( BaseModel ): weights : Weights vote_score : float test_score : float vote : bool class MachineLearningInterface ( abc . ABC ): @abc . abstractmethod def mli_propose_weights ( self ) -> Weights : \"\"\" Trains the model. Returns new weights. Does not change the current weights of the model. \"\"\" pass @abc . abstractmethod def mli_test_weights ( self , weights : Weights ) -> ProposedWeights : \"\"\" Tests the proposed weights and fills in the rest of the fields \"\"\" @abc . abstractmethod def mli_accept_weights ( self , weights : Weights ): \"\"\" Updates the model with the proposed set of weights :param weights: The new weights \"\"\" pass @abc . abstractmethod def mli_get_current_weights ( self ) -> Weights : \"\"\" Returns the current weights of the model \"\"\" pass There are four methods that need to be implemented: propose_weights causes the model to do some training and then return a new set of weights that are proposed to the other learners. This method shouldn't charge the current weights of the model - that only happens when accept_weights is called. test_weights - the models takes some new weights and returns a vote on whether the new weights are an improvement. As in propose_weights, this shouldn't change the current weights of the model - that only happens when accept_weights is called. accept_weights - the model accepts some weights that have been voted on and approved by the set of learners. The old weighs of the model are discarded and replaced by the new weights. current_weights should return the current weights of the model. Algorithms that work with colearn: These conditions need to be fulfilled for algorithms to work with collective learning: Model fitting must be incremental so that the previous model is used as the starting point for training. This is easy to achieve for neural networks because neural network training is always iterative, but for other learning algorithms more care must be taken. Some examples of getting this wrong: from sklearn.linear_model import LinearRegression model = LinearRegression () model . fit ( X , y ) from sklearn.ensemble import RandomForestClassifier model = RandomForestClassifier ( n_estimators = 10 ) # it would be okay with warm_start=True model . fit ( X , y ) from xgboost import XGBRegressor model = XGBRegressor () model . fit ( X , y ) None of the training methods here use the previous result when fit is called for a second time; instead they start again from scratch. Good examples of incremental training can be seen in the examples . Many sklearn models have a warm_start parameter which can be set to True to use the previous training result. XGBoost has an xgb_model parameter for passing in the previous training results. The model mustn't overfit when propose_weights() is called. You should limit training so that a learner will not overfit their training data in one round. For example, if a learner overfits their own training data then the other learners will reject the proposed update because it is not a good fit for their data. For a neural network a good approach is to restrict the number of batches that are used each round; for random forest, restrict the trees that are added each round. Implementation for fraud detection task Here is the class that implements the MachineLearningInterface for the task of detecting fraud in bank transactions. class FraudSklearnLearner ( MachineLearningInterface ): def __init__ ( self , train_data , train_labels , test_data , test_labels , batch_size : int = 10000 , steps_per_round : int = 1 ): self . steps_per_round = steps_per_round self . batch_size = batch_size self . train_data = train_data self . train_labels = train_labels self . test_data = test_data self . test_labels = test_labels self . class_labels = np . unique ( train_labels ) self . train_sampler = infinite_batch_sampler ( train_data . shape [ 0 ], batch_size ) self . model = SGDClassifier ( max_iter = 1 , verbose = 0 , loss = \"modified_huber\" ) self . model . partial_fit ( self . train_data [ 0 : 1 ], self . train_labels [ 0 : 1 ], classes = self . class_labels ) # this needs to be called before predict self . vote_score = self . test ( self . train_data , self . train_labels ) def mli_propose_weights ( self ) -> Weights : current_weights = self . mli_get_current_weights () for i in range ( self . steps_per_round ): batch_indices = next ( self . train_sampler ) train_data = self . train_data [ batch_indices ] train_labels = self . train_labels [ batch_indices ] self . model . partial_fit ( train_data , train_labels , classes = self . class_labels ) new_weights = self . mli_get_current_weights () self . set_weights ( current_weights ) return new_weights def mli_test_weights ( self , weights : Weights ) -> ProposedWeights : current_weights = self . mli_get_current_weights () self . set_weights ( weights ) vote_score = self . test ( self . train_data , self . train_labels ) test_score = self . test ( self . test_data , self . test_labels ) vote = self . vote_score <= vote_score self . set_weights ( current_weights ) return ProposedWeights ( weights = weights , vote_score = vote_score , test_score = test_score , vote = vote ) def mli_accept_weights ( self , weights : Weights ): self . set_weights ( weights ) self . vote_score = self . test ( self . train_data , self . train_labels ) def mli_get_current_weights ( self ): # return Weights(weights=copy.deepcopy(self.model)) return Weights ( weights = dict ( coef_ = self . model . coef_ , intercept_ = self . model . intercept_ )) def set_weights ( self , weights : Weights ): # self.model = weights.weights self . model . coef_ = weights . weights [ 'coef_' ] self . model . intercept_ = weights . weights [ 'intercept_' ] def test ( self , data , labels ): try : return self . model . score ( data , labels ) except sklearn . exceptions . NotFittedError : return 0 Let's step through this and see how it works. The propose_weights method saves the current weights of the model. Then it performs some training of the model, and gets the new weights. It returns the new weights, and resets the model weights to be the old weights. def mli_propose_weights ( self ) -> Weights : current_weights = self . mli_get_current_weights () for i in range ( self . steps_per_round ): batch_indices = next ( self . train_sampler ) train_data = self . train_data [ batch_indices ] train_labels = self . train_labels [ batch_indices ] self . model . partial_fit ( train_data , train_labels , classes = self . class_labels ) new_weights = self . mli_get_current_weights () self . set_weights ( current_weights ) return new_weights The test_weights method takes as a parameter the proposed weights that it needs to vote on. It saves the current weights of the model, and then sets the model weights to be the proposed weights. It tests the model and votes based on whether the score that it is monitoring has improved. The vote score can be any metric that you like. You could use loss, accuracy, mean squared error or any custom metric. If the vote score is the loss then the model would only vote True if the score has decreased. Here we're using accuracy, so the vote is true if the score increases. This method then resets the weights to the old values and returns the vote along with some scores for monitoring purposes. def mli_test_weights ( self , weights : Weights ) -> ProposedWeights : current_weights = self . mli_get_current_weights () self . set_weights ( weights ) vote_score = self . test ( self . train_data , self . train_labels ) test_score = self . test ( self . test_data , self . test_labels ) vote = self . vote_score <= vote_score self . set_weights ( current_weights ) return ProposedWeights ( weights = weights , vote_score = vote_score , test_score = test_score , vote = vote ) The accept_weights method sets the weights of the model to be the new weights. It also updates the vote score to be the current performance. Note You could implement a cache here. These weights will already have been tested in test_weights, so the vote score could be retrieved from the cache instead of recomputed. def mli_accept_weights ( self , weights : Weights ): self . set_weights ( weights ) self . vote_score = self . test ( self . train_data , self . train_labels ) The final method is the simplest - get_current_weights just returns the current weights of the model. These weights are wrapped inside a Weights object. def mli_get_current_weights ( self ): return Weights ( weights = dict ( coef_ = self . model . coef_ , intercept_ = self . model . intercept_ )) The rest of the example The data is loaded and preprocessed and then split into equal parts for each learner. Then a list of FraudLearner instances is created, each with its own dataset. all_learner_models = [] for i in range ( n_learners ): all_learner_models . append ( FraudLearner ( train_data = learner_train_data [ i ], train_labels = learner_train_labels [ i ], test_data = learner_test_data [ i ], test_labels = learner_test_labels [ i ] )) Then we give all the models the same weights to start off with: set_equal_weights ( all_learner_models ) And then we can move on to the final stage, which is training with Collective Learning. The function collective_learning_round performs one round of collective learning. One learner is selected to train and propose an update. The other learners vote on the update, and if the vote passes then the update is accepted. Then a new round begins. # Train the model using Collective Learning results = Results () results . data . append ( initial_result ( all_learner_models )) for round in range ( n_rounds ): results . data . append ( collective_learning_round ( all_learner_models , vote_threshold , round ) ) plot_results ( results , n_learners , block = False , score_name = all_learner_models [ 0 ] . criterion ) plot_votes ( results , block = False ) plot_results ( results , n_learners , block = False , score_name = all_learner_models [ 0 ] . criterion ) plot_votes ( results , block = True )","title":"The MachineLearningInterface"},{"location":"colearn/intro_tutorial_mli/#using-collective-learning","text":"This tutorial is a simple guide to trying out the collective learning protocol with your own machine learning code. Everything runs locally. The most flexible way to use the collective learning backends is to make a class that implements the Collective Learning MachineLearningInterface defined in ml_interface.py . This tutorial will walk through implementing the MachineLearningInterface . If you're already using keras or pytorch you might find it easier to use the KerasLearner or Pytorchlearner classes. See the other tutorials for details of how to do that.","title":"Using collective learning"},{"location":"colearn/intro_tutorial_mli/#the-machinelearninginterface","text":"# ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ import abc from typing import Any from pydantic import BaseModel class Weights ( BaseModel ): weights : Any class ProposedWeights ( BaseModel ): weights : Weights vote_score : float test_score : float vote : bool class MachineLearningInterface ( abc . ABC ): @abc . abstractmethod def mli_propose_weights ( self ) -> Weights : \"\"\" Trains the model. Returns new weights. Does not change the current weights of the model. \"\"\" pass @abc . abstractmethod def mli_test_weights ( self , weights : Weights ) -> ProposedWeights : \"\"\" Tests the proposed weights and fills in the rest of the fields \"\"\" @abc . abstractmethod def mli_accept_weights ( self , weights : Weights ): \"\"\" Updates the model with the proposed set of weights :param weights: The new weights \"\"\" pass @abc . abstractmethod def mli_get_current_weights ( self ) -> Weights : \"\"\" Returns the current weights of the model \"\"\" pass There are four methods that need to be implemented: propose_weights causes the model to do some training and then return a new set of weights that are proposed to the other learners. This method shouldn't charge the current weights of the model - that only happens when accept_weights is called. test_weights - the models takes some new weights and returns a vote on whether the new weights are an improvement. As in propose_weights, this shouldn't change the current weights of the model - that only happens when accept_weights is called. accept_weights - the model accepts some weights that have been voted on and approved by the set of learners. The old weighs of the model are discarded and replaced by the new weights. current_weights should return the current weights of the model.","title":"The MachineLearningInterface"},{"location":"colearn/intro_tutorial_mli/#algorithms-that-work-with-colearn","text":"These conditions need to be fulfilled for algorithms to work with collective learning: Model fitting must be incremental so that the previous model is used as the starting point for training. This is easy to achieve for neural networks because neural network training is always iterative, but for other learning algorithms more care must be taken. Some examples of getting this wrong: from sklearn.linear_model import LinearRegression model = LinearRegression () model . fit ( X , y ) from sklearn.ensemble import RandomForestClassifier model = RandomForestClassifier ( n_estimators = 10 ) # it would be okay with warm_start=True model . fit ( X , y ) from xgboost import XGBRegressor model = XGBRegressor () model . fit ( X , y ) None of the training methods here use the previous result when fit is called for a second time; instead they start again from scratch. Good examples of incremental training can be seen in the examples . Many sklearn models have a warm_start parameter which can be set to True to use the previous training result. XGBoost has an xgb_model parameter for passing in the previous training results. The model mustn't overfit when propose_weights() is called. You should limit training so that a learner will not overfit their training data in one round. For example, if a learner overfits their own training data then the other learners will reject the proposed update because it is not a good fit for their data. For a neural network a good approach is to restrict the number of batches that are used each round; for random forest, restrict the trees that are added each round.","title":"Algorithms that work with colearn:"},{"location":"colearn/intro_tutorial_mli/#implementation-for-fraud-detection-task","text":"Here is the class that implements the MachineLearningInterface for the task of detecting fraud in bank transactions. class FraudSklearnLearner ( MachineLearningInterface ): def __init__ ( self , train_data , train_labels , test_data , test_labels , batch_size : int = 10000 , steps_per_round : int = 1 ): self . steps_per_round = steps_per_round self . batch_size = batch_size self . train_data = train_data self . train_labels = train_labels self . test_data = test_data self . test_labels = test_labels self . class_labels = np . unique ( train_labels ) self . train_sampler = infinite_batch_sampler ( train_data . shape [ 0 ], batch_size ) self . model = SGDClassifier ( max_iter = 1 , verbose = 0 , loss = \"modified_huber\" ) self . model . partial_fit ( self . train_data [ 0 : 1 ], self . train_labels [ 0 : 1 ], classes = self . class_labels ) # this needs to be called before predict self . vote_score = self . test ( self . train_data , self . train_labels ) def mli_propose_weights ( self ) -> Weights : current_weights = self . mli_get_current_weights () for i in range ( self . steps_per_round ): batch_indices = next ( self . train_sampler ) train_data = self . train_data [ batch_indices ] train_labels = self . train_labels [ batch_indices ] self . model . partial_fit ( train_data , train_labels , classes = self . class_labels ) new_weights = self . mli_get_current_weights () self . set_weights ( current_weights ) return new_weights def mli_test_weights ( self , weights : Weights ) -> ProposedWeights : current_weights = self . mli_get_current_weights () self . set_weights ( weights ) vote_score = self . test ( self . train_data , self . train_labels ) test_score = self . test ( self . test_data , self . test_labels ) vote = self . vote_score <= vote_score self . set_weights ( current_weights ) return ProposedWeights ( weights = weights , vote_score = vote_score , test_score = test_score , vote = vote ) def mli_accept_weights ( self , weights : Weights ): self . set_weights ( weights ) self . vote_score = self . test ( self . train_data , self . train_labels ) def mli_get_current_weights ( self ): # return Weights(weights=copy.deepcopy(self.model)) return Weights ( weights = dict ( coef_ = self . model . coef_ , intercept_ = self . model . intercept_ )) def set_weights ( self , weights : Weights ): # self.model = weights.weights self . model . coef_ = weights . weights [ 'coef_' ] self . model . intercept_ = weights . weights [ 'intercept_' ] def test ( self , data , labels ): try : return self . model . score ( data , labels ) except sklearn . exceptions . NotFittedError : return 0 Let's step through this and see how it works. The propose_weights method saves the current weights of the model. Then it performs some training of the model, and gets the new weights. It returns the new weights, and resets the model weights to be the old weights. def mli_propose_weights ( self ) -> Weights : current_weights = self . mli_get_current_weights () for i in range ( self . steps_per_round ): batch_indices = next ( self . train_sampler ) train_data = self . train_data [ batch_indices ] train_labels = self . train_labels [ batch_indices ] self . model . partial_fit ( train_data , train_labels , classes = self . class_labels ) new_weights = self . mli_get_current_weights () self . set_weights ( current_weights ) return new_weights The test_weights method takes as a parameter the proposed weights that it needs to vote on. It saves the current weights of the model, and then sets the model weights to be the proposed weights. It tests the model and votes based on whether the score that it is monitoring has improved. The vote score can be any metric that you like. You could use loss, accuracy, mean squared error or any custom metric. If the vote score is the loss then the model would only vote True if the score has decreased. Here we're using accuracy, so the vote is true if the score increases. This method then resets the weights to the old values and returns the vote along with some scores for monitoring purposes. def mli_test_weights ( self , weights : Weights ) -> ProposedWeights : current_weights = self . mli_get_current_weights () self . set_weights ( weights ) vote_score = self . test ( self . train_data , self . train_labels ) test_score = self . test ( self . test_data , self . test_labels ) vote = self . vote_score <= vote_score self . set_weights ( current_weights ) return ProposedWeights ( weights = weights , vote_score = vote_score , test_score = test_score , vote = vote ) The accept_weights method sets the weights of the model to be the new weights. It also updates the vote score to be the current performance. Note You could implement a cache here. These weights will already have been tested in test_weights, so the vote score could be retrieved from the cache instead of recomputed. def mli_accept_weights ( self , weights : Weights ): self . set_weights ( weights ) self . vote_score = self . test ( self . train_data , self . train_labels ) The final method is the simplest - get_current_weights just returns the current weights of the model. These weights are wrapped inside a Weights object. def mli_get_current_weights ( self ): return Weights ( weights = dict ( coef_ = self . model . coef_ , intercept_ = self . model . intercept_ ))","title":"Implementation for fraud detection task"},{"location":"colearn/intro_tutorial_mli/#the-rest-of-the-example","text":"The data is loaded and preprocessed and then split into equal parts for each learner. Then a list of FraudLearner instances is created, each with its own dataset. all_learner_models = [] for i in range ( n_learners ): all_learner_models . append ( FraudLearner ( train_data = learner_train_data [ i ], train_labels = learner_train_labels [ i ], test_data = learner_test_data [ i ], test_labels = learner_test_labels [ i ] )) Then we give all the models the same weights to start off with: set_equal_weights ( all_learner_models ) And then we can move on to the final stage, which is training with Collective Learning. The function collective_learning_round performs one round of collective learning. One learner is selected to train and propose an update. The other learners vote on the update, and if the vote passes then the update is accepted. Then a new round begins. # Train the model using Collective Learning results = Results () results . data . append ( initial_result ( all_learner_models )) for round in range ( n_rounds ): results . data . append ( collective_learning_round ( all_learner_models , vote_threshold , round ) ) plot_results ( results , n_learners , block = False , score_name = all_learner_models [ 0 ] . criterion ) plot_votes ( results , block = False ) plot_results ( results , n_learners , block = False , score_name = all_learner_models [ 0 ] . criterion ) plot_votes ( results , block = True )","title":"The rest of the example"},{"location":"colearn/intro_tutorial_pytorch/","text":"Using collective learning with pytorch This tutorial is a simple guide to trying out the collective learning protocol with your own machine learning code. Everything runs locally. The most flexible way to use the collective learning backends is to make a class that implements the Collective Learning MachineLearningInterface defined in ml_interface.py . For more details on how to use the MachineLearningInterface see here However, the simpler way is to use one of the helper classes that we have provided that implement most of the interface for popular ML libraries. In this tutorial we are going to walk through using the PytorchLearner . First we are going to define the model architecture, then we are going to load the data and configure the model, and then we will run Collective Learning. A standard script for machine learning with Pytorch looks like the one below # ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ from torchsummary import summary from torchvision import transforms , datasets import torch.utils.data import torch.nn as nn import torch.nn.functional as nn_func # define some constants batch_size = 64 seed = 42 n_rounds = 20 train_fraction = 0.9 learning_rate = 0.001 height = 28 width = 28 n_classes = 10 num_test_batches = 10 no_cuda = False cuda = not no_cuda and torch . cuda . is_available () device = torch . device ( \"cuda\" if cuda else \"cpu\" ) kwargs = { 'num_workers' : 1 , 'pin_memory' : True } if cuda else {} # Load the data data = datasets . MNIST ( '/tmp/mnist' , transform = transforms . ToTensor (), download = True ) n_train = int ( train_fraction * len ( data )) n_test = len ( data ) - n_train train_data , test_data = torch . utils . data . random_split ( data , [ n_train , n_test ]) train_dataloader = torch . utils . data . DataLoader ( train_data , batch_size = batch_size , shuffle = True , ** kwargs ) test_dataloader = torch . utils . data . DataLoader ( test_data , batch_size = batch_size , shuffle = True , ** kwargs ) # Define the model class Net ( nn . Module ): def __init__ ( self ): super ( Net , self ) . __init__ () self . conv1 = nn . Conv2d ( 1 , 20 , 5 , 1 ) self . conv2 = nn . Conv2d ( 20 , 50 , 5 , 1 ) self . fc1 = nn . Linear ( 4 * 4 * 50 , 500 ) self . fc2 = nn . Linear ( 500 , n_classes ) def forward ( self , x ): x = nn_func . relu ( self . conv1 ( x . view ( - 1 , 1 , height , width ))) x = nn_func . max_pool2d ( x , 2 , 2 ) x = nn_func . relu ( self . conv2 ( x )) x = nn_func . max_pool2d ( x , 2 , 2 ) x = x . view ( - 1 , 4 * 4 * 50 ) x = nn_func . relu ( self . fc1 ( x )) x = self . fc2 ( x ) return nn_func . log_softmax ( x , dim = 1 ) model = Net () opt = torch . optim . Adam ( model . parameters (), lr = learning_rate ) criterion = torch . nn . NLLLoss () # Train and evaluate the model for round in range ( n_rounds ): # train model model . train () for batch_idx , ( data , labels ) in enumerate ( train_dataloader ): opt . zero_grad () # Data needs to be on same device as model data = data . to ( device ) labels = labels . to ( device ) output = model ( data ) loss = criterion ( output , labels ) loss . backward () opt . step () # evaluate model model . eval () total_score = 0 all_labels = [] all_outputs = [] with torch . no_grad (): for batch_idx , ( data , labels ) in enumerate ( test_dataloader ): if batch_idx == num_test_batches : break data = data . to ( device ) labels = labels . to ( device ) output = model ( data ) total_score += criterion ( output , labels ) avg_loss = float ( total_score / ( num_test_batches * batch_size )) print ( f \"Average loss at round { round } is { avg_loss } \" ) There are three steps: Load the data Define the model Train the model In this tutorial we are going to see how to modify each step to use collective learning. We'll end up with code like this: # ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ import os from typing_extensions import TypedDict import torch.nn as nn import torch.nn.functional as nn_func import torch.utils.data from torchsummary import summary from torchvision import transforms , datasets from colearn.training import initial_result , collective_learning_round , set_equal_weights from colearn.utils.plot import ColearnPlot from colearn.utils.results import Results , print_results from colearn_pytorch.utils import categorical_accuracy from colearn_pytorch.pytorch_learner import PytorchLearner \"\"\" MNIST training example using PyTorch Used dataset: - MNIST is set of 60 000 black and white hand written digits images of size 28x28x1 in 10 classes What script does: - Loads MNIST dataset from torchvision.datasets - Randomly splits dataset between multiple learners - Does multiple rounds of learning process and displays plot with results \"\"\" # define some constants n_learners = 5 batch_size = 64 testing_mode = bool ( os . getenv ( \"COLEARN_EXAMPLES_TEST\" , \"\" )) # for testing n_rounds = 20 if not testing_mode else 1 vote_threshold = 0.5 train_fraction = 0.9 learning_rate = 0.001 height = 28 width = 28 n_classes = 10 vote_batches = 2 score_name = \"categorical accuracy\" no_cuda = False cuda = not no_cuda and torch . cuda . is_available () device = torch . device ( \"cuda\" if cuda else \"cpu\" ) DataloaderKwargs = TypedDict ( 'DataloaderKwargs' , { 'num_workers' : int , 'pin_memory' : bool }, total = False ) kwargs : DataloaderKwargs = { 'num_workers' : 1 , 'pin_memory' : True } if cuda else {} # Load the data and split for each learner. DATA_DIR = os . environ . get ( 'PYTORCH_DATA_DIR' , os . path . expanduser ( os . path . join ( '~' , 'pytorch_datasets' ))) data = datasets . MNIST ( DATA_DIR , transform = transforms . ToTensor (), download = True ) n_train = int ( train_fraction * len ( data )) n_test = len ( data ) - n_train train_data , test_data = torch . utils . data . random_split ( data , [ n_train , n_test ]) data_split = [ len ( train_data ) // n_learners ] * n_learners learner_train_data = torch . utils . data . random_split ( train_data , data_split ) learner_train_dataloaders = [ torch . utils . data . DataLoader ( ds , batch_size = batch_size , shuffle = True , ** kwargs ) for ds in learner_train_data ] data_split = [ len ( test_data ) // n_learners ] * n_learners learner_test_data = torch . utils . data . random_split ( test_data , data_split ) learner_test_dataloaders = [ torch . utils . data . DataLoader ( ds , batch_size = batch_size , shuffle = True , ** kwargs ) for ds in learner_test_data ] # Define the model class Net ( nn . Module ): def __init__ ( self ): super ( Net , self ) . __init__ () self . conv1 = nn . Conv2d ( 1 , 20 , 5 , 1 ) self . conv2 = nn . Conv2d ( 20 , 50 , 5 , 1 ) self . fc1 = nn . Linear ( 4 * 4 * 50 , 500 ) self . fc2 = nn . Linear ( 500 , n_classes ) def forward ( self , x ): x = nn_func . relu ( self . conv1 ( x . view ( - 1 , 1 , height , width ))) x = nn_func . max_pool2d ( x , 2 , 2 ) x = nn_func . relu ( self . conv2 ( x )) x = nn_func . max_pool2d ( x , 2 , 2 ) x = x . view ( - 1 , 4 * 4 * 50 ) x = nn_func . relu ( self . fc1 ( x )) x = self . fc2 ( x ) return nn_func . log_softmax ( x , dim = 1 ) # Make n instances of PytorchLearner with model and torch dataloaders all_learner_models = [] for i in range ( n_learners ): model = Net () . to ( device ) opt = torch . optim . Adam ( model . parameters (), lr = learning_rate ) learner = PytorchLearner ( model = model , train_loader = learner_train_dataloaders [ i ], test_loader = learner_test_dataloaders [ i ], device = device , optimizer = opt , criterion = torch . nn . NLLLoss (), num_test_batches = vote_batches , vote_criterion = categorical_accuracy , minimise_criterion = False ) all_learner_models . append ( learner ) # Ensure all learners starts with exactly same weights set_equal_weights ( all_learner_models ) summary ( all_learner_models [ 0 ] . model , input_size = ( width , height ), device = str ( device )) # Train the model using Collective Learning results = Results () results . data . append ( initial_result ( all_learner_models )) plot = ColearnPlot ( score_name = score_name ) for round_index in range ( n_rounds ): results . data . append ( collective_learning_round ( all_learner_models , vote_threshold , round_index ) ) print_results ( results ) plot . plot_results_and_votes ( results ) plot . block () print ( \"Colearn Example Finished!\" ) The first thing is to modify the data loading code. Each learner needs to have their own training and testing set from the data. This is easy to do with the pytorch random_split utility: data_split = [ len ( test_data ) // n_learners ] * n_learners learner_test_data = torch . utils . data . random_split ( test_data , data_split ) The model definition is the same as before. To use collective learning, we need to create an object that implements the MachineLearningInterface. To make it easier to use the MachineLearningInterface with pytorch, we've defined PytorchLearner . PytorchLearner implements standard training and evaluation routines as well as the MachineLearningInterface methods. # ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ from typing import Optional , Callable try : import torch except ImportError : raise Exception ( \"Pytorch is not installed. To use the pytorch \" \"add-ons please install colearn with `pip install colearn[pytorch]`.\" ) import torch.nn import torch.optim import torch.utils import torch.utils.data from torch.nn.modules.loss import _Loss from colearn.ml_interface import MachineLearningInterface , Weights , ProposedWeights _DEFAULT_DEVICE = torch . device ( \"cpu\" ) class PytorchLearner ( MachineLearningInterface ): \"\"\" Pytorch learner implementation of machine learning interface \"\"\" def __init__ ( self , model : torch . nn . Module , optimizer : torch . optim . Optimizer , train_loader : torch . utils . data . DataLoader , test_loader : Optional [ torch . utils . data . DataLoader ] = None , device = _DEFAULT_DEVICE , criterion : Optional [ _Loss ] = None , minimise_criterion = True , vote_criterion : Optional [ Callable [[ torch . Tensor , torch . Tensor ], float ]] = None , num_train_batches : Optional [ int ] = None , num_test_batches : Optional [ int ] = None ): \"\"\" :param model: Pytorch model used for training :param optimizer: Training optimizer :param train_loader: Train dataset :param test_loader: Optional test dataset - subset of training set will be used if not specified :param device: Pytorch device - CPU or GPU :param criterion: Loss function :param minimise_criterion: True to minimise value of criterion, False to maximise :param vote_criterion: Function to measure model performance for voting :param num_train_batches: Number of training batches :param num_test_batches: Number of testing batches \"\"\" # Model has to be on same device as data self . model : torch . nn . Module = model . to ( device ) self . optimizer : torch . optim . Optimizer = optimizer self . criterion = criterion self . train_loader : torch . utils . data . DataLoader = train_loader self . test_loader : Optional [ torch . utils . data . DataLoader ] = test_loader self . device = device self . num_train_batches = num_train_batches or len ( train_loader ) self . num_test_batches = num_test_batches self . minimise_criterion = minimise_criterion self . vote_criterion = vote_criterion self . vote_score = self . test ( self . train_loader ) def mli_get_current_weights ( self ) -> Weights : \"\"\" :return: The current weights of the model \"\"\" w = Weights ( weights = [ x . clone () for x in self . model . parameters ()]) return w def set_weights ( self , weights : Weights ): \"\"\" Rewrites weight of current model :param weights: Weights to be stored \"\"\" with torch . no_grad (): for new_param , old_param in zip ( weights . weights , self . model . parameters ()): old_param . set_ ( new_param ) def train ( self ): \"\"\" Trains the model on the training dataset \"\"\" self . model . train () for batch_idx , ( data , labels ) in enumerate ( self . train_loader ): if batch_idx == self . num_train_batches : break self . optimizer . zero_grad () # Data needs to be on same device as model data = data . to ( self . device ) labels = labels . to ( self . device ) output = self . model ( data ) loss = self . criterion ( output , labels ) loss . backward () self . optimizer . step () def mli_propose_weights ( self ) -> Weights : \"\"\" Trains model on training set and returns new weights after training - Current model is reverted to original state after training :return: Weights after training \"\"\" current_weights = self . mli_get_current_weights () self . train () new_weights = self . mli_get_current_weights () self . set_weights ( current_weights ) return new_weights def mli_test_weights ( self , weights : Weights ) -> ProposedWeights : \"\"\" Tests given weights on training and test set and returns weights with score values :param weights: Weights to be tested :return: ProposedWeights - Weights with vote and test score \"\"\" current_weights = self . mli_get_current_weights () self . set_weights ( weights ) vote_score = self . test ( self . train_loader ) if self . test_loader : test_score = self . test ( self . test_loader ) else : test_score = 0 vote = self . vote ( vote_score ) self . set_weights ( current_weights ) return ProposedWeights ( weights = weights , vote_score = vote_score , test_score = test_score , vote = vote ) def vote ( self , new_score ) -> bool : \"\"\" Compares current model score with proposed model score and returns vote :param new_score: Proposed score :return: bool positive or negative vote \"\"\" if self . minimise_criterion : return new_score < self . vote_score else : return new_score > self . vote_score def test ( self , loader : torch . utils . data . DataLoader ) -> float : \"\"\" Tests performance of the model on specified dataset :param loader: Dataset for testing :return: Value of performance metric \"\"\" if not self . criterion : raise Exception ( \"Criterion is unspecified so test method cannot be used\" ) self . model . eval () total_score = 0 all_labels = [] all_outputs = [] batch_idx = 0 with torch . no_grad (): for batch_idx , ( data , labels ) in enumerate ( loader ): if self . num_test_batches and batch_idx == self . num_test_batches : break data = data . to ( self . device ) labels = labels . to ( self . device ) output = self . model ( data ) if self . vote_criterion is not None : all_labels . append ( labels ) all_outputs . append ( output ) else : total_score += self . criterion ( output , labels ) . item () if batch_idx == 0 : raise Exception ( \"No batches in loader\" ) if self . vote_criterion is None : return float ( total_score / ( batch_idx * loader . batch_size )) # type: ignore[operator] else : return self . vote_criterion ( torch . cat ( all_outputs , dim = 0 ), torch . cat ( all_labels , dim = 0 )) def mli_accept_weights ( self , weights : Weights ): \"\"\" Updates the model with the proposed set of weights :param weights: The new weights \"\"\" self . set_weights ( weights ) self . vote_score = self . test ( self . train_loader ) We create a set of PytorchLearners by passing in the model and the datasets: all_learner_models = [] for i in range ( n_learners ): model = Net () opt = torch . optim . Adam ( model . parameters (), lr = learning_rate ) learner = PytorchLearner ( model = model , train_loader = learner_train_dataloaders [ i ], test_loader = learner_test_dataloaders [ i ], device = device , optimizer = opt , criterion = torch . nn . NLLLoss (), num_test_batches = vote_batches , vote_criterion = categorical_accuracy , minimise_criterion = False ) all_learner_models . append ( learner ) Then we give all the models the same weights to start off with: set_equal_weights ( all_learner_models ) And then we can move on to the final stage, which is training with Collective Learning. The function collective_learning_round performs one round of collective learning. One learner is selected to train and propose an update. The other learners vote on the update, and if the vote passes then the update is accepted. Then a new round begins. # Train the model using Collective Learning results = Results () results . data . append ( initial_result ( all_learner_models )) for round in range ( n_rounds ): results . data . append ( collective_learning_round ( all_learner_models , vote_threshold , round ) ) plot_results ( results , n_learners , score_name = score_name ) plot_votes ( results ) # Plot the final result with votes plot_results ( results , n_learners , score_name = score_name ) plot_votes ( results , block = True )","title":"PyTorch"},{"location":"colearn/intro_tutorial_pytorch/#using-collective-learning-with-pytorch","text":"This tutorial is a simple guide to trying out the collective learning protocol with your own machine learning code. Everything runs locally. The most flexible way to use the collective learning backends is to make a class that implements the Collective Learning MachineLearningInterface defined in ml_interface.py . For more details on how to use the MachineLearningInterface see here However, the simpler way is to use one of the helper classes that we have provided that implement most of the interface for popular ML libraries. In this tutorial we are going to walk through using the PytorchLearner . First we are going to define the model architecture, then we are going to load the data and configure the model, and then we will run Collective Learning. A standard script for machine learning with Pytorch looks like the one below # ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ from torchsummary import summary from torchvision import transforms , datasets import torch.utils.data import torch.nn as nn import torch.nn.functional as nn_func # define some constants batch_size = 64 seed = 42 n_rounds = 20 train_fraction = 0.9 learning_rate = 0.001 height = 28 width = 28 n_classes = 10 num_test_batches = 10 no_cuda = False cuda = not no_cuda and torch . cuda . is_available () device = torch . device ( \"cuda\" if cuda else \"cpu\" ) kwargs = { 'num_workers' : 1 , 'pin_memory' : True } if cuda else {} # Load the data data = datasets . MNIST ( '/tmp/mnist' , transform = transforms . ToTensor (), download = True ) n_train = int ( train_fraction * len ( data )) n_test = len ( data ) - n_train train_data , test_data = torch . utils . data . random_split ( data , [ n_train , n_test ]) train_dataloader = torch . utils . data . DataLoader ( train_data , batch_size = batch_size , shuffle = True , ** kwargs ) test_dataloader = torch . utils . data . DataLoader ( test_data , batch_size = batch_size , shuffle = True , ** kwargs ) # Define the model class Net ( nn . Module ): def __init__ ( self ): super ( Net , self ) . __init__ () self . conv1 = nn . Conv2d ( 1 , 20 , 5 , 1 ) self . conv2 = nn . Conv2d ( 20 , 50 , 5 , 1 ) self . fc1 = nn . Linear ( 4 * 4 * 50 , 500 ) self . fc2 = nn . Linear ( 500 , n_classes ) def forward ( self , x ): x = nn_func . relu ( self . conv1 ( x . view ( - 1 , 1 , height , width ))) x = nn_func . max_pool2d ( x , 2 , 2 ) x = nn_func . relu ( self . conv2 ( x )) x = nn_func . max_pool2d ( x , 2 , 2 ) x = x . view ( - 1 , 4 * 4 * 50 ) x = nn_func . relu ( self . fc1 ( x )) x = self . fc2 ( x ) return nn_func . log_softmax ( x , dim = 1 ) model = Net () opt = torch . optim . Adam ( model . parameters (), lr = learning_rate ) criterion = torch . nn . NLLLoss () # Train and evaluate the model for round in range ( n_rounds ): # train model model . train () for batch_idx , ( data , labels ) in enumerate ( train_dataloader ): opt . zero_grad () # Data needs to be on same device as model data = data . to ( device ) labels = labels . to ( device ) output = model ( data ) loss = criterion ( output , labels ) loss . backward () opt . step () # evaluate model model . eval () total_score = 0 all_labels = [] all_outputs = [] with torch . no_grad (): for batch_idx , ( data , labels ) in enumerate ( test_dataloader ): if batch_idx == num_test_batches : break data = data . to ( device ) labels = labels . to ( device ) output = model ( data ) total_score += criterion ( output , labels ) avg_loss = float ( total_score / ( num_test_batches * batch_size )) print ( f \"Average loss at round { round } is { avg_loss } \" ) There are three steps: Load the data Define the model Train the model In this tutorial we are going to see how to modify each step to use collective learning. We'll end up with code like this: # ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ import os from typing_extensions import TypedDict import torch.nn as nn import torch.nn.functional as nn_func import torch.utils.data from torchsummary import summary from torchvision import transforms , datasets from colearn.training import initial_result , collective_learning_round , set_equal_weights from colearn.utils.plot import ColearnPlot from colearn.utils.results import Results , print_results from colearn_pytorch.utils import categorical_accuracy from colearn_pytorch.pytorch_learner import PytorchLearner \"\"\" MNIST training example using PyTorch Used dataset: - MNIST is set of 60 000 black and white hand written digits images of size 28x28x1 in 10 classes What script does: - Loads MNIST dataset from torchvision.datasets - Randomly splits dataset between multiple learners - Does multiple rounds of learning process and displays plot with results \"\"\" # define some constants n_learners = 5 batch_size = 64 testing_mode = bool ( os . getenv ( \"COLEARN_EXAMPLES_TEST\" , \"\" )) # for testing n_rounds = 20 if not testing_mode else 1 vote_threshold = 0.5 train_fraction = 0.9 learning_rate = 0.001 height = 28 width = 28 n_classes = 10 vote_batches = 2 score_name = \"categorical accuracy\" no_cuda = False cuda = not no_cuda and torch . cuda . is_available () device = torch . device ( \"cuda\" if cuda else \"cpu\" ) DataloaderKwargs = TypedDict ( 'DataloaderKwargs' , { 'num_workers' : int , 'pin_memory' : bool }, total = False ) kwargs : DataloaderKwargs = { 'num_workers' : 1 , 'pin_memory' : True } if cuda else {} # Load the data and split for each learner. DATA_DIR = os . environ . get ( 'PYTORCH_DATA_DIR' , os . path . expanduser ( os . path . join ( '~' , 'pytorch_datasets' ))) data = datasets . MNIST ( DATA_DIR , transform = transforms . ToTensor (), download = True ) n_train = int ( train_fraction * len ( data )) n_test = len ( data ) - n_train train_data , test_data = torch . utils . data . random_split ( data , [ n_train , n_test ]) data_split = [ len ( train_data ) // n_learners ] * n_learners learner_train_data = torch . utils . data . random_split ( train_data , data_split ) learner_train_dataloaders = [ torch . utils . data . DataLoader ( ds , batch_size = batch_size , shuffle = True , ** kwargs ) for ds in learner_train_data ] data_split = [ len ( test_data ) // n_learners ] * n_learners learner_test_data = torch . utils . data . random_split ( test_data , data_split ) learner_test_dataloaders = [ torch . utils . data . DataLoader ( ds , batch_size = batch_size , shuffle = True , ** kwargs ) for ds in learner_test_data ] # Define the model class Net ( nn . Module ): def __init__ ( self ): super ( Net , self ) . __init__ () self . conv1 = nn . Conv2d ( 1 , 20 , 5 , 1 ) self . conv2 = nn . Conv2d ( 20 , 50 , 5 , 1 ) self . fc1 = nn . Linear ( 4 * 4 * 50 , 500 ) self . fc2 = nn . Linear ( 500 , n_classes ) def forward ( self , x ): x = nn_func . relu ( self . conv1 ( x . view ( - 1 , 1 , height , width ))) x = nn_func . max_pool2d ( x , 2 , 2 ) x = nn_func . relu ( self . conv2 ( x )) x = nn_func . max_pool2d ( x , 2 , 2 ) x = x . view ( - 1 , 4 * 4 * 50 ) x = nn_func . relu ( self . fc1 ( x )) x = self . fc2 ( x ) return nn_func . log_softmax ( x , dim = 1 ) # Make n instances of PytorchLearner with model and torch dataloaders all_learner_models = [] for i in range ( n_learners ): model = Net () . to ( device ) opt = torch . optim . Adam ( model . parameters (), lr = learning_rate ) learner = PytorchLearner ( model = model , train_loader = learner_train_dataloaders [ i ], test_loader = learner_test_dataloaders [ i ], device = device , optimizer = opt , criterion = torch . nn . NLLLoss (), num_test_batches = vote_batches , vote_criterion = categorical_accuracy , minimise_criterion = False ) all_learner_models . append ( learner ) # Ensure all learners starts with exactly same weights set_equal_weights ( all_learner_models ) summary ( all_learner_models [ 0 ] . model , input_size = ( width , height ), device = str ( device )) # Train the model using Collective Learning results = Results () results . data . append ( initial_result ( all_learner_models )) plot = ColearnPlot ( score_name = score_name ) for round_index in range ( n_rounds ): results . data . append ( collective_learning_round ( all_learner_models , vote_threshold , round_index ) ) print_results ( results ) plot . plot_results_and_votes ( results ) plot . block () print ( \"Colearn Example Finished!\" ) The first thing is to modify the data loading code. Each learner needs to have their own training and testing set from the data. This is easy to do with the pytorch random_split utility: data_split = [ len ( test_data ) // n_learners ] * n_learners learner_test_data = torch . utils . data . random_split ( test_data , data_split ) The model definition is the same as before. To use collective learning, we need to create an object that implements the MachineLearningInterface. To make it easier to use the MachineLearningInterface with pytorch, we've defined PytorchLearner . PytorchLearner implements standard training and evaluation routines as well as the MachineLearningInterface methods. # ------------------------------------------------------------------------------ # # Copyright 2021 Fetch.AI Limited # # Licensed under the Creative Commons Attribution-NonCommercial International # License, Version 4.0 (the \"License\"); you may not use this file except in # compliance with the License. You may obtain a copy of the License at # # http://creativecommons.org/licenses/by-nc/4.0/legalcode # # Unless required by applicable law or agreed to in writing, software # distributed under the License is distributed on an \"AS IS\" BASIS, # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. # See the License for the specific language governing permissions and # limitations under the License. # # ------------------------------------------------------------------------------ from typing import Optional , Callable try : import torch except ImportError : raise Exception ( \"Pytorch is not installed. To use the pytorch \" \"add-ons please install colearn with `pip install colearn[pytorch]`.\" ) import torch.nn import torch.optim import torch.utils import torch.utils.data from torch.nn.modules.loss import _Loss from colearn.ml_interface import MachineLearningInterface , Weights , ProposedWeights _DEFAULT_DEVICE = torch . device ( \"cpu\" ) class PytorchLearner ( MachineLearningInterface ): \"\"\" Pytorch learner implementation of machine learning interface \"\"\" def __init__ ( self , model : torch . nn . Module , optimizer : torch . optim . Optimizer , train_loader : torch . utils . data . DataLoader , test_loader : Optional [ torch . utils . data . DataLoader ] = None , device = _DEFAULT_DEVICE , criterion : Optional [ _Loss ] = None , minimise_criterion = True , vote_criterion : Optional [ Callable [[ torch . Tensor , torch . Tensor ], float ]] = None , num_train_batches : Optional [ int ] = None , num_test_batches : Optional [ int ] = None ): \"\"\" :param model: Pytorch model used for training :param optimizer: Training optimizer :param train_loader: Train dataset :param test_loader: Optional test dataset - subset of training set will be used if not specified :param device: Pytorch device - CPU or GPU :param criterion: Loss function :param minimise_criterion: True to minimise value of criterion, False to maximise :param vote_criterion: Function to measure model performance for voting :param num_train_batches: Number of training batches :param num_test_batches: Number of testing batches \"\"\" # Model has to be on same device as data self . model : torch . nn . Module = model . to ( device ) self . optimizer : torch . optim . Optimizer = optimizer self . criterion = criterion self . train_loader : torch . utils . data . DataLoader = train_loader self . test_loader : Optional [ torch . utils . data . DataLoader ] = test_loader self . device = device self . num_train_batches = num_train_batches or len ( train_loader ) self . num_test_batches = num_test_batches self . minimise_criterion = minimise_criterion self . vote_criterion = vote_criterion self . vote_score = self . test ( self . train_loader ) def mli_get_current_weights ( self ) -> Weights : \"\"\" :return: The current weights of the model \"\"\" w = Weights ( weights = [ x . clone () for x in self . model . parameters ()]) return w def set_weights ( self , weights : Weights ): \"\"\" Rewrites weight of current model :param weights: Weights to be stored \"\"\" with torch . no_grad (): for new_param , old_param in zip ( weights . weights , self . model . parameters ()): old_param . set_ ( new_param ) def train ( self ): \"\"\" Trains the model on the training dataset \"\"\" self . model . train () for batch_idx , ( data , labels ) in enumerate ( self . train_loader ): if batch_idx == self . num_train_batches : break self . optimizer . zero_grad () # Data needs to be on same device as model data = data . to ( self . device ) labels = labels . to ( self . device ) output = self . model ( data ) loss = self . criterion ( output , labels ) loss . backward () self . optimizer . step () def mli_propose_weights ( self ) -> Weights : \"\"\" Trains model on training set and returns new weights after training - Current model is reverted to original state after training :return: Weights after training \"\"\" current_weights = self . mli_get_current_weights () self . train () new_weights = self . mli_get_current_weights () self . set_weights ( current_weights ) return new_weights def mli_test_weights ( self , weights : Weights ) -> ProposedWeights : \"\"\" Tests given weights on training and test set and returns weights with score values :param weights: Weights to be tested :return: ProposedWeights - Weights with vote and test score \"\"\" current_weights = self . mli_get_current_weights () self . set_weights ( weights ) vote_score = self . test ( self . train_loader ) if self . test_loader : test_score = self . test ( self . test_loader ) else : test_score = 0 vote = self . vote ( vote_score ) self . set_weights ( current_weights ) return ProposedWeights ( weights = weights , vote_score = vote_score , test_score = test_score , vote = vote ) def vote ( self , new_score ) -> bool : \"\"\" Compares current model score with proposed model score and returns vote :param new_score: Proposed score :return: bool positive or negative vote \"\"\" if self . minimise_criterion : return new_score < self . vote_score else : return new_score > self . vote_score def test ( self , loader : torch . utils . data . DataLoader ) -> float : \"\"\" Tests performance of the model on specified dataset :param loader: Dataset for testing :return: Value of performance metric \"\"\" if not self . criterion : raise Exception ( \"Criterion is unspecified so test method cannot be used\" ) self . model . eval () total_score = 0 all_labels = [] all_outputs = [] batch_idx = 0 with torch . no_grad (): for batch_idx , ( data , labels ) in enumerate ( loader ): if self . num_test_batches and batch_idx == self . num_test_batches : break data = data . to ( self . device ) labels = labels . to ( self . device ) output = self . model ( data ) if self . vote_criterion is not None : all_labels . append ( labels ) all_outputs . append ( output ) else : total_score += self . criterion ( output , labels ) . item () if batch_idx == 0 : raise Exception ( \"No batches in loader\" ) if self . vote_criterion is None : return float ( total_score / ( batch_idx * loader . batch_size )) # type: ignore[operator] else : return self . vote_criterion ( torch . cat ( all_outputs , dim = 0 ), torch . cat ( all_labels , dim = 0 )) def mli_accept_weights ( self , weights : Weights ): \"\"\" Updates the model with the proposed set of weights :param weights: The new weights \"\"\" self . set_weights ( weights ) self . vote_score = self . test ( self . train_loader ) We create a set of PytorchLearners by passing in the model and the datasets: all_learner_models = [] for i in range ( n_learners ): model = Net () opt = torch . optim . Adam ( model . parameters (), lr = learning_rate ) learner = PytorchLearner ( model = model , train_loader = learner_train_dataloaders [ i ], test_loader = learner_test_dataloaders [ i ], device = device , optimizer = opt , criterion = torch . nn . NLLLoss (), num_test_batches = vote_batches , vote_criterion = categorical_accuracy , minimise_criterion = False ) all_learner_models . append ( learner ) Then we give all the models the same weights to start off with: set_equal_weights ( all_learner_models ) And then we can move on to the final stage, which is training with Collective Learning. The function collective_learning_round performs one round of collective learning. One learner is selected to train and propose an update. The other learners vote on the update, and if the vote passes then the update is accepted. Then a new round begins. # Train the model using Collective Learning results = Results () results . data . append ( initial_result ( all_learner_models )) for round in range ( n_rounds ): results . data . append ( collective_learning_round ( all_learner_models , vote_threshold , round ) ) plot_results ( results , n_learners , score_name = score_name ) plot_votes ( results ) # Plot the final result with votes plot_results ( results , n_learners , score_name = score_name ) plot_votes ( results , block = True )","title":"Using collective learning with pytorch"},{"location":"colearn/mli_factory/","text":"MLI Factory The machine learning interface factory are the minimum methods a client needs to implement to work with the GRPC Server (and become a Learner). There are two main types of functions: - Supported Systems (get_models, get_dataloaders, get_compatibilities) - Get a MachineLearningInterface (get_mli) When the GRPC server is connected to the Orchestrator, it will query the supported system functions to know what the MLI Factory can serve. Later when the Orchestrator wants to run something on this Learner it will call get_mli with a model_arch_name, a dataloader_name and more parameters for both. The object returned is then used to run the experiment through the MLI. Supported Systems The supported systems functions get_models and get_dataloaders should return a set of which will be stored (not currently implemented) in the api database. The idea being that the user can change these values on the UI while preparing to start/join an experiment. ExampleMliFactory An example MLIFactory that will implement all the tasks in run_demo. This is the one used by contract_learn.","title":"MLI Factory"},{"location":"colearn/mli_factory/#mli-factory","text":"The machine learning interface factory are the minimum methods a client needs to implement to work with the GRPC Server (and become a Learner). There are two main types of functions: - Supported Systems (get_models, get_dataloaders, get_compatibilities) - Get a MachineLearningInterface (get_mli) When the GRPC server is connected to the Orchestrator, it will query the supported system functions to know what the MLI Factory can serve. Later when the Orchestrator wants to run something on this Learner it will call get_mli with a model_arch_name, a dataloader_name and more parameters for both. The object returned is then used to run the experiment through the MLI.","title":"MLI Factory"},{"location":"colearn/mli_factory/#supported-systems","text":"The supported systems functions get_models and get_dataloaders should return a set of which will be stored (not currently implemented) in the api database. The idea being that the user can change these values on the UI while preparing to start/join an experiment.","title":"Supported Systems"},{"location":"colearn/mli_factory/#examplemlifactory","text":"An example MLIFactory that will implement all the tasks in run_demo. This is the one used by contract_learn.","title":"ExampleMliFactory"},{"location":"colearn/tasks/","text":"1. CIFAR10 dataset 1.1. Information and installation 1.1.1. Information about the dataset The CIFAR-10 dataset consists of 60000 32x32x3 colour images in 10 classes, with 6000 images per class. The 10 different classes represent airplanes, cars, birds, cats, deer, dogs, frogs, horses, ships, and trucks Input for NN are raw 32x32 3 channels GRB images NN output is distribution of probabilities for each class i.e. 10 values that sums up to 1 Code folder: here Invoke parameter: -t CIFAR10 1.1.2. Requirements Cifar dataset is loaded from tensorflow.keras.datasets.cifar10 and no stored data are required 1.2. Models 1.2.1. CIFAR10Conv Keras model _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= Input (InputLayer) (32, 32, 3) 0 _________________________________________________________________ Conv1_1 (Conv2D) (32, 32, 64) 1792 bn1_1 (BatchNormalization) (32, 32, 64) 256 Conv1_2 (Conv2D) (32, 32, 64) 36928 bn1_2 (BatchNormalization) (32, 32, 64) 256 pool1 (MaxPooling2D) (16, 16, 64) 0 _________________________________________________________________ Conv2_1 (Conv2D) (16, 16, 128 73856 bn2_1 (BatchNormalization) (16, 16, 128 512 Conv2_2 (Conv2D) (16, 16, 128 147584 bn2_2 (BatchNormalization) (16, 16, 128 512 pool2 (MaxPooling2D) (8, 8, 128) 0 _________________________________________________________________ Conv3_1 (Conv2D) (8, 8, 256) 295168 bn3_1 (BatchNormalization) (8, 8, 256) 1024 Conv3_2 (Conv2D) (8, 8, 256) 590080 bn3_2 (BatchNormalization) (8, 8, 256) 1024 Conv3_3 (Conv2D) (8, 8, 256) 590080 bn3_3 (BatchNormalization) (8, 8, 256) 1024 _________________________________________________________________ flatten (Flatten) (16384) 0 fc1 (Dense) (100) 1638500 fc2 (Dense) (10) 1010 ================================================================= Total params: 3,379,606 Trainable params: 3,377,302 Non-trainable params: 2,304 _________________________________________________________________ 1.2.2. CIFAR10Conv2 Keras model _________________________________________________________ Layer (type) Output Shape Param # ========================================================= Input (InputLayer) (32, 32, 3) 0 _________________________________________________________ Conv1_1 (Conv2D) (32, 32, 32) 896 Conv1_2 (Conv2D) (32, 32, 32) 9248 pool1 (MaxPooling2D) (16, 16, 32) 0 _________________________________________________________ Conv2_1 (Conv2D) (16, 16, 64) 18496 Conv2_2 (Conv2D) (16, 16, 64) 36928 pool2 (MaxPooling2D) (8, 8, 64) 0 _________________________________________________________ Conv3_1 (Conv2D) (8, 8, 128) 73856 Conv3_2 (Conv2D) (8, 8, 128) 147584 pool3 (MaxPooling2D) (4, 4, 128) 0 _________________________________________________________ flatten (Flatten) (2048) 0 fc1 (Dense) (128) 262272 fc2 (Dense) (10) 1290 ========================================================= Total params: 550,570 Trainable params: 550,570 Non-trainable params: 0 _________________________________________________________ 1.2.3. CIFAR10Resnet50 Keras model ________________________________________________________ Layer (type) Output Shape Param # ======================================================== Input (InputLayer) (32, 32, 3)] 0 ________________________________________________________ resnet50 (Model) (1, 1, 2048) 23587712 ________________________________________________________ Global_average_pooling2d (2048) 0 flatten (Flatten) (2048) 0 fc1 (Dense) (10) 20490 ======================================================== Total params: 23,608,202 Trainable params: 23,555,082 Non-trainable params: 53,120 ________________________________________________________ 2. Covid X-RAY dataset 2.1. Information and installation 2.1.1. Information about the dataset The Covid X-Ray dataset consists of grayscale images, there are 478 covid images and 203 normal images. To increase the number of images normal/pneumonia dataset is added Final dataset, which is a combination of two previously mentioned datasets, contains 1434 images, 478 images for each class. Images are cropped and resized to 512x512 pixel and spatial domain (Texture, GLDM, GLCM) and frequency domain (FFT and Wavelet) features are used to create 256 dimensional vector representation of each image. PCA is applied after to reduce dimensionality to 64 values which represents the first 64 highest eigenvalues of the covariance matrix. Input for NN are 64 values for each image NN output is distribution of probabilities for each class i.e. 3 values Code folder: here Invoke parameter: -t COVID 2.1.2 Requirements Download Covid dataset: here Download pneumonia dataset: here 2.2. Models 2.2.1. Covid XRAY Keras model _________________________________________________________ Layer (type) Output Shape Param # ========================================================= input_1 (InputLayer) (64) 0 _________________________________________________________ dense (Dense) (128) 8320 dropout (Dropout) (128) 0 _________________________________________________________ dense_1 (Dense) (16) 2064 dropout_1 (Dropout) (16) 0 _________________________________________________________ dense_2 (Dense) (3) 51 ========================================================= Total params: 10,435 Trainable params: 10,435 Non-trainable params: 0 _________________________________________________________ 3. FRAUD dataset 3.1. Information and installation 3.1.1. Information about the dataset EEE-CIS Fraud Detection, contains multiple files with credit card transactions Raw dataset files are automatically merged and pre-processed and input files for neural network are created X.csv with data - has 431 values for each transaction Y.csv with labels - v has 1 value for each transaction 0 = not a fraud 1 = fraud Code folder: here Invoke parameter: -t FRAUD 3.1.2. Requirements Download dataset: here 3.2. Models 3.2.1. FraudDense1 Keras model _________________________________________________________ Layer (type) Output Shape Param # ========================================================= Input (InputLayer) (431) 0 _________________________________________________________ dense (Dense) (512) 221184 Batch_normalization (512) 2048 _________________________________________________________ dense_1 (Dense) (512) 262656 Batch_normalization_1 (512) 2048 _________________________________________________________ dense_2 (Dense) (512) 262656 Batch_normalization_2 (512) 2048 _________________________________________________________ fc1 (Dense) (1) 513 ========================================================= Total params: 753,153 Trainable params: 750,081 Non-trainable params: 3,072 _________________________________________________________ 3.2.2. FraudSVM Scikit-learn model Model is defined as SGDClassifier(max_iter=1, verbose=0, loss=\"modified_huber\") Which is support vector machine linear classifier 4. MNIST 4.1. Information and installation 4.1.1. Information about the dataset This is a dataset of 70,000 28x28x1 grayscale images of the 10 digits Input for NN are raw 28x28 1 channel images NN output is distribution of probabilities for each class i.e. 10 values that sums up to 1 Code folder: here Invoke parameter: -t MNIST 4.1.2 Requirements MNIST dataset is loaded from tensorflow.keras.datasets.cifar10 and no stored data are required 4.2. Models 4.2.1. MNISTConv Keras model _________________________________________________________ Layer (type) Output Shape Param # ========================================================= Input (InputLayer) (28, 28, 1) 0 _________________________________________________________ Conv1_1 (Conv2D) (28, 28, 64) 640 bn1 (BatchNormalization) (28, 28, 64) 256 pool1 (MaxPooling2D) (14, 14, 64) 0 _________________________________________________________ Conv2_1 (Conv2D) (14, 14, 128) 73856 bn4 (BatchNormalization) (14, 14, 128) 512 pool2 (MaxPooling2D) (7, 7, 128) 0 _________________________________________________________ flatten (Flatten) (6272) 0 fc1 (Dense) (10) 62730 ========================================================= Total params: 137,994 Trainable params: 137,610 Non-trainable params: 384 _________________________________________________________ 4.2.2. MNIST Pytorch model --------------------------------------------------------- Layer (type) Output Shape Param # ========================================================= Input [28,28,1] 0 Conv2d-1 [20, 24, 24] 520 Conv2d-2 [50, 8, 8] 25,050 Linear-3 [500] 400,500 Linear-4 [10] 5,010 ========================================================= Total params: 431,080 Trainable params: 431,080 Non-trainable params: 0 --------------------------------------------------------- 4.2.3. MNISTSupermini Keras model ________________________________________________________________________________________ Layer (type) Output Shape Param # Connected to ======================================================================================== input_1 (InputLayer) (28, 28, 1) 0 ________________________________________________________________________________________ conv2d (Conv2D) (26, 26, 8) 80 input_1[0][0] Batch_normalization (26, 26, 8) 32 conv2d[0][0] Max_pooling2d (13, 13, 8) 0 batch_normalization[0][0] dropout (Dropout) (13, 13, 8) 0 max_pooling2d[0][0] ________________________________________________________________________________________ Separable_conv2d (11, 11, 26) 306 dropout[0][0] batch_normalization_1 (11, 11, 26) 104 separable_conv2d[0][0] dropout_1 (Dropout) (11, 11, 26) 0 batch_normalization_1[0][0] ________________________________________________________________________________________ Separable_conv2d_1 (11, 11, 26) 936 dropout_1[0][0] dropout_2[0][0] dropout_3[0][0] ________________________________________________________________________________________ Batch_normalization_2 (11, 11, 26) 104 separable_conv2d_1[0][0] dropout_2 (Dropout) (11, 11, 26) 0 batch_normalization_2[0][0] ________________________________________________________________________________________ Batch_normalization_3 (11, 11, 26) 104 separable_conv2d_1[1][0] dropout_3 (Dropout) (11, 11, 26) 0 batch_normalization_3[0][0] ________________________________________________________________________________________ Batch_normalization_4 (11, 11, 26) 104 separable_conv2d_1[2][0] dropout_4 (Dropout) (11, 11, 26) 0 batch_normalization_4[0][0] ________________________________________________________________________________________ Global_average_pooling2d (26) 0 dropout_4[0][0] dense (Dense) (16) 432 global_average_pooling2d[0][0] Batch_normalization_5 (16) 64 dense[0][0] dropout_5 (Dropout) (16) 0 batch_normalization_5[0][0] dense_1 (Dense) (10) 170 dropout_5[0][0] ======================================================================================== Total params: 2,436 Trainable params: 2,180 Non-trainable params: 256 ________________________________________________________________________________________ 5. Pneumonia XRAY 5.1. Information and installation 5.1.1. Information about the dataset The Chest X-Ray Images (Pneumonia) dataset consists of 5856 grayscale images of various sizes in 2 classes (normal/pneumonia). Labels are determined by folder name - NORMAL or PNEUMONIA Input for NN are raw resized 128x128 1 channel images NN output is distribution of probabilities for each class i.e. 2 values Code folder: here Invoke parameter: -t XRAY 5.1.2 Requirements Download dataset: here 5.2. Models 5.2.1. XraySupermini Keras model _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= Input (InputLayer) [(128, 128, 1)] 0 _________________________________________________________________ Conv1_1 (Conv2D) (128, 128, 32) 320 _________________________________________________________________ bn1 (BatchNormalization) (128, 128, 32) 128 _________________________________________________________________ pool1 (MaxPooling2D) (32, 32, 32) 0 _________________________________________________________________ Conv2_1 (Conv2D) (32, 32, 64) 18496 _________________________________________________________________ bn2 (BatchNormalization) (32, 32, 64) 256 _________________________________________________________________ Global_max_pooling2d (64) 0 _________________________________________________________________ fc1 (Dense) (1) 65 ================================================================= Total params: 19,265 Trainable params: 19,073 Non-trainable params: 192 _________________________________________________________________ 5.2.2. XrayResnet50 Keras model _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= Input (InputLayer) [(128, 128, 1)] 0 _________________________________________________________________ resnet50 (Model) (4, 4, 2048) 23581440 _________________________________________________________________ global_average_pooling2d (2048) 0 _________________________________________________________________ flatten (Flatten) (2048) 0 _________________________________________________________________ fc1 (Dense) (1) 2049 ================================================================= Total params: 23,583,489 Trainable params: 23,530,369 Non-trainable params: 53,120 _________________________________________________________________ 5.2.3. XrayPretrainedResnet50 Keras model _____________________________________________________________________________________ Layer (type) Output Shape Param # Connected to ===================================================================================== Input (InputLayer) (128, 128, 1) 0 _____________________________________________________________________________________ concatenate (Concatenate) (128, 128, 3) 0 Input[0][0] Input[0][0] Input[0][0] _____________________________________________________________________________________ tf_op_layer_mul (128, 128, 3) 0 concatenate[0][0] tf_op_layer_strided_slice (128, 128, 3) 0 tf_op_layer_mul[0][0] tf_op_layer_BiasAdd (128, 128, 3) 0 tf_op_layer_strided_slice[0][0] _____________________________________________________________________________________ resnet50 (Model) (4, 4, 2048) 23587712 tf_op_layer_BiasAdd[0][0] _____________________________________________________________________________________ global_average_pooling2d (2048) 0 resnet50[1][0] flatten (Flatten) (2048) 0 global_average_pooling2d[0][0] _____________________________________________________________________________________ fc1 (Dense) (1) 2049 flatten[0][0] ===================================================================================== Total params: 23,589,761 Trainable params: 23,536,641 Non-trainable params: 53,120 _____________________________________________________________________________________ 5.2.4. XrayDropout Keras model _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= Input (InputLayer) [(128, 128, 1)] 0 _________________________________________________________________ Conv1_1 (Conv2D) (128, 128, 128) 1280 bn1 (BatchNormalization) (128, 128, 128) 512 pool1 (MaxPooling2D) (32, 32, 128) 0 _________________________________________________________________ Conv2_1 (Conv2D) (32, 32, 256) 295168 bn2 (BatchNormalization) (32, 32, 256) 1024 pool2 (MaxPooling2D) (8, 8, 256) 0 _________________________________________________________________ flatten (Flatten) (16384) 0 fc1 (Dense) (128) 2097280 bn3 (BatchNormalization) (128) 512 dropout (Dropout) (128) 0 _________________________________________________________________ fc2 (Dense) (64) 8256 bn4 (BatchNormalization) (64) 256 dropout_1 (Dropout) (64) 0 _________________________________________________________________ fc3 (Dense) (1) 65 ================================================================= Total params: 2,404,353 Trainable params: 2,403,201 Non-trainable params: 1,152 _________________________________________________________________ 5.2.5. XrayDropout2 Keras model _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= Input (InputLayer) (128, 128, 1) 0 _________________________________________________________________ Conv1_1 (Conv2D) (128, 128, 64) 640 bn1 (BatchNormalization) (128, 128, 64) 256 pool1 (MaxPooling2D) (64, 64, 64) 0 _________________________________________________________________ Conv2_1 (Conv2D) (64, 64, 128) 73856 bn2 (BatchNormalization) (64, 64, 128) 512 pool2 (MaxPooling2D) (32, 32, 128) 0 _________________________________________________________________ Conv3_1 (Conv2D) (32, 32, 256) 295168 bn3 (BatchNormalization) (32, 32, 256) 1024 pool3 (MaxPooling2D) (16, 16, 256) 0 _________________________________________________________________ Conv4_1 (Conv2D) (16, 16, 512) 1180160 bn4 (BatchNormalization) (16, 16, 512) 2048 pool4 (MaxPooling2D) (8, 8, 512) 0 _________________________________________________________________ Conv5_1 (Conv2D) (8, 8, 512) 2359808 bn5 (BatchNormalization) (8, 8, 512) 2048 pool5 (MaxPooling2D) (4, 4, 512) 0 _________________________________________________________________ flatten (Flatten) (8192) 0 fc1 (Dense) (256) 2097408 bn6 (BatchNormalization) (256) 1024 dropout (Dropout) (256) 0 _________________________________________________________________ fc2 (Dense) (128) 32896 bn7 (BatchNormalization) (128) 512 dropout_1 (Dropout) (128) 0 _________________________________________________________________ fc3 (Dense) (64) 8256 bn8 (BatchNormalization) (64) 256 dropout_2 (Dropout) (64) 0 _________________________________________________________________ fc4 (Dense) (1) 65 ================================================================= Total params: 6,055,937 Trainable params: 6,052,097 Non-trainable params: 3,840 _________________________________________________________________ 5.2.6. XrayVGG16 Keras model _____________________________________________________________________________________ Layer (type) Output Shape Param # Connected to ===================================================================================== Input (InputLayer) (128, 128, 1) 0 _____________________________________________________________________________________ concatenate (Concatenate) (128, 128, 3) 0 Input[0][0] Input[0][0] Input[0][0] _____________________________________________________________________________________ tf_op_layer_mul (128, 128, 3) 0 concatenate[0][0] Tf_op_layer_strided_slice (28, 128, 3) 0 tf_op_layer_mul[0][0] tf_op_layer_BiasAdd (128, 128, 3) 0 tf_op_layer_strided_slice[0][0] _____________________________________________________________________________________ vgg16 (Model) (4, 4, 512) 14714688 tf_op_layer_BiasAdd[0][0] _____________________________________________________________________________________ flatten (Flatten) (8192) 0 vgg16[1][0] fc1 (Dense) (1) 8193 flatten[0][0] ===================================================================================== Total params: 14,722,881 Trainable params: 14,722,881 Non-trainable params: 0 _____________________________________________________________________________________ 5.2.7. XrayMini Keras model _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= Input (InputLayer) [(128, 128, 1)] 0 _________________________________________________________________ Conv1_1 (Conv2D) (128, 128, 128) 1280 bn1 (BatchNormalization) (128, 128, 128) 512 pool1 (MaxPooling2D) (32, 32, 128) 0 _________________________________________________________________ Conv2_1 (Conv2D) (32, 32, 256) 295168 bn2 (BatchNormalization) (32, 32, 256) 1024 pool2 (MaxPooling2D) (8, 8, 256) 0 _________________________________________________________________ flatten (Flatten) (16384) 0 fc1 (Dense) (1) 16385 ================================================================= Total params: 314,369 Trainable params: 313,601 Non-trainable params: 768 _________________________________________________________________ 5.2.7. XrayOneMB Keras model _________________________________________________________________ Layer (type) Output Shape Param # ================================================================= Input (InputLayer) (128, 128, 1) 0 _________________________________________________________________ Conv1_1 (Conv2D) (128, 128, 64) 640 bn1_1 (BatchNormalization) (128, 128, 64) 256 Conv1_2 (Conv2D) (128, 128, 64) 36928 bn1_2 (BatchNormalization) (128, 128, 64) 256 pool1 (MaxPooling2D) (64, 64, 64) 0 _________________________________________________________________ Conv2_1 (Conv2D) (64, 64, 64) 36928 bn2_1 (BatchNormalization) (64, 64, 64) 256 Conv2_2 (Conv2D) (64, 64, 64) 36928 bn2_2 (BatchNormalization) (64, 64, 64) 256 pool2 (MaxPooling2D) (32, 32, 64) 0 _________________________________________________________________ Conv3_1 (Conv2D) (32, 32, 128) 73856 bn3_1 (BatchNormalization) (32, 32, 128) 512 Conv3_2 (SeparableConv2D) (32, 32, 128) 17664 bn3_2 (BatchNormalization) (32, 32, 128) 512 pool3 (MaxPooling2D) (16, 16, 128) 0 _________________________________________________________________ Conv4_1 (SeparableConv2D) (16, 16, 128) 17664 bn4_1 (BatchNormalization) (16, 16, 128) 512 _________________________________________________________________ Conv4_2 (SeparableConv2D) (16, 16, 128) 17664 bn4_2 (BatchNormalization) (16, 16, 128) 512 _________________________________________________________________ pool4 (AveragePooling2D) (4, 4, 128) 0 flatten (Flatten) (2048) 0 _________________________________________________________________ fc1 (Dense) (1) 2049 ================================================================= Total params: 243,393 Trainable params: 241,857 Non-trainable params: 1,536 _________________________________________________________________","title":"1. CIFAR10 dataset"},{"location":"colearn/tasks/#1-cifar10-dataset","text":"","title":"1. CIFAR10 dataset"},{"location":"colearn/tasks/#11-information-and-installation","text":"","title":"1.1. Information and installation"},{"location":"colearn/tasks/#111-information-about-the-dataset","text":"The CIFAR-10 dataset consists of 60000 32x32x3 colour images in 10 classes, with 6000 images per class. The 10 different classes represent airplanes, cars, birds, cats, deer, dogs, frogs, horses, ships, and trucks Input for NN are raw 32x32 3 channels GRB images NN output is distribution of probabilities for each class i.e. 10 values that sums up to 1 Code folder: here Invoke parameter: -t CIFAR10","title":"1.1.1. Information about the dataset"},{"location":"colearn/tasks/#112-requirements","text":"Cifar dataset is loaded from tensorflow.keras.datasets.cifar10 and no stored data are required","title":"1.1.2. Requirements"},{"location":"colearn/tasks/#12-models","text":"","title":"1.2. Models"},{"location":"colearn/tasks/#121-cifar10conv-keras-model","text":"_________________________________________________________________ Layer (type) Output Shape Param # ================================================================= Input (InputLayer) (32, 32, 3) 0 _________________________________________________________________ Conv1_1 (Conv2D) (32, 32, 64) 1792 bn1_1 (BatchNormalization) (32, 32, 64) 256 Conv1_2 (Conv2D) (32, 32, 64) 36928 bn1_2 (BatchNormalization) (32, 32, 64) 256 pool1 (MaxPooling2D) (16, 16, 64) 0 _________________________________________________________________ Conv2_1 (Conv2D) (16, 16, 128 73856 bn2_1 (BatchNormalization) (16, 16, 128 512 Conv2_2 (Conv2D) (16, 16, 128 147584 bn2_2 (BatchNormalization) (16, 16, 128 512 pool2 (MaxPooling2D) (8, 8, 128) 0 _________________________________________________________________ Conv3_1 (Conv2D) (8, 8, 256) 295168 bn3_1 (BatchNormalization) (8, 8, 256) 1024 Conv3_2 (Conv2D) (8, 8, 256) 590080 bn3_2 (BatchNormalization) (8, 8, 256) 1024 Conv3_3 (Conv2D) (8, 8, 256) 590080 bn3_3 (BatchNormalization) (8, 8, 256) 1024 _________________________________________________________________ flatten (Flatten) (16384) 0 fc1 (Dense) (100) 1638500 fc2 (Dense) (10) 1010 ================================================================= Total params: 3,379,606 Trainable params: 3,377,302 Non-trainable params: 2,304 _________________________________________________________________","title":"1.2.1. CIFAR10Conv Keras model"},{"location":"colearn/tasks/#122-cifar10conv2-keras-model","text":"_________________________________________________________ Layer (type) Output Shape Param # ========================================================= Input (InputLayer) (32, 32, 3) 0 _________________________________________________________ Conv1_1 (Conv2D) (32, 32, 32) 896 Conv1_2 (Conv2D) (32, 32, 32) 9248 pool1 (MaxPooling2D) (16, 16, 32) 0 _________________________________________________________ Conv2_1 (Conv2D) (16, 16, 64) 18496 Conv2_2 (Conv2D) (16, 16, 64) 36928 pool2 (MaxPooling2D) (8, 8, 64) 0 _________________________________________________________ Conv3_1 (Conv2D) (8, 8, 128) 73856 Conv3_2 (Conv2D) (8, 8, 128) 147584 pool3 (MaxPooling2D) (4, 4, 128) 0 _________________________________________________________ flatten (Flatten) (2048) 0 fc1 (Dense) (128) 262272 fc2 (Dense) (10) 1290 ========================================================= Total params: 550,570 Trainable params: 550,570 Non-trainable params: 0 _________________________________________________________","title":"1.2.2. CIFAR10Conv2 Keras model"},{"location":"colearn/tasks/#123-cifar10resnet50-keras-model","text":"________________________________________________________ Layer (type) Output Shape Param # ======================================================== Input (InputLayer) (32, 32, 3)] 0 ________________________________________________________ resnet50 (Model) (1, 1, 2048) 23587712 ________________________________________________________ Global_average_pooling2d (2048) 0 flatten (Flatten) (2048) 0 fc1 (Dense) (10) 20490 ======================================================== Total params: 23,608,202 Trainable params: 23,555,082 Non-trainable params: 53,120 ________________________________________________________","title":"1.2.3. CIFAR10Resnet50 Keras model"},{"location":"colearn/tasks/#2-covid-x-ray-dataset","text":"","title":"2. Covid X-RAY dataset"},{"location":"colearn/tasks/#21-information-and-installation","text":"","title":"2.1. Information and installation"},{"location":"colearn/tasks/#211-information-about-the-dataset","text":"The Covid X-Ray dataset consists of grayscale images, there are 478 covid images and 203 normal images. To increase the number of images normal/pneumonia dataset is added Final dataset, which is a combination of two previously mentioned datasets, contains 1434 images, 478 images for each class. Images are cropped and resized to 512x512 pixel and spatial domain (Texture, GLDM, GLCM) and frequency domain (FFT and Wavelet) features are used to create 256 dimensional vector representation of each image. PCA is applied after to reduce dimensionality to 64 values which represents the first 64 highest eigenvalues of the covariance matrix. Input for NN are 64 values for each image NN output is distribution of probabilities for each class i.e. 3 values Code folder: here Invoke parameter: -t COVID","title":"2.1.1. Information about the dataset"},{"location":"colearn/tasks/#212-requirements","text":"Download Covid dataset: here Download pneumonia dataset: here","title":"2.1.2 Requirements"},{"location":"colearn/tasks/#22-models","text":"","title":"2.2. Models"},{"location":"colearn/tasks/#221-covid-xray-keras-model","text":"_________________________________________________________ Layer (type) Output Shape Param # ========================================================= input_1 (InputLayer) (64) 0 _________________________________________________________ dense (Dense) (128) 8320 dropout (Dropout) (128) 0 _________________________________________________________ dense_1 (Dense) (16) 2064 dropout_1 (Dropout) (16) 0 _________________________________________________________ dense_2 (Dense) (3) 51 ========================================================= Total params: 10,435 Trainable params: 10,435 Non-trainable params: 0 _________________________________________________________","title":"2.2.1. Covid XRAY Keras model"},{"location":"colearn/tasks/#3-fraud-dataset","text":"","title":"3. FRAUD dataset"},{"location":"colearn/tasks/#31-information-and-installation","text":"","title":"3.1. Information and installation"},{"location":"colearn/tasks/#311-information-about-the-dataset","text":"EEE-CIS Fraud Detection, contains multiple files with credit card transactions Raw dataset files are automatically merged and pre-processed and input files for neural network are created X.csv with data - has 431 values for each transaction Y.csv with labels - v has 1 value for each transaction 0 = not a fraud 1 = fraud Code folder: here Invoke parameter: -t FRAUD","title":"3.1.1. Information about the dataset"},{"location":"colearn/tasks/#312-requirements","text":"Download dataset: here","title":"3.1.2. Requirements"},{"location":"colearn/tasks/#32-models","text":"","title":"3.2. Models"},{"location":"colearn/tasks/#321-frauddense1-keras-model","text":"_________________________________________________________ Layer (type) Output Shape Param # ========================================================= Input (InputLayer) (431) 0 _________________________________________________________ dense (Dense) (512) 221184 Batch_normalization (512) 2048 _________________________________________________________ dense_1 (Dense) (512) 262656 Batch_normalization_1 (512) 2048 _________________________________________________________ dense_2 (Dense) (512) 262656 Batch_normalization_2 (512) 2048 _________________________________________________________ fc1 (Dense) (1) 513 ========================================================= Total params: 753,153 Trainable params: 750,081 Non-trainable params: 3,072 _________________________________________________________","title":"3.2.1. FraudDense1 Keras model"},{"location":"colearn/tasks/#322-fraudsvm-scikit-learn-model","text":"Model is defined as SGDClassifier(max_iter=1, verbose=0, loss=\"modified_huber\") Which is support vector machine linear classifier","title":"3.2.2. FraudSVM Scikit-learn model"},{"location":"colearn/tasks/#4-mnist","text":"","title":"4. MNIST"},{"location":"colearn/tasks/#41-information-and-installation","text":"","title":"4.1. Information and installation"},{"location":"colearn/tasks/#411-information-about-the-dataset","text":"This is a dataset of 70,000 28x28x1 grayscale images of the 10 digits Input for NN are raw 28x28 1 channel images NN output is distribution of probabilities for each class i.e. 10 values that sums up to 1 Code folder: here Invoke parameter: -t MNIST","title":"4.1.1. Information about the dataset"},{"location":"colearn/tasks/#412-requirements","text":"MNIST dataset is loaded from tensorflow.keras.datasets.cifar10 and no stored data are required","title":"4.1.2 Requirements"},{"location":"colearn/tasks/#42-models","text":"","title":"4.2. Models"},{"location":"colearn/tasks/#421-mnistconv-keras-model","text":"_________________________________________________________ Layer (type) Output Shape Param # ========================================================= Input (InputLayer) (28, 28, 1) 0 _________________________________________________________ Conv1_1 (Conv2D) (28, 28, 64) 640 bn1 (BatchNormalization) (28, 28, 64) 256 pool1 (MaxPooling2D) (14, 14, 64) 0 _________________________________________________________ Conv2_1 (Conv2D) (14, 14, 128) 73856 bn4 (BatchNormalization) (14, 14, 128) 512 pool2 (MaxPooling2D) (7, 7, 128) 0 _________________________________________________________ flatten (Flatten) (6272) 0 fc1 (Dense) (10) 62730 ========================================================= Total params: 137,994 Trainable params: 137,610 Non-trainable params: 384 _________________________________________________________","title":"4.2.1. MNISTConv Keras model"},{"location":"colearn/tasks/#422-mnist-pytorch-model","text":"--------------------------------------------------------- Layer (type) Output Shape Param # ========================================================= Input [28,28,1] 0 Conv2d-1 [20, 24, 24] 520 Conv2d-2 [50, 8, 8] 25,050 Linear-3 [500] 400,500 Linear-4 [10] 5,010 ========================================================= Total params: 431,080 Trainable params: 431,080 Non-trainable params: 0 ---------------------------------------------------------","title":"4.2.2. MNIST Pytorch model"},{"location":"colearn/tasks/#423-mnistsupermini-keras-model","text":"________________________________________________________________________________________ Layer (type) Output Shape Param # Connected to ======================================================================================== input_1 (InputLayer) (28, 28, 1) 0 ________________________________________________________________________________________ conv2d (Conv2D) (26, 26, 8) 80 input_1[0][0] Batch_normalization (26, 26, 8) 32 conv2d[0][0] Max_pooling2d (13, 13, 8) 0 batch_normalization[0][0] dropout (Dropout) (13, 13, 8) 0 max_pooling2d[0][0] ________________________________________________________________________________________ Separable_conv2d (11, 11, 26) 306 dropout[0][0] batch_normalization_1 (11, 11, 26) 104 separable_conv2d[0][0] dropout_1 (Dropout) (11, 11, 26) 0 batch_normalization_1[0][0] ________________________________________________________________________________________ Separable_conv2d_1 (11, 11, 26) 936 dropout_1[0][0] dropout_2[0][0] dropout_3[0][0] ________________________________________________________________________________________ Batch_normalization_2 (11, 11, 26) 104 separable_conv2d_1[0][0] dropout_2 (Dropout) (11, 11, 26) 0 batch_normalization_2[0][0] ________________________________________________________________________________________ Batch_normalization_3 (11, 11, 26) 104 separable_conv2d_1[1][0] dropout_3 (Dropout) (11, 11, 26) 0 batch_normalization_3[0][0] ________________________________________________________________________________________ Batch_normalization_4 (11, 11, 26) 104 separable_conv2d_1[2][0] dropout_4 (Dropout) (11, 11, 26) 0 batch_normalization_4[0][0] ________________________________________________________________________________________ Global_average_pooling2d (26) 0 dropout_4[0][0] dense (Dense) (16) 432 global_average_pooling2d[0][0] Batch_normalization_5 (16) 64 dense[0][0] dropout_5 (Dropout) (16) 0 batch_normalization_5[0][0] dense_1 (Dense) (10) 170 dropout_5[0][0] ======================================================================================== Total params: 2,436 Trainable params: 2,180 Non-trainable params: 256 ________________________________________________________________________________________","title":"4.2.3. MNISTSupermini Keras model"},{"location":"colearn/tasks/#5-pneumonia-xray","text":"","title":"5. Pneumonia XRAY"},{"location":"colearn/tasks/#51-information-and-installation","text":"","title":"5.1. Information and installation"},{"location":"colearn/tasks/#511-information-about-the-dataset","text":"The Chest X-Ray Images (Pneumonia) dataset consists of 5856 grayscale images of various sizes in 2 classes (normal/pneumonia). Labels are determined by folder name - NORMAL or PNEUMONIA Input for NN are raw resized 128x128 1 channel images NN output is distribution of probabilities for each class i.e. 2 values Code folder: here Invoke parameter: -t XRAY","title":"5.1.1. Information about the dataset"},{"location":"colearn/tasks/#512-requirements","text":"Download dataset: here","title":"5.1.2 Requirements"},{"location":"colearn/tasks/#52-models","text":"","title":"5.2. Models"},{"location":"colearn/tasks/#521-xraysupermini-keras-model","text":"_________________________________________________________________ Layer (type) Output Shape Param # ================================================================= Input (InputLayer) [(128, 128, 1)] 0 _________________________________________________________________ Conv1_1 (Conv2D) (128, 128, 32) 320 _________________________________________________________________ bn1 (BatchNormalization) (128, 128, 32) 128 _________________________________________________________________ pool1 (MaxPooling2D) (32, 32, 32) 0 _________________________________________________________________ Conv2_1 (Conv2D) (32, 32, 64) 18496 _________________________________________________________________ bn2 (BatchNormalization) (32, 32, 64) 256 _________________________________________________________________ Global_max_pooling2d (64) 0 _________________________________________________________________ fc1 (Dense) (1) 65 ================================================================= Total params: 19,265 Trainable params: 19,073 Non-trainable params: 192 _________________________________________________________________","title":"5.2.1. XraySupermini Keras model"},{"location":"colearn/tasks/#522-xrayresnet50-keras-model","text":"_________________________________________________________________ Layer (type) Output Shape Param # ================================================================= Input (InputLayer) [(128, 128, 1)] 0 _________________________________________________________________ resnet50 (Model) (4, 4, 2048) 23581440 _________________________________________________________________ global_average_pooling2d (2048) 0 _________________________________________________________________ flatten (Flatten) (2048) 0 _________________________________________________________________ fc1 (Dense) (1) 2049 ================================================================= Total params: 23,583,489 Trainable params: 23,530,369 Non-trainable params: 53,120 _________________________________________________________________","title":"5.2.2. XrayResnet50 Keras model"},{"location":"colearn/tasks/#523-xraypretrainedresnet50-keras-model","text":"_____________________________________________________________________________________ Layer (type) Output Shape Param # Connected to ===================================================================================== Input (InputLayer) (128, 128, 1) 0 _____________________________________________________________________________________ concatenate (Concatenate) (128, 128, 3) 0 Input[0][0] Input[0][0] Input[0][0] _____________________________________________________________________________________ tf_op_layer_mul (128, 128, 3) 0 concatenate[0][0] tf_op_layer_strided_slice (128, 128, 3) 0 tf_op_layer_mul[0][0] tf_op_layer_BiasAdd (128, 128, 3) 0 tf_op_layer_strided_slice[0][0] _____________________________________________________________________________________ resnet50 (Model) (4, 4, 2048) 23587712 tf_op_layer_BiasAdd[0][0] _____________________________________________________________________________________ global_average_pooling2d (2048) 0 resnet50[1][0] flatten (Flatten) (2048) 0 global_average_pooling2d[0][0] _____________________________________________________________________________________ fc1 (Dense) (1) 2049 flatten[0][0] ===================================================================================== Total params: 23,589,761 Trainable params: 23,536,641 Non-trainable params: 53,120 _____________________________________________________________________________________","title":"5.2.3. XrayPretrainedResnet50 Keras model"},{"location":"colearn/tasks/#524-xraydropout-keras-model","text":"_________________________________________________________________ Layer (type) Output Shape Param # ================================================================= Input (InputLayer) [(128, 128, 1)] 0 _________________________________________________________________ Conv1_1 (Conv2D) (128, 128, 128) 1280 bn1 (BatchNormalization) (128, 128, 128) 512 pool1 (MaxPooling2D) (32, 32, 128) 0 _________________________________________________________________ Conv2_1 (Conv2D) (32, 32, 256) 295168 bn2 (BatchNormalization) (32, 32, 256) 1024 pool2 (MaxPooling2D) (8, 8, 256) 0 _________________________________________________________________ flatten (Flatten) (16384) 0 fc1 (Dense) (128) 2097280 bn3 (BatchNormalization) (128) 512 dropout (Dropout) (128) 0 _________________________________________________________________ fc2 (Dense) (64) 8256 bn4 (BatchNormalization) (64) 256 dropout_1 (Dropout) (64) 0 _________________________________________________________________ fc3 (Dense) (1) 65 ================================================================= Total params: 2,404,353 Trainable params: 2,403,201 Non-trainable params: 1,152 _________________________________________________________________","title":"5.2.4. XrayDropout Keras model"},{"location":"colearn/tasks/#525-xraydropout2-keras-model","text":"_________________________________________________________________ Layer (type) Output Shape Param # ================================================================= Input (InputLayer) (128, 128, 1) 0 _________________________________________________________________ Conv1_1 (Conv2D) (128, 128, 64) 640 bn1 (BatchNormalization) (128, 128, 64) 256 pool1 (MaxPooling2D) (64, 64, 64) 0 _________________________________________________________________ Conv2_1 (Conv2D) (64, 64, 128) 73856 bn2 (BatchNormalization) (64, 64, 128) 512 pool2 (MaxPooling2D) (32, 32, 128) 0 _________________________________________________________________ Conv3_1 (Conv2D) (32, 32, 256) 295168 bn3 (BatchNormalization) (32, 32, 256) 1024 pool3 (MaxPooling2D) (16, 16, 256) 0 _________________________________________________________________ Conv4_1 (Conv2D) (16, 16, 512) 1180160 bn4 (BatchNormalization) (16, 16, 512) 2048 pool4 (MaxPooling2D) (8, 8, 512) 0 _________________________________________________________________ Conv5_1 (Conv2D) (8, 8, 512) 2359808 bn5 (BatchNormalization) (8, 8, 512) 2048 pool5 (MaxPooling2D) (4, 4, 512) 0 _________________________________________________________________ flatten (Flatten) (8192) 0 fc1 (Dense) (256) 2097408 bn6 (BatchNormalization) (256) 1024 dropout (Dropout) (256) 0 _________________________________________________________________ fc2 (Dense) (128) 32896 bn7 (BatchNormalization) (128) 512 dropout_1 (Dropout) (128) 0 _________________________________________________________________ fc3 (Dense) (64) 8256 bn8 (BatchNormalization) (64) 256 dropout_2 (Dropout) (64) 0 _________________________________________________________________ fc4 (Dense) (1) 65 ================================================================= Total params: 6,055,937 Trainable params: 6,052,097 Non-trainable params: 3,840 _________________________________________________________________","title":"5.2.5. XrayDropout2 Keras model"},{"location":"colearn/tasks/#526-xrayvgg16-keras-model","text":"_____________________________________________________________________________________ Layer (type) Output Shape Param # Connected to ===================================================================================== Input (InputLayer) (128, 128, 1) 0 _____________________________________________________________________________________ concatenate (Concatenate) (128, 128, 3) 0 Input[0][0] Input[0][0] Input[0][0] _____________________________________________________________________________________ tf_op_layer_mul (128, 128, 3) 0 concatenate[0][0] Tf_op_layer_strided_slice (28, 128, 3) 0 tf_op_layer_mul[0][0] tf_op_layer_BiasAdd (128, 128, 3) 0 tf_op_layer_strided_slice[0][0] _____________________________________________________________________________________ vgg16 (Model) (4, 4, 512) 14714688 tf_op_layer_BiasAdd[0][0] _____________________________________________________________________________________ flatten (Flatten) (8192) 0 vgg16[1][0] fc1 (Dense) (1) 8193 flatten[0][0] ===================================================================================== Total params: 14,722,881 Trainable params: 14,722,881 Non-trainable params: 0 _____________________________________________________________________________________","title":"5.2.6. XrayVGG16 Keras model"},{"location":"colearn/tasks/#527-xraymini-keras-model","text":"_________________________________________________________________ Layer (type) Output Shape Param # ================================================================= Input (InputLayer) [(128, 128, 1)] 0 _________________________________________________________________ Conv1_1 (Conv2D) (128, 128, 128) 1280 bn1 (BatchNormalization) (128, 128, 128) 512 pool1 (MaxPooling2D) (32, 32, 128) 0 _________________________________________________________________ Conv2_1 (Conv2D) (32, 32, 256) 295168 bn2 (BatchNormalization) (32, 32, 256) 1024 pool2 (MaxPooling2D) (8, 8, 256) 0 _________________________________________________________________ flatten (Flatten) (16384) 0 fc1 (Dense) (1) 16385 ================================================================= Total params: 314,369 Trainable params: 313,601 Non-trainable params: 768 _________________________________________________________________","title":"5.2.7. XrayMini Keras model"},{"location":"colearn/tasks/#527-xrayonemb-keras-model","text":"_________________________________________________________________ Layer (type) Output Shape Param # ================================================================= Input (InputLayer) (128, 128, 1) 0 _________________________________________________________________ Conv1_1 (Conv2D) (128, 128, 64) 640 bn1_1 (BatchNormalization) (128, 128, 64) 256 Conv1_2 (Conv2D) (128, 128, 64) 36928 bn1_2 (BatchNormalization) (128, 128, 64) 256 pool1 (MaxPooling2D) (64, 64, 64) 0 _________________________________________________________________ Conv2_1 (Conv2D) (64, 64, 64) 36928 bn2_1 (BatchNormalization) (64, 64, 64) 256 Conv2_2 (Conv2D) (64, 64, 64) 36928 bn2_2 (BatchNormalization) (64, 64, 64) 256 pool2 (MaxPooling2D) (32, 32, 64) 0 _________________________________________________________________ Conv3_1 (Conv2D) (32, 32, 128) 73856 bn3_1 (BatchNormalization) (32, 32, 128) 512 Conv3_2 (SeparableConv2D) (32, 32, 128) 17664 bn3_2 (BatchNormalization) (32, 32, 128) 512 pool3 (MaxPooling2D) (16, 16, 128) 0 _________________________________________________________________ Conv4_1 (SeparableConv2D) (16, 16, 128) 17664 bn4_1 (BatchNormalization) (16, 16, 128) 512 _________________________________________________________________ Conv4_2 (SeparableConv2D) (16, 16, 128) 17664 bn4_2 (BatchNormalization) (16, 16, 128) 512 _________________________________________________________________ pool4 (AveragePooling2D) (4, 4, 128) 0 flatten (Flatten) (2048) 0 _________________________________________________________________ fc1 (Dense) (1) 2049 ================================================================= Total params: 243,393 Trainable params: 241,857 Non-trainable params: 1,536 _________________________________________________________________","title":"5.2.7. XrayOneMB Keras model"},{"location":"ledger_v2/","text":"Mainnet is here The fetchhub mainnet forms the core of the Fetch.ai ecosystem. In these pages, you will find all information to setup your client and connect on the network and cli-introduction pages. Previous test networks are still available as well for your tests and experiments. This documentation covers some of the things you need to know in order to prepare for and develop for this new network: Test Networks The starting point for most developers will be our Agent Land test network, since this is primarily used for agent development and testing. Agent Land is fully supported by our Agent Framework from version 0.6 and above. If you are developing autonomous economic agents using our latest framework, then moving to Agent Land is relatively straightforward, unless smart contracts are involved. Agentland and other testnets on the journey have a new address format. Here is a typical example: fetch1almpjpf769p23k0v4m5eglvzr4jupsjs66vxf4 Key links and information Block explorer and token tap: https://explore-agent-land.fetch.ai/ Understanding building block relationships: https://docs.fetch.ai/aea/oef-ledger/ For more detailed information, have a look at our network information page. Roadmap for Smart Contracts The fetchhub mainnet along with our test-nets support a webassembly (WASM) virtual machine VM. Smart contracts can be developed using Cosmwasm, which currently supports contracts written in Rust but will in future support a variety of languages such as Go, Python or Javascript. For more information on Rust contracts for Cosmwasm, you can go to https://www.cosmwasm.com/ and https://github.com/CosmWasm/cosmwasm-template .","title":"Introduction"},{"location":"ledger_v2/#mainnet-is-here","text":"The fetchhub mainnet forms the core of the Fetch.ai ecosystem. In these pages, you will find all information to setup your client and connect on the network and cli-introduction pages. Previous test networks are still available as well for your tests and experiments. This documentation covers some of the things you need to know in order to prepare for and develop for this new network:","title":"Mainnet is here"},{"location":"ledger_v2/#test-networks","text":"The starting point for most developers will be our Agent Land test network, since this is primarily used for agent development and testing. Agent Land is fully supported by our Agent Framework from version 0.6 and above. If you are developing autonomous economic agents using our latest framework, then moving to Agent Land is relatively straightforward, unless smart contracts are involved. Agentland and other testnets on the journey have a new address format. Here is a typical example: fetch1almpjpf769p23k0v4m5eglvzr4jupsjs66vxf4","title":"Test Networks"},{"location":"ledger_v2/#key-links-and-information","text":"Block explorer and token tap: https://explore-agent-land.fetch.ai/ Understanding building block relationships: https://docs.fetch.ai/aea/oef-ledger/ For more detailed information, have a look at our network information page.","title":"Key links and information"},{"location":"ledger_v2/#roadmap-for-smart-contracts","text":"The fetchhub mainnet along with our test-nets support a webassembly (WASM) virtual machine VM. Smart contracts can be developed using Cosmwasm, which currently supports contracts written in Rust but will in future support a variety of languages such as Go, Python or Javascript. For more information on Rust contracts for Cosmwasm, you can go to https://www.cosmwasm.com/ and https://github.com/CosmWasm/cosmwasm-template .","title":"Roadmap for Smart Contracts"},{"location":"ledger_v2/block-explorer/","text":"Block Explorer Each of the networks has a dedicated block explorer web site associated with it. This is a useful tool for monitoring network activity. Logging in with the Ledger Nano Return to the block explorer landing page and click on the key button in the top right corner. You'll then be prompted to \"Sign in With Ledger\". You must accept this request on your ledger nano device. After completing this process, the key button will be replaced by a person icon with a link to your personal address page, which keeps track of the activity that you have performed on the test-net. Getting Testnet Tokens from the Faucet For networks that support it, you can obtain tokens for your account by copying the address and pasting it into the token faucet. Then, return to the main page, press the \"Get Funds\" button and paste your address in the pop-up. Afterwards you can return to your address page (via the person icon) and should observe that you have been allocated 1 TESTFET. Transferring Tokens to another Address After receiving tokens, you can send these to another address using the purple Transfer button on your address page. This will trigger a pop-up that prompts you to specify the destination address and the amount you wish to transfer. After filling in this information, you will be asked to sign the transaction using your ledger nano. The confirmation that the transaction has been broadcast gives two links that can be used to check that the transaction has been executed on the blockchain using either the transaction hash or your account page. Note: The transaction format includes a memo field that can be used to check the transaction information on the ledger nano display. Delegating Stake to a Validator You can delegate your test-net tokens to a validator who is operating the network by clicking on the Validators tab, and selecting one of the validators that you wish to delegate stake towards. In the Voting Power panel there is an option to DELEGATE tokens. Pressing this button will trigger a pop-up that prompts you to select a delegation amount and then sign the transaction with your Ledger Nano device. After delegating tokens, buttons labelled with REDELEGATE and UNDELEGATE will appear. The delegation of tokens to a validator provides you with a reward for helping to secure the network. It is also possible to delegate your tokens to a different validator using a REDELEGATE transaction. You can return any bonded tokens to your address by submitting an UNDELEGATE request, which will trigger the tokens to be returned after 21 days have elapsed. The rewards that you receive from delegating tokens to a validator are shown in the account page. These can be sent to your address by sending a WITHDRAW transaction.","title":"Block Explorer"},{"location":"ledger_v2/block-explorer/#block-explorer","text":"Each of the networks has a dedicated block explorer web site associated with it. This is a useful tool for monitoring network activity.","title":"Block Explorer"},{"location":"ledger_v2/block-explorer/#logging-in-with-the-ledger-nano","text":"Return to the block explorer landing page and click on the key button in the top right corner. You'll then be prompted to \"Sign in With Ledger\". You must accept this request on your ledger nano device. After completing this process, the key button will be replaced by a person icon with a link to your personal address page, which keeps track of the activity that you have performed on the test-net.","title":"Logging in with the Ledger Nano"},{"location":"ledger_v2/block-explorer/#getting-testnet-tokens-from-the-faucet","text":"For networks that support it, you can obtain tokens for your account by copying the address and pasting it into the token faucet. Then, return to the main page, press the \"Get Funds\" button and paste your address in the pop-up. Afterwards you can return to your address page (via the person icon) and should observe that you have been allocated 1 TESTFET.","title":"Getting Testnet Tokens from the Faucet"},{"location":"ledger_v2/block-explorer/#transferring-tokens-to-another-address","text":"After receiving tokens, you can send these to another address using the purple Transfer button on your address page. This will trigger a pop-up that prompts you to specify the destination address and the amount you wish to transfer. After filling in this information, you will be asked to sign the transaction using your ledger nano. The confirmation that the transaction has been broadcast gives two links that can be used to check that the transaction has been executed on the blockchain using either the transaction hash or your account page. Note: The transaction format includes a memo field that can be used to check the transaction information on the ledger nano display.","title":"Transferring Tokens to another Address"},{"location":"ledger_v2/block-explorer/#delegating-stake-to-a-validator","text":"You can delegate your test-net tokens to a validator who is operating the network by clicking on the Validators tab, and selecting one of the validators that you wish to delegate stake towards. In the Voting Power panel there is an option to DELEGATE tokens. Pressing this button will trigger a pop-up that prompts you to select a delegation amount and then sign the transaction with your Ledger Nano device. After delegating tokens, buttons labelled with REDELEGATE and UNDELEGATE will appear. The delegation of tokens to a validator provides you with a reward for helping to secure the network. It is also possible to delegate your tokens to a different validator using a REDELEGATE transaction. You can return any bonded tokens to your address by submitting an UNDELEGATE request, which will trigger the tokens to be returned after 21 days have elapsed. The rewards that you receive from delegating tokens to a validator are shown in the account page. These can be sent to your address by sending a WITHDRAW transaction.","title":"Delegating Stake to a Validator"},{"location":"ledger_v2/building/","text":"Building the Ledger Prerequisites Go 1.16+ (installation instructions available here ) Packages: make , gcc (on ubunty, install them with sudo apt-get update && sudo apt-get install -y make gcc ) Building the code Download the latest released version from github and build the project using the following commands: git clone https://github.com/fetchai/fetchd.git && cd fetchd Then select the particular tag version you want to build, ie: git checkout v0.8.7 Then build the code with the command: make build This will generate the ./build/fetchd binary. For non-developer users we recommend that the user installs the binaries into their system. This can be done with the following command: make install This will install the binaries in the directory specified by your $GOBIN environment variable (default to ~/go/bin ). which fetchd This should return a path such as ~/go/bin/fetchd (might be different depending on your actual go installation). If you get no output, or an error such as which: no fetchd in ... , possible cause can either be that make install failed with some errors or that your go binary folder (default: ~/go/bin) is not in your PATH . To add the ~/go/bin folder to your PATH, add this line at the end of your ~/.bashrc: export PATH=$PATH:~/go/bin and reload it with: source ~/.bashrc You can also verify that you are running the correct version fetchd version This should print a version number that must be compatible with the network you're connecting to (see the network page for the list of supported versions per network). FAQ Error: failed to parse log level (main:info,state:info,:error): Unknown Level String: 'main:info,state:info,:error', defaulting to NoLevel This means you had a pre-stargate version of fetchd (<= v0.7.x), and just installed a stargate version (>= v0.8.x), you'll need to remove the previous configuration files with: rm ~/.fetchd/config/app.toml ~/.fetchd/config/config.toml","title":"Installation"},{"location":"ledger_v2/building/#building-the-ledger","text":"","title":"Building the Ledger"},{"location":"ledger_v2/building/#prerequisites","text":"Go 1.16+ (installation instructions available here ) Packages: make , gcc (on ubunty, install them with sudo apt-get update && sudo apt-get install -y make gcc )","title":"Prerequisites"},{"location":"ledger_v2/building/#building-the-code","text":"Download the latest released version from github and build the project using the following commands: git clone https://github.com/fetchai/fetchd.git && cd fetchd Then select the particular tag version you want to build, ie: git checkout v0.8.7 Then build the code with the command: make build This will generate the ./build/fetchd binary. For non-developer users we recommend that the user installs the binaries into their system. This can be done with the following command: make install This will install the binaries in the directory specified by your $GOBIN environment variable (default to ~/go/bin ). which fetchd This should return a path such as ~/go/bin/fetchd (might be different depending on your actual go installation). If you get no output, or an error such as which: no fetchd in ... , possible cause can either be that make install failed with some errors or that your go binary folder (default: ~/go/bin) is not in your PATH . To add the ~/go/bin folder to your PATH, add this line at the end of your ~/.bashrc: export PATH=$PATH:~/go/bin and reload it with: source ~/.bashrc You can also verify that you are running the correct version fetchd version This should print a version number that must be compatible with the network you're connecting to (see the network page for the list of supported versions per network).","title":"Building the code"},{"location":"ledger_v2/building/#faq","text":"Error: failed to parse log level (main:info,state:info,:error): Unknown Level String: 'main:info,state:info,:error', defaulting to NoLevel This means you had a pre-stargate version of fetchd (<= v0.7.x), and just installed a stargate version (>= v0.8.x), you'll need to remove the previous configuration files with: rm ~/.fetchd/config/app.toml ~/.fetchd/config/config.toml","title":"FAQ"},{"location":"ledger_v2/cli-bls/","text":"BLS signatures The BLS algorithm can be selected when creating new keys and signing transactions. BLS supported keys are particularly useful for the increasing the efficiency of multi-signature transactions at the cost of simplicity in verification. It affords the users a shorter and yet still robust grouping of each signature from party members without the sacrifice of security on each multi-signature transaction. Creating BLS keys Creating BLS keys is straightforward in comparison to normal key instantiation with the addition of one extra parameter to the command. This example will show the additional flag required in comparison to a key with the standard algorithm; with 'bls12381' in place of the default 'secp256k1'. Example # Create a normal key fetchd keys add Ron # Create a key capable of BLS signed transactions fetchd keys add Tom_BLS --algo bls12381 # 'Ron' can be assumed to define implicitly --algo secp256k1 by default BLS Transactions and signatures After creating this BLS key, transactions can be carried out between two keys using the different algorithms. Example Ensure that the 'Ron' key has some funds before performing this example. # Perform a normal transfer of funds from Ron to Tom_BLS fetchd tx bank send <address_of_Ron> <address_of_Tom_BLS> 1000test # This should provide a breakdown of the transaction parameters, including the gas fees # Keep note of these fees # Check that these funds have been transferred to Tom_BLS fetchd query bank balaces <address_of_Tom_BLS> # Perform a BLS signed transaction from Tom_BLS to Ron fetchd tx bank send <address_of_Tom_BLS> <address_of_Ron> 1000test # Compare the difference between information printed from each transaction and observe # the difference in gas costs (?) # Now assure funds were successfully transferred back to Ron through a BLS signed transaction fetchd query bank balaces <address_of_Tom_BLS> fetchd query bank balaces <address_of_Ron>","title":"BLS signatures"},{"location":"ledger_v2/cli-bls/#bls-signatures","text":"The BLS algorithm can be selected when creating new keys and signing transactions. BLS supported keys are particularly useful for the increasing the efficiency of multi-signature transactions at the cost of simplicity in verification. It affords the users a shorter and yet still robust grouping of each signature from party members without the sacrifice of security on each multi-signature transaction.","title":"BLS signatures"},{"location":"ledger_v2/cli-bls/#creating-bls-keys","text":"Creating BLS keys is straightforward in comparison to normal key instantiation with the addition of one extra parameter to the command. This example will show the additional flag required in comparison to a key with the standard algorithm; with 'bls12381' in place of the default 'secp256k1'.","title":"Creating BLS keys"},{"location":"ledger_v2/cli-bls/#example","text":"# Create a normal key fetchd keys add Ron # Create a key capable of BLS signed transactions fetchd keys add Tom_BLS --algo bls12381 # 'Ron' can be assumed to define implicitly --algo secp256k1 by default","title":"Example"},{"location":"ledger_v2/cli-bls/#bls-transactions-and-signatures","text":"After creating this BLS key, transactions can be carried out between two keys using the different algorithms.","title":"BLS Transactions and signatures"},{"location":"ledger_v2/cli-bls/#example_1","text":"Ensure that the 'Ron' key has some funds before performing this example. # Perform a normal transfer of funds from Ron to Tom_BLS fetchd tx bank send <address_of_Ron> <address_of_Tom_BLS> 1000test # This should provide a breakdown of the transaction parameters, including the gas fees # Keep note of these fees # Check that these funds have been transferred to Tom_BLS fetchd query bank balaces <address_of_Tom_BLS> # Perform a BLS signed transaction from Tom_BLS to Ron fetchd tx bank send <address_of_Tom_BLS> <address_of_Ron> 1000test # Compare the difference between information printed from each transaction and observe # the difference in gas costs (?) # Now assure funds were successfully transferred back to Ron through a BLS signed transaction fetchd query bank balaces <address_of_Tom_BLS> fetchd query bank balaces <address_of_Ron>","title":"Example"},{"location":"ledger_v2/cli-governance/","text":"Governance Proposals In order to change any attribute of a network, a governance proposal must be submitted. This could be a simple poll, a software update or a governing parameter change. Parameter change This is an example of the process in which network parameters may be changed through the use of a governance proposal. The values within this code can be changed in order to alter the minimum deposited fund threshold for a proposal to enter the voting phase, and the length of the deposit stage in which the minimum deposit threshold must be met. # A JSON file containing the following code should be created to instantiate the proposal. # The two variables of interest are the \"amount\" which is set from 10000000stake to 1000stake # and the \"max_deposit_period\" which is changed from the default value to 7200000000000 # equal to 2 hours, instead of the standard 2 days (in nanoseconds). { \"title\": \"Staking Param Change\", \"description\": \"Update max validators\", \"changes\": [ { \"subspace\": \"staking\", \"key\": \"MaxValidators\", \"value\": 105 } ], \"deposit\": \"1000000000000000000atestfet\" } # Create initial proposal by uploading the JSON file # this is signed by a key 'proposer' that provides a portion of the current threshold deposit fetchd tx gov submit-proposal --proposal ~/json_path/proposal.json --from proposer # In order to later refer to this proposal, the proposal_id can be determined fetchd query gov proposals Proposal deposit phase The characteristics of the deposit phase are described by a set of network governance parameters, where the deposit period is two days from the initial proposal deposit until expiration, and a minimum threshold of 10000000denom as default. The minimum threshold must be met during this deposit period in order to proceed to the voting phase. The proposer may provide all of this threshold, or just some. In which case, supporters of the proposal may donate additional funding towards the goal of meeting the threshold. At any point of the deposit stage, the deposit pot can be queried. # To get the proposal ID, use the txhash obtained when the proposal was submitted and run the following command: fetchd query tx <txhash> # This command returns a text representation of the current total deposit value of a proposal fetchd query gov deposits <proposal_id> # Other users may contribute to funding the proposal using fetchd tx gov deposit <proposal_id> <deposit_amount> --from contributer This documentation provides a more detailed explanation of the deposit funding period. Proposal voting and querying After the deposit period has passed, there are two outcomes: either the current minimum threshold is met, or the value is not met and the funds are returned. In the first case this proposal is submitted and to be voted on, returning a tally at the end of the voting period. In order to submit a vote on a proposal that has passed into the voting phase, all staked users except the proposer may do so using this command. # Submit a vote from a key 'voter' with the desired outcome of the voter fetchd tx gov vote <proposal_id> <yes|no|no_with_veto|abstain> --from voter The current voting turnout and tally can be queried, which displays a list of all voters and their choice. # The current voting statistics can be printed using fetchd query gov votes <proposal_id> Example output votes: - option: VOTE_OPTION_YES proposal_id: \"1\" voter: fetch1dmehhhvul8y7slqs3zu2z3fede9kzlnyupd9rr - option: VOTE_OPTION_NO proposal_id: \"1\" voter: fetch1064endj5ne5e868asnf0encctwlga4y2jf3h28 - option: VOTE_OPTION_YES proposal_id: \"1\" voter: fetch1k3ee923osju93jm03fkfmewnal39fjdbakje1x Voting outcome After the voting period has ended, the results are used to determine the next step of the proposal. The potential outcomes include: Majority yes vote The proposal passes through and the users act according to the proposal type - e.g. A Software update proposal passes, and users begin uptake of the new version Majority no vote The funds deposited to pass into the voting stage are returned, and there is no governance change Majority no_with_veto vote This outcome is indicative of a proposal which may undermine the current governance system, e.g. a proposal to set the deposit threshold or voting period to an absurd value All funds deposited in the proposal are to be burned subject to this outcome, and there is no governance change","title":"Governance Proposals"},{"location":"ledger_v2/cli-governance/#governance-proposals","text":"In order to change any attribute of a network, a governance proposal must be submitted. This could be a simple poll, a software update or a governing parameter change.","title":"Governance Proposals"},{"location":"ledger_v2/cli-governance/#parameter-change","text":"This is an example of the process in which network parameters may be changed through the use of a governance proposal. The values within this code can be changed in order to alter the minimum deposited fund threshold for a proposal to enter the voting phase, and the length of the deposit stage in which the minimum deposit threshold must be met. # A JSON file containing the following code should be created to instantiate the proposal. # The two variables of interest are the \"amount\" which is set from 10000000stake to 1000stake # and the \"max_deposit_period\" which is changed from the default value to 7200000000000 # equal to 2 hours, instead of the standard 2 days (in nanoseconds). { \"title\": \"Staking Param Change\", \"description\": \"Update max validators\", \"changes\": [ { \"subspace\": \"staking\", \"key\": \"MaxValidators\", \"value\": 105 } ], \"deposit\": \"1000000000000000000atestfet\" } # Create initial proposal by uploading the JSON file # this is signed by a key 'proposer' that provides a portion of the current threshold deposit fetchd tx gov submit-proposal --proposal ~/json_path/proposal.json --from proposer # In order to later refer to this proposal, the proposal_id can be determined fetchd query gov proposals","title":"Parameter change"},{"location":"ledger_v2/cli-governance/#proposal-deposit-phase","text":"The characteristics of the deposit phase are described by a set of network governance parameters, where the deposit period is two days from the initial proposal deposit until expiration, and a minimum threshold of 10000000denom as default. The minimum threshold must be met during this deposit period in order to proceed to the voting phase. The proposer may provide all of this threshold, or just some. In which case, supporters of the proposal may donate additional funding towards the goal of meeting the threshold. At any point of the deposit stage, the deposit pot can be queried. # To get the proposal ID, use the txhash obtained when the proposal was submitted and run the following command: fetchd query tx <txhash> # This command returns a text representation of the current total deposit value of a proposal fetchd query gov deposits <proposal_id> # Other users may contribute to funding the proposal using fetchd tx gov deposit <proposal_id> <deposit_amount> --from contributer This documentation provides a more detailed explanation of the deposit funding period.","title":"Proposal deposit phase"},{"location":"ledger_v2/cli-governance/#proposal-voting-and-querying","text":"After the deposit period has passed, there are two outcomes: either the current minimum threshold is met, or the value is not met and the funds are returned. In the first case this proposal is submitted and to be voted on, returning a tally at the end of the voting period. In order to submit a vote on a proposal that has passed into the voting phase, all staked users except the proposer may do so using this command. # Submit a vote from a key 'voter' with the desired outcome of the voter fetchd tx gov vote <proposal_id> <yes|no|no_with_veto|abstain> --from voter The current voting turnout and tally can be queried, which displays a list of all voters and their choice. # The current voting statistics can be printed using fetchd query gov votes <proposal_id>","title":"Proposal voting and querying"},{"location":"ledger_v2/cli-governance/#example-output","text":"votes: - option: VOTE_OPTION_YES proposal_id: \"1\" voter: fetch1dmehhhvul8y7slqs3zu2z3fede9kzlnyupd9rr - option: VOTE_OPTION_NO proposal_id: \"1\" voter: fetch1064endj5ne5e868asnf0encctwlga4y2jf3h28 - option: VOTE_OPTION_YES proposal_id: \"1\" voter: fetch1k3ee923osju93jm03fkfmewnal39fjdbakje1x","title":"Example output"},{"location":"ledger_v2/cli-governance/#voting-outcome","text":"After the voting period has ended, the results are used to determine the next step of the proposal. The potential outcomes include: Majority yes vote The proposal passes through and the users act according to the proposal type - e.g. A Software update proposal passes, and users begin uptake of the new version Majority no vote The funds deposited to pass into the voting stage are returned, and there is no governance change Majority no_with_veto vote This outcome is indicative of a proposal which may undermine the current governance system, e.g. a proposal to set the deposit threshold or voting period to an absurd value All funds deposited in the proposal are to be burned subject to this outcome, and there is no governance change","title":"Voting outcome"},{"location":"ledger_v2/cli-introduction/","text":"CLI - Introduction The command line client provides all of the capabilities for interacting with the fetch ledger such as creating addresses, sending transactions and the governance capabilities. Before starting with the command line client you need to follow the installation instructions here Connecting to a network While some users will want to connect a node to the network and sync the entire blockchain, for many however, it is quicker and easier to connect directly to existing publically available nodes. Connecting to fetchhub mainnet To connect to the mainnet run the following configuration steps: fetchd config chain-id fetchhub-2 fetchd config node https://rpc-fetchhub.fetch.ai:443 Connecting to stargateworld network To connect to the stargateworld network run the following configuration steps: fetchd config chain-id stargateworld-3 fetchd config node https://rpc-stargateworld.fetch.ai:443 Checkout the Network Information page for more detailed information on the available networks.","title":"Introduction"},{"location":"ledger_v2/cli-introduction/#cli-introduction","text":"The command line client provides all of the capabilities for interacting with the fetch ledger such as creating addresses, sending transactions and the governance capabilities. Before starting with the command line client you need to follow the installation instructions here","title":"CLI - Introduction"},{"location":"ledger_v2/cli-introduction/#connecting-to-a-network","text":"While some users will want to connect a node to the network and sync the entire blockchain, for many however, it is quicker and easier to connect directly to existing publically available nodes.","title":"Connecting to a network"},{"location":"ledger_v2/cli-introduction/#connecting-to-fetchhub-mainnet","text":"To connect to the mainnet run the following configuration steps: fetchd config chain-id fetchhub-2 fetchd config node https://rpc-fetchhub.fetch.ai:443","title":"Connecting to fetchhub mainnet"},{"location":"ledger_v2/cli-introduction/#connecting-to-stargateworld-network","text":"To connect to the stargateworld network run the following configuration steps: fetchd config chain-id stargateworld-3 fetchd config node https://rpc-stargateworld.fetch.ai:443 Checkout the Network Information page for more detailed information on the available networks.","title":"Connecting to stargateworld network"},{"location":"ledger_v2/cli-keys/","text":"CLI - Managing Keys Managing your keys is an essential part of working with the Ledger, since all interactions are authenticated with these keys. Adding keys To create a new local key you need run the following command: fetchd keys add <your_key_name> Note These keys are stored locally on your system. By default, these keys will be stored in the OS level keychain, however, in general these keys are considered less secure than using a hardware device After running the command fetchd will print out a summary of the new key. An example of this output is shown below: - name: test type: local address: fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0 pubkey: fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx mnemonic: \"\" threshold: 0 pubkeys: [] This will be followed by a 24-word mnemonic that can be used to re-generate the private key and address for the account (keep this safe, if ever used to control main-net tokens). Looking up an address A common operation that you will want to do is to lookup the address for a specified key. This can be done quickly using the following command: fetchd keys show -a <name of key> An example of the expected output is shown below: fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0 A less common operation, but still useful, would be to lookup the public key for a specified key. The can be achieved with the following command: fetchd keys show -p <name of the key> An example of the expected output is shown below: fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx Listing keys To lookup more detailed information for all keys on your system use the following command: fetchd keys list This will output all of your keys information in a yaml format that is similar to the one generated when you first created the key. - name: test type: local address: fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0 pubkey: fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx mnemonic: \"\" threshold: 0 pubkeys: [] Recovering a key You can import a key from a 24-word mnemonic by running: fetchd keys add <name> --recover > Enter your bip39 mnemonic < type or paste your mnemonic> You'll be prompted to enter the mnemonic phrase, and it will then print the matching address and key details as when creating a new key. Hardware Wallets Setup We recommend hardware wallets as a solution for managing private keys. The Fetch ledger is compatible with Ledger Nano hardware wallets. To use your Ledger Nano you will need to complete the following steps: Set-up your wallet by creating a PIN and passphrase, which must be stored securely to enable recovery if the device is lost or damaged. Connect your device to your PC and update the firmware to the latest version using the Ledger Live application. Install the Cosmos application using the software manager (Manager > Cosmos > Install). Adding a new key In order to use the hardware wallet address with the cli, the user must first add it via fetchd . This process only records the public information about the key. To import the key first plug in the device and enter the device pin. Once you have unlocked the device navigate to the Cosmos app on the device and open it. To add the key use the following command: fetchd keys add <name for the key> --ledger --index 0 Note The --ledger flag tells the command line tool to talk to the ledger device and the --index flag selects which HD index should be used. When running this command, the Ledger device will prompt you to verify the genereated address. Once you have done this you will get an output in the following form: - name: hw1 type: ledger address: fetch1xqqftqp8ranv2taxsx8h594xprfw3qxl7j3ra2 pubkey: fetchpub1addwnpepq2dulyd9mly3xqnvfgdsjkqlqzsxldpdhd6cnpm67sx90zhfw2ragk9my5h mnemonic: \"\" threshold: 0 pubkeys: []","title":"Keys"},{"location":"ledger_v2/cli-keys/#cli-managing-keys","text":"Managing your keys is an essential part of working with the Ledger, since all interactions are authenticated with these keys.","title":"CLI - Managing Keys"},{"location":"ledger_v2/cli-keys/#adding-keys","text":"To create a new local key you need run the following command: fetchd keys add <your_key_name> Note These keys are stored locally on your system. By default, these keys will be stored in the OS level keychain, however, in general these keys are considered less secure than using a hardware device After running the command fetchd will print out a summary of the new key. An example of this output is shown below: - name: test type: local address: fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0 pubkey: fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx mnemonic: \"\" threshold: 0 pubkeys: [] This will be followed by a 24-word mnemonic that can be used to re-generate the private key and address for the account (keep this safe, if ever used to control main-net tokens).","title":"Adding keys"},{"location":"ledger_v2/cli-keys/#looking-up-an-address","text":"A common operation that you will want to do is to lookup the address for a specified key. This can be done quickly using the following command: fetchd keys show -a <name of key> An example of the expected output is shown below: fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0 A less common operation, but still useful, would be to lookup the public key for a specified key. The can be achieved with the following command: fetchd keys show -p <name of the key> An example of the expected output is shown below: fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx","title":"Looking up an address"},{"location":"ledger_v2/cli-keys/#listing-keys","text":"To lookup more detailed information for all keys on your system use the following command: fetchd keys list This will output all of your keys information in a yaml format that is similar to the one generated when you first created the key. - name: test type: local address: fetch142tawq2rj397mctc3jtw9dfzf03ns0ze4swat0 pubkey: fetchpub1addwnpepqvtmze0ekffynnjx9n85g6sexzl49ze2vpgc2f52fteyyghjtvvqw682nkx mnemonic: \"\" threshold: 0 pubkeys: []","title":"Listing keys"},{"location":"ledger_v2/cli-keys/#recovering-a-key","text":"You can import a key from a 24-word mnemonic by running: fetchd keys add <name> --recover > Enter your bip39 mnemonic < type or paste your mnemonic> You'll be prompted to enter the mnemonic phrase, and it will then print the matching address and key details as when creating a new key.","title":"Recovering a key"},{"location":"ledger_v2/cli-keys/#hardware-wallets","text":"","title":"Hardware Wallets"},{"location":"ledger_v2/cli-keys/#setup","text":"We recommend hardware wallets as a solution for managing private keys. The Fetch ledger is compatible with Ledger Nano hardware wallets. To use your Ledger Nano you will need to complete the following steps: Set-up your wallet by creating a PIN and passphrase, which must be stored securely to enable recovery if the device is lost or damaged. Connect your device to your PC and update the firmware to the latest version using the Ledger Live application. Install the Cosmos application using the software manager (Manager > Cosmos > Install).","title":"Setup"},{"location":"ledger_v2/cli-keys/#adding-a-new-key","text":"In order to use the hardware wallet address with the cli, the user must first add it via fetchd . This process only records the public information about the key. To import the key first plug in the device and enter the device pin. Once you have unlocked the device navigate to the Cosmos app on the device and open it. To add the key use the following command: fetchd keys add <name for the key> --ledger --index 0 Note The --ledger flag tells the command line tool to talk to the ledger device and the --index flag selects which HD index should be used. When running this command, the Ledger device will prompt you to verify the genereated address. Once you have done this you will get an output in the following form: - name: hw1 type: ledger address: fetch1xqqftqp8ranv2taxsx8h594xprfw3qxl7j3ra2 pubkey: fetchpub1addwnpepq2dulyd9mly3xqnvfgdsjkqlqzsxldpdhd6cnpm67sx90zhfw2ragk9my5h mnemonic: \"\" threshold: 0 pubkeys: []","title":"Adding a new key"},{"location":"ledger_v2/cli-multisig/","text":"Multisig keys This feature of fetchd allows users to securely control keys in a number of configurations. Using a threshold number K of maximum N keys, a user or group of users can set the minimum number of keys required to sign a transaction. Some examples of these configurations allow some useful features such as the choice of a spare key, where only one key is required to sign (K=1) but there are two keys available to do so. Another more complex example configuration is set out below. Creating a multisig key The following represents the syntax and argument layout of the fetchd command to create a multisig key. # Create a simple multisig key with a threshold of 1 as default fetchd keys add <multisig_key_name> --multisig <list_of_key_names> # Creating a multisig key with a higher threshold, K fetchd keys add <multisig_key_name> --multisig <list_of_key_names> --multisig-threshold <threshold integer K> Example instantiation of a multisig key This example represents a shared multisig key that could be used within a business amongst three account holders - where at least two of three (K=2) must sign off on each transaction. # Create the three keys owned by the separate account holders fetchd keys add fred fetchd keys add ted fetchd keys add ned # Create the multisig key from keys above fetchd keys add business_key --multisig fred,ted,ned --multisig-threshold 2 Signing and broadcasting multisig transactions Transactions must be signed and broadcast before they are carried out. In order to sign a multisig transaction, the transaction itself must not be immediately broadcast; but instead, the keyholders must each sign until a the minimum threshold K signatures are present. For this example we will be representing the transaction on the Stargate network and will therefore will be using atestfet as the denomination - this should be changed relative to the currency used on the relevant network Multisig transaction example # Create a key to represent a vendor that the business must pay fetchd keys add vendor # Generate a transaction as an output file to be signed by # the keyholders, 'ted' and 'fred' in this example fetchd tx bank send <business_key address> <vendor address> 1000atestfet --generate-only > transfer.json # This transaction file (transfer.json) is then made available for # the first keyholder to sign, 'fred' fetchd tx sign transfer.json --chain-id stargateworld-1 --from fred --multisig <address of business_key> > transfer_fredsigned.json # This is repeated for 'ted' fetchd tx sign transfer.json --chain-id stargateworld-1 --from ted --multisig <address of business_key> > transfer_tedsigned.json # These two files are then collated together and used as inputs to the # multisign command to create a fully signed transaction fetchd tx multisign transfer.json business_key transfer_fredsigned.json transfer_tedsigned.json > signed_transfer.json # Now that the transaction is fully signed, it may be broadcast fetchd tx broadcast signed_transfer.json # Now display the result of the transaction and confirm that the vendor has # received payment fetchd query bank balances <address of vendor> It is important to note that this method of signing transactions can apply to all types of transaction. Other multisig transaction examples # In order to create a staking transaction using a multisig key # the same process as above can be used with the output file of this command fetchd tx staking delegate <wallet address> 10000atestfet --from <address> --generate-only > stake.json # The following command can also be used to create a withdrawal transaction for the # rewards from staking when using a multisig key - this too must be signed as before fetchd tx distribution withdraw-all-rewards --from <address> --generate-only > withdrawal.json","title":"Multisig Keys"},{"location":"ledger_v2/cli-multisig/#multisig-keys","text":"This feature of fetchd allows users to securely control keys in a number of configurations. Using a threshold number K of maximum N keys, a user or group of users can set the minimum number of keys required to sign a transaction. Some examples of these configurations allow some useful features such as the choice of a spare key, where only one key is required to sign (K=1) but there are two keys available to do so. Another more complex example configuration is set out below.","title":"Multisig keys"},{"location":"ledger_v2/cli-multisig/#creating-a-multisig-key","text":"The following represents the syntax and argument layout of the fetchd command to create a multisig key. # Create a simple multisig key with a threshold of 1 as default fetchd keys add <multisig_key_name> --multisig <list_of_key_names> # Creating a multisig key with a higher threshold, K fetchd keys add <multisig_key_name> --multisig <list_of_key_names> --multisig-threshold <threshold integer K>","title":"Creating a multisig key"},{"location":"ledger_v2/cli-multisig/#example-instantiation-of-a-multisig-key","text":"This example represents a shared multisig key that could be used within a business amongst three account holders - where at least two of three (K=2) must sign off on each transaction. # Create the three keys owned by the separate account holders fetchd keys add fred fetchd keys add ted fetchd keys add ned # Create the multisig key from keys above fetchd keys add business_key --multisig fred,ted,ned --multisig-threshold 2","title":"Example instantiation of a multisig key"},{"location":"ledger_v2/cli-multisig/#signing-and-broadcasting-multisig-transactions","text":"Transactions must be signed and broadcast before they are carried out. In order to sign a multisig transaction, the transaction itself must not be immediately broadcast; but instead, the keyholders must each sign until a the minimum threshold K signatures are present. For this example we will be representing the transaction on the Stargate network and will therefore will be using atestfet as the denomination - this should be changed relative to the currency used on the relevant network","title":"Signing and broadcasting multisig transactions"},{"location":"ledger_v2/cli-multisig/#multisig-transaction-example","text":"# Create a key to represent a vendor that the business must pay fetchd keys add vendor # Generate a transaction as an output file to be signed by # the keyholders, 'ted' and 'fred' in this example fetchd tx bank send <business_key address> <vendor address> 1000atestfet --generate-only > transfer.json # This transaction file (transfer.json) is then made available for # the first keyholder to sign, 'fred' fetchd tx sign transfer.json --chain-id stargateworld-1 --from fred --multisig <address of business_key> > transfer_fredsigned.json # This is repeated for 'ted' fetchd tx sign transfer.json --chain-id stargateworld-1 --from ted --multisig <address of business_key> > transfer_tedsigned.json # These two files are then collated together and used as inputs to the # multisign command to create a fully signed transaction fetchd tx multisign transfer.json business_key transfer_fredsigned.json transfer_tedsigned.json > signed_transfer.json # Now that the transaction is fully signed, it may be broadcast fetchd tx broadcast signed_transfer.json # Now display the result of the transaction and confirm that the vendor has # received payment fetchd query bank balances <address of vendor> It is important to note that this method of signing transactions can apply to all types of transaction.","title":"Multisig transaction example"},{"location":"ledger_v2/cli-multisig/#other-multisig-transaction-examples","text":"# In order to create a staking transaction using a multisig key # the same process as above can be used with the output file of this command fetchd tx staking delegate <wallet address> 10000atestfet --from <address> --generate-only > stake.json # The following command can also be used to create a withdrawal transaction for the # rewards from staking when using a multisig key - this too must be signed as before fetchd tx distribution withdraw-all-rewards --from <address> --generate-only > withdrawal.json","title":"Other multisig transaction examples"},{"location":"ledger_v2/cli-tokens/","text":"CLI - Managing Tokens Querying your balance Once fetchd is configured for the desired network . The user can query there balance using the following command: fetchd query bank balances fetch1akvyhle79nts4rwn075t85xrwmp5ysuqynxcn4 If the address exists on the network then the user will expect to see an output in the following form: balances: - amount: \"8000000000000000000\" denom: atestfet pagination: next_key: null total: \"0\" Sending funds Before sending funds, make sure the sender address has tokens available by querying your balance as shown above. Checkout the Token Faucet page for more information on how to add test tokens to your address. To send funds from one address to another address then you would use the tx send subcommand. As shown below: fetchd tx bank send <from address or key name> <target address> <amount> In a more concrete example if the user wanted to send 100atestfet from main key/address to fetch106vm9q6ezu9va7v7e0cvq0nedc54egjm692fcp then the following command would be used. fetchd tx bank send main fetch106vm9q6ezu9va7v7e0cvq0nedc54egjm692fcp 100atestfet When you run the command you will get a similar output and prompt. The user can check the details of the transfer and then press 'y' to confirm the transfer. {\"body\":{\"messages\":[{\"@type\":\"/cosmos.bank.v1beta1.MsgSend\",\"from_address\":\"fetch12cjntwl32dry7fxck8qlgxq6na3fk5juwjdyy3\",\"to_address\":\"fetch1hph8kd54gl6qk0hy5rl08qw9gcr4vltmk3w02v\",\"amount\":[{\"denom\":\"atestfet\",\"amount\":\"100\"}]}],\"memo\":\"\",\"timeout_height\":\"0\",\"extension_options\":[],\"non_critical_extension_options\":[]},\"auth_info\":{\"signer_infos\":[],\"fee\":{\"amount\":[],\"gas_limit\":\"200000\",\"payer\":\"\",\"granter\":\"\"}},\"signatures\":[]} confirm transaction before signing and broadcasting [y/N]: y Once the transfer has been made a summary is presented to the user. An example is shown below: code: 0 codespace: \"\" data: \"\" gas_used: \"0\" gas_wanted: \"0\" height: \"0\" info: \"\" logs: [] raw_log: '[]' timestamp: \"\" tx: null txhash: 77C7382A0B1B9FE39257A6C16C7E3169A875CB3A87F2CE9D947D7C1335B53E76 On failure, the response will have a non zero code, as well as some logs under the raw_log key: code: 4 codespace: sdk data: \"\" gas_used: \"0\" gas_wanted: \"0\" height: \"0\" info: \"\" logs: [] raw_log: 'signature verification failed; please verify account number (5815) and chain-id (stargateworld-1): unauthorized' timestamp: \"\" tx: null txhash: 23701B052B423D63EB4AC94773B5B8227B03A576692A57999E92F2554F2372D4","title":"Tokens"},{"location":"ledger_v2/cli-tokens/#cli-managing-tokens","text":"","title":"CLI - Managing Tokens"},{"location":"ledger_v2/cli-tokens/#querying-your-balance","text":"Once fetchd is configured for the desired network . The user can query there balance using the following command: fetchd query bank balances fetch1akvyhle79nts4rwn075t85xrwmp5ysuqynxcn4 If the address exists on the network then the user will expect to see an output in the following form: balances: - amount: \"8000000000000000000\" denom: atestfet pagination: next_key: null total: \"0\"","title":"Querying your balance"},{"location":"ledger_v2/cli-tokens/#sending-funds","text":"Before sending funds, make sure the sender address has tokens available by querying your balance as shown above. Checkout the Token Faucet page for more information on how to add test tokens to your address. To send funds from one address to another address then you would use the tx send subcommand. As shown below: fetchd tx bank send <from address or key name> <target address> <amount> In a more concrete example if the user wanted to send 100atestfet from main key/address to fetch106vm9q6ezu9va7v7e0cvq0nedc54egjm692fcp then the following command would be used. fetchd tx bank send main fetch106vm9q6ezu9va7v7e0cvq0nedc54egjm692fcp 100atestfet When you run the command you will get a similar output and prompt. The user can check the details of the transfer and then press 'y' to confirm the transfer. {\"body\":{\"messages\":[{\"@type\":\"/cosmos.bank.v1beta1.MsgSend\",\"from_address\":\"fetch12cjntwl32dry7fxck8qlgxq6na3fk5juwjdyy3\",\"to_address\":\"fetch1hph8kd54gl6qk0hy5rl08qw9gcr4vltmk3w02v\",\"amount\":[{\"denom\":\"atestfet\",\"amount\":\"100\"}]}],\"memo\":\"\",\"timeout_height\":\"0\",\"extension_options\":[],\"non_critical_extension_options\":[]},\"auth_info\":{\"signer_infos\":[],\"fee\":{\"amount\":[],\"gas_limit\":\"200000\",\"payer\":\"\",\"granter\":\"\"}},\"signatures\":[]} confirm transaction before signing and broadcasting [y/N]: y Once the transfer has been made a summary is presented to the user. An example is shown below: code: 0 codespace: \"\" data: \"\" gas_used: \"0\" gas_wanted: \"0\" height: \"0\" info: \"\" logs: [] raw_log: '[]' timestamp: \"\" tx: null txhash: 77C7382A0B1B9FE39257A6C16C7E3169A875CB3A87F2CE9D947D7C1335B53E76 On failure, the response will have a non zero code, as well as some logs under the raw_log key: code: 4 codespace: sdk data: \"\" gas_used: \"0\" gas_wanted: \"0\" height: \"0\" info: \"\" logs: [] raw_log: 'signature verification failed; please verify account number (5815) and chain-id (stargateworld-1): unauthorized' timestamp: \"\" tx: null txhash: 23701B052B423D63EB4AC94773B5B8227B03A576692A57999E92F2554F2372D4","title":"Sending funds"},{"location":"ledger_v2/delegator-guide-cli/","text":"CLI - Delegator guide Querying the state Querying the current staking holdings of the validators The following command can be used to retrieve the current staking holdings of all validators: fetchd query staking validators On stargateworld network, this will produce an output similar to the following, describing the status of all the existing validators: - | operatoraddress: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w conspubkey: fetchvalconspub1zcjduepq3urw6c6u0zvqmde4vr4gmy56nnq57shdhg56jynpu8n3s74hrm0q0mzqrx jailed: false status: 2 tokens: \"1000000000000000000000\" delegatorshares: \"1000000000000000000000.000000000000000000\" description: moniker: validator5 identity: \"\" website: \"\" security_contact: \"\" details: \"\" unbondingheight: 0 unbondingcompletiontime: 1970-01-01T00:00:00Z commission: commission_rates: rate: \"0.050000000000000000\" max_rate: \"0.100000000000000000\" max_change_rate: \"0.010000000000000000\" update_time: 2021-02-12T12:41:25.579730119Z minselfdelegation: \"1000000000000000000000\" producingblocks: true - | operatoraddress: fetchvaloper1ysc8n5uspv4698nyk8u75lx98uu92zt7m3udw8 conspubkey: fetchvalconspub1zcjduepqmxr8gmcs6pwuxpsma264ax59wxtxd3vchrcv2c06deq9986kwt3s0wsk6n jailed: false status: 2 tokens: \"1000000000000000000000\" delegatorshares: \"1000000000000000000000.000000000000000000\" description: moniker: validator2 identity: \"\" website: \"\" security_contact: \"\" details: \"\" unbondingheight: 0 unbondingcompletiontime: 1970-01-01T00:00:00Z commission: commission_rates: rate: \"0.050000000000000000\" max_rate: \"0.100000000000000000\" max_change_rate: \"0.010000000000000000\" update_time: 2021-02-03T13:00:00Z minselfdelegation: \"1000000000000000000000\" producingblocks: true ... To obtain the same informations for a single validator, use the following command, providing the operatoraddress of the validator. fetchd query staking validator fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w A delegator will be particularly interested in the following keys: commission/commission_rates/rate : The commission rate on revenue charged to any delegator by the validator. commission/commission_rates/max_change_rate : The maximum daily increase of the validator's commission. This parameter cannot be changed by the validator operator. commission/commission_rates/max_rate : The maximum commission rate this validator can charge. This parameter cannot be changed by the validator operator. minselfdelegation : Minimum amount of atestfet the validator need to have bonded at all time. If the validator's self-bonded stake falls below this limit, their entire staking pool (i.e. all its delegators) will unbond. This parameter exists as a safeguard for delegators. Indeed, when a validator misbehaves, part of their total stake gets slashed. This included the validator's self-delegateds stake as well as their delegators' stake. Thus, a validator with a high amount of self-delegated atestfet has more skin-in-the-game than a validator with a low amount. The minimum self-bond amount parameter guarantees to delegators that a validator will never fall below a certain amount of self-bonded stake, thereby ensuring a minimum level of skin-in-the-game. This parameter can only be increased by the validator operator. Query the delegations made to a validator From a validator address, we can retrieve the list of delegations it received: fetchd query staking delegations-to fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w Here is a sample of delegations validator5 received on stargateworld : - delegation: delegator_address: fetch1z72rph6l5j6ex83n4urputykawcqg6t9zzruef validator_address: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w shares: \"1000000000000000000000.000000000000000000\" balance: denom: atestfet amount: \"1000000000000000000000\" - delegation: delegator_address: fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m validator_address: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w shares: \"100000.000000000000000000\" balance: denom: atestfet amount: \"100000\" Query the redelegations Delegators can choose to redelegate the tokens they already delegated from one validator to another. Redelegation takes effect immediately, without any waiting period, but the tokens can't be redelegated until the initial redelegation transaction complete after 21 days (the unlocking time is indicated by the redelegationentry/completion_time field in the outputs below). To obtains the list of redelegations made from a validator, use the following command: fetchd query staking redelegations-from fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w Which produce an output similar to the following, where delegator fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m issued 2 redelegations from fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w to fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu : fetchd query staking redelegations-from fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w - redelegation: delegator_address: fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m validator_src_address: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w validator_dst_address: fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu entries: [] entries: - redelegationentry: creation_height: 291037 completion_time: 2021-03-24T14:24:38.973444629Z initial_balance: \"50000\" shares_dst: \"50000.000000000000000000\" balance: \"50000\" - redelegationentry: creation_height: 291133 completion_time: 2021-03-24T14:33:43.425472866Z initial_balance: \"10000\" shares_dst: \"10000.000000000000000000\" balance: \"10000\" Similarly, the list of redelegations issued by a delegator can be obtained with the following: fetchd query staking redelegations fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m Query the user rewards After having delegated some tokens to a validator, the user is eligible to a share of the rewards the validator collect. To retrieve all the outstanding rewards for an address, issue the following command: fetchd query distribution rewards fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m This address having delegated tokens to 2 validators on stargateworld , it produces the following output: rewards: - validator_address: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w reward: - denom: atestfet amount: \"0.000000000000200000\" - validator_address: fetchvaloper1ysc8n5uspv4698nyk8u75lx98uu92zt7m3udw8 reward: - denom: atestfet amount: \"0.000000000001000000\" total: - denom: atestfet amount: \"0.000000000001200000\" Rewards can also be filtered for a given validator, like validator5 here: fetchd query distribution rewards fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w we now get only the reward from this validator: - denom: atestfet amount: \"0.000000000000200000\" Delegator operations Delegating tokens To delegate 1000000 atestfet tokens to the fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w validator from the account myKey , the following command can be used: fetchd tx staking delegate fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w 1000000atestfet --from myKey This will prompt for confirmation before issuing a transaction. After the transaction get processed, it should appear under the delegations of the fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w validator. Note Once delegated, tokens can only be redelegated to another validator, or unbond in order to be returned to their original account. It's important to note that those two operations take 21 days to complete , period in which the involved tokens will be unavailable. Redelegating tokens Redelegating tokens allows to transfer already delegated tokens from one validator to another. From the above example where we delegated 1000000 atestfet to fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w , we can now redelegate parts or all of those tokens to another validator. For example, we redelegate 400000 atestfet from fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w to fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu with the following command: fetchd tx staking redelegate fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu 400000atestfet --from myKey This will prompt for confirmation and issue a new transaction once accepted. From here, inspecting the delegations from our account, we'll see that our delegated tokens are now: 600000atestfet to validator fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w (our initial 1000000 minus the 400000 redelegated) 400000atestfet to validator fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu Now thoses 400000 atestfet we redelegated can't be redelegated anymore for 21 days (the exact date can be found by querying the redelegation transaction, under the completion_time key). Note that it's still possible to unbond those tokens if needed. Unbonding tokens At any time, we can transfer parts or all of our delegated tokens back to our account: fetchd tx staking unbond fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w 300000atestfet --from myKey Once again, this will prompt for confirmation and issue a transaction, initiating the transfer of 300000 atestfet from our stake on fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w validator back to our account. Those tokens will then be available after a 21 days period (the exact date can be found by querying the redelegation transaction, under the completion_time key). Withdrawing rewards In order to transfer rewards to the wallet, the following command can be used: fetchd tx distribution withdraw-rewards fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w --from myKey It requires the validator address from where the reward is withdrawn, and the name of the account private key having delegated tokens to the validator. When having delegated tokens to multiple validators, all rewards can be claimed in a single command: fetchd tx distribution withdraw-all-rewards --from myKey The rewards then appears on the account as soon as the transaction is processed.","title":"Delegator Guide"},{"location":"ledger_v2/delegator-guide-cli/#cli-delegator-guide","text":"","title":"CLI - Delegator guide"},{"location":"ledger_v2/delegator-guide-cli/#querying-the-state","text":"","title":"Querying the state"},{"location":"ledger_v2/delegator-guide-cli/#querying-the-current-staking-holdings-of-the-validators","text":"The following command can be used to retrieve the current staking holdings of all validators: fetchd query staking validators On stargateworld network, this will produce an output similar to the following, describing the status of all the existing validators: - | operatoraddress: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w conspubkey: fetchvalconspub1zcjduepq3urw6c6u0zvqmde4vr4gmy56nnq57shdhg56jynpu8n3s74hrm0q0mzqrx jailed: false status: 2 tokens: \"1000000000000000000000\" delegatorshares: \"1000000000000000000000.000000000000000000\" description: moniker: validator5 identity: \"\" website: \"\" security_contact: \"\" details: \"\" unbondingheight: 0 unbondingcompletiontime: 1970-01-01T00:00:00Z commission: commission_rates: rate: \"0.050000000000000000\" max_rate: \"0.100000000000000000\" max_change_rate: \"0.010000000000000000\" update_time: 2021-02-12T12:41:25.579730119Z minselfdelegation: \"1000000000000000000000\" producingblocks: true - | operatoraddress: fetchvaloper1ysc8n5uspv4698nyk8u75lx98uu92zt7m3udw8 conspubkey: fetchvalconspub1zcjduepqmxr8gmcs6pwuxpsma264ax59wxtxd3vchrcv2c06deq9986kwt3s0wsk6n jailed: false status: 2 tokens: \"1000000000000000000000\" delegatorshares: \"1000000000000000000000.000000000000000000\" description: moniker: validator2 identity: \"\" website: \"\" security_contact: \"\" details: \"\" unbondingheight: 0 unbondingcompletiontime: 1970-01-01T00:00:00Z commission: commission_rates: rate: \"0.050000000000000000\" max_rate: \"0.100000000000000000\" max_change_rate: \"0.010000000000000000\" update_time: 2021-02-03T13:00:00Z minselfdelegation: \"1000000000000000000000\" producingblocks: true ... To obtain the same informations for a single validator, use the following command, providing the operatoraddress of the validator. fetchd query staking validator fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w A delegator will be particularly interested in the following keys: commission/commission_rates/rate : The commission rate on revenue charged to any delegator by the validator. commission/commission_rates/max_change_rate : The maximum daily increase of the validator's commission. This parameter cannot be changed by the validator operator. commission/commission_rates/max_rate : The maximum commission rate this validator can charge. This parameter cannot be changed by the validator operator. minselfdelegation : Minimum amount of atestfet the validator need to have bonded at all time. If the validator's self-bonded stake falls below this limit, their entire staking pool (i.e. all its delegators) will unbond. This parameter exists as a safeguard for delegators. Indeed, when a validator misbehaves, part of their total stake gets slashed. This included the validator's self-delegateds stake as well as their delegators' stake. Thus, a validator with a high amount of self-delegated atestfet has more skin-in-the-game than a validator with a low amount. The minimum self-bond amount parameter guarantees to delegators that a validator will never fall below a certain amount of self-bonded stake, thereby ensuring a minimum level of skin-in-the-game. This parameter can only be increased by the validator operator.","title":"Querying the current staking holdings of the validators"},{"location":"ledger_v2/delegator-guide-cli/#query-the-delegations-made-to-a-validator","text":"From a validator address, we can retrieve the list of delegations it received: fetchd query staking delegations-to fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w Here is a sample of delegations validator5 received on stargateworld : - delegation: delegator_address: fetch1z72rph6l5j6ex83n4urputykawcqg6t9zzruef validator_address: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w shares: \"1000000000000000000000.000000000000000000\" balance: denom: atestfet amount: \"1000000000000000000000\" - delegation: delegator_address: fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m validator_address: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w shares: \"100000.000000000000000000\" balance: denom: atestfet amount: \"100000\"","title":"Query the delegations made to a validator"},{"location":"ledger_v2/delegator-guide-cli/#query-the-redelegations","text":"Delegators can choose to redelegate the tokens they already delegated from one validator to another. Redelegation takes effect immediately, without any waiting period, but the tokens can't be redelegated until the initial redelegation transaction complete after 21 days (the unlocking time is indicated by the redelegationentry/completion_time field in the outputs below). To obtains the list of redelegations made from a validator, use the following command: fetchd query staking redelegations-from fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w Which produce an output similar to the following, where delegator fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m issued 2 redelegations from fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w to fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu : fetchd query staking redelegations-from fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w - redelegation: delegator_address: fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m validator_src_address: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w validator_dst_address: fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu entries: [] entries: - redelegationentry: creation_height: 291037 completion_time: 2021-03-24T14:24:38.973444629Z initial_balance: \"50000\" shares_dst: \"50000.000000000000000000\" balance: \"50000\" - redelegationentry: creation_height: 291133 completion_time: 2021-03-24T14:33:43.425472866Z initial_balance: \"10000\" shares_dst: \"10000.000000000000000000\" balance: \"10000\" Similarly, the list of redelegations issued by a delegator can be obtained with the following: fetchd query staking redelegations fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m","title":"Query the redelegations"},{"location":"ledger_v2/delegator-guide-cli/#query-the-user-rewards","text":"After having delegated some tokens to a validator, the user is eligible to a share of the rewards the validator collect. To retrieve all the outstanding rewards for an address, issue the following command: fetchd query distribution rewards fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m This address having delegated tokens to 2 validators on stargateworld , it produces the following output: rewards: - validator_address: fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w reward: - denom: atestfet amount: \"0.000000000000200000\" - validator_address: fetchvaloper1ysc8n5uspv4698nyk8u75lx98uu92zt7m3udw8 reward: - denom: atestfet amount: \"0.000000000001000000\" total: - denom: atestfet amount: \"0.000000000001200000\" Rewards can also be filtered for a given validator, like validator5 here: fetchd query distribution rewards fetch15fn3meky8ktfry3qm73xkpjckzw4dazxpfx34m fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w we now get only the reward from this validator: - denom: atestfet amount: \"0.000000000000200000\"","title":"Query the user rewards"},{"location":"ledger_v2/delegator-guide-cli/#delegator-operations","text":"","title":"Delegator operations"},{"location":"ledger_v2/delegator-guide-cli/#delegating-tokens","text":"To delegate 1000000 atestfet tokens to the fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w validator from the account myKey , the following command can be used: fetchd tx staking delegate fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w 1000000atestfet --from myKey This will prompt for confirmation before issuing a transaction. After the transaction get processed, it should appear under the delegations of the fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w validator. Note Once delegated, tokens can only be redelegated to another validator, or unbond in order to be returned to their original account. It's important to note that those two operations take 21 days to complete , period in which the involved tokens will be unavailable.","title":"Delegating tokens"},{"location":"ledger_v2/delegator-guide-cli/#redelegating-tokens","text":"Redelegating tokens allows to transfer already delegated tokens from one validator to another. From the above example where we delegated 1000000 atestfet to fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w , we can now redelegate parts or all of those tokens to another validator. For example, we redelegate 400000 atestfet from fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w to fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu with the following command: fetchd tx staking redelegate fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu 400000atestfet --from myKey This will prompt for confirmation and issue a new transaction once accepted. From here, inspecting the delegations from our account, we'll see that our delegated tokens are now: 600000atestfet to validator fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w (our initial 1000000 minus the 400000 redelegated) 400000atestfet to validator fetchvaloper122veneudkzyalay6gusvrhhpp0560mparpanvu Now thoses 400000 atestfet we redelegated can't be redelegated anymore for 21 days (the exact date can be found by querying the redelegation transaction, under the completion_time key). Note that it's still possible to unbond those tokens if needed.","title":"Redelegating tokens"},{"location":"ledger_v2/delegator-guide-cli/#unbonding-tokens","text":"At any time, we can transfer parts or all of our delegated tokens back to our account: fetchd tx staking unbond fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w 300000atestfet --from myKey Once again, this will prompt for confirmation and issue a transaction, initiating the transfer of 300000 atestfet from our stake on fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w validator back to our account. Those tokens will then be available after a 21 days period (the exact date can be found by querying the redelegation transaction, under the completion_time key).","title":"Unbonding tokens"},{"location":"ledger_v2/delegator-guide-cli/#withdrawing-rewards","text":"In order to transfer rewards to the wallet, the following command can be used: fetchd tx distribution withdraw-rewards fetchvaloper1z72rph6l5j6ex83n4urputykawcqg6t98xul2w --from myKey It requires the validator address from where the reward is withdrawn, and the name of the account private key having delegated tokens to the validator. When having delegated tokens to multiple validators, all rewards can be claimed in a single command: fetchd tx distribution withdraw-all-rewards --from myKey The rewards then appears on the account as soon as the transaction is processed.","title":"Withdrawing rewards"},{"location":"ledger_v2/faucet/","text":"Token Faucet For our test networks, we have a simple token faucet implemented to allow users of the network to get started quickly. You can send it an account address, and it will transfer some test token on it. Token Faucets are network specific, depending on the network type they may or may not be deployed. Please check the networks page for specific details. The Token Faucet itself is available from the network block explorer ( GET FUNDS button on the homepage). Enter your fetch... address in the popup and click Add funds button. Wait a few blocks for the transaction to be processed, and you should see it appear along with some funds on your account.","title":"Faucet"},{"location":"ledger_v2/faucet/#token-faucet","text":"For our test networks, we have a simple token faucet implemented to allow users of the network to get started quickly. You can send it an account address, and it will transfer some test token on it. Token Faucets are network specific, depending on the network type they may or may not be deployed. Please check the networks page for specific details. The Token Faucet itself is available from the network block explorer ( GET FUNDS button on the homepage). Enter your fetch... address in the popup and click Add funds button. Wait a few blocks for the transaction to be processed, and you should see it appear along with some funds on your account.","title":"Token Faucet"},{"location":"ledger_v2/governance/","text":"Governance In order to be able to take part in the governance you either need to be running a full validator node or you need to have have delegated stake to an existing validator Stake Delegation In order to delegate stake to a validator the following command should be used: fetchd tx staking delegate <VALOPER_ADDRESS> <AMOUNT> --from <KEY_NAME> Where the <VALOPER_ADDRESS> begins with the prefix fetchvaloper1... and the <AMOUNT> field contains the currency denomination. For example: fetchd tx staking delegate fetchvaloper1cct4fhhksplu9m9wjljuthjqhjj93z0s97p3g7 1000atestfet --from agent Proposals Overview There are three types of proposal: Text Proposals : These are the most basic type of proposal. They can be used to get the opinion from participants of the network on a given topic. Parameter Proposals : These proposals are used to update the value of an existing software parameter of the network. Software Upgrade Proposals : These are used to propose an upgrade of the fetchd software, particularly in cases where the software changes might not necessary be backwards compatible or in some way present a major update to the network. The Proposal Process Any FET holder can submit a proposal. In order for the proposal to be open for voting, it needs to come with a deposit that is greater than a parameter called minDeposit . The deposit need not be provided in its entirety by the submitter. If the initial proposer's deposit is not sufficient, the proposal enters the deposit period status. Then, any FET holder can increase the deposit by sending a depositTx transaction to the network. Once the deposit reaches minDeposit , the proposal enters the voting period , which lasts 2 weeks. Any bonded FET holder can then cast a vote on this proposal. The user has the following options for voting: Yes No NoWithVeto Abstain At the end of the voting period, the proposal is accepted if there are more than 50% Yes votes (excluding Abstain votes) and less than 33.33% of NoWithVeto votes (excluding Abstain votes). Generating Proposals When creating a proposal, the user will create a proposal JSON file with all the relevant information. An example of a text proposal is shown below: { \"title\" : \"Switch to semantic commit messages for fetchd\" , \"description\" : \"This proposal is advocating a switch to sematic commit messages\\nYou can find the full discussion here: https://github.com/fetchai/fetchd/issues/231\" , \"type\" : \"Text\" , \"deposit\" : \"10000000000000000000atestfet\" } It is always recommended that the description of a text proposal has a link to a Github issue with the full proposal text along with the discussions about it. Once the user has created the JSON file, to generate the text propsal on chain run the following command: fetchd tx gov submit-proposal --proposal proposal.json --from <name of signing key> Increasing the deposit for a proposal If a user wants to increase the deposit of a proposal they would run the following command: fetchd tx gov deposit <proposalID> 100atestfet --from <key name> For example: fetchd tx gov deposit 2 100atestfet --from validator To get the proposalID, use the txhash obtained when the proposal was submitted and run the following command: fetchd query tx <txhash> Listing current proposals Current proposals are visible from the block explorer and using the CLI. To get the list of current proposals and their corresponding proposal-ids the run the following command: fetchd query gov proposals Voting on a proposal To vote for a proposal run the following command fetchd tx gov vote <proposalID> <option> --from <delegatorKeyName> For example: fetchd tx gov vote 5 yes --from validator Note When using CLI commands make sure that your CLI is pointing at the correct network. See the CLI introduction documentation for more details","title":"Governance"},{"location":"ledger_v2/governance/#governance","text":"In order to be able to take part in the governance you either need to be running a full validator node or you need to have have delegated stake to an existing validator","title":"Governance"},{"location":"ledger_v2/governance/#stake-delegation","text":"In order to delegate stake to a validator the following command should be used: fetchd tx staking delegate <VALOPER_ADDRESS> <AMOUNT> --from <KEY_NAME> Where the <VALOPER_ADDRESS> begins with the prefix fetchvaloper1... and the <AMOUNT> field contains the currency denomination. For example: fetchd tx staking delegate fetchvaloper1cct4fhhksplu9m9wjljuthjqhjj93z0s97p3g7 1000atestfet --from agent","title":"Stake Delegation"},{"location":"ledger_v2/governance/#proposals-overview","text":"There are three types of proposal: Text Proposals : These are the most basic type of proposal. They can be used to get the opinion from participants of the network on a given topic. Parameter Proposals : These proposals are used to update the value of an existing software parameter of the network. Software Upgrade Proposals : These are used to propose an upgrade of the fetchd software, particularly in cases where the software changes might not necessary be backwards compatible or in some way present a major update to the network.","title":"Proposals Overview"},{"location":"ledger_v2/governance/#the-proposal-process","text":"Any FET holder can submit a proposal. In order for the proposal to be open for voting, it needs to come with a deposit that is greater than a parameter called minDeposit . The deposit need not be provided in its entirety by the submitter. If the initial proposer's deposit is not sufficient, the proposal enters the deposit period status. Then, any FET holder can increase the deposit by sending a depositTx transaction to the network. Once the deposit reaches minDeposit , the proposal enters the voting period , which lasts 2 weeks. Any bonded FET holder can then cast a vote on this proposal. The user has the following options for voting: Yes No NoWithVeto Abstain At the end of the voting period, the proposal is accepted if there are more than 50% Yes votes (excluding Abstain votes) and less than 33.33% of NoWithVeto votes (excluding Abstain votes).","title":"The Proposal Process"},{"location":"ledger_v2/governance/#generating-proposals","text":"When creating a proposal, the user will create a proposal JSON file with all the relevant information. An example of a text proposal is shown below: { \"title\" : \"Switch to semantic commit messages for fetchd\" , \"description\" : \"This proposal is advocating a switch to sematic commit messages\\nYou can find the full discussion here: https://github.com/fetchai/fetchd/issues/231\" , \"type\" : \"Text\" , \"deposit\" : \"10000000000000000000atestfet\" } It is always recommended that the description of a text proposal has a link to a Github issue with the full proposal text along with the discussions about it. Once the user has created the JSON file, to generate the text propsal on chain run the following command: fetchd tx gov submit-proposal --proposal proposal.json --from <name of signing key>","title":"Generating Proposals"},{"location":"ledger_v2/governance/#increasing-the-deposit-for-a-proposal","text":"If a user wants to increase the deposit of a proposal they would run the following command: fetchd tx gov deposit <proposalID> 100atestfet --from <key name> For example: fetchd tx gov deposit 2 100atestfet --from validator To get the proposalID, use the txhash obtained when the proposal was submitted and run the following command: fetchd query tx <txhash>","title":"Increasing the deposit for a proposal"},{"location":"ledger_v2/governance/#listing-current-proposals","text":"Current proposals are visible from the block explorer and using the CLI. To get the list of current proposals and their corresponding proposal-ids the run the following command: fetchd query gov proposals","title":"Listing current proposals"},{"location":"ledger_v2/governance/#voting-on-a-proposal","text":"To vote for a proposal run the following command fetchd tx gov vote <proposalID> <option> --from <delegatorKeyName> For example: fetchd tx gov vote 5 yes --from validator Note When using CLI commands make sure that your CLI is pointing at the correct network. See the CLI introduction documentation for more details","title":"Voting on a proposal"},{"location":"ledger_v2/joining-a-testnet/","text":"Joining a testnet In order to join the test network you will need to have the correct version of the fetchd ledger available on your system. Using a local version Assuming that you have followed the installation guide . You should now have fetchd successfully installed in your path. You can check this with the following command: fetchd version This should print a version number that must be compatible with the network you're connecting to (see the network page for the list of supported versions per network). Configuring the client fetchd In general to configure the CLI to point at a given network it needs as a minimum the following configuration values fetchd config chain-id <chain-id> fetchd config node <rpc url> Stargate example In the case of the Stargate network this would be as follows: fetchd config chain-id stargateworld-3 fetchd config node https://rpc-stargateworld.fetch.ai:443 Configuring the server fetchd Initialize fetchd by running command. This setups a default / empty genesis configuration. fetchd init <moniker-name> --chain-id <chain id> This will initialize default configuration files under the FETCHD_HOME folder, which default to ~/.fetchd/ . Execute the following command to download the latest genesis file: curl <rpc url>/genesis | jq '.result.genesis' > ~/.fetchd/config/genesis.json Finally connect fetchd to the network by getting it to connect to a seed node for the given network. fetchd start --p2p.seeds = <network seed peers> Stargate Example Less abstractly then, if you wants to connect to the Stargate test net for example, you would need to run the following steps: # init fetchd init my-first-fetch-node --chain-id stargateworld-3 # genesis curl https://rpc-stargateworld.fetch.ai/genesis | jq '.result.genesis' > ~/.fetchd/config/genesis.json # start fetchd start --p2p.seeds = 0831c7f4cb4b12fe02b35cc682c7edb03f6df36c@connect-stargateworld.t-v2-london-c.fetch-ai.com:36656 Your local node will then start to synchronise itself with the network, replaying all blocks and transactions up to the current block. Depending on the age of the network and your hard disk speed, this could take a while. To know when your node as finished syncing, you can query it's status from its RPC API: curl -s 127 .0.01:26657/status | jq '.result.sync_info.catching_up' true # this will print \"false\" once your node is up to date","title":"Joining a Testnet"},{"location":"ledger_v2/joining-a-testnet/#joining-a-testnet","text":"In order to join the test network you will need to have the correct version of the fetchd ledger available on your system.","title":"Joining a testnet"},{"location":"ledger_v2/joining-a-testnet/#using-a-local-version","text":"Assuming that you have followed the installation guide . You should now have fetchd successfully installed in your path. You can check this with the following command: fetchd version This should print a version number that must be compatible with the network you're connecting to (see the network page for the list of supported versions per network).","title":"Using a local version"},{"location":"ledger_v2/joining-a-testnet/#configuring-the-client-fetchd","text":"In general to configure the CLI to point at a given network it needs as a minimum the following configuration values fetchd config chain-id <chain-id> fetchd config node <rpc url>","title":"Configuring the client fetchd"},{"location":"ledger_v2/joining-a-testnet/#stargate-example","text":"In the case of the Stargate network this would be as follows: fetchd config chain-id stargateworld-3 fetchd config node https://rpc-stargateworld.fetch.ai:443","title":"Stargate example"},{"location":"ledger_v2/joining-a-testnet/#configuring-the-server-fetchd","text":"Initialize fetchd by running command. This setups a default / empty genesis configuration. fetchd init <moniker-name> --chain-id <chain id> This will initialize default configuration files under the FETCHD_HOME folder, which default to ~/.fetchd/ . Execute the following command to download the latest genesis file: curl <rpc url>/genesis | jq '.result.genesis' > ~/.fetchd/config/genesis.json Finally connect fetchd to the network by getting it to connect to a seed node for the given network. fetchd start --p2p.seeds = <network seed peers> Stargate Example Less abstractly then, if you wants to connect to the Stargate test net for example, you would need to run the following steps: # init fetchd init my-first-fetch-node --chain-id stargateworld-3 # genesis curl https://rpc-stargateworld.fetch.ai/genesis | jq '.result.genesis' > ~/.fetchd/config/genesis.json # start fetchd start --p2p.seeds = 0831c7f4cb4b12fe02b35cc682c7edb03f6df36c@connect-stargateworld.t-v2-london-c.fetch-ai.com:36656 Your local node will then start to synchronise itself with the network, replaying all blocks and transactions up to the current block. Depending on the age of the network and your hard disk speed, this could take a while. To know when your node as finished syncing, you can query it's status from its RPC API: curl -s 127 .0.01:26657/status | jq '.result.sync_info.catching_up' true # this will print \"false\" once your node is up to date","title":"Configuring the server fetchd"},{"location":"ledger_v2/networks/","text":"Networks Mainnet The chain identifier of our production network is fetchhub-3. Parameter Value Chain ID fetchhub-3 Denomination afet Decimals 18 (1fet = 1000000000000000000afet) Version v0.9.x (fetchcli >= v0.9.0) RPC Endpoint https://rpc-fetchhub.fetch.ai:443 GRPC Endpoint https://grpc-fetchhub.fetch.ai:443 REST Endpoint https://rest-fetchhub.fetch.ai:443 Block Explorer https://explore-fetchhub.fetch.ai Token Faucet N/A Seed Node(s) 5f3fa6404a67b664be07d0e133a00c1600967396@connect-fetchhub.fetch.ai:36756 Test Nets Capricorn This network is running the same software as our mainnet ( fetchhub-3 ), and is stable for deploying smart contracts and testing IBC. Parameter Value Chain ID capricorn-1 Denomination atestfet Decimals 18 (1testfet = 1000000000000000000atestfet) Version v0.9.0 (fetchd >= v0.9.0) RPC Endpoint https://rpc-capricorn.fetch.ai:443 GRPC Endpoint https://grpc-capricorn.fetch.ai:443 REST Endpoint https://rest-capricorn.fetch.ai:443 Block Explorer https://explore-capricorn.fetch.ai/ Token Faucet Use block explorer Seed Node(s) fec822ecf6e503a694a709ce663fd0c6da5fda3e@connect-capricorn.fetch.ai:36956","title":"Networks"},{"location":"ledger_v2/networks/#networks","text":"","title":"Networks"},{"location":"ledger_v2/networks/#mainnet","text":"The chain identifier of our production network is fetchhub-3. Parameter Value Chain ID fetchhub-3 Denomination afet Decimals 18 (1fet = 1000000000000000000afet) Version v0.9.x (fetchcli >= v0.9.0) RPC Endpoint https://rpc-fetchhub.fetch.ai:443 GRPC Endpoint https://grpc-fetchhub.fetch.ai:443 REST Endpoint https://rest-fetchhub.fetch.ai:443 Block Explorer https://explore-fetchhub.fetch.ai Token Faucet N/A Seed Node(s) 5f3fa6404a67b664be07d0e133a00c1600967396@connect-fetchhub.fetch.ai:36756","title":"Mainnet"},{"location":"ledger_v2/networks/#test-nets","text":"","title":"Test Nets"},{"location":"ledger_v2/networks/#capricorn","text":"This network is running the same software as our mainnet ( fetchhub-3 ), and is stable for deploying smart contracts and testing IBC. Parameter Value Chain ID capricorn-1 Denomination atestfet Decimals 18 (1testfet = 1000000000000000000atestfet) Version v0.9.0 (fetchd >= v0.9.0) RPC Endpoint https://rpc-capricorn.fetch.ai:443 GRPC Endpoint https://grpc-capricorn.fetch.ai:443 REST Endpoint https://rest-capricorn.fetch.ai:443 Block Explorer https://explore-capricorn.fetch.ai/ Token Faucet Use block explorer Seed Node(s) fec822ecf6e503a694a709ce663fd0c6da5fda3e@connect-capricorn.fetch.ai:36956","title":"Capricorn"},{"location":"ledger_v2/reconciliation-service/","text":"Reconciliation Service What is it? During the stake migration from ETH to the Fetch Mainnet on September 14th 2021 some users decided to opt to wait for reconciliation to access their funds after the auto-migration was complete. The staked funds were all migrated from Ethereum staking contract to the Fetch.ai Mainnet. The reconciliation service has been built as part of the latest system upgrade to restore access of the migrated funds to their owners. Who is it for? The reconciliation service is specifically only for those people who opted to not use the guides to gain access to their staked funds during the migration. If you are unable to access your funds for any other reason, for example due to having been hacked, then the reconciliation service is not applicable to you and we advise you to not fill in the form to regain access to your funds. How do I know if I need to use it? If you are unable to access your funds after the stake migration from ETH to Fetch Mainet, and you have not restored access to them, then the reconciliation service is likely to be of use. Prerequisites In order to use the reconciliation service, you will need to have access to: The Fetch Mainnet wallet you use when connecting to the reconciliation site. This must have at least one transaction previously recorded on the network from your address to be able to submit the form. If you have never used it in a transaction before, the reconciliation tool and the network have no way of knowing your wallet exists and will not allow you to complete the final submission. At least 1 Native $FET token in your wallet so you can pay the transaction fee associated with the reconciliation tool.If you are unable to acquire them, we have you covered. You can get some native FET from Indacoin using your VISA or Mastercard to pay for the registered transaction to verify your reconciliation request. This service is available for FET holders in 180 countries. Your Metamask configured with the address which was used in the original staking. The Fetch Browser Extension wallet which is configured with the destination address you made that the funds should be recovered to. Once your registered transaction is successful and your reconciliation request has been deemed valid, the funds will be automatically distributed during the network upgrade planned on February 8th 2022 to your Mainnet address on the Fetch browser wallet. If you have these ready, to begin the reconciliation service click here and follow the instructions.","title":"Reconciliation Service"},{"location":"ledger_v2/reconciliation-service/#reconciliation-service","text":"What is it? During the stake migration from ETH to the Fetch Mainnet on September 14th 2021 some users decided to opt to wait for reconciliation to access their funds after the auto-migration was complete. The staked funds were all migrated from Ethereum staking contract to the Fetch.ai Mainnet. The reconciliation service has been built as part of the latest system upgrade to restore access of the migrated funds to their owners. Who is it for? The reconciliation service is specifically only for those people who opted to not use the guides to gain access to their staked funds during the migration. If you are unable to access your funds for any other reason, for example due to having been hacked, then the reconciliation service is not applicable to you and we advise you to not fill in the form to regain access to your funds. How do I know if I need to use it? If you are unable to access your funds after the stake migration from ETH to Fetch Mainet, and you have not restored access to them, then the reconciliation service is likely to be of use. Prerequisites In order to use the reconciliation service, you will need to have access to: The Fetch Mainnet wallet you use when connecting to the reconciliation site. This must have at least one transaction previously recorded on the network from your address to be able to submit the form. If you have never used it in a transaction before, the reconciliation tool and the network have no way of knowing your wallet exists and will not allow you to complete the final submission. At least 1 Native $FET token in your wallet so you can pay the transaction fee associated with the reconciliation tool.If you are unable to acquire them, we have you covered. You can get some native FET from Indacoin using your VISA or Mastercard to pay for the registered transaction to verify your reconciliation request. This service is available for FET holders in 180 countries. Your Metamask configured with the address which was used in the original staking. The Fetch Browser Extension wallet which is configured with the destination address you made that the funds should be recovered to. Once your registered transaction is successful and your reconciliation request has been deemed valid, the funds will be automatically distributed during the network upgrade planned on February 8th 2022 to your Mainnet address on the Fetch browser wallet. If you have these ready, to begin the reconciliation service click here and follow the instructions.","title":"Reconciliation Service"},{"location":"ledger_v2/single-node-network/","text":"Running a Single Node Network Especially for things like contract development, it can be very useful to be able to run a single node network for testing. This document will outline the steps that are required in order to configure a fetchd network of 1 node. Network Setup These steps only need to be done once in order to setup the local network. Step 1 - Build the ledger from source Follow the build instructions in order to compile the latest version of the ledger. Step 2 - Remove any existing networks Since we are starting a new network we need to remove any local files that we have in our system from a previous network rm -Rf ~/.fetchd Step 3 - Create an initial genesis Create the initial genesis file ( ~/.fetchd/config/genesis.json ) with the following command: fetchd init --chain-id localnet-1 my-local-node-name localnet-1 is the chain id my-local-node-name is the moniker for the node If you want to make any updates to the genesis, it is a good opportunity to make these updates now. Step 4 - Create your validator key In the following steps we will need to create the public/private keypair for our node. To create a new key called \"validator\" use the following command. fetchd keys add validator validator is the name of the key in the keyring For more information checkout the complete documentation on keys . Step 5 - Adding the validator to the network To set the initial state for the network use the following command. This allocates 100000000000000000000 stake tokens to the validator which can be bonded. fetchd add-genesis-account validator 100000000000000000000stake Step 6 - Generating a validator transaction To get your validator to sign the genesis block (and to agree that this is the correct genesis starting point) use the following command. fetchd gentx validator 100000000000000000000stake --chain-id localnet-1 validator here is the name that you have given to the key Step 7 - Building the complete genesis To build final genesis configuration for the network run the following command fetchd collect-gentxs After running this command the network is successfully configured and you have computed the final genesis configuration for the network. Running the local node To run the network use the following command. `fetchd start` Resetting the network Often you will want to clear out all the data from the network and start again. To do that in a local network simply run the following command: `fetchd unsafe-reset-all` This resets the chain back to genesis, you DO NOT need to perform the network setup steps again. After running this command you can simply run the fetchd start command again.","title":"Single Node Testnet"},{"location":"ledger_v2/single-node-network/#running-a-single-node-network","text":"Especially for things like contract development, it can be very useful to be able to run a single node network for testing. This document will outline the steps that are required in order to configure a fetchd network of 1 node.","title":"Running a Single Node Network"},{"location":"ledger_v2/single-node-network/#network-setup","text":"These steps only need to be done once in order to setup the local network. Step 1 - Build the ledger from source Follow the build instructions in order to compile the latest version of the ledger. Step 2 - Remove any existing networks Since we are starting a new network we need to remove any local files that we have in our system from a previous network rm -Rf ~/.fetchd Step 3 - Create an initial genesis Create the initial genesis file ( ~/.fetchd/config/genesis.json ) with the following command: fetchd init --chain-id localnet-1 my-local-node-name localnet-1 is the chain id my-local-node-name is the moniker for the node If you want to make any updates to the genesis, it is a good opportunity to make these updates now. Step 4 - Create your validator key In the following steps we will need to create the public/private keypair for our node. To create a new key called \"validator\" use the following command. fetchd keys add validator validator is the name of the key in the keyring For more information checkout the complete documentation on keys . Step 5 - Adding the validator to the network To set the initial state for the network use the following command. This allocates 100000000000000000000 stake tokens to the validator which can be bonded. fetchd add-genesis-account validator 100000000000000000000stake Step 6 - Generating a validator transaction To get your validator to sign the genesis block (and to agree that this is the correct genesis starting point) use the following command. fetchd gentx validator 100000000000000000000stake --chain-id localnet-1 validator here is the name that you have given to the key Step 7 - Building the complete genesis To build final genesis configuration for the network run the following command fetchd collect-gentxs After running this command the network is successfully configured and you have computed the final genesis configuration for the network.","title":"Network Setup"},{"location":"ledger_v2/single-node-network/#running-the-local-node","text":"To run the network use the following command. `fetchd start`","title":"Running the local node"},{"location":"ledger_v2/single-node-network/#resetting-the-network","text":"Often you will want to clear out all the data from the network and start again. To do that in a local network simply run the following command: `fetchd unsafe-reset-all` This resets the chain back to genesis, you DO NOT need to perform the network setup steps again. After running this command you can simply run the fetchd start command again.","title":"Resetting the network"},{"location":"ledger_v2/versions/","text":"Versions There are multiple versions of the fetchd software with differing levels of features and maturity. The following table outlines the rough overview of these versions Version Maturity Description v0.2.x Stable This is a stable version of the network to support agent development v0.3.x Beta Builds upon our stable release and adds support for the random beacon consensus module v0.4.x Alpha Builds upon the random beacon consensus and adds support for aggregated signatures v0.5.x Release Candidate Extension of v0.4.x v0.6.x Release Candidate Extension of v0.5.x v0.7.x Stable Pre stargate fetchhub mainnet version v0.8.x Stable Mainline version of the network used for Stargate fetchhub mainnet","title":"Versions"},{"location":"ledger_v2/versions/#versions","text":"There are multiple versions of the fetchd software with differing levels of features and maturity. The following table outlines the rough overview of these versions Version Maturity Description v0.2.x Stable This is a stable version of the network to support agent development v0.3.x Beta Builds upon our stable release and adds support for the random beacon consensus module v0.4.x Alpha Builds upon the random beacon consensus and adds support for aggregated signatures v0.5.x Release Candidate Extension of v0.4.x v0.6.x Release Candidate Extension of v0.5.x v0.7.x Stable Pre stargate fetchhub mainnet version v0.8.x Stable Mainline version of the network used for Stargate fetchhub mainnet","title":"Versions"},{"location":"ledger_v2/validators/overview/","text":"Validators Overview Introduction The Fetch.ai Ledger relies on a set of validators that are responsible for committing new blocks in the blockchain. These validators participate in the consensus protocol by broadcasting votes which contain cryptographic signatures signed by each validator's private key. Validator candidates can bond their own FET and have FET delegated, or staked, to them by token holders. The validators are determined by who has the most stake delegated to them. The top N validator candidates with the most stake will become the active validators. Validators and their delegators will earn FET as block provisions and tokens as transaction fees through execution of the consensus protocol. Transaction fees will be paid in FET. If validators double sign, are frequently offline or do not participate in governance, their staked FET (including FET of users that delegated to them) can be slashed. The penalty depends on the severity of the violation. Hardware The hardware resources for running a validator node largely depend on the network load. As a recommended configuration we sugest the following requirements 2 x CPU, either Intel or AMD, with the SSE4.1, SSE4.2 and AVX flags (use lscpu to verify) 4 GB RAM 500 GB SSD 100 Mbit/s always-on internet connection Linux OS (Ubuntu 18.04 or 20.04 recommended) / MacOS Uptime in incredibly important for being a validator. It is expected that validators will have appriopriate redundancies for compute, power, connectivity etc. While the blockchain itself it highly replicated it is also expected that validators will perform local storage backups in order to minimise validator down time. Set Up a Website Set up a dedicated validator's website and signal your intention to become a validator on our Discord server. This is important since delegators will want to have information about the entity they are delegating their FET to. Strictly speaking this is not necessary, however, it is recommended. As a validator on the network you will want to get other community users to delegate stake to your validator. The more combined stake that a validate has then the great share of the block rewards they will take. Seek Legal Advice Seek legal advice if you intend to run a Validator. Community We highly recommdend to check out the validator community on the discord channel for more information and to see that latest announcements about becoming a validator. Discord","title":"Overview"},{"location":"ledger_v2/validators/overview/#validators-overview","text":"","title":"Validators Overview"},{"location":"ledger_v2/validators/overview/#introduction","text":"The Fetch.ai Ledger relies on a set of validators that are responsible for committing new blocks in the blockchain. These validators participate in the consensus protocol by broadcasting votes which contain cryptographic signatures signed by each validator's private key. Validator candidates can bond their own FET and have FET delegated, or staked, to them by token holders. The validators are determined by who has the most stake delegated to them. The top N validator candidates with the most stake will become the active validators. Validators and their delegators will earn FET as block provisions and tokens as transaction fees through execution of the consensus protocol. Transaction fees will be paid in FET. If validators double sign, are frequently offline or do not participate in governance, their staked FET (including FET of users that delegated to them) can be slashed. The penalty depends on the severity of the violation.","title":"Introduction"},{"location":"ledger_v2/validators/overview/#hardware","text":"The hardware resources for running a validator node largely depend on the network load. As a recommended configuration we sugest the following requirements 2 x CPU, either Intel or AMD, with the SSE4.1, SSE4.2 and AVX flags (use lscpu to verify) 4 GB RAM 500 GB SSD 100 Mbit/s always-on internet connection Linux OS (Ubuntu 18.04 or 20.04 recommended) / MacOS Uptime in incredibly important for being a validator. It is expected that validators will have appriopriate redundancies for compute, power, connectivity etc. While the blockchain itself it highly replicated it is also expected that validators will perform local storage backups in order to minimise validator down time.","title":"Hardware"},{"location":"ledger_v2/validators/overview/#set-up-a-website","text":"Set up a dedicated validator's website and signal your intention to become a validator on our Discord server. This is important since delegators will want to have information about the entity they are delegating their FET to. Strictly speaking this is not necessary, however, it is recommended. As a validator on the network you will want to get other community users to delegate stake to your validator. The more combined stake that a validate has then the great share of the block rewards they will take.","title":"Set Up a Website"},{"location":"ledger_v2/validators/overview/#seek-legal-advice","text":"Seek legal advice if you intend to run a Validator.","title":"Seek Legal Advice"},{"location":"ledger_v2/validators/overview/#community","text":"We highly recommdend to check out the validator community on the discord channel for more information and to see that latest announcements about becoming a validator. Discord","title":"Community"},{"location":"ledger_v2/validators/security/","text":"Validator Security Each validator candidate is encouraged to run its operations independently, as diverse setups increase the resilience of the network. Validator candidates should commence their setup phase now in order to be on time for launch. Key Management - HSM It is mission critical that an attacker cannot steal a validator's key. If this is possible, it puts the entire stake delegated to the compromised validator at risk. Hardware security modules are an important strategy for mitigating this risk. HSM modules must support ed25519 signatures. Sentry Nodes (DDOS Protection) Validators are responsible for ensuring that the network can sustain denial of service attacks. One recommended way to mitigate these risks is for validators is to carefully structure their network topology in a so-called sentry node architecture. Validator nodes should only connect to full-nodes they trust because they operate them themselves or are run by other validators they know socially. This architecture shifts the burden of denial-of-service from the validator's node directly to its sentry nodes, and may require new sentry nodes be spun up or activated to mitigate attacks on existing ones. Sentry nodes can be quickly spun up or change their IP addresses. Because the links to the sentry nodes are in private IP space, an internet based attacked cannot disturb them directly. This will ensure validator block proposals and votes always make it to the rest of the network. To setup your sentry node architecture you can follow the instructions below: Validators nodes should edit their config.toml: # Comma separated list of nodes to keep persistent connections to # Do not add private peers to this list if you don't want them advertised persistent_peers =[ list of sentry nodes ] # Set true to enable the peer-exchange reactor pex = false Sentry Nodes should edit their config.toml: # Comma separated list of peer IDs to keep private (will not be gossiped to other peers) # Example ID: 3e16af0cead27979e1fc3dac57d03df3c7a77acc@3.87.179.235:26656 private_peer_ids = \"node_ids_of_private_peers\"","title":"Security"},{"location":"ledger_v2/validators/security/#validator-security","text":"Each validator candidate is encouraged to run its operations independently, as diverse setups increase the resilience of the network. Validator candidates should commence their setup phase now in order to be on time for launch.","title":"Validator Security"},{"location":"ledger_v2/validators/security/#key-management-hsm","text":"It is mission critical that an attacker cannot steal a validator's key. If this is possible, it puts the entire stake delegated to the compromised validator at risk. Hardware security modules are an important strategy for mitigating this risk. HSM modules must support ed25519 signatures.","title":"Key Management - HSM"},{"location":"ledger_v2/validators/security/#sentry-nodes-ddos-protection","text":"Validators are responsible for ensuring that the network can sustain denial of service attacks. One recommended way to mitigate these risks is for validators is to carefully structure their network topology in a so-called sentry node architecture. Validator nodes should only connect to full-nodes they trust because they operate them themselves or are run by other validators they know socially. This architecture shifts the burden of denial-of-service from the validator's node directly to its sentry nodes, and may require new sentry nodes be spun up or activated to mitigate attacks on existing ones. Sentry nodes can be quickly spun up or change their IP addresses. Because the links to the sentry nodes are in private IP space, an internet based attacked cannot disturb them directly. This will ensure validator block proposals and votes always make it to the rest of the network. To setup your sentry node architecture you can follow the instructions below: Validators nodes should edit their config.toml: # Comma separated list of nodes to keep persistent connections to # Do not add private peers to this list if you don't want them advertised persistent_peers =[ list of sentry nodes ] # Set true to enable the peer-exchange reactor pex = false Sentry Nodes should edit their config.toml: # Comma separated list of peer IDs to keep private (will not be gossiped to other peers) # Example ID: 3e16af0cead27979e1fc3dac57d03df3c7a77acc@3.87.179.235:26656 private_peer_ids = \"node_ids_of_private_peers\"","title":"Sentry Nodes (DDOS Protection)"},{"location":"ledger_v2/validators/setup/","text":"Setting up a Validator Node This guide assumes that you have successfuly installed , configured and connected your validator to the desired network. Creating a validator To create a validator on the network you will need to send a transaction to the network bonding / staking your FET tokens. This process registers you as a validator and if you are one of the chosen validators you will start to produce blocks. fetchd tx staking create-validator \\ --amount = <the amount to bond> \\ --pubkey = $( fetchd tendermint show-validator ) \\ --moniker = \"choose a moniker\" \\ --chain-id = <chain_id> \\ --commission-rate = \"0.10\" \\ --commission-max-rate = \"0.20\" \\ --commission-max-change-rate = \"0.01\" \\ --min-self-delegation = \"<the min self delegation>\" \\ --from = <key_name> Stargateworld Example Before trying to create a validator you should verify that you have some tokens available beforehand. The easiest way to do this is via the CLI . Here is an sample of a typical command line command that will register the node as running the validator. fetchd tx staking create-validator \\ --amount = 1000000000000000000atestfet \\ --pubkey = $( fetchd tendermint show-validator ) \\ --moniker = \"my-test-validator\" \\ --chain-id = stargateworld-3 \\ --commission-rate = \"0.10\" \\ --commission-max-rate = \"0.20\" \\ --commission-max-change-rate = \"0.01\" \\ --min-self-delegation = \"1000000000000000000\" \\ --from = test-key Editing a validator Over time it is possible that validators will want to adjust various settings about their nodes. This can be simple things like the associated website for a validator or more consequential actions like altering the commission rate. In either case, should a validator choose to make this update they would send an \"edit-validator\" transaction to the network. These can be created in a similar way to the \"create-validator\" transactions as shown below: fetchd tx staking edit-validator --moniker = \"choose a moniker\" \\ --website = \"https://fetch.ai\" \\ --details = \"To infinity and beyond!\" \\ --chain-id = <chain_id> \\ --commission-rate = \"0.10\" --from = <key_name> Unbonding a validator When / if a validator wants to stop being a validator for any reason, they can unbond some or all of their staked tokens. This is done with the following command. fetchd tx staking unbond \\ <validator operator address> \\ <amount to remove> \\ --from <key name> An example of the command is given in the following example: fetchd tx staking unbond \\ fetchvaloper1jqqwdch3jmzlmj4tjfn67s3sqm9elkd3wrpspf \\ 1000000000000000000000atestfet \\ --from test-key Note Validators' obligations continue until the end of the aeon (which is typically 100 blocks or ~8 minutes depending on the configuration). It is therefore important that after a validator unbonds their stake they must leave their node up and running for 2 complete aeons before switching off. Failure to do so is treated as malicious behaviour and will result in stake being slashed.","title":"Setup"},{"location":"ledger_v2/validators/setup/#setting-up-a-validator-node","text":"This guide assumes that you have successfuly installed , configured and connected your validator to the desired network.","title":"Setting up a Validator Node"},{"location":"ledger_v2/validators/setup/#creating-a-validator","text":"To create a validator on the network you will need to send a transaction to the network bonding / staking your FET tokens. This process registers you as a validator and if you are one of the chosen validators you will start to produce blocks. fetchd tx staking create-validator \\ --amount = <the amount to bond> \\ --pubkey = $( fetchd tendermint show-validator ) \\ --moniker = \"choose a moniker\" \\ --chain-id = <chain_id> \\ --commission-rate = \"0.10\" \\ --commission-max-rate = \"0.20\" \\ --commission-max-change-rate = \"0.01\" \\ --min-self-delegation = \"<the min self delegation>\" \\ --from = <key_name> Stargateworld Example Before trying to create a validator you should verify that you have some tokens available beforehand. The easiest way to do this is via the CLI . Here is an sample of a typical command line command that will register the node as running the validator. fetchd tx staking create-validator \\ --amount = 1000000000000000000atestfet \\ --pubkey = $( fetchd tendermint show-validator ) \\ --moniker = \"my-test-validator\" \\ --chain-id = stargateworld-3 \\ --commission-rate = \"0.10\" \\ --commission-max-rate = \"0.20\" \\ --commission-max-change-rate = \"0.01\" \\ --min-self-delegation = \"1000000000000000000\" \\ --from = test-key","title":"Creating a validator"},{"location":"ledger_v2/validators/setup/#editing-a-validator","text":"Over time it is possible that validators will want to adjust various settings about their nodes. This can be simple things like the associated website for a validator or more consequential actions like altering the commission rate. In either case, should a validator choose to make this update they would send an \"edit-validator\" transaction to the network. These can be created in a similar way to the \"create-validator\" transactions as shown below: fetchd tx staking edit-validator --moniker = \"choose a moniker\" \\ --website = \"https://fetch.ai\" \\ --details = \"To infinity and beyond!\" \\ --chain-id = <chain_id> \\ --commission-rate = \"0.10\" --from = <key_name>","title":"Editing a validator"},{"location":"ledger_v2/validators/setup/#unbonding-a-validator","text":"When / if a validator wants to stop being a validator for any reason, they can unbond some or all of their staked tokens. This is done with the following command. fetchd tx staking unbond \\ <validator operator address> \\ <amount to remove> \\ --from <key name> An example of the command is given in the following example: fetchd tx staking unbond \\ fetchvaloper1jqqwdch3jmzlmj4tjfn67s3sqm9elkd3wrpspf \\ 1000000000000000000000atestfet \\ --from test-key Note Validators' obligations continue until the end of the aeon (which is typically 100 blocks or ~8 minutes depending on the configuration). It is therefore important that after a validator unbonds their stake they must leave their node up and running for 2 complete aeons before switching off. Failure to do so is treated as malicious behaviour and will result in stake being slashed.","title":"Unbonding a validator"},{"location":"soef/simple-oef-usage/","text":"You can use the SOEF in the agent framework by using the SOEF connection as a package in your agent project. Note Please consult the relevant guide for details.","title":"SOEF Connection"},{"location":"soef/simple-oef/","text":"Simple-OEF: Agent Search and Discovery This documentation has been produced for the Simple-OEF version 0.3.4 . Concepts The Simple-OEF, or soef, is a search and discovery mechanism for autonomous economic agents . Agents register with the soef and are then able to conduct searches around them to find other agents that may be able to help. It is a relatively simple implementation focussing on functionality, performance and ease-of-use. As it develops, it will evolve into a full-scale decentralised, multi-dimensional digital world. The work-flow is: Find relevant agents on the soef, Communicate using the Agent Framework's peer-to-peer network, Negotiate and then transact on the ledger in order to exchange value for tokens When an agent registers with the soef, it is issued with a unique reference which is quoted in all subsequent transactions. This way, the soef knows who its talking to. The soef is transaction based, so it does not need a permanent connection to be maintained in order to work with it. If it does not hear from an agent for a period of time, that agent will be timed out and automatically unregistered. This period of time is typically about one hour, but you can see the soef's configuration at: https://s-oef.fetch.ai:443 Agents identify themselves in a number of ways. These include their address, their given name, their classification and their genus. They can also describe how they \"look\" in other ways, and specify the services that they provide. In order to register, agents must provide a valid address and a given name. The address can be for the Fetch.ai native ledger, the Fetch.ai Cosmos ledger or the Ethereum ledger. It is this that uniquely identifies them, and addresses cannot be duplicated or shared. The given name can be anything and it is not used for search filtering. Typically, it can be thought of as a debugging aid or a context. Names could be Alice, Bob or Jim, as well as they could be a flight number, train identity or reference code. They appear in find results, but are not used to find by. Describing an Agent Agents describe themselves in three ways: Identity : their address and ledger type along with their given name Personality pieces : how they look Service keys : what they do , sell or want . We cover all of these in this next section. It's important to understand the difference between personality pieces and service keys, as agents only have one appearance, but they can provide many services. Search results can be filtered by a number of both, and wildcards are permitted where relevant. Personality Pieces Agents can have a number of personality pieces. These describe how an agent appears, where it is, and other properties such as heading, supported protocols and types of transactions. All personality pieces are optional, but the more you set, the easier it is for searchers to narrow you down accurately . Piece Description genus Coarse type of agent, includes things such as vehicle , building , iot . See the genus table below. classification An agent's classification, typically in the form mobility.railway.train . See note below on classifications. No fixed classifications are specified. Classifications can contain alphanumeric characters, the period, underscore and colon ( _.: ). architecture Agent's architecture. See the architecture table below. Introduced in version 0.1.20 . The vast majority of agents should set this to agentframework . dynamics.moving Boolean, indicates if the agent is moving or not. dynamics.heading Indicates the heading of the agent, in radians, with 0.0 pointing due north. dynamics.altitude Altitude of the agent in metres from MSL dynamics.position Indicates the GPS co-ordinates of the agent as latitude and longitude. action.buyer Boolean, indicates whether the agent wishes to buy information, i.e., is an agent that requires value from another agent. action.seller Boolean, indicates whether the agent sells information, i.e., provides value. Value provided can be zero-cost. Genus list A genus is a coarse agent class. It is the roughest description of what an agent is, and an easy way of filtering large groups of agents out of searches. The supported genus list is: Name Description test Agent is a test agent, and should be generally ignored. vehicle Moving objects such as trains, planes and automobiles avatar An agent that represents a human being service An agent that provides a service iot An agent that represents an Internet of Things device data An agent that represents data furniture Small fixed location items such as signs, mobile masts building Large fixed location item such as house, railway station, school buyer Indicates the agent is a buyer only and does not have value to deliver viewer The agent is a view in the world, acting as a \"camera\" to view content financial Financial agent: service, exchange, autonomous market maker, etc. The best way to use genus is to pick the best fit choice. If there isn't one for you, then do not specify it. If you feel that a high-level genus is missing, please make the suggestion in our Developer Discord (see here ). Architectures An architecture is a clue to other agents to describe how the agent is built. The vast majority of agents will be built using the Fetch Agent Framework, but in some cases, such as light-weight IoT devices or test/debugging, agents are built otherwise. Architecture offers a way of describing or filtering, as agents with a similar architecture are more likely to be able to communicate with each other in a meaningful way. Architecture Description custom Custom agent architecture agentframework Built using the Fetch Agent Framework A note on classifications There is currently no fixed set of guidelines as to how classifications are used. It is expected that agent builders will converge on a set of standards, and as those become clearer, they will be documented as \"by convention\" classification uses. Here are some examples of classifications in use: mobility.railway.station mobility.railway.train mobility.road.taxi infrastructure.road.sign When filtering by classifications, the * wildcard can be used to, for example, capture all mobility related agents with a wildcard of mobility.* . Service Keys Agents can have a number of service keys. Service keys are simple key/value pairs that describe the list of services that the agent provides. Whilst personality pieces can be thought of as how an agent looks , service keys are what an agent has or does . Service keys are user defined and as with personality pieces, currently have no convention for formatting. They are at the agent builder's discretion. As this changes, the documentation will be updated. However, for buyer agents, three suggested keys are: buying_genus buying_architecture buying_classifications data_type si_unit This allows searches to look for potential buyers of classifications, genus or with a compatible architecture. Finding Agents The soef is designed for geographic searches where agents are able to find other agents near to them that are able to provide them with the value that they want, or who might wish to have the value they provide. However, it also allows for positionless searches on a single node. Future versions of the soef will support searches across nodes, and dimensional reduction-based fuzzy searches. Geographic searches are performed using the find_around_me operation. This allows searches that: Are within a certain range in KM Optionally must be positioned within an angle of a heading That have a specified set of personality pieces (with wildcards where applicable) That have a specified set of service keys (with wildcards) Where chain identifiers match Positionless searches are performed using the find_on_this_node operation. This allows searches that: That have a specified set of personality pieces (with wildcards where applicable) That have a specified set of service keys (with wildcards) Where chain identifiers match At least one filter must be supplied in positionless searches. Positionless searches are not boundless, they are capped at a specific number. The tighter the filters, the less likely that you will be capped. Some limits apply to the maximum number of filters, range and returned results. This may vary from soef instance to soef instance. You can see (and parse if required) these by getting the soef status at: https://s-oef.fetch.ai:443 The soef returns XML that includes information about all found agents. An example of that, unparsed, looks like this: <response> <success> 1 </success> <total> 1 </total> <capped> 0 </capped> <results> <agent name= \"TrainNumber1234\" genus= \"vehicle\" classification= \"mobility.railway.train\" user_context= \"18:00 to Berlin\" > <identities> <identity chain_identifier= \"fetchai\" > 2h6fi8oCkMz9GCpL7EUYMHjzgdRFGmDP5V4Ls97jZpzjg523yY </identity> </identities> <range_in_km> 55.7363 </range_in_km> <location accuracy= \"3\" > <latitude> 52.5 </latitude> <longitude> 0.2 </longitude> </location> </agent> </results> </response> The <location> block is only returned if the agent has set itself to disclose its position in a find. Likewise, the user_context=\"\" is only returned if enabled . Normally, the default is not to, and agents will then only return the <range_in_km> item. This is because agents may deliver their precise location as part of the value that they deliver, and therefore it would need to be negotiated and potentially paid for. However, sometimes, it is desirable for agents to always deliver their position when found but specify the accuracy. Because of this, the soef supports four levels of accuracy: Level Accuracy none Default do not disclose position, range only. low Rounded to nearest 11km medium Rounded to nearest 1.1km high Rounded to nearest 110 metres maximum No rounding: supplied in maximum available detail Technical Details For the majority of use cases, the soef will be used from the Agent Framework. As a result, talking to it directly will not be needed. There are some occasions where interacting with the soef directly may be required, and this section documents the API functionality. Until version 1.0 and main-net version 2 (expected in early 2021), some of the security and paid-for-services are not implemented and where they are, they generally not enforced. Digital signatures for the sign-on process and unique identity recovery will be implemented, as will encryption on sensitive data transport, for example. Thus the API is likely to change substantially in the coming months, particularly the initial registration process. It is not recommended that you invest in substantial code that talks to the soef directly until after 1.0, and it is always preferred to go through the Agent Framework. Registration Agents register at the /register page on the soef. They are expected to provide four pieces of information: An API key A chain identifier, which can be either fetchai_v1 for the Fetch native network (testnet or mainnet), fetchai_v2_* for the Fetch version 2 network or ethereum for the Ethereum network. See the \"Chain identifiers\" table below for a complete list of supported chain identifiers. An address, which must be a valid address for the specified chain identifier A \"given name\" (see \"Concepts\", above), which can be anything from Alice to Bob, or a flight number, or any other user-given context. It must not exceed 128 characters. If registration is successful, the soef will return a result like this: <response> <encrypted> 0 </encrypted> <token> 0A709D1ED170A3E96C4AC9D014BCAE30 </token> <page_address> oef_AEC97453A80FFFF5F11E612594585F611D1728FFCD74BBF4FE915BBBB052 </page_address> </response> This indicates success and that the agent is now in the Lobby . The lobby is a temporary holding pen where newly registered agents wait until the negotiation is complete. If an agent does not respond and complete its registration within 60 seconds, it is removed from the lobby and registration is cancelled. The <page_address> is the unique URL for the new agent. This must be quoted in all subsequent interactions and is how the soef identifies that specific agent. To complete registration, use the unique URL and specify the parameters: token= with the token that was returned above and command=acknowledge If this works, you will receive a success response: <response> <success> 1 </success> </response> At this point, your agent is now fully registered and can then communicate with the soef. Agents that do not contact the soef at least once over a specified interval will be automatically unregistered. The typical setting for this is 60 minutes. Chain identifiers The soef supports a selection of chain identifiers designed to allow agents to distinguish networks in searches, but also to identify the type of address used for verification purposes. Chain identifier Network fetchai_v1 Version 1 Fetch.ai network (testnet or mainnet). Versions prior to 0.2 of the soef used fetchai for this, which is retained for compatibility. fetchai_v2_testnet_stable Version 2 Fetch.ai stable testnet, also known as \"Agentland\". Versions prior to 0.2 of the soef used fetchai_cosmos which is retained for compatibility, but deprecated. fetchai_v2_testnet_incentivised Current incentivised testnet. Fetch.ai are running a high-reward sequence of testnets in Q4 2020 and Q1 2021 leading to V2 mainnet. fetchai_v2_misc Miscellaneous v2 network. These are temporary or transient testnets where there is a desire to separate the chain ID from other v2 networks. fetchai_v2_mainnet Fetch.ai v2 mainnet. Not yet active. Commands The soef has a number of commands that can be used to set or update personality pieces, manage service keys, unregister, find other agents and other operations. These commands are specified using the agent's unique URL and a command= parameter. There may then be other required and optional parameters for that particular command. Command Details unregister Unregisters the agent from the soef. The unique URL is invalidated and the agent will no longer appear in searches. No parameters. ping Say hello. This is for agents that have been idle for a long period of time and wish to maintain their connection. No parameters. set_personality_piece Sets or updates a personality piece. Specify the piece (see personality piece table above) and the value . For personality pieces with multiple values, such as dynamics.position , separate them with the pipe character | . set_service_key Sets or updates a service key. Specify the key and the value to assign to it. remove_service_key Removes an existing service key. Specify the key . set_find_position_disclosure_accuracy Sets the find disclosure accuracy. See the table in \"Finding Agents\", above, for the accepted values for the parameter accuracy . find_around_me Geographic finding of agents around me. This allows various filters, such as personality pieces and service keys, to be specified. See below, as this is more complex. find_on_this_node Positionless finding of agents on this node. Various filters such as personality pieces and service keys can narrow the search. See below for more information. set_position This is a direct internal mapping to set_personality_piece with a piece of dynamics.position . It existed in the earliest versions of the soef and remains as a short-cut. It expects longitude and latitude as parameters. set_declared_name This allows an agent's declared name to be changed after registration. It takes one parameter, name , to specify the replacement name. Names cannot exceed 128 characters and must not contain illegal characters. set_user_context Sets an optional user-context for an agent to what is specified in the value parameter. This can be optionally disclosed in find_around_me if enabled. See set_disclose_user_context , below. The user context must not contain illegal characters and is limited to 160 maximum. set_disclose_user_context If the disclose parameter is set to true , the optional user context is disclosed if it has been set. Default is false . Find commands in detail find_around_me and find_on_this_node are the big commands. Ultimately, they will cost a small amount of tokens to use, depending on the size of the request, as it involves the most computing time. This provides an incentive for soef operators to maintain soef nodes that correspond to subject areas, geographic areas or both. The command has a number of parameters specifying the filtering required. For find_around_me , the range_in_km is required , whereas narrowing down agents to be within a certain angle of a direction is optional. This cannot exceed a certain range, typically between 50 and 75km. This, and other configuration items, are available on the soef's configuration page. There are other parameters that are optional, although for find_on_this_node at least one ppfilter or skfilter must be specified. The parameters are: Parameter Use range_in_km Range in kilometres to include agents in results. of_heading Optional: if a pizza-slice type search is required, this is the direction, in degrees, with 0.0 being north. within Optional: if a pizza-slice search, this is the angle in degrees from the of_heading that is allowed. If either of_heading or within are specified, both must be specified. Example: of_heading set to 90.0 and within set to 30 would exclude any agents that are not within 30 degrees of direct east of the me agent. chains_must_match Boolean. Must be true or false . Default is false . If specified, this ensures that any agents returned in the search will have the same chain identifier as you. ppfilter Specify a personality piece filter. Multiple ppfilter s can be specified. Example use is: ppfilter=dynamics.moving,true . Wildcards can be used where relevant, e.g.: ppfilter=classification,mobility* will match all classifications that start with mobility , whereas ppfilter=classification,*mobility* will match all classifications with mobility anywhere in it. skfilter Specify a service key filter. Multiple skfilter s can be specified. Example use is: skfilter=fruit,peach which will require any returned results to have a service key of fruit and a value of peach . Wildcards can be specified, so skfilter=fruit,pea* will match any agent with a service key of fruit that starts pea , so pear and peach would match. SK Filters: filter modes The skfilter parameter for find_around_me also supports a mode . Four modes are supported: Mode string Description PS Key must be present, and success is required PF Key must be present, and failure is required OS Only match if present, and success is required OF Only match if present, and failure is required For example: command=find_around_me&range_in_km=50&skfilter=type,fruit,PS&skfilter=size,large,OF In this example, the key type must be present, and it must match to fruit . If the size key is present, and it is set to large , then do not match. I.e., return everything that's a fruit within 50km except where the size is large. Further information You can find further information, or talk to us, in the #agents channel on our official developer Discord server, which you can access here . We welcome your feedback and strive to deliver the best decentralised search and discovery service for agents that is possible. There are many upcoming features, including the operation incentive mechanisms, additional security and encryption, active searches (where results happen without find_around_me being issued), non-geographic searches across one and many soef nodes and dimensional-reduction based approximate searches. [Docs: issue 15, 0.3.4 , 28-Dec-2020 , TWS]","title":"Simple OEF"},{"location":"soef/simple-oef/#simple-oef-agent-search-and-discovery","text":"This documentation has been produced for the Simple-OEF version 0.3.4 .","title":"Simple-OEF: Agent Search and Discovery"},{"location":"soef/simple-oef/#concepts","text":"The Simple-OEF, or soef, is a search and discovery mechanism for autonomous economic agents . Agents register with the soef and are then able to conduct searches around them to find other agents that may be able to help. It is a relatively simple implementation focussing on functionality, performance and ease-of-use. As it develops, it will evolve into a full-scale decentralised, multi-dimensional digital world. The work-flow is: Find relevant agents on the soef, Communicate using the Agent Framework's peer-to-peer network, Negotiate and then transact on the ledger in order to exchange value for tokens When an agent registers with the soef, it is issued with a unique reference which is quoted in all subsequent transactions. This way, the soef knows who its talking to. The soef is transaction based, so it does not need a permanent connection to be maintained in order to work with it. If it does not hear from an agent for a period of time, that agent will be timed out and automatically unregistered. This period of time is typically about one hour, but you can see the soef's configuration at: https://s-oef.fetch.ai:443 Agents identify themselves in a number of ways. These include their address, their given name, their classification and their genus. They can also describe how they \"look\" in other ways, and specify the services that they provide. In order to register, agents must provide a valid address and a given name. The address can be for the Fetch.ai native ledger, the Fetch.ai Cosmos ledger or the Ethereum ledger. It is this that uniquely identifies them, and addresses cannot be duplicated or shared. The given name can be anything and it is not used for search filtering. Typically, it can be thought of as a debugging aid or a context. Names could be Alice, Bob or Jim, as well as they could be a flight number, train identity or reference code. They appear in find results, but are not used to find by.","title":"Concepts"},{"location":"soef/simple-oef/#describing-an-agent","text":"Agents describe themselves in three ways: Identity : their address and ledger type along with their given name Personality pieces : how they look Service keys : what they do , sell or want . We cover all of these in this next section. It's important to understand the difference between personality pieces and service keys, as agents only have one appearance, but they can provide many services. Search results can be filtered by a number of both, and wildcards are permitted where relevant.","title":"Describing an Agent"},{"location":"soef/simple-oef/#personality-pieces","text":"Agents can have a number of personality pieces. These describe how an agent appears, where it is, and other properties such as heading, supported protocols and types of transactions. All personality pieces are optional, but the more you set, the easier it is for searchers to narrow you down accurately . Piece Description genus Coarse type of agent, includes things such as vehicle , building , iot . See the genus table below. classification An agent's classification, typically in the form mobility.railway.train . See note below on classifications. No fixed classifications are specified. Classifications can contain alphanumeric characters, the period, underscore and colon ( _.: ). architecture Agent's architecture. See the architecture table below. Introduced in version 0.1.20 . The vast majority of agents should set this to agentframework . dynamics.moving Boolean, indicates if the agent is moving or not. dynamics.heading Indicates the heading of the agent, in radians, with 0.0 pointing due north. dynamics.altitude Altitude of the agent in metres from MSL dynamics.position Indicates the GPS co-ordinates of the agent as latitude and longitude. action.buyer Boolean, indicates whether the agent wishes to buy information, i.e., is an agent that requires value from another agent. action.seller Boolean, indicates whether the agent sells information, i.e., provides value. Value provided can be zero-cost.","title":"Personality Pieces"},{"location":"soef/simple-oef/#genus-list","text":"A genus is a coarse agent class. It is the roughest description of what an agent is, and an easy way of filtering large groups of agents out of searches. The supported genus list is: Name Description test Agent is a test agent, and should be generally ignored. vehicle Moving objects such as trains, planes and automobiles avatar An agent that represents a human being service An agent that provides a service iot An agent that represents an Internet of Things device data An agent that represents data furniture Small fixed location items such as signs, mobile masts building Large fixed location item such as house, railway station, school buyer Indicates the agent is a buyer only and does not have value to deliver viewer The agent is a view in the world, acting as a \"camera\" to view content financial Financial agent: service, exchange, autonomous market maker, etc. The best way to use genus is to pick the best fit choice. If there isn't one for you, then do not specify it. If you feel that a high-level genus is missing, please make the suggestion in our Developer Discord (see here ).","title":"Genus list"},{"location":"soef/simple-oef/#architectures","text":"An architecture is a clue to other agents to describe how the agent is built. The vast majority of agents will be built using the Fetch Agent Framework, but in some cases, such as light-weight IoT devices or test/debugging, agents are built otherwise. Architecture offers a way of describing or filtering, as agents with a similar architecture are more likely to be able to communicate with each other in a meaningful way. Architecture Description custom Custom agent architecture agentframework Built using the Fetch Agent Framework","title":"Architectures"},{"location":"soef/simple-oef/#a-note-on-classifications","text":"There is currently no fixed set of guidelines as to how classifications are used. It is expected that agent builders will converge on a set of standards, and as those become clearer, they will be documented as \"by convention\" classification uses. Here are some examples of classifications in use: mobility.railway.station mobility.railway.train mobility.road.taxi infrastructure.road.sign When filtering by classifications, the * wildcard can be used to, for example, capture all mobility related agents with a wildcard of mobility.* .","title":"A note on classifications"},{"location":"soef/simple-oef/#service-keys","text":"Agents can have a number of service keys. Service keys are simple key/value pairs that describe the list of services that the agent provides. Whilst personality pieces can be thought of as how an agent looks , service keys are what an agent has or does . Service keys are user defined and as with personality pieces, currently have no convention for formatting. They are at the agent builder's discretion. As this changes, the documentation will be updated. However, for buyer agents, three suggested keys are: buying_genus buying_architecture buying_classifications data_type si_unit This allows searches to look for potential buyers of classifications, genus or with a compatible architecture.","title":"Service Keys"},{"location":"soef/simple-oef/#finding-agents","text":"The soef is designed for geographic searches where agents are able to find other agents near to them that are able to provide them with the value that they want, or who might wish to have the value they provide. However, it also allows for positionless searches on a single node. Future versions of the soef will support searches across nodes, and dimensional reduction-based fuzzy searches. Geographic searches are performed using the find_around_me operation. This allows searches that: Are within a certain range in KM Optionally must be positioned within an angle of a heading That have a specified set of personality pieces (with wildcards where applicable) That have a specified set of service keys (with wildcards) Where chain identifiers match Positionless searches are performed using the find_on_this_node operation. This allows searches that: That have a specified set of personality pieces (with wildcards where applicable) That have a specified set of service keys (with wildcards) Where chain identifiers match At least one filter must be supplied in positionless searches. Positionless searches are not boundless, they are capped at a specific number. The tighter the filters, the less likely that you will be capped. Some limits apply to the maximum number of filters, range and returned results. This may vary from soef instance to soef instance. You can see (and parse if required) these by getting the soef status at: https://s-oef.fetch.ai:443 The soef returns XML that includes information about all found agents. An example of that, unparsed, looks like this: <response> <success> 1 </success> <total> 1 </total> <capped> 0 </capped> <results> <agent name= \"TrainNumber1234\" genus= \"vehicle\" classification= \"mobility.railway.train\" user_context= \"18:00 to Berlin\" > <identities> <identity chain_identifier= \"fetchai\" > 2h6fi8oCkMz9GCpL7EUYMHjzgdRFGmDP5V4Ls97jZpzjg523yY </identity> </identities> <range_in_km> 55.7363 </range_in_km> <location accuracy= \"3\" > <latitude> 52.5 </latitude> <longitude> 0.2 </longitude> </location> </agent> </results> </response> The <location> block is only returned if the agent has set itself to disclose its position in a find. Likewise, the user_context=\"\" is only returned if enabled . Normally, the default is not to, and agents will then only return the <range_in_km> item. This is because agents may deliver their precise location as part of the value that they deliver, and therefore it would need to be negotiated and potentially paid for. However, sometimes, it is desirable for agents to always deliver their position when found but specify the accuracy. Because of this, the soef supports four levels of accuracy: Level Accuracy none Default do not disclose position, range only. low Rounded to nearest 11km medium Rounded to nearest 1.1km high Rounded to nearest 110 metres maximum No rounding: supplied in maximum available detail","title":"Finding Agents"},{"location":"soef/simple-oef/#technical-details","text":"For the majority of use cases, the soef will be used from the Agent Framework. As a result, talking to it directly will not be needed. There are some occasions where interacting with the soef directly may be required, and this section documents the API functionality. Until version 1.0 and main-net version 2 (expected in early 2021), some of the security and paid-for-services are not implemented and where they are, they generally not enforced. Digital signatures for the sign-on process and unique identity recovery will be implemented, as will encryption on sensitive data transport, for example. Thus the API is likely to change substantially in the coming months, particularly the initial registration process. It is not recommended that you invest in substantial code that talks to the soef directly until after 1.0, and it is always preferred to go through the Agent Framework.","title":"Technical Details"},{"location":"soef/simple-oef/#registration","text":"Agents register at the /register page on the soef. They are expected to provide four pieces of information: An API key A chain identifier, which can be either fetchai_v1 for the Fetch native network (testnet or mainnet), fetchai_v2_* for the Fetch version 2 network or ethereum for the Ethereum network. See the \"Chain identifiers\" table below for a complete list of supported chain identifiers. An address, which must be a valid address for the specified chain identifier A \"given name\" (see \"Concepts\", above), which can be anything from Alice to Bob, or a flight number, or any other user-given context. It must not exceed 128 characters. If registration is successful, the soef will return a result like this: <response> <encrypted> 0 </encrypted> <token> 0A709D1ED170A3E96C4AC9D014BCAE30 </token> <page_address> oef_AEC97453A80FFFF5F11E612594585F611D1728FFCD74BBF4FE915BBBB052 </page_address> </response> This indicates success and that the agent is now in the Lobby . The lobby is a temporary holding pen where newly registered agents wait until the negotiation is complete. If an agent does not respond and complete its registration within 60 seconds, it is removed from the lobby and registration is cancelled. The <page_address> is the unique URL for the new agent. This must be quoted in all subsequent interactions and is how the soef identifies that specific agent. To complete registration, use the unique URL and specify the parameters: token= with the token that was returned above and command=acknowledge If this works, you will receive a success response: <response> <success> 1 </success> </response> At this point, your agent is now fully registered and can then communicate with the soef. Agents that do not contact the soef at least once over a specified interval will be automatically unregistered. The typical setting for this is 60 minutes.","title":"Registration"},{"location":"soef/simple-oef/#chain-identifiers","text":"The soef supports a selection of chain identifiers designed to allow agents to distinguish networks in searches, but also to identify the type of address used for verification purposes. Chain identifier Network fetchai_v1 Version 1 Fetch.ai network (testnet or mainnet). Versions prior to 0.2 of the soef used fetchai for this, which is retained for compatibility. fetchai_v2_testnet_stable Version 2 Fetch.ai stable testnet, also known as \"Agentland\". Versions prior to 0.2 of the soef used fetchai_cosmos which is retained for compatibility, but deprecated. fetchai_v2_testnet_incentivised Current incentivised testnet. Fetch.ai are running a high-reward sequence of testnets in Q4 2020 and Q1 2021 leading to V2 mainnet. fetchai_v2_misc Miscellaneous v2 network. These are temporary or transient testnets where there is a desire to separate the chain ID from other v2 networks. fetchai_v2_mainnet Fetch.ai v2 mainnet. Not yet active.","title":"Chain identifiers"},{"location":"soef/simple-oef/#commands","text":"The soef has a number of commands that can be used to set or update personality pieces, manage service keys, unregister, find other agents and other operations. These commands are specified using the agent's unique URL and a command= parameter. There may then be other required and optional parameters for that particular command. Command Details unregister Unregisters the agent from the soef. The unique URL is invalidated and the agent will no longer appear in searches. No parameters. ping Say hello. This is for agents that have been idle for a long period of time and wish to maintain their connection. No parameters. set_personality_piece Sets or updates a personality piece. Specify the piece (see personality piece table above) and the value . For personality pieces with multiple values, such as dynamics.position , separate them with the pipe character | . set_service_key Sets or updates a service key. Specify the key and the value to assign to it. remove_service_key Removes an existing service key. Specify the key . set_find_position_disclosure_accuracy Sets the find disclosure accuracy. See the table in \"Finding Agents\", above, for the accepted values for the parameter accuracy . find_around_me Geographic finding of agents around me. This allows various filters, such as personality pieces and service keys, to be specified. See below, as this is more complex. find_on_this_node Positionless finding of agents on this node. Various filters such as personality pieces and service keys can narrow the search. See below for more information. set_position This is a direct internal mapping to set_personality_piece with a piece of dynamics.position . It existed in the earliest versions of the soef and remains as a short-cut. It expects longitude and latitude as parameters. set_declared_name This allows an agent's declared name to be changed after registration. It takes one parameter, name , to specify the replacement name. Names cannot exceed 128 characters and must not contain illegal characters. set_user_context Sets an optional user-context for an agent to what is specified in the value parameter. This can be optionally disclosed in find_around_me if enabled. See set_disclose_user_context , below. The user context must not contain illegal characters and is limited to 160 maximum. set_disclose_user_context If the disclose parameter is set to true , the optional user context is disclosed if it has been set. Default is false .","title":"Commands"},{"location":"soef/simple-oef/#find-commands-in-detail","text":"find_around_me and find_on_this_node are the big commands. Ultimately, they will cost a small amount of tokens to use, depending on the size of the request, as it involves the most computing time. This provides an incentive for soef operators to maintain soef nodes that correspond to subject areas, geographic areas or both. The command has a number of parameters specifying the filtering required. For find_around_me , the range_in_km is required , whereas narrowing down agents to be within a certain angle of a direction is optional. This cannot exceed a certain range, typically between 50 and 75km. This, and other configuration items, are available on the soef's configuration page. There are other parameters that are optional, although for find_on_this_node at least one ppfilter or skfilter must be specified. The parameters are: Parameter Use range_in_km Range in kilometres to include agents in results. of_heading Optional: if a pizza-slice type search is required, this is the direction, in degrees, with 0.0 being north. within Optional: if a pizza-slice search, this is the angle in degrees from the of_heading that is allowed. If either of_heading or within are specified, both must be specified. Example: of_heading set to 90.0 and within set to 30 would exclude any agents that are not within 30 degrees of direct east of the me agent. chains_must_match Boolean. Must be true or false . Default is false . If specified, this ensures that any agents returned in the search will have the same chain identifier as you. ppfilter Specify a personality piece filter. Multiple ppfilter s can be specified. Example use is: ppfilter=dynamics.moving,true . Wildcards can be used where relevant, e.g.: ppfilter=classification,mobility* will match all classifications that start with mobility , whereas ppfilter=classification,*mobility* will match all classifications with mobility anywhere in it. skfilter Specify a service key filter. Multiple skfilter s can be specified. Example use is: skfilter=fruit,peach which will require any returned results to have a service key of fruit and a value of peach . Wildcards can be specified, so skfilter=fruit,pea* will match any agent with a service key of fruit that starts pea , so pear and peach would match.","title":"Find commands in detail"},{"location":"soef/simple-oef/#sk-filters-filter-modes","text":"The skfilter parameter for find_around_me also supports a mode . Four modes are supported: Mode string Description PS Key must be present, and success is required PF Key must be present, and failure is required OS Only match if present, and success is required OF Only match if present, and failure is required For example: command=find_around_me&range_in_km=50&skfilter=type,fruit,PS&skfilter=size,large,OF In this example, the key type must be present, and it must match to fruit . If the size key is present, and it is set to large , then do not match. I.e., return everything that's a fruit within 50km except where the size is large.","title":"SK Filters: filter modes"},{"location":"soef/simple-oef/#further-information","text":"You can find further information, or talk to us, in the #agents channel on our official developer Discord server, which you can access here . We welcome your feedback and strive to deliver the best decentralised search and discovery service for agents that is possible. There are many upcoming features, including the operation incentive mechanisms, additional security and encryption, active searches (where results happen without find_around_me being issued), non-geographic searches across one and many soef nodes and dimensional-reduction based approximate searches. [Docs: issue 15, 0.3.4 , 28-Dec-2020 , TWS]","title":"Further information"}]}